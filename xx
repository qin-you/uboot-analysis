
u-boot:     file format elf32-littlearm


Disassembly of section .text:

34800000 <__image_copy_start>:
#include <version.h>
#include <asm/system.h>
#include <linux/linkage.h>

.globl _start			/* declaration global symbol */
_start: b	reset		/* jump without condition */
34800000:	ea000014 	b	34800058 <reset>
	/* exceptions in spl */
	ldr	pc, _undefined_instruction	/* ldr: load register  ldr a,b: move value of address b to a */
34800004:	e59ff014 	ldr	pc, [pc, #20]	; 34800020 <_undefined_instruction>
	ldr	pc, _software_interrupt
34800008:	e59ff014 	ldr	pc, [pc, #20]	; 34800024 <_software_interrupt>
	ldr	pc, _prefetch_abort
3480000c:	e59ff014 	ldr	pc, [pc, #20]	; 34800028 <_prefetch_abort>
	ldr	pc, _data_abort
34800010:	e59ff014 	ldr	pc, [pc, #20]	; 3480002c <_data_abort>
	ldr	pc, _not_used
34800014:	e59ff014 	ldr	pc, [pc, #20]	; 34800030 <_not_used>
	ldr	pc, _irq
34800018:	e59ff014 	ldr	pc, [pc, #20]	; 34800034 <_irq>
	ldr	pc, _fiq
3480001c:	e59ff014 	ldr	pc, [pc, #20]	; 34800038 <_fiq>

34800020 <_undefined_instruction>:
34800020:	34800200 	.word	0x34800200

34800024 <_software_interrupt>:
34800024:	34800260 	.word	0x34800260

34800028 <_prefetch_abort>:
34800028:	348002c0 	.word	0x348002c0

3480002c <_data_abort>:
3480002c:	34800320 	.word	0x34800320

34800030 <_not_used>:
34800030:	34800380 	.word	0x34800380

34800034 <_irq>:
34800034:	348003e0 	.word	0x348003e0

34800038 <_fiq>:
34800038:	34800440 	.word	0x34800440

3480003c <_pad>:
3480003c:	12345678 	.word	0x12345678

34800040 <_TEXT_BASE>:
34800040:	34800000 	.word	0x34800000

34800044 <_bss_start_ofs>:
34800044:	000285d0 	.word	0x000285d0

34800048 <_image_copy_end_ofs>:
34800048:	000285d0 	.word	0x000285d0

3480004c <_bss_end_ofs>:
3480004c:	0002a938 	.word	0x0002a938

34800050 <_end_ofs>:
34800050:	0002c830 	.word	0x0002c830

34800054 <IRQ_STACK_START_IN>:
34800054:	0badc0de 	.word	0x0badc0de

34800058 <reset>:
/*
 * the actual reset code
 */

reset:
	bl	save_boot_params	/* bl: goto and return, mov next instruction's addr into lr */
34800058:	eb000058 	bl	348001c0 <save_boot_params>
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr		/* mrs: move to register from status   cpsr: arm register */
3480005c:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x1f		/* bit clear */
34800060:	e3c0001f 	bic	r0, r0, #31
	orr	r0, r0, #0xd3		/* disable IRQ and FIQ ; set cpu supervisor mode */
34800064:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0			/* msr: move to status register    write back */
34800068:	e129f000 	msr	CPSR_fc, r0
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector  page-1477 can see all regs of cp15 */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
3480006c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0  set 0x00000000 as exception vector baseaddr. 1:0xffff0000
34800070:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
34800074:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
34800078:	e59f0438 	ldr	r0, [pc, #1080]	; 348004b8 <led1_on+0x14>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
3480007c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	bl	gpio_out
34800080:	eb000100 	bl	34800488 <gpio_out>
	bl	led1_on
34800084:	eb000106 	bl	348004a4 <led1_on>



	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT		/* true within SPL stage in SRAM, flase within u-boot in DDR */
	bl	cpu_init_cp15
34800088:	eb00004d 	bl	348001c4 <cpu_init_cp15>
	bl	cpu_init_crit			/* call lowlevel_init and return*/
3480008c:	eb00005a 	bl	348001fc <cpu_init_crit>

34800090 <call_board_init_f>:
#endif

/* Set stackpointer in internal RAM to call board_init_f */
call_board_init_f:
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
34800090:	e3a0d423 	mov	sp, #587202560	; 0x23000000
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
34800094:	e3cdd007 	bic	sp, sp, #7
	ldr	r0,=0x00000000
34800098:	e3a00000 	mov	r0, #0
	bl	board_init_f			/* C function */
3480009c:	eb00061c 	bl	34801914 <board_init_f>

348000a0 <relocate_code>:
 * This "function" does not return, instead it continues in RAM
 * after relocating the monitor code.
 *
 */
ENTRY(relocate_code)
	mov	r4, r0	/* save addr_sp */
348000a0:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
348000a4:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination */
348000a8:	e1a06002 	mov	r6, r2

348000ac <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	mov	sp, r4
348000ac:	e1a0d004 	mov	sp, r4

	adr	r0, _start
348000b0:	e24f00b8 	sub	r0, pc, #184	; 0xb8
	cmp	r0, r6
348000b4:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
348000b8:	03a09000 	moveq	r9, #0
	beq	clear_bss		/* skip relocation */
348000bc:	0a000026 	beq	3480015c <clear_bss>
	mov	r1, r6			/* r1 <- scratch for copy_loop */
348000c0:	e1a01006 	mov	r1, r6
	ldr	r3, _image_copy_end_ofs
348000c4:	e51f3084 	ldr	r3, [pc, #-132]	; 34800048 <_image_copy_end_ofs>
	add	r2, r0, r3		/* r2 <- source end address	    */
348000c8:	e0802003 	add	r2, r0, r3

348000cc <copy_loop>:

copy_loop:
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
348000cc:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
348000d0:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]    */
348000d4:	e1500002 	cmp	r0, r2
	blo	copy_loop
348000d8:	3afffffb 	bcc	348000cc <copy_loop>

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
348000dc:	e51f00a4 	ldr	r0, [pc, #-164]	; 34800040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset */
348000e0:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
348000e4:	e59fa06c 	ldr	sl, [pc, #108]	; 34800158 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
348000e8:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
348000ec:	e59f205c 	ldr	r2, [pc, #92]	; 34800150 <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
348000f0:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
348000f4:	e59f3058 	ldr	r3, [pc, #88]	; 34800154 <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
348000f8:	e0833000 	add	r3, r3, r0

348000fc <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
348000fc:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
34800100:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]
34800104:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
34800108:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
3480010c:	e3570017 	cmp	r7, #23
	beq	fixrel
34800110:	0a000007 	beq	34800134 <fixrel>
	cmp	r7, #2			/* absolute fixup? */
34800114:	e3570002 	cmp	r7, #2
	beq	fixabs
34800118:	0a000000 	beq	34800120 <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
3480011c:	ea000006 	b	3480013c <fixnext>

34800120 <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
34800120:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
34800124:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
34800128:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
3480012c:	e0811009 	add	r1, r1, r9
	b	fixnext
34800130:	ea000001 	b	3480013c <fixnext>

34800134 <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]
34800134:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
34800138:	e0811009 	add	r1, r1, r9

3480013c <fixnext>:
fixnext:
	str	r1, [r0]
3480013c:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
34800140:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
34800144:	e1520003 	cmp	r2, r3
	blo	fixloop
34800148:	3affffeb 	bcc	348000fc <fixloop>
	b	clear_bss
3480014c:	ea000002 	b	3480015c <clear_bss>

34800150 <_rel_dyn_start_ofs>:
34800150:	000285d0 	.word	0x000285d0

34800154 <_rel_dyn_end_ofs>:
34800154:	0002c800 	.word	0x0002c800

34800158 <_dynsym_start_ofs>:
34800158:	0002c800 	.word	0x0002c800

3480015c <clear_bss>:
	.word __rel_dyn_end - _start
_dynsym_start_ofs:
	.word __dynsym_start - _start

clear_bss:
	ldr	r0, _bss_start_ofs
3480015c:	e51f0120 	ldr	r0, [pc, #-288]	; 34800044 <_bss_start_ofs>
	ldr	r1, _bss_end_ofs
34800160:	e51f111c 	ldr	r1, [pc, #-284]	; 3480004c <_bss_end_ofs>
	mov	r4, r6			/* reloc addr */
34800164:	e1a04006 	mov	r4, r6
	add	r0, r0, r4
34800168:	e0800004 	add	r0, r0, r4
	add	r1, r1, r4
3480016c:	e0811004 	add	r1, r1, r4
	mov	r2, #0x00000000		/* clear			    */
34800170:	e3a02000 	mov	r2, #0

34800174 <clbss_l>:

clbss_l:cmp	r0, r1			/* clear loop... */
34800174:	e1500001 	cmp	r0, r1
	bhs	clbss_e			/* if reached end of bss, exit */
34800178:	2a000002 	bcs	34800188 <clbss_e>
	str	r2, [r0]
3480017c:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
34800180:	e2800004 	add	r0, r0, #4
	b	clbss_l
34800184:	eafffffa 	b	34800174 <clbss_l>

34800188 <clbss_e>:
jump_2_ram:
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
34800188:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
3480018c:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
34800190:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
/*
 * Move vector table
 */
#if !defined(CONFIG_TEGRA20)
	/* Set vector address in CP15 VBAR register */
	ldr     r0, =_start
34800194:	e59f031c 	ldr	r0, [pc, #796]	; 348004b8 <led1_on+0x14>
	add     r0, r0, r9
34800198:	e0800009 	add	r0, r0, r9
	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
3480019c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif /* !Tegra20 */

	ldr	r0, _board_init_r_ofs
348001a0:	e59f0014 	ldr	r0, [pc, #20]	; 348001bc <_board_init_r_ofs>
	adr	r1, _start
348001a4:	e24f1f6b 	sub	r1, pc, #428	; 0x1ac
	add	lr, r0, r1
348001a8:	e080e001 	add	lr, r0, r1
	add	lr, lr, r9
348001ac:	e08ee009 	add	lr, lr, r9
	/* setup parameters for board_init_r */
	mov	r0, r5		/* gd_t */
348001b0:	e1a00005 	mov	r0, r5
	mov	r1, r6		/* dest_addr */
348001b4:	e1a01006 	mov	r1, r6
	/* jump to it ... */
	mov	pc, lr
348001b8:	e1a0f00e 	mov	pc, lr

348001bc <_board_init_r_ofs>:
348001bc:	00001860 	.word	0x00001860

348001c0 <save_boot_params>:
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)		/* ENTRY: macro, declaration & align & define label */
	bx	lr			@ back to my caller
348001c0:	e12fff1e 	bx	lr

348001c4 <cpu_init_cp15>:
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
348001c4:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
348001c8:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
348001cc:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
348001d0:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
348001d4:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001d8:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
348001dc:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
348001e0:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
348001e4:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
348001e8:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
348001ec:	e3800b02 	orr	r0, r0, #2048	; 0x800
#ifdef CONFIG_SYS_ICACHE_OFF
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
348001f0:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
348001f4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mov	pc, lr			@ back to my caller
348001f8:	e1a0f00e 	mov	pc, lr

348001fc <cpu_init_crit>:
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory
348001fc:	ea0000b8 	b	348004e4 <lowlevel_init>

34800200 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
34800200:	e51fd1b4 	ldr	sp, [pc, #-436]	; 34800054 <IRQ_STACK_START_IN>
34800204:	e58de000 	str	lr, [sp]
34800208:	e14fe000 	mrs	lr, SPSR
3480020c:	e58de004 	str	lr, [sp, #4]
34800210:	e3a0d013 	mov	sp, #19
34800214:	e169f00d 	msr	SPSR_fc, sp
34800218:	e1a0e00f 	mov	lr, pc
3480021c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800220:	e24dd048 	sub	sp, sp, #72	; 0x48
34800224:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800228:	e51f21dc 	ldr	r2, [pc, #-476]	; 34800054 <IRQ_STACK_START_IN>
3480022c:	e892000c 	ldm	r2, {r2, r3}
34800230:	e28d0048 	add	r0, sp, #72	; 0x48
34800234:	e28d5034 	add	r5, sp, #52	; 0x34
34800238:	e1a0100e 	mov	r1, lr
3480023c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800240:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
34800244:	eb0006f1 	bl	34801e10 <do_undefined_instruction>
34800248:	e320f000 	nop	{0}
3480024c:	e320f000 	nop	{0}
34800250:	e320f000 	nop	{0}
34800254:	e320f000 	nop	{0}
34800258:	e320f000 	nop	{0}
3480025c:	e320f000 	nop	{0}

34800260 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
34800260:	e24dd004 	sub	sp, sp, #4
34800264:	e58d0000 	str	r0, [sp]
34800268:	e51f021c 	ldr	r0, [pc, #-540]	; 34800054 <IRQ_STACK_START_IN>
3480026c:	e580e000 	str	lr, [r0]
34800270:	e14f0000 	mrs	r0, SPSR
34800274:	e580e004 	str	lr, [r0, #4]
34800278:	e59d0000 	ldr	r0, [sp]
3480027c:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
34800280:	e24dd048 	sub	sp, sp, #72	; 0x48
34800284:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800288:	e51f223c 	ldr	r2, [pc, #-572]	; 34800054 <IRQ_STACK_START_IN>
3480028c:	e892000c 	ldm	r2, {r2, r3}
34800290:	e28d0048 	add	r0, sp, #72	; 0x48
34800294:	e28d5034 	add	r5, sp, #52	; 0x34
34800298:	e1a0100e 	mov	r1, lr
3480029c:	e885000f 	stm	r5, {r0, r1, r2, r3}
348002a0:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
348002a4:	eb0006e1 	bl	34801e30 <do_software_interrupt>
348002a8:	e320f000 	nop	{0}
348002ac:	e320f000 	nop	{0}
348002b0:	e320f000 	nop	{0}
348002b4:	e320f000 	nop	{0}
348002b8:	e320f000 	nop	{0}
348002bc:	e320f000 	nop	{0}

348002c0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
348002c0:	e51fd274 	ldr	sp, [pc, #-628]	; 34800054 <IRQ_STACK_START_IN>
348002c4:	e58de000 	str	lr, [sp]
348002c8:	e14fe000 	mrs	lr, SPSR
348002cc:	e58de004 	str	lr, [sp, #4]
348002d0:	e3a0d013 	mov	sp, #19
348002d4:	e169f00d 	msr	SPSR_fc, sp
348002d8:	e1a0e00f 	mov	lr, pc
348002dc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348002e0:	e24dd048 	sub	sp, sp, #72	; 0x48
348002e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348002e8:	e51f229c 	ldr	r2, [pc, #-668]	; 34800054 <IRQ_STACK_START_IN>
348002ec:	e892000c 	ldm	r2, {r2, r3}
348002f0:	e28d0048 	add	r0, sp, #72	; 0x48
348002f4:	e28d5034 	add	r5, sp, #52	; 0x34
348002f8:	e1a0100e 	mov	r1, lr
348002fc:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800300:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
34800304:	eb0006d1 	bl	34801e50 <do_prefetch_abort>
34800308:	e320f000 	nop	{0}
3480030c:	e320f000 	nop	{0}
34800310:	e320f000 	nop	{0}
34800314:	e320f000 	nop	{0}
34800318:	e320f000 	nop	{0}
3480031c:	e320f000 	nop	{0}

34800320 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
34800320:	e51fd2d4 	ldr	sp, [pc, #-724]	; 34800054 <IRQ_STACK_START_IN>
34800324:	e58de000 	str	lr, [sp]
34800328:	e14fe000 	mrs	lr, SPSR
3480032c:	e58de004 	str	lr, [sp, #4]
34800330:	e3a0d013 	mov	sp, #19
34800334:	e169f00d 	msr	SPSR_fc, sp
34800338:	e1a0e00f 	mov	lr, pc
3480033c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800340:	e24dd048 	sub	sp, sp, #72	; 0x48
34800344:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800348:	e51f22fc 	ldr	r2, [pc, #-764]	; 34800054 <IRQ_STACK_START_IN>
3480034c:	e892000c 	ldm	r2, {r2, r3}
34800350:	e28d0048 	add	r0, sp, #72	; 0x48
34800354:	e28d5034 	add	r5, sp, #52	; 0x34
34800358:	e1a0100e 	mov	r1, lr
3480035c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800360:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
34800364:	eb0006c1 	bl	34801e70 <do_data_abort>
34800368:	e320f000 	nop	{0}
3480036c:	e320f000 	nop	{0}
34800370:	e320f000 	nop	{0}
34800374:	e320f000 	nop	{0}
34800378:	e320f000 	nop	{0}
3480037c:	e320f000 	nop	{0}

34800380 <not_used>:

	.align	5
not_used:
	get_bad_stack
34800380:	e51fd334 	ldr	sp, [pc, #-820]	; 34800054 <IRQ_STACK_START_IN>
34800384:	e58de000 	str	lr, [sp]
34800388:	e14fe000 	mrs	lr, SPSR
3480038c:	e58de004 	str	lr, [sp, #4]
34800390:	e3a0d013 	mov	sp, #19
34800394:	e169f00d 	msr	SPSR_fc, sp
34800398:	e1a0e00f 	mov	lr, pc
3480039c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348003a0:	e24dd048 	sub	sp, sp, #72	; 0x48
348003a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348003a8:	e51f235c 	ldr	r2, [pc, #-860]	; 34800054 <IRQ_STACK_START_IN>
348003ac:	e892000c 	ldm	r2, {r2, r3}
348003b0:	e28d0048 	add	r0, sp, #72	; 0x48
348003b4:	e28d5034 	add	r5, sp, #52	; 0x34
348003b8:	e1a0100e 	mov	r1, lr
348003bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348003c0:	e1a0000d 	mov	r0, sp
	bl	do_not_used
348003c4:	eb0006b1 	bl	34801e90 <do_not_used>
348003c8:	e320f000 	nop	{0}
348003cc:	e320f000 	nop	{0}
348003d0:	e320f000 	nop	{0}
348003d4:	e320f000 	nop	{0}
348003d8:	e320f000 	nop	{0}
348003dc:	e320f000 	nop	{0}

348003e0 <irq>:

#else

	.align	5
irq:
	get_bad_stack
348003e0:	e51fd394 	ldr	sp, [pc, #-916]	; 34800054 <IRQ_STACK_START_IN>
348003e4:	e58de000 	str	lr, [sp]
348003e8:	e14fe000 	mrs	lr, SPSR
348003ec:	e58de004 	str	lr, [sp, #4]
348003f0:	e3a0d013 	mov	sp, #19
348003f4:	e169f00d 	msr	SPSR_fc, sp
348003f8:	e1a0e00f 	mov	lr, pc
348003fc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800400:	e24dd048 	sub	sp, sp, #72	; 0x48
34800404:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800408:	e51f23bc 	ldr	r2, [pc, #-956]	; 34800054 <IRQ_STACK_START_IN>
3480040c:	e892000c 	ldm	r2, {r2, r3}
34800410:	e28d0048 	add	r0, sp, #72	; 0x48
34800414:	e28d5034 	add	r5, sp, #52	; 0x34
34800418:	e1a0100e 	mov	r1, lr
3480041c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800420:	e1a0000d 	mov	r0, sp
	bl	do_irq
34800424:	eb0006a9 	bl	34801ed0 <do_irq>
34800428:	e320f000 	nop	{0}
3480042c:	e320f000 	nop	{0}
34800430:	e320f000 	nop	{0}
34800434:	e320f000 	nop	{0}
34800438:	e320f000 	nop	{0}
3480043c:	e320f000 	nop	{0}

34800440 <fiq>:

	.align	5
fiq:
	get_bad_stack
34800440:	e51fd3f4 	ldr	sp, [pc, #-1012]	; 34800054 <IRQ_STACK_START_IN>
34800444:	e58de000 	str	lr, [sp]
34800448:	e14fe000 	mrs	lr, SPSR
3480044c:	e58de004 	str	lr, [sp, #4]
34800450:	e3a0d013 	mov	sp, #19
34800454:	e169f00d 	msr	SPSR_fc, sp
34800458:	e1a0e00f 	mov	lr, pc
3480045c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800460:	e24dd048 	sub	sp, sp, #72	; 0x48
34800464:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800468:	e51f241c 	ldr	r2, [pc, #-1052]	; 34800054 <IRQ_STACK_START_IN>
3480046c:	e892000c 	ldm	r2, {r2, r3}
34800470:	e28d0048 	add	r0, sp, #72	; 0x48
34800474:	e28d5034 	add	r5, sp, #52	; 0x34
34800478:	e1a0100e 	mov	r1, lr
3480047c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800480:	e1a0000d 	mov	r0, sp
	bl	do_fiq
34800484:	eb000689 	bl	34801eb0 <do_fiq>

34800488 <gpio_out>:

#endif /* CONFIG_USE_IRQ */
#endif /* CONFIG_SPL_BUILD */

gpio_out:
	ldr r11, =0xE0200280	/* gpioJ GDIR Reg addr in mainboard */
34800488:	e59fb02c 	ldr	fp, [pc, #44]	; 348004bc <led1_on+0x18>
	ldr r12, =0x00001111	/* set output mode */
3480048c:	e59fc02c 	ldr	ip, [pc, #44]	; 348004c0 <led1_on+0x1c>
	str r12, [r11]		/* write back to GPIOJ GDIR Reg */
34800490:	e58bc000 	str	ip, [fp]

	ldr r11, =0xE0200284	/* GPIOJ data Reg addr */
34800494:	e59fb028 	ldr	fp, [pc, #40]	; 348004c4 <led1_on+0x20>
	ldr r12, =0xF		/* set high */
34800498:	e3a0c00f 	mov	ip, #15
	str r12, [r11]
3480049c:	e58bc000 	str	ip, [fp]

	mov pc, lr		/* return */
348004a0:	e1a0f00e 	mov	pc, lr

348004a4 <led1_on>:



.global led1_on			/* global func, other files can access */
led1_on:
	ldr r11, =0xE0200284	/* GPIO DR addr */
348004a4:	e59fb018 	ldr	fp, [pc, #24]	; 348004c4 <led1_on+0x20>
	ldr r12, [r11]		/* read DR to r12 */
348004a8:	e59bc000 	ldr	ip, [fp]
	bic r12, r12, #1	/* r12 = r12 & ~1 , set the pin low */
348004ac:	e3ccc001 	bic	ip, ip, #1
	str r12, [r11]		/* write back */
348004b0:	e58bc000 	str	ip, [fp]
	
	mov pc, lr		/* return to caller */
348004b4:	e1a0f00e 	mov	pc, lr
	ldr	r0, =_start
348004b8:	34800000 	.word	0x34800000
	ldr r11, =0xE0200280	/* gpioJ GDIR Reg addr in mainboard */
348004bc:	e0200280 	.word	0xe0200280
	ldr r12, =0x00001111	/* set output mode */
348004c0:	00001111 	.word	0x00001111
	ldr r11, =0xE0200284	/* GPIOJ data Reg addr */
348004c4:	e0200284 	.word	0xe0200284
348004c8:	e320f000 	nop	{0}
348004cc:	e320f000 	nop	{0}
348004d0:	e320f000 	nop	{0}
348004d4:	e320f000 	nop	{0}
348004d8:	e320f000 	nop	{0}
348004dc:	e320f000 	nop	{0}

348004e0 <_TEXT_BASE>:
348004e0:	34800000 	.word	0x34800000

348004e4 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE		/* 0x34800000. defined in ./config.mk */

	.globl lowlevel_init
lowlevel_init:
	mov	r11, lr
348004e4:	e1a0b00e 	mov	fp, lr

	/* r5 has always zero */
	mov	r5, #0
348004e8:	e3a05000 	mov	r5, #0

	ldr	r7, =S5PC100_GPIO_BASE
348004ec:	e59f73f0 	ldr	r7, [pc, #1008]	; 348008e4 <ddrmem_init+0x4>
	ldr	r8, =S5PC100_GPIO_BASE
348004f0:	e59f83ec 	ldr	r8, [pc, #1004]	; 348008e4 <ddrmem_init+0x4>
	/* Read CPU ID */
	ldr	r2, =S5PC110_PRO_ID
348004f4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
	ldr	r0, [r2]
348004f8:	e5920000 	ldr	r0, [r2]
	mov	r1, #0x00010000
348004fc:	e3a01801 	mov	r1, #65536	; 0x10000
	and	r0, r0, r1
34800500:	e0000001 	and	r0, r0, r1
	cmp	r0, r5
34800504:	e1500005 	cmp	r0, r5
	beq	100f
34800508:	0a000000 	beq	34800510 <lowlevel_init+0x2c>
	ldr	r8, =S5PC110_GPIO_BASE
3480050c:	e59f83d4 	ldr	r8, [pc, #980]	; 348008e8 <ddrmem_init+0x8>
100:
	/* Turn on KEY_LED_ON [GPJ4(1)] XMSMWEN */
	cmp	r7, r8
34800510:	e1570008 	cmp	r7, r8
	beq	skip_check_didle			@ Support C110 only
34800514:	0a000005 	beq	34800530 <skip_check_didle>

	ldr	r0, =S5PC110_RST_STAT
34800518:	e59f03cc 	ldr	r0, [pc, #972]	; 348008ec <ddrmem_init+0xc>
	ldr	r1, [r0]
3480051c:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #0x000D0000
34800520:	e201180d 	and	r1, r1, #851968	; 0xd0000
	cmp	r1, #(0x1 << 19)			@ DEEPIDLE_WAKEUP
34800524:	e3510702 	cmp	r1, #524288	; 0x80000
	beq	didle_wakeup
34800528:	0a000066 	beq	348006c8 <didle_wakeup>
	cmp	r7, r8
3480052c:	e1570008 	cmp	r7, r8

34800530 <skip_check_didle>:

skip_check_didle:
	addeq	r0, r8, #0x280				@ S5PC100_GPIO_J4
34800530:	02880d0a 	addeq	r0, r8, #640	; 0x280
	addne	r0, r8, #0x2C0				@ S5PC110_GPIO_J4
34800534:	12880d0b 	addne	r0, r8, #704	; 0x2c0
	ldr	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800538:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 4)			@ 1 * 4-bit
3480053c:	e3c110f0 	bic	r1, r1, #240	; 0xf0
	orr	r1, r1, #(0x1 << 4)
34800540:	e3811010 	orr	r1, r1, #16
	str	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800544:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800548:	e5901004 	ldr	r1, [r0, #4]
	bic	r1, r1, #(1 << 1)
3480054c:	e3c11002 	bic	r1, r1, #2
	str	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800550:	e5801004 	str	r1, [r0, #4]

	/* Don't setup at s5pc100 */
	beq	100f
34800554:	0a00002e 	beq	34800614 <skip_check_didle+0xe4>
	 *	0xF1D0_0000
	 *	0xF1E0_0000
	 *	0xF1F0_0000
	 *	0xFAF0_0000
	 */
	ldr     r0, =0xe0f00000
34800558:	e59f0390 	ldr	r0, [pc, #912]	; 348008f0 <ddrmem_init+0x10>
	ldr     r1, [r0]
3480055c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800560:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800564:	e5801000 	str	r1, [r0]

	ldr     r0, =0xe1f00000
34800568:	e59f0384 	ldr	r0, [pc, #900]	; 348008f4 <ddrmem_init+0x14>
	ldr     r1, [r0]
3480056c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800570:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800574:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1800000
34800578:	e59f0378 	ldr	r0, [pc, #888]	; 348008f8 <ddrmem_init+0x18>
	ldr     r1, [r0]
3480057c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800580:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800584:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1900000
34800588:	e59f036c 	ldr	r0, [pc, #876]	; 348008fc <ddrmem_init+0x1c>
	ldr     r1, [r0]
3480058c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800590:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800594:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1a00000
34800598:	e59f0360 	ldr	r0, [pc, #864]	; 34800900 <ddrmem_init+0x20>
	ldr     r1, [r0]
3480059c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005a0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005a4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1b00000
348005a8:	e59f0354 	ldr	r0, [pc, #852]	; 34800904 <ddrmem_init+0x24>
	ldr     r1, [r0]
348005ac:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005b0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005b4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1c00000
348005b8:	e59f0348 	ldr	r0, [pc, #840]	; 34800908 <ddrmem_init+0x28>
	ldr     r1, [r0]
348005bc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005c0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005c4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1d00000
348005c8:	e59f033c 	ldr	r0, [pc, #828]	; 3480090c <ddrmem_init+0x2c>
	ldr     r1, [r0]
348005cc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005d0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005d4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1e00000
348005d8:	e59f0330 	ldr	r0, [pc, #816]	; 34800910 <ddrmem_init+0x30>
	ldr     r1, [r0]
348005dc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005e0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005e4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1f00000
348005e8:	e59f0324 	ldr	r0, [pc, #804]	; 34800914 <ddrmem_init+0x34>
	ldr     r1, [r0]
348005ec:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005f0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005f4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xfaf00000
348005f8:	e59f0318 	ldr	r0, [pc, #792]	; 34800918 <ddrmem_init+0x38>
	ldr     r1, [r0]
348005fc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800600:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800604:	e5801000 	str	r1, [r0]

	/*
	 * Diable ABB block to reduce sleep current at low temperature
	 * Note that it's hidden register setup don't modify it
	 */
	ldr	r0, =0xE010C300
34800608:	e59f030c 	ldr	r0, [pc, #780]	; 3480091c <ddrmem_init+0x3c>
	ldr	r1, =0x00800000
3480060c:	e3a01502 	mov	r1, #8388608	; 0x800000
	str	r1, [r0]
34800610:	e5801000 	str	r1, [r0]

100:
	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
34800614:	059f0304 	ldreq	r0, [pc, #772]	; 34800920 <ddrmem_init+0x40>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
34800618:	159f0304 	ldrne	r0, [pc, #772]	; 34800924 <ddrmem_init+0x44>
	ldr	r1, [r0]
3480061c:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
34800620:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800624:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
34800628:	e1811002 	orr	r1, r1, r2
	/* Do not release retention here for S5PC110 */
	streq	r1, [r0]
3480062c:	05801000 	streq	r1, [r0]

	/* Disable Watchdog */
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
34800630:	059f02f0 	ldreq	r0, [pc, #752]	; 34800928 <ddrmem_init+0x48>
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
34800634:	159f02f0 	ldrne	r0, [pc, #752]	; 3480092c <ddrmem_init+0x4c>
	str	r5, [r0]
34800638:	e5805000 	str	r5, [r0]

	/* setting SRAM */
	ldreq	r0, =S5PC100_SROMC_BASE
3480063c:	03a004e7 	moveq	r0, #-419430400	; 0xe7000000
	ldrne	r0, =S5PC110_SROMC_BASE
34800640:	13a0033a 	movne	r0, #-402653184	; 0xe8000000
	ldr	r1, =0x9
34800644:	e3a01009 	mov	r1, #9
	str	r1, [r0]
34800648:	e5801000 	str	r1, [r0]

	/* S5PC100 has 3 groups of interrupt sources */
	ldreq	r0, =S5PC100_VIC0_BASE			@ 0xE4000000
3480064c:	03a00339 	moveq	r0, #-469762048	; 0xe4000000
	ldrne	r0, =S5PC110_VIC0_BASE			@ 0xF2000000
34800650:	13a004f2 	movne	r0, #-234881024	; 0xf2000000
	add	r1, r0, #0x00100000
34800654:	e2801601 	add	r1, r0, #1048576	; 0x100000
	add	r2, r0, #0x00200000
34800658:	e2802602 	add	r2, r0, #2097152	; 0x200000

	/* Disable all interrupts (VIC0, VIC1 and VIC2) */
	mvn	r3, #0x0
3480065c:	e3e03000 	mvn	r3, #0
	str	r3, [r0, #0x14]				@ INTENCLEAR
34800660:	e5803014 	str	r3, [r0, #20]
	str	r3, [r1, #0x14]				@ INTENCLEAR
34800664:	e5813014 	str	r3, [r1, #20]
	str	r3, [r2, #0x14]				@ INTENCLEAR
34800668:	e5823014 	str	r3, [r2, #20]

	/* Set all interrupts as IRQ */
	str	r5, [r0, #0xc]				@ INTSELECT
3480066c:	e580500c 	str	r5, [r0, #12]
	str	r5, [r1, #0xc]				@ INTSELECT
34800670:	e581500c 	str	r5, [r1, #12]
	str	r5, [r2, #0xc]				@ INTSELECT
34800674:	e582500c 	str	r5, [r2, #12]

	/* Pending Interrupt Clear */
	str	r5, [r0, #0xf00]			@ INTADDRESS
34800678:	e5805f00 	str	r5, [r0, #3840]	; 0xf00
	str	r5, [r1, #0xf00]			@ INTADDRESS
3480067c:	e5815f00 	str	r5, [r1, #3840]	; 0xf00
	str	r5, [r2, #0xf00]			@ INTADDRESS
34800680:	e5825f00 	str	r5, [r2, #3840]	; 0xf00

	/* for UART */
	bl	uart_asm_init
34800684:	eb000074 	bl	3480085c <uart_asm_init>

	/* for DDR */
	bl	ddrmem_init
34800688:	eb000094 	bl	348008e0 <ddrmem_init>

	/* for copy_sd_to_ddr */
	bl	copy_code_to_dram		/* copy u-boot.bin to ddr */
3480068c:	eb000151 	bl	34800bd8 <copy_code_to_dram>
	



	bl	internal_ram_init
34800690:	eb00006c 	bl	34800848 <internal_ram_init>

	cmp	r7, r8
34800694:	e1570008 	cmp	r7, r8
	/* Clear wakeup status register */
	ldreq	r0, =S5PC100_WAKEUP_STAT
34800698:	059f0290 	ldreq	r0, [pc, #656]	; 34800930 <ddrmem_init+0x50>
	ldrne	r0, =S5PC110_WAKEUP_STAT
3480069c:	159f0290 	ldrne	r0, [pc, #656]	; 34800934 <ddrmem_init+0x54>
	ldr	r1, [r0]
348006a0:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
348006a4:	e5801000 	str	r1, [r0]

	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
348006a8:	059f0270 	ldreq	r0, [pc, #624]	; 34800920 <ddrmem_init+0x40>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
348006ac:	159f0270 	ldrne	r0, [pc, #624]	; 34800924 <ddrmem_init+0x44>
	ldr	r1, [r0]
348006b0:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
348006b4:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
348006b8:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
348006bc:	e1811002 	orr	r1, r1, r2
	str	r1, [r0]
348006c0:	e5801000 	str	r1, [r0]

	b	1f
348006c4:	ea00000c 	b	348006fc <lockloop+0x30>

348006c8 <didle_wakeup>:

didle_wakeup:
	/* Wait when APLL is locked */
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
348006c8:	e59f0268 	ldr	r0, [pc, #616]	; 34800938 <ddrmem_init+0x58>

348006cc <lockloop>:
lockloop:
	ldr	r1, [r0]
348006cc:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #(1 << 29)
348006d0:	e2011202 	and	r1, r1, #536870912	; 0x20000000
	cmp	r1, #(1 << 29)
348006d4:	e3510202 	cmp	r1, #536870912	; 0x20000000
	bne	lockloop
348006d8:	1afffffb 	bne	348006cc <lockloop>

	ldr	r0, =S5PC110_INFORM0
348006dc:	e59f0258 	ldr	r0, [pc, #600]	; 3480093c <ddrmem_init+0x5c>
	ldr	r1, [r0]
348006e0:	e5901000 	ldr	r1, [r0]
	mov	pc, r1
348006e4:	e1a0f001 	mov	pc, r1
	nop
348006e8:	e320f000 	nop	{0}
	nop
348006ec:	e320f000 	nop	{0}
	nop
348006f0:	e320f000 	nop	{0}
	nop
348006f4:	e320f000 	nop	{0}
	nop
348006f8:	e320f000 	nop	{0}

1:
	mov	lr, r11
348006fc:	e1a0e00b 	mov	lr, fp
	mov	pc, lr
34800700:	e1a0f00e 	mov	pc, lr

34800704 <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
34800704:	e59f0234 	ldr	r0, [pc, #564]	; 34800940 <ddrmem_init+0x60>

	/* Check S5PC100 */
	cmp	r7, r8
34800708:	e1570008 	cmp	r7, r8
	bne	110f
3480070c:	1a00001b 	bne	34800780 <system_clock_init+0x7c>
100:
	/* Set Lock Time */
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
34800710:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x000]		@ S5PC100_APLL_LOCK
34800714:	e5801000 	str	r1, [r0]
	str	r1, [r0, #0x004]		@ S5PC100_MPLL_LOCK
34800718:	e5801004 	str	r1, [r0, #4]
	str	r1, [r0, #0x008]		@ S5PC100_EPLL_LOCK
3480071c:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x00C]		@ S5PC100_HPLL_LOCK
34800720:	e580100c 	str	r1, [r0, #12]

	/* S5P_APLL_CON */
	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
34800724:	e59f1218 	ldr	r1, [pc, #536]	; 34800944 <ddrmem_init+0x64>
	str	r1, [r0, #0x100]
34800728:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5P_MPLL_CON */
	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
3480072c:	e59f1214 	ldr	r1, [pc, #532]	; 34800948 <ddrmem_init+0x68>
	str	r1, [r0, #0x104]
34800730:	e5801104 	str	r1, [r0, #260]	; 0x104
	/* S5P_EPLL_CON */
	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
34800734:	e59f1210 	ldr	r1, [pc, #528]	; 3480094c <ddrmem_init+0x6c>
	str	r1, [r0, #0x108]
34800738:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5P_HPLL_CON */
	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
3480073c:	e59f120c 	ldr	r1, [pc, #524]	; 34800950 <ddrmem_init+0x70>
	str	r1, [r0, #0x10C]
34800740:	e580110c 	str	r1, [r0, #268]	; 0x10c

	ldr     r1, [r0, #0x300]
34800744:	e5901300 	ldr	r1, [r0, #768]	; 0x300
	ldr     r2, =0x00003fff
34800748:	e59f2204 	ldr	r2, [pc, #516]	; 34800954 <ddrmem_init+0x74>
	bic     r1, r1, r2
3480074c:	e1c11002 	bic	r1, r1, r2
	ldr     r2, =0x00011301
34800750:	e59f2200 	ldr	r2, [pc, #512]	; 34800958 <ddrmem_init+0x78>

	orr	r1, r1, r2
34800754:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #0x300]
34800758:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr     r1, [r0, #0x304]
3480075c:	e5901304 	ldr	r1, [r0, #772]	; 0x304
	ldr     r2, =0x00011110
34800760:	e59f21f4 	ldr	r2, [pc, #500]	; 3480095c <ddrmem_init+0x7c>
	orr     r1, r1, r2
34800764:	e1811002 	orr	r1, r1, r2
	str     r1, [r0, #0x304]
34800768:	e5801304 	str	r1, [r0, #772]	; 0x304
	ldr     r1, =0x00000001
3480076c:	e3a01001 	mov	r1, #1
	str     r1, [r0, #0x308]
34800770:	e5801308 	str	r1, [r0, #776]	; 0x308

	/* Set Source Clock */
	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
34800774:	e59f11e4 	ldr	r1, [pc, #484]	; 34800960 <ddrmem_init+0x80>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
34800778:	e5801200 	str	r1, [r0, #512]	; 0x200

	b	200f
3480077c:	ea00002d 	b	34800838 <system_clock_init+0x134>
110:
	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
34800780:	e59f01dc 	ldr	r0, [pc, #476]	; 34800964 <ddrmem_init+0x84>

	/* Set OSC_FREQ value */
	ldr	r1, =0xf
34800784:	e3a0100f 	mov	r1, #15
	str	r1, [r0, #0x100]		@ S5PC110_OSC_FREQ
34800788:	e5801100 	str	r1, [r0, #256]	; 0x100

	/* Set MTC_STABLE value */
	ldr	r1, =0xffffffff
3480078c:	e3e01000 	mvn	r1, #0
	str	r1, [r0, #0x110]		@ S5PC110_MTC_STABLE
34800790:	e5801110 	str	r1, [r0, #272]	; 0x110

	/* Set CLAMP_STABLE value */
	ldr	r1, =0x3ff03ff
34800794:	e59f11cc 	ldr	r1, [pc, #460]	; 34800968 <ddrmem_init+0x88>
	str	r1, [r0, #0x114]		@ S5PC110_CLAMP_STABLE
34800798:	e5801114 	str	r1, [r0, #276]	; 0x114

	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
3480079c:	e59f019c 	ldr	r0, [pc, #412]	; 34800940 <ddrmem_init+0x60>

	/* Set Clock divider */
	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
348007a0:	e59f11c4 	ldr	r1, [pc, #452]	; 3480096c <ddrmem_init+0x8c>
	str	r1, [r0, #0x300]
348007a4:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
348007a8:	e59f11c0 	ldr	r1, [pc, #448]	; 34800970 <ddrmem_init+0x90>
	str	r1, [r0, #0x310]
348007ac:	e5801310 	str	r1, [r0, #784]	; 0x310

	/* Set Lock Time */
	ldr	r1, =0x2cf			@ Locktime : 30us
348007b0:	e59f11bc 	ldr	r1, [pc, #444]	; 34800974 <ddrmem_init+0x94>
	str	r1, [r0, #0x000]		@ S5PC110_APLL_LOCK
348007b4:	e5801000 	str	r1, [r0]
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
348007b8:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x008]		@ S5PC110_MPLL_LOCK
348007bc:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x010]		@ S5PC110_EPLL_LOCK
348007c0:	e5801010 	str	r1, [r0, #16]
	str	r1, [r0, #0x020]		@ S5PC110_VPLL_LOCK
348007c4:	e5801020 	str	r1, [r0, #32]

	/* S5PC110_APLL_CON */
	ldr	r1, =0x80C80601			@ 800MHz
348007c8:	e59f11a8 	ldr	r1, [pc, #424]	; 34800978 <ddrmem_init+0x98>
	str	r1, [r0, #0x100]
348007cc:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5PC110_MPLL_CON */
	ldr	r1, =0x829B0C01			@ 667MHz
348007d0:	e59f11a4 	ldr	r1, [pc, #420]	; 3480097c <ddrmem_init+0x9c>
	str	r1, [r0, #0x108]
348007d4:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5PC110_EPLL_CON */
	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
348007d8:	e59f11a0 	ldr	r1, [pc, #416]	; 34800980 <ddrmem_init+0xa0>
	str	r1, [r0, #0x110]
348007dc:	e5801110 	str	r1, [r0, #272]	; 0x110
	/* S5PC110_VPLL_CON */
	ldr	r1, =0x806C0603			@  54MHz
348007e0:	e59f119c 	ldr	r1, [pc, #412]	; 34800984 <ddrmem_init+0xa4>
	str	r1, [r0, #0x120]
348007e4:	e5801120 	str	r1, [r0, #288]	; 0x120

	/* Set Source Clock */
	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
348007e8:	e59f1198 	ldr	r1, [pc, #408]	; 34800988 <ddrmem_init+0xa8>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
348007ec:	e5801200 	str	r1, [r0, #512]	; 0x200

	/* OneDRAM(DMC0) clock setting */
	ldr	r1, =0x01000000			@ ONEDRAM_SEL[25:24] 1 SCLKMPLL
348007f0:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #0x218]		@ S5PC110_CLK_SRC6
348007f4:	e5801218 	str	r1, [r0, #536]	; 0x218
	ldr	r1, =0x30000000			@ ONEDRAM_RATIO[31:28] 3 + 1
348007f8:	e3a01203 	mov	r1, #805306368	; 0x30000000
	str	r1, [r0, #0x318]		@ S5PC110_CLK_DIV6
348007fc:	e5801318 	str	r1, [r0, #792]	; 0x318

	/* XCLKOUT = XUSBXTI 24MHz */
	add	r2, r0, #0xE000			@ S5PC110_OTHERS
34800800:	e2802a0e 	add	r2, r0, #57344	; 0xe000
	ldr     r1, [r2]
34800804:	e5921000 	ldr	r1, [r2]
	orr	r1, r1, #(0x3 << 8)		@ CLKOUT[9:8] 3 XUSBXTI
34800808:	e3811c03 	orr	r1, r1, #768	; 0x300
	str	r1, [r2]
3480080c:	e5821000 	str	r1, [r2]

	/* CLK_IP0 */
	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
34800810:	e59f1174 	ldr	r1, [pc, #372]	; 3480098c <ddrmem_init+0xac>
	str	r1, [r0, #0x460]		@ S5PC110_CLK_IP0
34800814:	e5801460 	str	r1, [r0, #1120]	; 0x460

	/* CLK_IP1 */
	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
34800818:	e59f1170 	ldr	r1, [pc, #368]	; 34800990 <ddrmem_init+0xb0>
						@ NANDXL[24]
	str	r1, [r0, #0x464]		@ S5PC110_CLK_IP1
3480081c:	e5801464 	str	r1, [r0, #1124]	; 0x464

	/* CLK_IP2 */
	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
34800820:	e59f116c 	ldr	r1, [pc, #364]	; 34800994 <ddrmem_init+0xb4>
						@ HOSTIF[10] HSMMC0[16]
						@ HSMMC2[18] VIC[27:24]
	str	r1, [r0, #0x468]		@ S5PC110_CLK_IP2
34800824:	e5801468 	str	r1, [r0, #1128]	; 0x468

	/* CLK_IP3 */
	ldr	r1, =0x8eff038c			@ I2C[8:6]
34800828:	e59f1168 	ldr	r1, [pc, #360]	; 34800998 <ddrmem_init+0xb8>
						@ SYSTIMER[16] UART0[17]
						@ UART1[18] UART2[19]
						@ UART3[20] WDT[22]
						@ PWM[23] GPIO[26] SYSCON[27]
	str	r1, [r0, #0x46c]		@ S5PC110_CLK_IP3
3480082c:	e580146c 	str	r1, [r0, #1132]	; 0x46c

	/* CLK_IP4 */
	ldr	r1, =0xfffffff1			@ CHIP_ID[0] TZPC[8:5]
34800830:	e3e0100e 	mvn	r1, #14
	str	r1, [r0, #0x470]		@ S5PC110_CLK_IP3
34800834:	e5801470 	str	r1, [r0, #1136]	; 0x470

200:
	/* wait at least 200us to stablize all clock */
	mov	r2, #0x10000
34800838:	e3a02801 	mov	r2, #65536	; 0x10000
1:	subs	r2, r2, #1
3480083c:	e2522001 	subs	r2, r2, #1
	bne	1b
34800840:	1afffffd 	bne	3480083c <system_clock_init+0x138>

	mov	pc, lr
34800844:	e1a0f00e 	mov	pc, lr

34800848 <internal_ram_init>:

internal_ram_init:
	ldreq	r0, =0xE3800000
34800848:	059f014c 	ldreq	r0, [pc, #332]	; 3480099c <ddrmem_init+0xbc>
	ldrne	r0, =0xF1500000
3480084c:	159f014c 	ldrne	r0, [pc, #332]	; 348009a0 <ddrmem_init+0xc0>
	ldr	r1, =0x0
34800850:	e3a01000 	mov	r1, #0
	str	r1, [r0]
34800854:	e5801000 	str	r1, [r0]

	mov	pc, lr
34800858:	e1a0f00e 	mov	pc, lr

3480085c <uart_asm_init>:
/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	/* set GPIO to enable UART0-UART4 */
	mov	r0, r8
3480085c:	e1a00008 	mov	r0, r8
	ldr	r1, =0x22222222
34800860:	e59f113c 	ldr	r1, [pc, #316]	; 348009a4 <ddrmem_init+0xc4>
	str	r1, [r0, #0x0]			@ S5PC100_GPIO_A0_OFFSET
34800864:	e5801000 	str	r1, [r0]
	ldr	r1, =0x00002222
34800868:	e59f1138 	ldr	r1, [pc, #312]	; 348009a8 <ddrmem_init+0xc8>
	str	r1, [r0, #0x20]			@ S5PC100_GPIO_A1_OFFSET
3480086c:	e5801020 	str	r1, [r0, #32]

	/* Check S5PC100 */
	cmp	r7, r8
34800870:	e1570008 	cmp	r7, r8
	bne	110f
34800874:	1a00000c 	bne	348008ac <uart_asm_init+0x50>

	/* UART_SEL GPK0[5] at S5PC100 */
	add	r0, r8, #0x2A0			@ S5PC100_GPIO_K0_OFFSET
34800878:	e2880e2a 	add	r0, r8, #672	; 0x2a0
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
3480087c:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 20)		@ 20 = 5 * 4-bit
34800880:	e3c1160f 	bic	r1, r1, #15728640	; 0xf00000
	orr	r1, r1, #(0x1 << 20)		@ Output
34800884:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
34800888:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
3480088c:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 10)		@ 10 = 5 * 2-bit
34800890:	e3c11b03 	bic	r1, r1, #3072	; 0xc00
	orr	r1, r1, #(0x2 << 10)		@ Pull-up enabled
34800894:	e3811b02 	orr	r1, r1, #2048	; 0x800
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800898:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3480089c:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 5)		@ 5 = 5 * 1-bit
348008a0:	e3811020 	orr	r1, r1, #32
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
348008a4:	e5801004 	str	r1, [r0, #4]

	b	200f
348008a8:	ea00000b 	b	348008dc <uart_asm_init+0x80>
	/*
	 * Note that the following address
	 * 0xE020'0360 is reserved address at S5PC100
	 */
	/* UART_SEL MP0_5[7] at S5PC110 */
	add	r0, r8, #0x360			@ S5PC110_GPIO_MP0_5_OFFSET
348008ac:	e2880e36 	add	r0, r8, #864	; 0x360
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348008b0:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 28)		@ 28 = 7 * 4-bit
348008b4:	e3c1120f 	bic	r1, r1, #-268435456	; 0xf0000000
	orr	r1, r1, #(0x1 << 28)		@ Output
348008b8:	e3811201 	orr	r1, r1, #268435456	; 0x10000000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348008bc:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
348008c0:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 14)		@ 14 = 7 * 2-bit
348008c4:	e3c11903 	bic	r1, r1, #49152	; 0xc000
	orr	r1, r1, #(0x2 << 14)		@ Pull-up enabled
348008c8:	e3811902 	orr	r1, r1, #32768	; 0x8000
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
348008cc:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
348008d0:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 7)		@ 7 = 7 * 1-bit
348008d4:	e3811080 	orr	r1, r1, #128	; 0x80
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
348008d8:	e5801004 	str	r1, [r0, #4]
200:
	mov	pc, lr
348008dc:	e1a0f00e 	mov	pc, lr

348008e0 <ddrmem_init>:



ddrmem_init:
348008e0:	e1a0f00e 	mov	pc, lr
	ldr	r7, =S5PC100_GPIO_BASE
348008e4:	e0300000 	.word	0xe0300000
	ldr	r8, =S5PC110_GPIO_BASE
348008e8:	e0200000 	.word	0xe0200000
	ldr	r0, =S5PC110_RST_STAT
348008ec:	e010a000 	.word	0xe010a000
	ldr     r0, =0xe0f00000
348008f0:	e0f00000 	.word	0xe0f00000
	ldr     r0, =0xe1f00000
348008f4:	e1f00000 	.word	0xe1f00000
	ldr     r0, =0xf1800000
348008f8:	f1800000 	.word	0xf1800000
	ldr     r0, =0xf1900000
348008fc:	f1900000 	.word	0xf1900000
	ldr     r0, =0xf1a00000
34800900:	f1a00000 	.word	0xf1a00000
	ldr     r0, =0xf1b00000
34800904:	f1b00000 	.word	0xf1b00000
	ldr     r0, =0xf1c00000
34800908:	f1c00000 	.word	0xf1c00000
	ldr     r0, =0xf1d00000
3480090c:	f1d00000 	.word	0xf1d00000
	ldr     r0, =0xf1e00000
34800910:	f1e00000 	.word	0xf1e00000
	ldr     r0, =0xf1f00000
34800914:	f1f00000 	.word	0xf1f00000
	ldr     r0, =0xfaf00000
34800918:	faf00000 	.word	0xfaf00000
	ldr	r0, =0xE010C300
3480091c:	e010c300 	.word	0xe010c300
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
34800920:	e0108200 	.word	0xe0108200
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
34800924:	e010e000 	.word	0xe010e000
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
34800928:	ea200000 	.word	0xea200000
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
3480092c:	e2700000 	.word	0xe2700000
	ldreq	r0, =S5PC100_WAKEUP_STAT
34800930:	e0108304 	.word	0xe0108304
	ldrne	r0, =S5PC110_WAKEUP_STAT
34800934:	e010c200 	.word	0xe010c200
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
34800938:	e0100100 	.word	0xe0100100
	ldr	r0, =S5PC110_INFORM0
3480093c:	e010f000 	.word	0xe010f000
	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
34800940:	e0100000 	.word	0xe0100000
	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
34800944:	81bc0400 	.word	0x81bc0400
	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
34800948:	80590201 	.word	0x80590201
	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
3480094c:	80870303 	.word	0x80870303
	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
34800950:	80600603 	.word	0x80600603
	ldr     r2, =0x00003fff
34800954:	00003fff 	.word	0x00003fff
	ldr     r2, =0x00011301
34800958:	00011301 	.word	0x00011301
	ldr     r2, =0x00011110
3480095c:	00011110 	.word	0x00011110
	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
34800960:	00001111 	.word	0x00001111
	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
34800964:	e010c000 	.word	0xe010c000
	ldr	r1, =0x3ff03ff
34800968:	03ff03ff 	.word	0x03ff03ff
	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
3480096c:	14131330 	.word	0x14131330
	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
34800970:	11110111 	.word	0x11110111
	ldr	r1, =0x2cf			@ Locktime : 30us
34800974:	000002cf 	.word	0x000002cf
	ldr	r1, =0x80C80601			@ 800MHz
34800978:	80c80601 	.word	0x80c80601
	ldr	r1, =0x829B0C01			@ 667MHz
3480097c:	829b0c01 	.word	0x829b0c01
	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
34800980:	80600602 	.word	0x80600602
	ldr	r1, =0x806C0603			@  54MHz
34800984:	806c0603 	.word	0x806c0603
	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
34800988:	10001111 	.word	0x10001111
	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
3480098c:	08fefeeb 	.word	0x08fefeeb
	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
34800990:	e9fdf0f9 	.word	0xe9fdf0f9
	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
34800994:	0f75f7fc 	.word	0x0f75f7fc
	ldr	r1, =0x8eff038c			@ I2C[8:6]
34800998:	8eff038c 	.word	0x8eff038c
	ldreq	r0, =0xE3800000
3480099c:	e3800000 	.word	0xe3800000
	ldrne	r0, =0xF1500000
348009a0:	f1500000 	.word	0xf1500000
	ldr	r1, =0x22222222
348009a4:	22222222 	.word	0x22222222
	ldr	r1, =0x00002222
348009a8:	00002222 	.word	0x00002222

348009ac <s5pc1xx_phy_control>:
}
#endif

#ifdef CONFIG_USB_GADGET
static int s5pc1xx_phy_control(int on)
{
348009ac:	e92d4070 	push	{r4, r5, r6, lr}
348009b0:	e1a05000 	mov	r5, r0
	int ret;
	static int status;
	struct pmic *p = get_pmic();
348009b4:	eb00415c 	bl	34810f2c <get_pmic>
348009b8:	e1a06000 	mov	r6, r0

	if (pmic_probe(p))
348009bc:	eb0041b8 	bl	348110a4 <pmic_probe>
348009c0:	e2504000 	subs	r4, r0, #0
348009c4:	1a000028 	bne	34800a6c <s5pc1xx_phy_control+0xc0>
		return -1;

	if (on && !status) {
348009c8:	e3550000 	cmp	r5, #0
348009cc:	e59f50a4 	ldr	r5, [pc, #164]	; 34800a78 <s5pc1xx_phy_control+0xcc>
348009d0:	e5953000 	ldr	r3, [r5]
348009d4:	0a000012 	beq	34800a24 <s5pc1xx_phy_control+0x78>
348009d8:	e3530000 	cmp	r3, #0
348009dc:	1a00001f 	bne	34800a60 <s5pc1xx_phy_control+0xb4>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
348009e0:	e3a03001 	mov	r3, #1
348009e4:	e3a02004 	mov	r2, #4
348009e8:	e3a01011 	mov	r1, #17
348009ec:	e1a00006 	mov	r0, r6
348009f0:	eb004135 	bl	34810ecc <pmic_set_output>
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
348009f4:	e3a03001 	mov	r3, #1
348009f8:	e3a02020 	mov	r2, #32
348009fc:	e3a01012 	mov	r1, #18
34800a00:	e1a00006 	mov	r0, r6
34800a04:	eb004130 	bl	34810ecc <pmic_set_output>
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800a08:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
34800a0c:	03a03001 	moveq	r3, #1
34800a10:	05853000 	streq	r3, [r5]
		if (ret) {
34800a14:	0a000011 	beq	34800a60 <s5pc1xx_phy_control+0xb4>
			puts("MAX8998 LDO setting error!\n");
34800a18:	e59f005c 	ldr	r0, [pc, #92]	; 34800a7c <s5pc1xx_phy_control+0xd0>
34800a1c:	eb002352 	bl	3480976c <puts>
34800a20:	ea000011 	b	34800a6c <s5pc1xx_phy_control+0xc0>
	} else if (!on && status) {
34800a24:	e3530000 	cmp	r3, #0
34800a28:	0a00000c 	beq	34800a60 <s5pc1xx_phy_control+0xb4>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800a2c:	e1a03004 	mov	r3, r4
34800a30:	e3a02004 	mov	r2, #4
34800a34:	e3a01011 	mov	r1, #17
34800a38:	e1a00006 	mov	r0, r6
34800a3c:	eb004122 	bl	34810ecc <pmic_set_output>
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800a40:	e1a03004 	mov	r3, r4
34800a44:	e3a02020 	mov	r2, #32
34800a48:	e3a01012 	mov	r1, #18
34800a4c:	e1a00006 	mov	r0, r6
34800a50:	eb00411d 	bl	34810ecc <pmic_set_output>
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800a54:	e3500000 	cmp	r0, #0
34800a58:	1affffee 	bne	34800a18 <s5pc1xx_phy_control+0x6c>
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 0;
34800a5c:	e5854000 	str	r4, [r5]
	}
	udelay(10000);
34800a60:	e3020710 	movw	r0, #10000	; 0x2710
34800a64:	eb006ce8 	bl	3481be0c <udelay>

	return 0;
34800a68:	ea000000 	b	34800a70 <s5pc1xx_phy_control+0xc4>
		return -1;
34800a6c:	e3e04000 	mvn	r4, #0
}
34800a70:	e1a00004 	mov	r0, r4
34800a74:	e8bd8070 	pop	{r4, r5, r6, pc}
34800a78:	348285d0 	.word	0x348285d0
34800a7c:	3482158c 	.word	0x3482158c

34800a80 <board_init>:
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800a80:	e59f202c 	ldr	r2, [pc, #44]	; 34800ab4 <board_init+0x34>
34800a84:	e59f302c 	ldr	r3, [pc, #44]	; 34800ab8 <board_init+0x38>
{
34800a88:	e92d4010 	push	{r4, lr}
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800a8c:	e5832004 	str	r2, [r3, #4]
	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800a90:	e3002b2e 	movw	r2, #2862	; 0xb2e
34800a94:	e5983000 	ldr	r3, [r8]
34800a98:	e5832004 	str	r2, [r3, #4]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800a9c:	e5983000 	ldr	r3, [r8]
34800aa0:	e59f2014 	ldr	r2, [pc, #20]	; 34800abc <board_init+0x3c>
34800aa4:	e5832008 	str	r2, [r3, #8]
	pmic_init();
34800aa8:	eb00418b 	bl	348110dc <pmic_init>
}
34800aac:	e3a00000 	mov	r0, #0
34800ab0:	e8bd8010 	pop	{r4, pc}
34800ab4:	e0200000 	.word	0xe0200000
34800ab8:	348285d0 	.word	0x348285d0
34800abc:	20000100 	.word	0x20000100

34800ac0 <dram_init>:
	gd->ram_size = PHYS_SDRAM_1_SIZE;
34800ac0:	e3a02202 	mov	r2, #536870912	; 0x20000000
}
34800ac4:	e3a00000 	mov	r0, #0
	gd->ram_size = PHYS_SDRAM_1_SIZE;
34800ac8:	e5882038 	str	r2, [r8, #56]	; 0x38
}
34800acc:	e12fff1e 	bx	lr

34800ad0 <dram_init_banksize>:
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800ad0:	e5982000 	ldr	r2, [r8]
34800ad4:	e3a03202 	mov	r3, #536870912	; 0x20000000
34800ad8:	e5823018 	str	r3, [r2, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800adc:	e5982000 	ldr	r2, [r8]
34800ae0:	e582301c 	str	r3, [r2, #28]
34800ae4:	e12fff1e 	bx	lr

34800ae8 <checkboard>:
{
34800ae8:	e92d4010 	push	{r4, lr}
	puts("Board:\tGoni\n");
34800aec:	e59f0008 	ldr	r0, [pc, #8]	; 34800afc <checkboard+0x14>
34800af0:	eb00231d 	bl	3480976c <puts>
}
34800af4:	e3a00000 	mov	r0, #0
34800af8:	e8bd8010 	pop	{r4, pc}
34800afc:	348215a8 	.word	0x348215a8

34800b00 <board_mmc_init>:
{
34800b00:	e92d4070 	push	{r4, r5, r6, lr}
	for (i = 0; i < 7; i++) {
34800b04:	e3a04000 	mov	r4, #0
	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
34800b08:	e59f5094 	ldr	r5, [pc, #148]	; 34800ba4 <board_mmc_init+0xa4>
34800b0c:	e3a02001 	mov	r2, #1
34800b10:	e3a01007 	mov	r1, #7
34800b14:	e5950004 	ldr	r0, [r5, #4]
34800b18:	e2800d0a 	add	r0, r0, #640	; 0x280
34800b1c:	eb003d9d 	bl	34810198 <s5p_gpio_direction_output>
		if (i == 2)
34800b20:	e3540002 	cmp	r4, #2
34800b24:	0a00000e 	beq	34800b64 <board_mmc_init+0x64>
		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
34800b28:	e5950004 	ldr	r0, [r5, #4]
34800b2c:	e3a02002 	mov	r2, #2
34800b30:	e1a01004 	mov	r1, r4
34800b34:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800b38:	eb003d8f 	bl	3481017c <s5p_gpio_cfg_pin>
		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
34800b3c:	e5950004 	ldr	r0, [r5, #4]
34800b40:	e3a02000 	mov	r2, #0
34800b44:	e1a01004 	mov	r1, r4
34800b48:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800b4c:	eb003daf 	bl	34810210 <s5p_gpio_set_pull>
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
34800b50:	e5950004 	ldr	r0, [r5, #4]
34800b54:	e3a02003 	mov	r2, #3
34800b58:	e1a01004 	mov	r1, r4
34800b5c:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800b60:	eb003db3 	bl	34810234 <s5p_gpio_set_drv>
	for (i = 0; i < 7; i++) {
34800b64:	e2844001 	add	r4, r4, #1
34800b68:	e3540007 	cmp	r4, #7
34800b6c:	1affffeb 	bne	34800b20 <board_mmc_init+0x20>
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800b70:	e59f3030 	ldr	r3, [pc, #48]	; 34800ba8 <board_mmc_init+0xa8>
34800b74:	e5933000 	ldr	r3, [r3]
}

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
34800b78:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800b7c:	059f0028 	ldreq	r0, [pc, #40]	; 34800bac <board_mmc_init+0xac>
34800b80:	0a000003 	beq	34800b94 <board_mmc_init+0x94>
34800b84:	e30c0110 	movw	r0, #49424	; 0xc110
34800b88:	e1530000 	cmp	r3, r0
34800b8c:	03a004eb 	moveq	r0, #-352321536	; 0xeb000000
34800b90:	13a00000 	movne	r0, #0
int s5p_sdhci_init(u32 regbase, int index, int bus_width);

static inline unsigned int s5p_mmc_init(int index, int bus_width)
{
	unsigned int base = samsung_get_base_mmc() + (0x10000 * index);
	return s5p_sdhci_init(base, index, bus_width);
34800b94:	e3a02004 	mov	r2, #4
34800b98:	e3a01000 	mov	r1, #0
}
34800b9c:	e8bd4070 	pop	{r4, r5, r6, lr}
34800ba0:	ea004908 	b	34812fc8 <s5p_sdhci_init>
34800ba4:	348285d0 	.word	0x348285d0
34800ba8:	34827004 	.word	0x34827004
34800bac:	ed800000 	.word	0xed800000

34800bb0 <onenand_board_init>:
#include <linux/mtd/samsung_onenand.h>
#include <onenand_uboot.h>

void onenand_board_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34800bb0:	e5903094 	ldr	r3, [r0, #148]	; 0x94

	this->base = (void *)CONFIG_SYS_ONENAND_BASE;
34800bb4:	e3a0220b 	mov	r2, #-1342177280	; 0xb0000000
34800bb8:	e5832000 	str	r2, [r3]
	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34800bbc:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
34800bc0:	e3822c02 	orr	r2, r2, #512	; 0x200
34800bc4:	e583202c 	str	r2, [r3, #44]	; 0x2c
	this->chip_probe = s5pc110_chip_probe;
34800bc8:	e59f2004 	ldr	r2, [pc, #4]	; 34800bd4 <onenand_board_init+0x24>
34800bcc:	e5832070 	str	r2, [r3, #112]	; 0x70
34800bd0:	e12fff1e 	bx	lr
34800bd4:	34817b60 	.word	0x34817b60

34800bd8 <copy_code_to_dram>:
        unsigned long dest = 0x34800000;
        unsigned int  sec_no = 49;

        unsigned int ret;

        ch = *(volatile unsigned int *)(0xD0037488);
34800bd8:	e59f3064 	ldr	r3, [pc, #100]	; 34800c44 <copy_code_to_dram+0x6c>
{
34800bdc:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
        ch = *(volatile unsigned int *)(0xD0037488);
34800be0:	e5932488 	ldr	r2, [r3, #1160]	; 0x488

        copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem)(*(unsigned int *)(0xD0037F98));
34800be4:	e5935f98 	ldr	r5, [r3, #3992]	; 0xf98

        if (ch == 0xEB000000) {
34800be8:	e35204eb 	cmp	r2, #-352321536	; 0xeb000000
34800bec:	1a000012 	bne	34800c3c <copy_code_to_dram+0x64>
                ret = copy_bl2(0, sec_no, 128, (unsigned int *)dest, 0);
34800bf0:	e3a04000 	mov	r4, #0
34800bf4:	e3a035d2 	mov	r3, #880803840	; 0x34800000
34800bf8:	e3a02080 	mov	r2, #128	; 0x80
34800bfc:	e3a01031 	mov	r1, #49	; 0x31
34800c00:	e58d4000 	str	r4, [sp]
34800c04:	e1a00004 	mov	r0, r4
34800c08:	e12fff35 	blx	r5
                ret = copy_bl2(0, sec_no+128, 128, (unsigned int *)(dest+0x10000), 0);
34800c0c:	e59f3034 	ldr	r3, [pc, #52]	; 34800c48 <copy_code_to_dram+0x70>
34800c10:	e3a02080 	mov	r2, #128	; 0x80
34800c14:	e3a010b1 	mov	r1, #177	; 0xb1
34800c18:	e58d4000 	str	r4, [sp]
34800c1c:	e1a00004 	mov	r0, r4
34800c20:	e12fff35 	blx	r5
                ret = copy_bl2(0, sec_no+256, 128, (unsigned int *)(dest+0x20000), 0);
34800c24:	e58d4000 	str	r4, [sp]
34800c28:	e3a02080 	mov	r2, #128	; 0x80
34800c2c:	e59f3018 	ldr	r3, [pc, #24]	; 34800c4c <copy_code_to_dram+0x74>
34800c30:	e3001131 	movw	r1, #305	; 0x131
34800c34:	e1a00004 	mov	r0, r4
34800c38:	e12fff35 	blx	r5
        }
}
34800c3c:	e28dd00c 	add	sp, sp, #12
34800c40:	e8bd8030 	pop	{r4, r5, pc}
34800c44:	d0037000 	.word	0xd0037000
34800c48:	34810000 	.word	0x34810000
34800c4c:	34820000 	.word	0x34820000

34800c50 <v7_maint_dcache_all>:
						   way_shift, log2_line_len);
	}
}

static void v7_maint_dcache_all(u32 operation)
{
34800c50:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800c54:	ee304f30 	mrc	15, 1, r4, cr0, cr0, {1}
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800c58:	e3a01000 	mov	r1, #0
	CP15DSB;
34800c5c:	e1a0e001 	mov	lr, r1
34800c60:	e1a0c081 	lsl	ip, r1, #1
34800c64:	e08c3001 	add	r3, ip, r1
		cache_type = (clidr >> level_start_bit) & 0x7;
34800c68:	e1a03334 	lsr	r3, r4, r3
34800c6c:	e2033007 	and	r3, r3, #7
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
34800c70:	e2433002 	sub	r3, r3, #2
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
34800c74:	e3530002 	cmp	r3, #2
34800c78:	8a000024 	bhi	34800d10 <v7_maint_dcache_all+0xc0>
	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
34800c7c:	ee40cf10 	mcr	15, 2, ip, cr0, cr0, {0}
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800c80:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800c84:	e7e931d5 	ubfx	r3, r5, #3, #10
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800c88:	e2056007 	and	r6, r5, #7
	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800c8c:	e2839001 	add	r9, r3, #1
	log2_line_len += 2;
34800c90:	e2866004 	add	r6, r6, #4
	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
34800c94:	e7ee56d5 	ubfx	r5, r5, #13, #15
#define _UTILS_H_

static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
	u32 temp = n;
34800c98:	e1a07009 	mov	r7, r9
	s32 log2n = -1;
34800c9c:	e3e02000 	mvn	r2, #0

	while (temp) {
34800ca0:	e1b070a7 	lsrs	r7, r7, #1
		log2n++;
34800ca4:	e2822001 	add	r2, r2, #1
	while (temp) {
34800ca8:	1afffffc 	bne	34800ca0 <v7_maint_dcache_all+0x50>
		temp >>= 1;
	}

	if (n & (n - 1))
34800cac:	e1190003 	tst	r9, r3
		return log2n + 1; /* not power of 2 - round up */
34800cb0:	12822001 	addne	r2, r2, #1
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800cb4:	e3500001 	cmp	r0, #1
	way_shift = (32 - log2_num_ways);
34800cb8:	e2622020 	rsb	r2, r2, #32
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800cbc:	1a000008 	bne	34800ce4 <v7_maint_dcache_all+0x94>
34800cc0:	e18ca213 	orr	sl, ip, r3, lsl r2
		for (set = num_sets - 1; set >= 0; set--) {
34800cc4:	e1a07005 	mov	r7, r5
			setway = (level << 1) | (set << log2_line_len) |
34800cc8:	e18a9617 	orr	r9, sl, r7, lsl r6
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
34800ccc:	ee079f56 	mcr	15, 0, r9, cr7, cr6, {2}
		for (set = num_sets - 1; set >= 0; set--) {
34800cd0:	e2577001 	subs	r7, r7, #1
34800cd4:	2afffffb 	bcs	34800cc8 <v7_maint_dcache_all+0x78>
	for (way = num_ways - 1; way >= 0 ; way--) {
34800cd8:	e2533001 	subs	r3, r3, #1
34800cdc:	2afffff7 	bcs	34800cc0 <v7_maint_dcache_all+0x70>
34800ce0:	ea000009 	b	34800d0c <v7_maint_dcache_all+0xbc>
	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
34800ce4:	e3500002 	cmp	r0, #2
34800ce8:	1a000008 	bne	34800d10 <v7_maint_dcache_all+0xc0>
34800cec:	e18ca213 	orr	sl, ip, r3, lsl r2
		for (set = num_sets - 1; set >= 0; set--) {
34800cf0:	e1a07005 	mov	r7, r5
			setway = (level << 1) | (set << log2_line_len) |
34800cf4:	e18a9617 	orr	r9, sl, r7, lsl r6
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
34800cf8:	ee079f5e 	mcr	15, 0, r9, cr7, cr14, {2}
		for (set = num_sets - 1; set >= 0; set--) {
34800cfc:	e2577001 	subs	r7, r7, #1
34800d00:	2afffffb 	bcs	34800cf4 <v7_maint_dcache_all+0xa4>
	for (way = num_ways - 1; way >= 0 ; way--) {
34800d04:	e2533001 	subs	r3, r3, #1
34800d08:	2afffff7 	bcs	34800cec <v7_maint_dcache_all+0x9c>
	CP15DSB;
34800d0c:	ee07ef9a 	mcr	15, 0, lr, cr7, cr10, {4}
	for (level = 0; level < 7; level++) {
34800d10:	e2811001 	add	r1, r1, #1
34800d14:	e3510007 	cmp	r1, #7
34800d18:	1affffd0 	bne	34800c60 <v7_maint_dcache_all+0x10>
		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
			v7_maint_dcache_level_setway(level, operation);
		level_start_bit += 3;
	}
}
34800d1c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

34800d20 <invalidate_icache_all>:
{
	/*
	 * Invalidate all instruction caches to PoU.
	 * Also flushes branch target cache.
	 */
	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
34800d20:	e3a03000 	mov	r3, #0
34800d24:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}

	/* Invalidate entire branch predictor array */
	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
34800d28:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}

	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
34800d2c:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}

	/* ISB - make sure the instruction stream sees it */
	CP15ISB;
34800d30:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
34800d34:	e12fff1e 	bx	lr

34800d38 <__v7_outer_cache_enable>:

/*
 * Stub implementations for outer cache operations
 */
void __v7_outer_cache_enable(void)
{
34800d38:	e12fff1e 	bx	lr

34800d3c <__v7_outer_cache_disable>:
}
void v7_outer_cache_enable(void)
	__attribute__((weak, alias("__v7_outer_cache_enable")));

void __v7_outer_cache_disable(void)
{
34800d3c:	e12fff1e 	bx	lr

34800d40 <__v7_outer_cache_flush_all>:
}
void v7_outer_cache_disable(void)
	__attribute__((weak, alias("__v7_outer_cache_disable")));

void __v7_outer_cache_flush_all(void)
{
34800d40:	e12fff1e 	bx	lr

34800d44 <flush_dcache_all>:
{
34800d44:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
34800d48:	e3a00002 	mov	r0, #2
34800d4c:	ebffffbf 	bl	34800c50 <v7_maint_dcache_all>
}
34800d50:	e8bd4010 	pop	{r4, lr}
	v7_outer_cache_flush_all();
34800d54:	eafffff9 	b	34800d40 <__v7_outer_cache_flush_all>

34800d58 <__v7_outer_cache_inval_all>:
}
void v7_outer_cache_flush_all(void)
	__attribute__((weak, alias("__v7_outer_cache_flush_all")));

void __v7_outer_cache_inval_all(void)
{
34800d58:	e12fff1e 	bx	lr

34800d5c <invalidate_dcache_all>:
{
34800d5c:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
34800d60:	e3a00001 	mov	r0, #1
34800d64:	ebffffb9 	bl	34800c50 <v7_maint_dcache_all>
}
34800d68:	e8bd4010 	pop	{r4, lr}
	v7_outer_cache_inval_all();
34800d6c:	eafffff9 	b	34800d58 <__v7_outer_cache_inval_all>

34800d70 <arm_init_before_mmu>:
{
34800d70:	e92d4010 	push	{r4, lr}
	v7_outer_cache_enable();
34800d74:	eb000269 	bl	34801720 <v7_outer_cache_enable>
	invalidate_dcache_all();
34800d78:	ebfffff7 	bl	34800d5c <invalidate_dcache_all>
	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
34800d7c:	e3a03000 	mov	r3, #0
34800d80:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
34800d84:	ee083f16 	mcr	15, 0, r3, cr8, cr6, {0}
	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
34800d88:	ee083f15 	mcr	15, 0, r3, cr8, cr5, {0}
	CP15DSB;
34800d8c:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	CP15ISB;
34800d90:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
34800d94:	e8bd8010 	pop	{r4, pc}

34800d98 <__v7_outer_cache_flush_range>:
}
void v7_outer_cache_inval_all(void)
	__attribute__((weak, alias("__v7_outer_cache_inval_all")));

void __v7_outer_cache_flush_range(u32 start, u32 end)
{
34800d98:	e12fff1e 	bx	lr

34800d9c <flush_dcache_range>:
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800d9c:	ee303f10 	mrc	15, 1, r3, cr0, cr0, {0}
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800da0:	e2033007 	and	r3, r3, #7
	line_len = 1 << line_len;
34800da4:	e3a02001 	mov	r2, #1
	line_len += 2;
34800da8:	e2833004 	add	r3, r3, #4
	line_len = 1 << line_len;
34800dac:	e1a02312 	lsl	r2, r2, r3
	start &= ~(line_len - 1);
34800db0:	e2623000 	rsb	r3, r2, #0
34800db4:	e0033000 	and	r3, r3, r0
	for (mva = start; mva < stop; mva = mva + line_len) {
34800db8:	e1530001 	cmp	r3, r1
34800dbc:	2a000002 	bcs	34800dcc <flush_dcache_range+0x30>
		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
34800dc0:	ee073f3e 	mcr	15, 0, r3, cr7, cr14, {1}
	for (mva = start; mva < stop; mva = mva + line_len) {
34800dc4:	e0833002 	add	r3, r3, r2
34800dc8:	eafffffa 	b	34800db8 <flush_dcache_range+0x1c>
	CP15DSB;
34800dcc:	e3a03000 	mov	r3, #0
34800dd0:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	v7_outer_cache_flush_range(start, stop);
34800dd4:	eaffffef 	b	34800d98 <__v7_outer_cache_flush_range>

34800dd8 <flush_cache>:
	flush_dcache_range(start, start + size);
34800dd8:	e0801001 	add	r1, r0, r1
34800ddc:	eaffffee 	b	34800d9c <flush_dcache_range>

34800de0 <__v7_outer_cache_inval_range>:
}
void v7_outer_cache_flush_range(u32 start, u32 end)
	__attribute__((weak, alias("__v7_outer_cache_flush_range")));

void __v7_outer_cache_inval_range(u32 start, u32 end)
{
34800de0:	e12fff1e 	bx	lr

34800de4 <invalidate_dcache_range>:
{
34800de4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34800de8:	e1a06000 	mov	r6, r0
34800dec:	e1a07001 	mov	r7, r1
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800df0:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800df4:	e2055007 	and	r5, r5, #7
	line_len += 2;
34800df8:	e2853004 	add	r3, r5, #4
	line_len = 1 << line_len;
34800dfc:	e3a05001 	mov	r5, #1
34800e00:	e1a05315 	lsl	r5, r5, r3
	if (start & (line_len - 1)) {
34800e04:	e2459001 	sub	r9, r5, #1
34800e08:	e1190000 	tst	r9, r0
34800e0c:	01a04000 	moveq	r4, r0
34800e10:	0a000007 	beq	34800e34 <invalidate_dcache_range+0x50>
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34800e14:	e1a02000 	mov	r2, r0
34800e18:	e2464001 	sub	r4, r6, #1
34800e1c:	e59f1060 	ldr	r1, [pc, #96]	; 34800e84 <invalidate_dcache_range+0xa0>
34800e20:	e59f0060 	ldr	r0, [pc, #96]	; 34800e88 <invalidate_dcache_range+0xa4>
34800e24:	eb00225c 	bl	3480979c <printf>
		start = (start + line_len - 1) & ~(line_len - 1);
34800e28:	e0843005 	add	r3, r4, r5
34800e2c:	e2654000 	rsb	r4, r5, #0
34800e30:	e0044003 	and	r4, r4, r3
	if (stop & (line_len - 1)) {
34800e34:	e1190007 	tst	r9, r7
34800e38:	01a03007 	moveq	r3, r7
34800e3c:	0a000005 	beq	34800e58 <invalidate_dcache_range+0x74>
		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
34800e40:	e1a02007 	mov	r2, r7
34800e44:	e59f1038 	ldr	r1, [pc, #56]	; 34800e84 <invalidate_dcache_range+0xa0>
34800e48:	e59f003c 	ldr	r0, [pc, #60]	; 34800e8c <invalidate_dcache_range+0xa8>
34800e4c:	eb002252 	bl	3480979c <printf>
		stop &= ~(line_len - 1);
34800e50:	e2653000 	rsb	r3, r5, #0
34800e54:	e0033007 	and	r3, r3, r7
	for (mva = start; mva < stop; mva = mva + line_len) {
34800e58:	e1540003 	cmp	r4, r3
34800e5c:	2a000002 	bcs	34800e6c <invalidate_dcache_range+0x88>
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
34800e60:	ee074f36 	mcr	15, 0, r4, cr7, cr6, {1}
	for (mva = start; mva < stop; mva = mva + line_len) {
34800e64:	e0844005 	add	r4, r4, r5
34800e68:	eafffffa 	b	34800e58 <invalidate_dcache_range+0x74>
	CP15DSB;
34800e6c:	e3a03000 	mov	r3, #0
34800e70:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	v7_outer_cache_inval_range(start, stop);
34800e74:	e1a01007 	mov	r1, r7
34800e78:	e1a00006 	mov	r0, r6
}
34800e7c:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	v7_outer_cache_inval_range(start, stop);
34800e80:	eaffffd6 	b	34800de0 <__v7_outer_cache_inval_range>
34800e84:	348214ca 	.word	0x348214ca
34800e88:	348215b5 	.word	0x348215b5
34800e8c:	348215e8 	.word	0x348215e8

34800e90 <cpu_cache_initialization>:
#include <asm/system.h>
#include <asm/cache.h>
#include <asm/armv7.h>
#include <linux/compiler.h>

void __weak cpu_cache_initialization(void){}
34800e90:	e12fff1e 	bx	lr

34800e94 <cleanup_before_linux>:

int cleanup_before_linux(void)
{
34800e94:	e92d4010 	push	{r4, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */
#ifndef CONFIG_SPL_BUILD
	disable_interrupts();
34800e98:	eb000387 	bl	34801cbc <disable_interrupts>
#endif

	/*
	 * Turn off I-cache and invalidate it
	 */
	icache_disable();
34800e9c:	eb000438 	bl	34801f84 <icache_disable>
	invalidate_icache_all();
34800ea0:	ebffff9e 	bl	34800d20 <invalidate_icache_all>

	/*
	 * turn off D-cache
	 * dcache_disable() in turn flushes the d-cache and disables MMU
	 */
	dcache_disable();
34800ea4:	eb00046e 	bl	34802064 <dcache_disable>
	v7_outer_cache_disable();
34800ea8:	eb000221 	bl	34801734 <v7_outer_cache_disable>
	 * is all we did during this. We have not pushed anything on to the
	 * stack. Neither have we affected any static data)
	 * So just invalidate the entire d-cache again to avoid coherency
	 * problems for kernel
	 */
	invalidate_dcache_all();
34800eac:	ebffffaa 	bl	34800d5c <invalidate_dcache_all>

	/*
	 * Some CPU need more cache attention before starting the kernel.
	 */
	cpu_cache_initialization();
34800eb0:	ebfffff6 	bl	34800e90 <cpu_cache_initialization>

	return 0;
}
34800eb4:	e3a00000 	mov	r0, #0
34800eb8:	e8bd8010 	pop	{r4, pc}

34800ebc <sdelay>:
 *
 *  not inline to increase chances its in cache when called
 *************************************************************/
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
34800ebc:	e2500001 	subs	r0, r0, #1
34800ec0:	1afffffd 	bne	34800ebc <sdelay>
34800ec4:	e12fff1e 	bx	lr

34800ec8 <sr32>:
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34800ec8:	e3a0c001 	mov	ip, #1
34800ecc:	e1a0221c 	lsl	r2, ip, r2
	--msk;
	tmp = readl((u32)addr) & ~(msk << start_bit);
34800ed0:	e590c000 	ldr	ip, [r0]
	--msk;
34800ed4:	e2422001 	sub	r2, r2, #1
	tmp = readl((u32)addr) & ~(msk << start_bit);
34800ed8:	e1cc2112 	bic	r2, ip, r2, lsl r1
	tmp |= value << start_bit;
34800edc:	e1823113 	orr	r3, r2, r3, lsl r1
	writel(tmp, (u32)addr);
34800ee0:	e5803000 	str	r3, [r0]
34800ee4:	e12fff1e 	bx	lr

34800ee8 <wait_on_value>:
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
	u32 i = 0, val;
34800ee8:	e3a0c000 	mov	ip, #0
{
34800eec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	do {
		++i;
34800ef0:	e28cc001 	add	ip, ip, #1
		val = readl((u32)read_addr) & read_bit_mask;
34800ef4:	e592e000 	ldr	lr, [r2]
34800ef8:	e00ee000 	and	lr, lr, r0
		if (val == match_value)
34800efc:	e15e0001 	cmp	lr, r1
34800f00:	0a000003 	beq	34800f14 <wait_on_value+0x2c>
			return 1;
		if (i == bound)
34800f04:	e15c0003 	cmp	ip, r3
34800f08:	1afffff8 	bne	34800ef0 <wait_on_value+0x8>
			return 0;
34800f0c:	e3a00000 	mov	r0, #0
34800f10:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
			return 1;
34800f14:	e3a00001 	mov	r0, #1
	} while (1);
}
34800f18:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34800f1c <arch_cpu_init>:
	s5p_cpu_id = readl(S5PC100_PRO_ID);
34800f1c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
34800f20:	e5933000 	ldr	r3, [r3]
	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
34800f24:	e59f2010 	ldr	r2, [pc, #16]	; 34800f3c <arch_cpu_init+0x20>
34800f28:	e7eb3653 	ubfx	r3, r3, #12, #12
34800f2c:	e3833903 	orr	r3, r3, #49152	; 0xc000
int arch_cpu_init(void)
{
	s5p_set_cpu_id();

	return 0;
}
34800f30:	e3a00000 	mov	r0, #0
34800f34:	e5823000 	str	r3, [r2]
34800f38:	e12fff1e 	bx	lr
34800f3c:	34827004 	.word	0x34827004

34800f40 <get_device_type>:
#endif

u32 get_device_type(void)
{
	return s5p_cpu_id;
}
34800f40:	e59f3004 	ldr	r3, [pc, #4]	; 34800f4c <get_device_type+0xc>
34800f44:	e5930000 	ldr	r0, [r3]
34800f48:	e12fff1e 	bx	lr
34800f4c:	34827004 	.word	0x34827004

34800f50 <print_cpuinfo>:
#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
34800f50:	e59f3038 	ldr	r3, [pc, #56]	; 34800f90 <print_cpuinfo+0x40>
{
34800f54:	e92d4010 	push	{r4, lr}
34800f58:	e24dd020 	sub	sp, sp, #32
	printf("CPU:\t%s%X@%sMHz\n",
34800f5c:	e5934000 	ldr	r4, [r3]
34800f60:	eb0001c3 	bl	34801674 <get_arm_clk>
34800f64:	e1a01000 	mov	r1, r0
34800f68:	e1a0000d 	mov	r0, sp
34800f6c:	eb006b8d 	bl	3481bda8 <strmhz>
34800f70:	e1a02004 	mov	r2, r4
34800f74:	e1a03000 	mov	r3, r0
34800f78:	e59f1014 	ldr	r1, [pc, #20]	; 34800f94 <print_cpuinfo+0x44>
34800f7c:	e59f0014 	ldr	r0, [pc, #20]	; 34800f98 <print_cpuinfo+0x48>
34800f80:	eb002205 	bl	3480979c <printf>
			s5p_get_cpu_name(), s5p_cpu_id,
			strmhz(buf, get_arm_clk()));

	return 0;
}
34800f84:	e3a00000 	mov	r0, #0
34800f88:	e28dd020 	add	sp, sp, #32
34800f8c:	e8bd8010 	pop	{r4, pc}
34800f90:	34827004 	.word	0x34827004
34800f94:	3482161a 	.word	0x3482161a
34800f98:	3482161e 	.word	0x3482161e

34800f9c <samsung_get_base_timer>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800f9c:	e59f3028 	ldr	r3, [pc, #40]	; 34800fcc <samsung_get_base_timer+0x30>
34800fa0:	e5932000 	ldr	r2, [r3]
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34800fa4:	e3520cc1 	cmp	r2, #49408	; 0xc100
34800fa8:	0a000005 	beq	34800fc4 <samsung_get_base_timer+0x28>
34800fac:	e59f301c 	ldr	r3, [pc, #28]	; 34800fd0 <samsung_get_base_timer+0x34>
34800fb0:	e30c0110 	movw	r0, #49424	; 0xc110
34800fb4:	e1520000 	cmp	r2, r0
34800fb8:	13a00000 	movne	r0, #0
34800fbc:	01a00003 	moveq	r0, r3
34800fc0:	e12fff1e 	bx	lr
34800fc4:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
34800fc8:	e12fff1e 	bx	lr
34800fcc:	34827004 	.word	0x34827004
34800fd0:	e2500000 	.word	0xe2500000

34800fd4 <reset_timer_masked>:
	while (get_current_tick() < tmo)
		;	/* nop */
}

void reset_timer_masked(void)
{
34800fd4:	e92d4010 	push	{r4, lr}
	return (struct s5p_timer *)samsung_get_base_timer();
34800fd8:	ebffffef 	bl	34800f9c <samsung_get_base_timer>
	struct s5p_timer *const timer = s5p_get_base_timer();

	/* reset time */
	gd->lastinc = readl(&timer->tcnto4);
34800fdc:	e5902040 	ldr	r2, [r0, #64]	; 0x40
34800fe0:	e5882030 	str	r2, [r8, #48]	; 0x30
	gd->tbl = 0;
34800fe4:	e3a02000 	mov	r2, #0
34800fe8:	e5882020 	str	r2, [r8, #32]
34800fec:	e8bd8010 	pop	{r4, pc}

34800ff0 <timer_init>:
{
34800ff0:	e92d4010 	push	{r4, lr}
	pwm_init(4, MUX_DIV_2, 0);
34800ff4:	e3a02000 	mov	r2, #0
34800ff8:	e3a01001 	mov	r1, #1
34800ffc:	e3a00004 	mov	r0, #4
34801000:	eb0000f9 	bl	348013ec <pwm_init>
	pwm_config(4, 0, 0);
34801004:	e3a02000 	mov	r2, #0
34801008:	e3a00004 	mov	r0, #4
3480100c:	e1a01002 	mov	r1, r2
34801010:	eb0000a7 	bl	348012b4 <pwm_config>
	pwm_enable(4);
34801014:	e3a00004 	mov	r0, #4
34801018:	eb00008e 	bl	34801258 <pwm_enable>
	reset_timer_masked();
3480101c:	ebffffec 	bl	34800fd4 <reset_timer_masked>
}
34801020:	e3a00000 	mov	r0, #0
34801024:	e8bd8010 	pop	{r4, pc}

34801028 <get_current_tick>:

	return get_current_tick() / count_value;
}

unsigned long get_current_tick(void)
{
34801028:	e92d4010 	push	{r4, lr}
	return (struct s5p_timer *)samsung_get_base_timer();
3480102c:	ebffffda 	bl	34800f9c <samsung_get_base_timer>
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
34801030:	e590c040 	ldr	ip, [r0, #64]	; 0x40
	unsigned long count_value = readl(&timer->tcntb4);
34801034:	e590203c 	ldr	r2, [r0, #60]	; 0x3c

	if (gd->lastinc >= now)
34801038:	e5981030 	ldr	r1, [r8, #48]	; 0x30
3480103c:	e151000c 	cmp	r1, ip
		gd->tbl += gd->lastinc - now;
34801040:	e5981030 	ldr	r1, [r8, #48]	; 0x30
34801044:	25982020 	ldrcs	r2, [r8, #32]
	else
		gd->tbl += gd->lastinc + count_value - now;
34801048:	35980020 	ldrcc	r0, [r8, #32]
3480104c:	30812002 	addcc	r2, r1, r2
34801050:	20822001 	addcs	r2, r2, r1
34801054:	30822000 	addcc	r2, r2, r0
34801058:	e06c2002 	rsb	r2, ip, r2
3480105c:	e5882020 	str	r2, [r8, #32]

	gd->lastinc = now;
34801060:	e588c030 	str	ip, [r8, #48]	; 0x30

	return gd->tbl;
34801064:	e5980020 	ldr	r0, [r8, #32]
}
34801068:	e8bd8010 	pop	{r4, pc}

3480106c <__udelay>:
{
3480106c:	e92d4070 	push	{r4, r5, r6, lr}
34801070:	e1a04000 	mov	r4, r0
	return (struct s5p_timer *)samsung_get_base_timer();
34801074:	ebffffc8 	bl	34800f9c <samsung_get_base_timer>
	count_value = readl(&timer->tcntb4);
34801078:	e590c03c 	ldr	ip, [r0, #60]	; 0x3c
	if (usec >= 1000) {
3480107c:	e3540ffa 	cmp	r4, #1000	; 0x3e8
34801080:	e3a03ffa 	mov	r3, #1000	; 0x3e8
		tmo = usec / 1000;
34801084:	259fe054 	ldrcs	lr, [pc, #84]	; 348010e0 <__udelay+0x74>
34801088:	30000c93 	mulcc	r0, r3, ip
		tmo /= (1000 * 1000);
3480108c:	359f3050 	ldrcc	r3, [pc, #80]	; 348010e4 <__udelay+0x78>
34801090:	20030c93 	mulcs	r3, r3, ip
		tmo = usec / 1000;
34801094:	20810e94 	umullcs	r0, r1, r4, lr
		tmo = usec * CONFIG_SYS_HZ * count_value;
34801098:	30000094 	mulcc	r0, r4, r0
		tmo = usec / 1000;
3480109c:	21a02321 	lsrcs	r2, r1, #6
		tmo *= (CONFIG_SYS_HZ * count_value);
348010a0:	20030392 	mulcs	r3, r2, r3
		tmo /= (1000 * 1000);
348010a4:	30810390 	umullcc	r0, r1, r0, r3
		tmo /= 1000;
348010a8:	20810e93 	umullcs	r0, r1, r3, lr
		tmo /= (1000 * 1000);
348010ac:	31a05921 	lsrcc	r5, r1, #18
		tmo /= 1000;
348010b0:	21a05321 	lsrcs	r5, r1, #6
	tmp = get_current_tick();
348010b4:	ebffffdb 	bl	34801028 <get_current_tick>
	if ((tmo + tmp + 1) < tmp)
348010b8:	e0804005 	add	r4, r0, r5
348010bc:	e2843001 	add	r3, r4, #1
348010c0:	e1530000 	cmp	r3, r0
348010c4:	2a000001 	bcs	348010d0 <__udelay+0x64>
348010c8:	e1a04005 	mov	r4, r5
		reset_timer_masked();
348010cc:	ebffffc0 	bl	34800fd4 <reset_timer_masked>
	while (get_current_tick() < tmo)
348010d0:	ebffffd4 	bl	34801028 <get_current_tick>
348010d4:	e1500004 	cmp	r0, r4
348010d8:	3afffffc 	bcc	348010d0 <__udelay+0x64>
}
348010dc:	e8bd8070 	pop	{r4, r5, r6, pc}
348010e0:	10624dd3 	.word	0x10624dd3
348010e4:	431bde83 	.word	0x431bde83

348010e8 <get_timer_masked>:
{
348010e8:	e92d4010 	push	{r4, lr}
	return (struct s5p_timer *)samsung_get_base_timer();
348010ec:	ebffffaa 	bl	34800f9c <samsung_get_base_timer>
	unsigned long count_value = readl(&timer->tcntb4);
348010f0:	e590403c 	ldr	r4, [r0, #60]	; 0x3c
	return get_current_tick() / count_value;
348010f4:	ebffffcb 	bl	34801028 <get_current_tick>
348010f8:	e1a01004 	mov	r1, r4
348010fc:	fa0077c7 	blx	3481f020 <__udivsi3>
}
34801100:	e8bd8010 	pop	{r4, pc}

34801104 <get_timer>:
{
34801104:	e92d4010 	push	{r4, lr}
34801108:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
3480110c:	ebfffff5 	bl	348010e8 <get_timer_masked>
}
34801110:	e0640000 	rsb	r0, r4, r0
34801114:	e8bd8010 	pop	{r4, pc}

34801118 <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
34801118:	e92d4010 	push	{r4, lr}
	return get_timer_masked() - base;
3480111c:	ebfffff1 	bl	348010e8 <get_timer_masked>
	return get_timer(0);
}
34801120:	e3a01000 	mov	r1, #0
34801124:	e8bd8010 	pop	{r4, pc}

34801128 <get_tbclk>:
 * On ARM it returns the number of timer ticks per second.
 */
unsigned long get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
34801128:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3480112c:	e12fff1e 	bx	lr

34801130 <s5p_config_sromc>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801130:	e59f3040 	ldr	r3, [pc, #64]	; 34801178 <s5p_config_sromc+0x48>
 * srom_bank	- SROM
 * srom_bw_conf  - SMC Band witdh reg configuration value
 * srom_bc_conf  - SMC Bank Control reg configuration value
 */
void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf)
{
34801134:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
34801138:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(sromc, SROMC_BASE)
3480113c:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801140:	03a034e7 	moveq	r3, #-419430400	; 0xe7000000
34801144:	0a000003 	beq	34801158 <s5p_config_sromc+0x28>
34801148:	e30cc110 	movw	ip, #49424	; 0xc110
3480114c:	e153000c 	cmp	r3, ip
34801150:	03a0333a 	moveq	r3, #-402653184	; 0xe8000000
34801154:	13a03000 	movne	r3, #0
	u32 tmp;
	struct s5p_sromc *srom =
		(struct s5p_sromc *)samsung_get_base_sromc();

	/* Configure SMC_BW register to handle proper SROMC bank */
	tmp = srom->bw;
34801158:	e593c000 	ldr	ip, [r3]
	tmp &= ~(0xF << (srom_bank * 4));
3480115c:	e1a00100 	lsl	r0, r0, #2
34801160:	e3a0e00f 	mov	lr, #15
34801164:	e1ccc01e 	bic	ip, ip, lr, lsl r0
	tmp |= srom_bw_conf;
34801168:	e18c1001 	orr	r1, ip, r1
	srom->bw = tmp;
3480116c:	e6831000 	str	r1, [r3], r0

	/* Configure SMC_BC register */
	srom->bc[srom_bank] = srom_bc_conf;
34801170:	e5832004 	str	r2, [r3, #4]
34801174:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
34801178:	34827004 	.word	0x34827004

3480117c <wdt_stop>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
3480117c:	e59f3030 	ldr	r3, [pc, #48]	; 348011b4 <wdt_stop+0x38>
34801180:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(uart, UART_BASE)
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
34801184:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801188:	059f3028 	ldreq	r3, [pc, #40]	; 348011b8 <wdt_stop+0x3c>
3480118c:	0a000004 	beq	348011a4 <wdt_stop+0x28>
34801190:	e59f2024 	ldr	r2, [pc, #36]	; 348011bc <wdt_stop+0x40>
34801194:	e30c1110 	movw	r1, #49424	; 0xc110
34801198:	e1530001 	cmp	r3, r1
3480119c:	13a03000 	movne	r3, #0
348011a0:	01a03002 	moveq	r3, r2
{
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
	unsigned int wtcon;

	wtcon = readl(&wdt->wtcon);
348011a4:	e5932000 	ldr	r2, [r3]
	wtcon &= ~(WTCON_EN | WTCON_INT | WTCON_RESET);
348011a8:	e3c22025 	bic	r2, r2, #37	; 0x25

	writel(wtcon, &wdt->wtcon);
348011ac:	e5832000 	str	r2, [r3]
348011b0:	e12fff1e 	bx	lr
348011b4:	34827004 	.word	0x34827004
348011b8:	ea200000 	.word	0xea200000
348011bc:	e2700000 	.word	0xe2700000

348011c0 <wdt_start>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348011c0:	e59f304c 	ldr	r3, [pc, #76]	; 34801214 <wdt_start+0x54>
}

void wdt_start(unsigned int timeout)
{
348011c4:	e92d4070 	push	{r4, r5, r6, lr}
348011c8:	e1a05000 	mov	r5, r0
348011cc:	e5932000 	ldr	r2, [r3]
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
348011d0:	e3520cc1 	cmp	r2, #49408	; 0xc100
348011d4:	059f403c 	ldreq	r4, [pc, #60]	; 34801218 <wdt_start+0x58>
348011d8:	0a000004 	beq	348011f0 <wdt_start+0x30>
348011dc:	e59f3038 	ldr	r3, [pc, #56]	; 3480121c <wdt_start+0x5c>
348011e0:	e30c4110 	movw	r4, #49424	; 0xc110
348011e4:	e1520004 	cmp	r2, r4
348011e8:	13a04000 	movne	r4, #0
348011ec:	01a04003 	moveq	r4, r3
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
	unsigned int wtcon;

	wdt_stop();
348011f0:	ebffffe1 	bl	3480117c <wdt_stop>

	wtcon = readl(&wdt->wtcon);
348011f4:	e5943000 	ldr	r3, [r4]
	wtcon |= (WTCON_EN | WTCON_CLK(WTCON_CLK_128));
	wtcon &= ~WTCON_INT;
348011f8:	e3c33004 	bic	r3, r3, #4
	wtcon |= WTCON_RESET;
	wtcon |= WTCON_PRESCALER(PRESCALER_VAL);
348011fc:	e3833cff 	orr	r3, r3, #65280	; 0xff00
34801200:	e3833039 	orr	r3, r3, #57	; 0x39

	writel(timeout, &wdt->wtdat);
34801204:	e5845004 	str	r5, [r4, #4]
	writel(timeout, &wdt->wtcnt);
34801208:	e5845008 	str	r5, [r4, #8]
	writel(wtcon, &wdt->wtcon);
3480120c:	e5843000 	str	r3, [r4]
34801210:	e8bd8070 	pop	{r4, r5, r6, pc}
34801214:	34827004 	.word	0x34827004
34801218:	ea200000 	.word	0xea200000
3480121c:	e2700000 	.word	0xe2700000

34801220 <samsung_get_base_timer>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801220:	e59f3028 	ldr	r3, [pc, #40]	; 34801250 <samsung_get_base_timer+0x30>
34801224:	e5932000 	ldr	r2, [r3]
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34801228:	e3520cc1 	cmp	r2, #49408	; 0xc100
3480122c:	0a000005 	beq	34801248 <samsung_get_base_timer+0x28>
34801230:	e59f301c 	ldr	r3, [pc, #28]	; 34801254 <samsung_get_base_timer+0x34>
34801234:	e30c0110 	movw	r0, #49424	; 0xc110
34801238:	e1520000 	cmp	r2, r0
3480123c:	13a00000 	movne	r0, #0
34801240:	01a00003 	moveq	r0, r3
34801244:	e12fff1e 	bx	lr
34801248:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
3480124c:	e12fff1e 	bx	lr
34801250:	34827004 	.word	0x34827004
34801254:	e2500000 	.word	0xe2500000

34801258 <pwm_enable>:
#include <asm/io.h>
#include <asm/arch/pwm.h>
#include <asm/arch/clk.h>

int pwm_enable(int pwm_id)
{
34801258:	e92d4010 	push	{r4, lr}
3480125c:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801260:	ebffffee 	bl	34801220 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34801264:	e5903008 	ldr	r3, [r0, #8]
	tcon |= TCON_START(pwm_id);
34801268:	e3540000 	cmp	r4, #0
3480126c:	12844001 	addne	r4, r4, #1
34801270:	e3a02001 	mov	r2, #1
34801274:	e1a04104 	lsl	r4, r4, #2
34801278:	e1834412 	orr	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
3480127c:	e5804008 	str	r4, [r0, #8]

	return 0;
}
34801280:	e3a00000 	mov	r0, #0
34801284:	e8bd8010 	pop	{r4, pc}

34801288 <pwm_disable>:

void pwm_disable(int pwm_id)
{
34801288:	e92d4010 	push	{r4, lr}
3480128c:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801290:	ebffffe2 	bl	34801220 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34801294:	e5903008 	ldr	r3, [r0, #8]
	tcon &= ~TCON_START(pwm_id);
34801298:	e3540000 	cmp	r4, #0
3480129c:	12844001 	addne	r4, r4, #1
348012a0:	e3a02001 	mov	r2, #1
348012a4:	e1a04104 	lsl	r4, r4, #2
348012a8:	e1c34412 	bic	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
348012ac:	e5804008 	str	r4, [r0, #8]
348012b0:	e8bd8010 	pop	{r4, pc}

348012b4 <pwm_config>:
}

#define NS_IN_HZ (1000000000UL)

int pwm_config(int pwm_id, int duty_ns, int period_ns)
{
348012b4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348012b8:	e1a0a001 	mov	sl, r1
348012bc:	e1a07002 	mov	r7, r2
348012c0:	e1a05000 	mov	r5, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348012c4:	ebffffd5 	bl	34801220 <samsung_get_base_timer>
348012c8:	e1a04000 	mov	r4, r0
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
348012cc:	e59f0114 	ldr	r0, [pc, #276]	; 348013e8 <pwm_config+0x134>
348012d0:	e15a0000 	cmp	sl, r0
348012d4:	91570000 	cmpls	r7, r0
		return -ERANGE;
348012d8:	83e00021 	mvnhi	r0, #33	; 0x21
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
348012dc:	8a00003f 	bhi	348013e0 <pwm_config+0x12c>

	if (duty_ns > period_ns)
348012e0:	e15a0007 	cmp	sl, r7
348012e4:	ca00003c 	bgt	348013dc <pwm_config+0x128>
		return -EINVAL;

	period = NS_IN_HZ / period_ns;
348012e8:	e1a01007 	mov	r1, r7
	for (div = 2; div <= 16; div *= 2) {
348012ec:	e3a09002 	mov	r9, #2
	period = NS_IN_HZ / period_ns;
348012f0:	fa00774a 	blx	3481f020 <__udivsi3>
348012f4:	e1a0b000 	mov	fp, r0
	tin_parent_rate = get_pwm_clk();
348012f8:	eb0000f5 	bl	348016d4 <get_pwm_clk>
348012fc:	e3a03004 	mov	r3, #4
34801300:	e1a06000 	mov	r6, r0
		if ((tin_parent_rate / (div << 16)) < freq)
34801304:	e1a01809 	lsl	r1, r9, #16
34801308:	e1a00006 	mov	r0, r6
3480130c:	e58d3004 	str	r3, [sp, #4]
34801310:	fa007742 	blx	3481f020 <__udivsi3>
34801314:	e150000b 	cmp	r0, fp
34801318:	e59d3004 	ldr	r3, [sp, #4]
3480131c:	2a000004 	bcs	34801334 <pwm_config+0x80>
			return tin_parent_rate / div;
34801320:	e1a01009 	mov	r1, r9
34801324:	e1a00006 	mov	r0, r6
34801328:	fa00773c 	blx	3481f020 <__udivsi3>
3480132c:	e1a01000 	mov	r1, r0
34801330:	ea000003 	b	34801344 <pwm_config+0x90>
	for (div = 2; div <= 16; div *= 2) {
34801334:	e2533001 	subs	r3, r3, #1
34801338:	e1a09089 	lsl	r9, r9, #1
3480133c:	1afffff0 	bne	34801304 <pwm_config+0x50>
	return tin_parent_rate / 16;
34801340:	e1a01226 	lsr	r1, r6, #4

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
34801344:	e59f009c 	ldr	r0, [pc, #156]	; 348013e8 <pwm_config+0x134>
34801348:	fa007734 	blx	3481f020 <__udivsi3>
	tcnt = period_ns / tin_ns;
3480134c:	e1a01000 	mov	r1, r0
	tin_ns = NS_IN_HZ / tin_rate;
34801350:	e1a09000 	mov	r9, r0
	tcnt = period_ns / tin_ns;
34801354:	e1a00007 	mov	r0, r7
34801358:	fa007730 	blx	3481f020 <__udivsi3>

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
3480135c:	e1a01009 	mov	r1, r9
	tcnt = period_ns / tin_ns;
34801360:	e1a06000 	mov	r6, r0
	tcmp = duty_ns / tin_ns;
34801364:	e1a0000a 	mov	r0, sl
34801368:	fa00772c 	blx	3481f020 <__udivsi3>
	tcmp = tcnt - tcmp;
3480136c:	e0600006 	rsb	r0, r0, r6

	/*
	 * the pwm hw only checks the compare register after a decrement,
	 * so the pin never toggles if tcmp = tcnt
	 */
	if (tcmp == tcnt)
34801370:	e1500006 	cmp	r0, r6
		tcmp--;
34801374:	02400001 	subeq	r0, r0, #1
	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
	if (pwm_id < 4) {
34801378:	e3550003 	cmp	r5, #3
3480137c:	ca000004 	bgt	34801394 <pwm_config+0xe0>
	offset = pwm_id * 3;
34801380:	e0853085 	add	r3, r5, r5, lsl #1
		writel(tcnt, &pwm->tcntb0 + offset);
34801384:	e284200c 	add	r2, r4, #12
34801388:	e7826103 	str	r6, [r2, r3, lsl #2]
		writel(tcmp, &pwm->tcmpb0 + offset);
3480138c:	e2842010 	add	r2, r4, #16
34801390:	e7820103 	str	r0, [r2, r3, lsl #2]
	}

	tcon = readl(&pwm->tcon);
34801394:	e5942008 	ldr	r2, [r4, #8]
	tcon |= TCON_UPDATE(pwm_id);
34801398:	e3550000 	cmp	r5, #0
3480139c:	01a01005 	moveq	r1, r5
348013a0:	12851001 	addne	r1, r5, #1
348013a4:	e3a03001 	mov	r3, #1
348013a8:	e1a01101 	lsl	r1, r1, #2
	if (pwm_id < 4)
348013ac:	e3550003 	cmp	r5, #3
	tcon |= TCON_UPDATE(pwm_id);
348013b0:	e2810001 	add	r0, r1, #1
		tcon |= TCON_AUTO_RELOAD(pwm_id);
348013b4:	d2811003 	addle	r1, r1, #3
	tcon |= TCON_UPDATE(pwm_id);
348013b8:	e1a00013 	lsl	r0, r3, r0
348013bc:	e1802002 	orr	r2, r0, r2
		tcon |= TCON_AUTO_RELOAD(pwm_id);
348013c0:	d1823113 	orrle	r3, r2, r3, lsl r1
	else
		tcon |= TCON4_AUTO_RELOAD;
348013c4:	c3823501 	orrgt	r3, r2, #4194304	; 0x400000
	writel(tcon, &pwm->tcon);
348013c8:	e5843008 	str	r3, [r4, #8]

	tcon &= ~TCON_UPDATE(pwm_id);
348013cc:	e1c33000 	bic	r3, r3, r0
	writel(tcon, &pwm->tcon);

	return 0;
348013d0:	e3a00000 	mov	r0, #0
	writel(tcon, &pwm->tcon);
348013d4:	e5843008 	str	r3, [r4, #8]
	return 0;
348013d8:	ea000000 	b	348013e0 <pwm_config+0x12c>
		return -EINVAL;
348013dc:	e3e00015 	mvn	r0, #21
}
348013e0:	e28dd008 	add	sp, sp, #8
348013e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348013e8:	3b9aca00 	.word	0x3b9aca00

348013ec <pwm_init>:

int pwm_init(int pwm_id, int div, int invert)
{
348013ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348013f0:	e1a04000 	mov	r4, r0
348013f4:	e1a05001 	mov	r5, r1
348013f8:	e1a06002 	mov	r6, r2
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348013fc:	ebffff87 	bl	34801220 <samsung_get_base_timer>
34801400:	e1a07000 	mov	r7, r0
	/*
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
34801404:	e5903000 	ldr	r3, [r0]
	if (pwm_id < 2) {
34801408:	e3540001 	cmp	r4, #1
		prescaler = PRESCALER_0;
		val &= ~0xff;
3480140c:	d3c330ff 	bicle	r3, r3, #255	; 0xff
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
34801410:	c3c33cff 	bicgt	r3, r3, #65280	; 0xff00
		val |= (prescaler & 0xff);
34801414:	d3833007 	orrle	r3, r3, #7
		prescaler = PRESCALER_0;
34801418:	d3a0a007 	movle	sl, #7
		val |= (prescaler & 0xff) << 8;
3480141c:	c3833c0f 	orrgt	r3, r3, #3840	; 0xf00
		prescaler = PRESCALER_1;
34801420:	c3a0a00f 	movgt	sl, #15
	}
	writel(val, &pwm->tcfg0);
34801424:	e5803000 	str	r3, [r0]
	val = readl(&pwm->tcfg1);
34801428:	e5902004 	ldr	r2, [r0, #4]
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
3480142c:	e1a03104 	lsl	r3, r4, #2
34801430:	e3a0900f 	mov	r9, #15
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
34801434:	e0051009 	and	r1, r5, r9
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
34801438:	e1c22319 	bic	r2, r2, r9, lsl r3
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
3480143c:	e1823311 	orr	r3, r2, r1, lsl r3
	writel(val, &pwm->tcfg1);
34801440:	e5803004 	str	r3, [r0, #4]

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
34801444:	eb0000a2 	bl	348016d4 <get_pwm_clk>
			(div + 1));
34801448:	e2851001 	add	r1, r5, #1
	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
3480144c:	e021119a 	mla	r1, sl, r1, r1
34801450:	fa0076f2 	blx	3481f020 <__udivsi3>

	timer_rate_hz = timer_rate_hz / CONFIG_SYS_HZ;
34801454:	e59f3060 	ldr	r3, [pc, #96]	; 348014bc <pwm_init+0xd0>
34801458:	e0810390 	umull	r0, r1, r0, r3
3480145c:	e1a01321 	lsr	r1, r1, #6

	/* set count value */
	offset = pwm_id * 3;
34801460:	e0842084 	add	r2, r4, r4, lsl #1
	writel(timer_rate_hz, &pwm->tcntb0 + offset);
34801464:	e287300c 	add	r3, r7, #12
34801468:	e7831102 	str	r1, [r3, r2, lsl #2]

	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
3480146c:	e5972008 	ldr	r2, [r7, #8]
34801470:	e3540000 	cmp	r4, #0
34801474:	01a03004 	moveq	r3, r4
34801478:	12843001 	addne	r3, r4, #1
	if (invert && (pwm_id < 4))
3480147c:	e3540003 	cmp	r4, #3
34801480:	c3a01000 	movgt	r1, #0
34801484:	d3a01001 	movle	r1, #1
	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
34801488:	e1a03103 	lsl	r3, r3, #2
	if (invert && (pwm_id < 4))
3480148c:	e3560000 	cmp	r6, #0
34801490:	03a01000 	moveq	r1, #0
34801494:	e3510000 	cmp	r1, #0
	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
34801498:	e1c22319 	bic	r2, r2, r9, lsl r3
		val |= TCON_INVERTER(pwm_id);
3480149c:	13a01001 	movne	r1, #1
348014a0:	12833002 	addne	r3, r3, #2
348014a4:	11822311 	orrne	r2, r2, r1, lsl r3
	writel(val, &pwm->tcon);
348014a8:	e5872008 	str	r2, [r7, #8]

	pwm_enable(pwm_id);
348014ac:	e1a00004 	mov	r0, r4
348014b0:	ebffff68 	bl	34801258 <pwm_enable>

	return 0;
}
348014b4:	e3a00000 	mov	r0, #0
348014b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348014bc:	10624dd3 	.word	0x10624dd3

348014c0 <samsung_get_base_clock>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348014c0:	e59f3014 	ldr	r3, [pc, #20]	; 348014dc <samsung_get_base_clock+0x1c>
SAMSUNG_BASE(clock, CLOCK_BASE)
348014c4:	e59f0014 	ldr	r0, [pc, #20]	; 348014e0 <samsung_get_base_clock+0x20>
348014c8:	e5933000 	ldr	r3, [r3]
348014cc:	e3c33010 	bic	r3, r3, #16
348014d0:	e3530cc1 	cmp	r3, #49408	; 0xc100
348014d4:	13a00000 	movne	r0, #0
348014d8:	e12fff1e 	bx	lr
348014dc:	34827004 	.word	0x34827004
348014e0:	e0100000 	.word	0xe0100000

348014e4 <get_pll_clk>:
IS_SAMSUNG_TYPE(s5pc110, 0xc110)
348014e4:	e59f3110 	ldr	r3, [pc, #272]	; 348015fc <get_pll_clk+0x118>
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
348014e8:	e92d4070 	push	{r4, r5, r6, lr}
348014ec:	e1a05000 	mov	r5, r0
	if (cpu_is_s5pc110())
348014f0:	e5932000 	ldr	r2, [r3]
348014f4:	e30c3110 	movw	r3, #49424	; 0xc110
348014f8:	e1520003 	cmp	r2, r3
348014fc:	1a00001f 	bne	34801580 <get_pll_clk+0x9c>
		(struct s5pc110_clock *)samsung_get_base_clock();
34801500:	ebffffee 	bl	348014c0 <samsung_get_base_clock>
	switch (pllreg) {
34801504:	e3550004 	cmp	r5, #4
34801508:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
3480150c:	ea00002d 	b	348015c8 <get_pll_clk+0xe4>
34801510:	34801524 	.word	0x34801524
34801514:	3480152c 	.word	0x3480152c
34801518:	34801534 	.word	0x34801534
3480151c:	348015c8 	.word	0x348015c8
34801520:	3480153c 	.word	0x3480153c
		r = readl(&clk->apll_con);
34801524:	e5902100 	ldr	r2, [r0, #256]	; 0x100
34801528:	ea000004 	b	34801540 <get_pll_clk+0x5c>
		r = readl(&clk->mpll_con);
3480152c:	e5902108 	ldr	r2, [r0, #264]	; 0x108
34801530:	ea000002 	b	34801540 <get_pll_clk+0x5c>
		r = readl(&clk->epll_con);
34801534:	e5902110 	ldr	r2, [r0, #272]	; 0x110
34801538:	ea000000 	b	34801540 <get_pll_clk+0x5c>
		r = readl(&clk->vpll_con);
3480153c:	e5902120 	ldr	r2, [r0, #288]	; 0x120
		mask = 0x1ff;
34801540:	e30033ff 	movw	r3, #1023	; 0x3ff
34801544:	e3550001 	cmp	r5, #1
34801548:	e30001ff 	movw	r0, #511	; 0x1ff
3480154c:	91a00003 	movls	r0, r3
	if (pllreg == APLL) {
34801550:	e3550000 	cmp	r5, #0
	m = (r >> 16) & mask;
34801554:	e0004822 	and	r4, r0, r2, lsr #16
	p = (r >> 8) & 0x3f;
34801558:	e7e51452 	ubfx	r1, r2, #8, #6
	s = r & 0x7;
3480155c:	e2022007 	and	r2, r2, #7
	if (pllreg == APLL) {
34801560:	1a000002 	bne	34801570 <get_pll_clk+0x8c>
		if (s < 1)
34801564:	e3520000 	cmp	r2, #0
			s = 1;
34801568:	03a02001 	moveq	r2, #1
		fout = m * (freq / (p * (1 << (s - 1))));
3480156c:	e2422001 	sub	r2, r2, #1
		fout = m * (freq / (p * (1 << s)));
34801570:	e1a01211 	lsl	r1, r1, r2
34801574:	e59f0084 	ldr	r0, [pc, #132]	; 34801600 <get_pll_clk+0x11c>
34801578:	fa0076a8 	blx	3481f020 <__udivsi3>
3480157c:	ea00001c 	b	348015f4 <get_pll_clk+0x110>
		(struct s5pc100_clock *)samsung_get_base_clock();
34801580:	ebffffce 	bl	348014c0 <samsung_get_base_clock>
	switch (pllreg) {
34801584:	e3550003 	cmp	r5, #3
34801588:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
3480158c:	ea00000d 	b	348015c8 <get_pll_clk+0xe4>
34801590:	348015a0 	.word	0x348015a0
34801594:	348015ac 	.word	0x348015ac
34801598:	348015b4 	.word	0x348015b4
3480159c:	348015bc 	.word	0x348015bc
		r = readl(&clk->apll_con);
348015a0:	e5905100 	ldr	r5, [r0, #256]	; 0x100
		mask = 0x3ff;
348015a4:	e30043ff 	movw	r4, #1023	; 0x3ff
348015a8:	ea00000b 	b	348015dc <get_pll_clk+0xf8>
		r = readl(&clk->mpll_con);
348015ac:	e5905104 	ldr	r5, [r0, #260]	; 0x104
348015b0:	ea000002 	b	348015c0 <get_pll_clk+0xdc>
		r = readl(&clk->epll_con);
348015b4:	e5905108 	ldr	r5, [r0, #264]	; 0x108
348015b8:	ea000000 	b	348015c0 <get_pll_clk+0xdc>
		r = readl(&clk->hpll_con);
348015bc:	e590510c 	ldr	r5, [r0, #268]	; 0x10c
		mask = 0x0ff;
348015c0:	e3a040ff 	mov	r4, #255	; 0xff
348015c4:	ea000004 	b	348015dc <get_pll_clk+0xf8>
		printf("Unsupported PLL (%d)\n", pllreg);
348015c8:	e1a01005 	mov	r1, r5
348015cc:	e59f0030 	ldr	r0, [pc, #48]	; 34801604 <get_pll_clk+0x120>
348015d0:	eb002071 	bl	3480979c <printf>
		return 0;
348015d4:	e3a00000 	mov	r0, #0
348015d8:	e8bd8070 	pop	{r4, r5, r6, pc}
	m = (r >> 16) & mask;
348015dc:	e0044825 	and	r4, r4, r5, lsr #16
	s = r & 0x7;
348015e0:	e2053007 	and	r3, r5, #7
	p = (r >> 8) & 0x3f;
348015e4:	e7e51455 	ubfx	r1, r5, #8, #6
	fout = m * (freq / (p * (1 << s)));
348015e8:	e59f0018 	ldr	r0, [pc, #24]	; 34801608 <get_pll_clk+0x124>
348015ec:	e1a01311 	lsl	r1, r1, r3
348015f0:	fa00768a 	blx	3481f020 <__udivsi3>
348015f4:	e0000094 	mul	r0, r4, r0
348015f8:	e8bd8070 	pop	{r4, r5, r6, pc}
348015fc:	34827004 	.word	0x34827004
34801600:	016e3600 	.word	0x016e3600
34801604:	3482162f 	.word	0x3482162f
34801608:	00b71b00 	.word	0x00b71b00

3480160c <get_pclkd1>:
{
3480160c:	e92d4010 	push	{r4, lr}
		(struct s5pc100_clock *)samsung_get_base_clock();
34801610:	ebffffaa 	bl	348014c0 <samsung_get_base_clock>
	div = readl(&clk->div0);
34801614:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801618:	e3a00001 	mov	r0, #1
3480161c:	ebffffb0 	bl	348014e4 <get_pll_clk>
	d1_bus_ratio = (div >> 12) & 0x7;
34801620:	e7e21654 	ubfx	r1, r4, #12, #3
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801624:	e2811001 	add	r1, r1, #1
34801628:	fa00767c 	blx	3481f020 <__udivsi3>
	pclkd1_ratio = (div >> 16) & 0x7;
3480162c:	e7e21854 	ubfx	r1, r4, #16, #3
	pclkd1 = d1_bus / (pclkd1_ratio + 1);
34801630:	e2811001 	add	r1, r1, #1
34801634:	fa007679 	blx	3481f020 <__udivsi3>
}
34801638:	e8bd8010 	pop	{r4, pc}

3480163c <get_pclk_sys.constprop.1>:
static unsigned long get_pclk_sys(int dom)
3480163c:	e92d4070 	push	{r4, r5, r6, lr}
		(struct s5pc110_clock *)samsung_get_base_clock();
34801640:	ebffff9e 	bl	348014c0 <samsung_get_base_clock>
	div = readl(&clk->div0);
34801644:	e5904300 	ldr	r4, [r0, #768]	; 0x300
		(struct s5pc110_clock *)samsung_get_base_clock();
34801648:	ebffff9c 	bl	348014c0 <samsung_get_base_clock>
	div = readl(&clk->div0);
3480164c:	e5905300 	ldr	r5, [r0, #768]	; 0x300
	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
34801650:	e3a00001 	mov	r0, #1
34801654:	ebffffa2 	bl	348014e4 <get_pll_clk>
	hclk_sys_ratio = (div >> offset) & 0xf;
34801658:	e7e31c55 	ubfx	r1, r5, #24, #4
	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
3480165c:	e2811001 	add	r1, r1, #1
34801660:	fa00766e 	blx	3481f020 <__udivsi3>
	pclk_sys_ratio = (div >> offset) & 0x7;
34801664:	e7e21e54 	ubfx	r1, r4, #28, #3
	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
34801668:	e2811001 	add	r1, r1, #1
3480166c:	fa00766b 	blx	3481f020 <__udivsi3>
}
34801670:	e8bd8070 	pop	{r4, r5, r6, pc}

34801674 <get_arm_clk>:
34801674:	e59f3054 	ldr	r3, [pc, #84]	; 348016d0 <get_arm_clk+0x5c>
	else
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
34801678:	e92d4010 	push	{r4, lr}
	if (cpu_is_s5pc110())
3480167c:	e5932000 	ldr	r2, [r3]
34801680:	e30c3110 	movw	r3, #49424	; 0xc110
34801684:	e1520003 	cmp	r2, r3
34801688:	1a000005 	bne	348016a4 <get_arm_clk+0x30>
		(struct s5pc110_clock *)samsung_get_base_clock();
3480168c:	ebffff8b 	bl	348014c0 <samsung_get_base_clock>
	div = readl(&clk->div0);
34801690:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34801694:	e3a00000 	mov	r0, #0
34801698:	ebffff91 	bl	348014e4 <get_pll_clk>
	apll_ratio = div & 0x7;
3480169c:	e2041007 	and	r1, r4, #7
348016a0:	ea000007 	b	348016c4 <get_arm_clk+0x50>
		(struct s5pc100_clock *)samsung_get_base_clock();
348016a4:	ebffff85 	bl	348014c0 <samsung_get_base_clock>
	div = readl(&clk->div0);
348016a8:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348016ac:	e3a00000 	mov	r0, #0
348016b0:	ebffff8b 	bl	348014e4 <get_pll_clk>
	apll_ratio = div & 0x1;
348016b4:	e2041001 	and	r1, r4, #1
	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348016b8:	e2811001 	add	r1, r1, #1
348016bc:	fa007657 	blx	3481f020 <__udivsi3>
	arm_ratio = (div >> 4) & 0x7;
348016c0:	e7e21254 	ubfx	r1, r4, #4, #3
	armclk = dout_apll / (arm_ratio + 1);
348016c4:	e2811001 	add	r1, r1, #1
348016c8:	fa007654 	blx	3481f020 <__udivsi3>
		return s5pc110_get_arm_clk();
	else
		return s5pc100_get_arm_clk();
}
348016cc:	e8bd8010 	pop	{r4, pc}
348016d0:	34827004 	.word	0x34827004

348016d4 <get_pwm_clk>:
348016d4:	e59f3014 	ldr	r3, [pc, #20]	; 348016f0 <get_pwm_clk+0x1c>
	if (cpu_is_s5pc110())
348016d8:	e5932000 	ldr	r2, [r3]
348016dc:	e30c3110 	movw	r3, #49424	; 0xc110
348016e0:	e1520003 	cmp	r2, r3
348016e4:	1a000000 	bne	348016ec <get_pwm_clk+0x18>
	return get_pclk_sys(CLK_P);
348016e8:	eaffffd3 	b	3480163c <get_pclk_sys.constprop.1>
	return get_pclkd1();
348016ec:	eaffffc6 	b	3480160c <get_pclkd1>
348016f0:	34827004 	.word	0x34827004

348016f4 <get_uart_clk>:
348016f4:	e59f3014 	ldr	r3, [pc, #20]	; 34801710 <get_uart_clk+0x1c>
	if (cpu_is_s5pc110())
348016f8:	e5932000 	ldr	r2, [r3]
348016fc:	e30c3110 	movw	r3, #49424	; 0xc110
34801700:	e1520003 	cmp	r2, r3
34801704:	1a000000 	bne	3480170c <get_uart_clk+0x18>
	return get_pclk_sys(CLK_P);
34801708:	eaffffcb 	b	3480163c <get_pclk_sys.constprop.1>
	return get_pclkd1();
3480170c:	eaffffbe 	b	3480160c <get_pclkd1>
34801710:	34827004 	.word	0x34827004

34801714 <set_mmc_clk>:
{
	return s5pc1xx_get_uart_clk(dev_index);
}

void set_mmc_clk(int dev_index, unsigned int div)
{
34801714:	e12fff1e 	bx	lr
	...

34801720 <v7_outer_cache_enable>:

#include <linux/linkage.h>

#ifndef CONFIG_SYS_L2CACHE_OFF
ENTRY(v7_outer_cache_enable)
	push	{r0, r1, r2, lr}
34801720:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801724:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	orr	r3, r3, #2
34801728:	e3833002 	orr	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
3480172c:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801730:	e8bd800e 	pop	{r1, r2, r3, pc}

34801734 <v7_outer_cache_disable>:
ENDPROC(v7_outer_cache_enable)

ENTRY(v7_outer_cache_disable)
	push	{r0, r1, r2, lr}
34801734:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801738:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	bic	r3, r3, #2
3480173c:	e3c33002 	bic	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34801740:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801744:	e8bd800e 	pop	{r1, r2, r3, pc}
34801748:	e320f000 	nop	{0}
3480174c:	e320f000 	nop	{0}
34801750:	e320f000 	nop	{0}
34801754:	e320f000 	nop	{0}
34801758:	e320f000 	nop	{0}
3480175c:	e320f000 	nop	{0}

34801760 <reset_cpu>:

#define S5PC100_SWRESET			0xE0200000
#define S5PC110_SWRESET			0xE0102000

ENTRY(reset_cpu)
	ldr	r1, =S5PC100_PRO_ID
34801760:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	ldr	r2, [r1]
34801764:	e5912000 	ldr	r2, [r1]
	ldr	r4, =0x00010000
34801768:	e3a04801 	mov	r4, #65536	; 0x10000
	and	r4, r2, r4
3480176c:	e0024004 	and	r4, r2, r4
	cmp	r4, #0
34801770:	e3540000 	cmp	r4, #0
	bne	110f
34801774:	1a000002 	bne	34801784 <reset_cpu+0x24>
	/* S5PC100 */
	ldr	r1, =S5PC100_SWRESET
34801778:	e59f1014 	ldr	r1, [pc, #20]	; 34801794 <_loop_forever+0x4>
	ldr	r2, =0xC100
3480177c:	e3a02cc1 	mov	r2, #49408	; 0xc100
	b	200f
34801780:	ea000001 	b	3480178c <reset_cpu+0x2c>
110:	/* S5PC110 */
	ldr	r1, =S5PC110_SWRESET
34801784:	e59f100c 	ldr	r1, [pc, #12]	; 34801798 <_loop_forever+0x8>
	mov	r2, #1
34801788:	e3a02001 	mov	r2, #1
200:
	str	r2, [r1]
3480178c:	e5812000 	str	r2, [r1]

34801790 <_loop_forever>:
_loop_forever:
	b	_loop_forever
34801790:	eafffffe 	b	34801790 <_loop_forever>
	ldr	r1, =S5PC100_SWRESET
34801794:	e0200000 	.word	0xe0200000
	ldr	r1, =S5PC110_SWRESET
34801798:	e0102000 	.word	0xe0102000

3480179c <__arch_cpu_init>:
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
}
3480179c:	e3a00000 	mov	r0, #0
348017a0:	e12fff1e 	bx	lr

348017a4 <init_func_i2c>:
{
348017a4:	e92d4010 	push	{r4, lr}
	puts("I2C:   ");
348017a8:	e59f001c 	ldr	r0, [pc, #28]	; 348017cc <init_func_i2c+0x28>
348017ac:	eb001fee 	bl	3480976c <puts>
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
348017b0:	e3a010fe 	mov	r1, #254	; 0xfe
348017b4:	e30c0350 	movw	r0, #50000	; 0xc350
348017b8:	eb003b4c 	bl	348104f0 <i2c_init>
	puts("ready\n");
348017bc:	e59f000c 	ldr	r0, [pc, #12]	; 348017d0 <init_func_i2c+0x2c>
348017c0:	eb001fe9 	bl	3480976c <puts>
}
348017c4:	e3a00000 	mov	r0, #0
348017c8:	e8bd8010 	pop	{r4, pc}
348017cc:	34821645 	.word	0x34821645
348017d0:	34825cd0 	.word	0x34825cd0

348017d4 <display_banner>:
{
348017d4:	e92d4010 	push	{r4, lr}
	printf("\n\n%s\n\n", version_string);
348017d8:	e59f100c 	ldr	r1, [pc, #12]	; 348017ec <display_banner+0x18>
348017dc:	e59f000c 	ldr	r0, [pc, #12]	; 348017f0 <display_banner+0x1c>
348017e0:	eb001fed 	bl	3480979c <printf>
}
348017e4:	e3a00000 	mov	r0, #0
348017e8:	e8bd8010 	pop	{r4, pc}
348017ec:	3481f76c 	.word	0x3481f76c
348017f0:	3482164d 	.word	0x3482164d

348017f4 <init_baudrate>:
{
348017f4:	e92d4010 	push	{r4, lr}
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
348017f8:	e3a0100a 	mov	r1, #10
348017fc:	e1a04008 	mov	r4, r8
34801800:	e59f2010 	ldr	r2, [pc, #16]	; 34801818 <init_baudrate+0x24>
34801804:	e59f0010 	ldr	r0, [pc, #16]	; 3480181c <init_baudrate+0x28>
34801808:	eb001912 	bl	34807c58 <getenv_ulong>
3480180c:	e5840008 	str	r0, [r4, #8]
}
34801810:	e3a00000 	mov	r0, #0
34801814:	e8bd8010 	pop	{r4, pc}
34801818:	0001c200 	.word	0x0001c200
3480181c:	34821654 	.word	0x34821654

34801820 <__coloured_LED_init>:
inline void __coloured_LED_init(void) {}
34801820:	e12fff1e 	bx	lr

34801824 <__red_led_on>:
inline void __red_led_on(void) {}
34801824:	e12fff1e 	bx	lr

34801828 <__red_led_off>:
inline void __red_led_off(void) {}
34801828:	e12fff1e 	bx	lr

3480182c <__green_led_on>:
inline void __green_led_on(void) {}
3480182c:	e12fff1e 	bx	lr

34801830 <__green_led_off>:
inline void __green_led_off(void) {}
34801830:	e12fff1e 	bx	lr

34801834 <__yellow_led_on>:
inline void __yellow_led_on(void) {}
34801834:	e12fff1e 	bx	lr

34801838 <__yellow_led_off>:
inline void __yellow_led_off(void) {}
34801838:	e12fff1e 	bx	lr

3480183c <__blue_led_on>:
inline void __blue_led_on(void) {}
3480183c:	e12fff1e 	bx	lr

34801840 <__blue_led_off>:
inline void __blue_led_off(void) {}
34801840:	e12fff1e 	bx	lr

34801844 <__dram_init_banksize>:
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
34801844:	e5983000 	ldr	r3, [r8]
34801848:	e3a02202 	mov	r2, #536870912	; 0x20000000
3480184c:	e5832018 	str	r2, [r3, #24]
	gd->bd->bi_dram[0].size =  gd->ram_size;
34801850:	e5982000 	ldr	r2, [r8]
34801854:	e5983038 	ldr	r3, [r8, #56]	; 0x38
34801858:	e582301c 	str	r3, [r2, #28]
3480185c:	e12fff1e 	bx	lr

34801860 <board_init_r>:
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd = id;
34801860:	e1a08000 	mov	r8, r0
{
34801864:	e92d4010 	push	{r4, lr}

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801868:	e5983004 	ldr	r3, [r8, #4]
{
3480186c:	e1a04001 	mov	r4, r1
	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801870:	e3833001 	orr	r3, r3, #1
34801874:	e5883004 	str	r3, [r8, #4]
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
34801878:	e59f306c 	ldr	r3, [pc, #108]	; 348018ec <board_init_r+0x8c>
3480187c:	e5932000 	ldr	r2, [r3]
34801880:	e59f3068 	ldr	r3, [pc, #104]	; 348018f0 <board_init_r+0x90>
34801884:	e5832000 	str	r2, [r3]

	/* Enable caches */
	enable_caches();
34801888:	eb0001a7 	bl	34801f2c <__enable_caches>

	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init();	/* Setup chipselects */
3480188c:	ebfffc7b 	bl	34800a80 <board_init>
	 */
#ifdef CONFIG_CLOCKS
	set_cpu_clk_info(); /* Setup clock information */
#endif
#ifdef CONFIG_SERIAL_MULTI
	serial_initialize();
34801890:	eb003436 	bl	3480e970 <serial_initialize>
	post_output_backlog();
#endif

	/* The Malloc area is immediately below the monitor copy in DRAM */
	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
34801894:	e3a01706 	mov	r1, #1572864	; 0x180000
34801898:	e2440706 	sub	r0, r4, #1572864	; 0x180000
3480189c:	eb0020ca 	bl	34809bcc <mem_malloc_init>
	puts("NAND:  ");
	nand_init();		/* go init the NAND */
#endif

#if defined(CONFIG_CMD_ONENAND)
	onenand_init();
348018a0:	eb00497c 	bl	34813e98 <onenand_init>
#endif

#ifdef CONFIG_GENERIC_MMC
       puts("MMC:   ");
348018a4:	e59f0048 	ldr	r0, [pc, #72]	; 348018f4 <board_init_r+0x94>
348018a8:	eb001faf 	bl	3480976c <puts>
       mmc_initialize(gd->bd);
348018ac:	e5980000 	ldr	r0, [r8]
348018b0:	eb004385 	bl	348126cc <mmc_initialize>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate();
348018b4:	eb002567 	bl	3480ae58 <env_relocate>

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif

	stdio_init();	/* get the devices list going. */
348018b8:	eb0034a4 	bl	3480eb50 <stdio_init>

	jumptable_init();
348018bc:	eb002574 	bl	3480ae94 <jumptable_init>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
348018c0:	e59f4030 	ldr	r4, [pc, #48]	; 348018f8 <board_init_r+0x98>
	console_init_r();	/* fully init console as a device */
348018c4:	eb002048 	bl	348099ec <console_init_r>
	interrupt_init();
348018c8:	eb0000f3 	bl	34801c9c <interrupt_init>
	enable_interrupts();
348018cc:	eb0000f9 	bl	34801cb8 <enable_interrupts>
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
348018d0:	e5942000 	ldr	r2, [r4]
348018d4:	e3a01010 	mov	r1, #16
348018d8:	e59f001c 	ldr	r0, [pc, #28]	; 348018fc <board_init_r+0x9c>
348018dc:	eb0018dd 	bl	34807c58 <getenv_ulong>
348018e0:	e5840000 	str	r0, [r4]
	}
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop();
348018e4:	eb003288 	bl	3480e30c <main_loop>
	}
348018e8:	eafffffd 	b	348018e4 <board_init_r+0x84>
348018ec:	34800050 	.word	0x34800050
348018f0:	348285d8 	.word	0x348285d8
348018f4:	3482165d 	.word	0x3482165d
348018f8:	348271b4 	.word	0x348271b4
348018fc:	34821665 	.word	0x34821665

34801900 <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang(void)
{
34801900:	e92d4010 	push	{r4, lr}
	puts("### ERROR ### Please RESET the board ###\n");
34801904:	e59f0004 	ldr	r0, [pc, #4]	; 34801910 <hang+0x10>
34801908:	eb001f97 	bl	3480976c <puts>
	for (;;);
3480190c:	eafffffe 	b	3480190c <hang+0xc>
34801910:	3482166e 	.word	0x3482166e

34801914 <board_init_f>:
{
34801914:	e92d4080 	push	{r7, lr}
	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);	/* allocate 16M for gd_t */
34801918:	e3a08423 	mov	r8, #587202560	; 0x23000000
	memset((void *)gd, 0, sizeof(gd_t));	/* link addr beyond internal SRAM's 16k */
3480191c:	e3a02078 	mov	r2, #120	; 0x78
34801920:	e3a01000 	mov	r1, #0
34801924:	e1a00008 	mov	r0, r8
34801928:	eb006893 	bl	3481bb7c <memset>
	gd->mon_len = _bss_end_ofs;	/* whole u-boot length */
3480192c:	e59f30fc 	ldr	r3, [pc, #252]	; 34801a30 <board_init_f+0x11c>
34801930:	e1a04008 	mov	r4, r8
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801934:	e3a01010 	mov	r1, #16
34801938:	e59f00f4 	ldr	r0, [pc, #244]	; 34801a34 <board_init_f+0x120>
	gd->mon_len = _bss_end_ofs;	/* whole u-boot length */
3480193c:	e5933000 	ldr	r3, [r3]
34801940:	e588303c 	str	r3, [r8, #60]	; 0x3c
						(uintptr_t)gd->fdt_blob);
34801944:	e5982050 	ldr	r2, [r8, #80]	; 0x50
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801948:	eb0018c2 	bl	34807c58 <getenv_ulong>
3480194c:	e5840050 	str	r0, [r4, #80]	; 0x50
34801950:	e59f40e0 	ldr	r4, [pc, #224]	; 34801a38 <board_init_f+0x124>
	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801954:	e5b47004 	ldr	r7, [r4, #4]!
34801958:	e3570000 	cmp	r7, #0
3480195c:	0a000003 	beq	34801970 <board_init_f+0x5c>
		if ((*init_fnc_ptr)() != 0) {
34801960:	e12fff37 	blx	r7
34801964:	e3500000 	cmp	r0, #0
34801968:	0afffff9 	beq	34801954 <board_init_f+0x40>
			hang ();
3480196c:	ebffffe3 	bl	34801900 <hang>
	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
34801970:	e5983038 	ldr	r3, [r8, #56]	; 0x38
	addr -= (4096 * 4);
34801974:	e283357f 	add	r3, r3, #532676608	; 0x1fc00000
34801978:	e28339ff 	add	r3, r3, #4177920	; 0x3fc000
	addr &= ~(0x10000 - 1);
3480197c:	e1a03823 	lsr	r3, r3, #16
34801980:	e1a03803 	lsl	r3, r3, #16
	gd->tlb_addr = addr;
34801984:	e588304c 	str	r3, [r8, #76]	; 0x4c
	addr -= gd->mon_len;
34801988:	e598403c 	ldr	r4, [r8, #60]	; 0x3c
3480198c:	e0644003 	rsb	r4, r4, r3
	addr &= ~(4096 - 1);
34801990:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34801994:	e3c4400f 	bic	r4, r4, #15
	addr_sp -= sizeof (bd_t);
34801998:	e2445706 	sub	r5, r4, #1572864	; 0x180000
	addr_sp -= sizeof (gd_t);
3480199c:	e24590a8 	sub	r9, r5, #168	; 0xa8
	addr_sp -= sizeof (bd_t);
348019a0:	e2453030 	sub	r3, r5, #48	; 0x30
	gd->bd = bd;
348019a4:	e5883000 	str	r3, [r8]
	addr_sp &= ~0x07;
348019a8:	e24550b8 	sub	r5, r5, #184	; 0xb8
	gd->irq_sp = addr_sp;
348019ac:	e5889040 	str	r9, [r8, #64]	; 0x40
	gd->bd->bi_baudrate = gd->baudrate;
348019b0:	e5983000 	ldr	r3, [r8]
348019b4:	e5982008 	ldr	r2, [r8, #8]
348019b8:	e5832000 	str	r2, [r3]
	dram_init_banksize();
348019bc:	ebfffc43 	bl	34800ad0 <dram_init_banksize>
		size += gd->bd->bi_dram[i].size;
348019c0:	e5982000 	ldr	r2, [r8]
348019c4:	e5981000 	ldr	r1, [r8]
348019c8:	e5983000 	ldr	r3, [r8]
	puts("DRAM:  ");
348019cc:	e59f0068 	ldr	r0, [pc, #104]	; 34801a3c <board_init_f+0x128>
348019d0:	e5916024 	ldr	r6, [r1, #36]	; 0x24
348019d4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
348019d8:	e0833006 	add	r3, r3, r6
		size += gd->bd->bi_dram[i].size;
348019dc:	e592601c 	ldr	r6, [r2, #28]
348019e0:	e0836006 	add	r6, r3, r6
	puts("DRAM:  ");
348019e4:	eb001f60 	bl	3480976c <puts>
	print_size(size, "\n");
348019e8:	e59f2050 	ldr	r2, [pc, #80]	; 34801a40 <board_init_f+0x12c>
348019ec:	e1a00006 	mov	r0, r6
348019f0:	e1a01007 	mov	r1, r7
348019f4:	eb006132 	bl	34819ec4 <print_size>
	gd->reloc_off = addr - _TEXT_BASE;
348019f8:	e59f3044 	ldr	r3, [pc, #68]	; 34801a44 <board_init_f+0x130>
	gd->relocaddr = addr;
348019fc:	e1a01008 	mov	r1, r8
34801a00:	e5884034 	str	r4, [r8, #52]	; 0x34
	memcpy(id, (void *)gd, sizeof(gd_t));
34801a04:	e3a02078 	mov	r2, #120	; 0x78
	gd->start_addr_sp = addr_sp;
34801a08:	e5885044 	str	r5, [r8, #68]	; 0x44
	memcpy(id, (void *)gd, sizeof(gd_t));
34801a0c:	e1a00009 	mov	r0, r9
	gd->reloc_off = addr - _TEXT_BASE;
34801a10:	e5933000 	ldr	r3, [r3]
34801a14:	e0633004 	rsb	r3, r3, r4
34801a18:	e5883048 	str	r3, [r8, #72]	; 0x48
	memcpy(id, (void *)gd, sizeof(gd_t));
34801a1c:	eb006876 	bl	3481bbfc <memcpy>
	relocate_code(addr_sp, id, addr);
34801a20:	e1a02004 	mov	r2, r4
34801a24:	e1a01009 	mov	r1, r9
34801a28:	e1a00005 	mov	r0, r5
34801a2c:	ebfff99b 	bl	348000a0 <relocate_code>
34801a30:	3480004c 	.word	0x3480004c
34801a34:	34821698 	.word	0x34821698
34801a38:	34827008 	.word	0x34827008
34801a3c:	348216a7 	.word	0x348216a7
34801a40:	34824f42 	.word	0x34824f42
34801a44:	34800040 	.word	0x34800040

34801a48 <boot_prep_linux>:
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
34801a48:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34801a4c:	e1a06000 	mov	r6, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
34801a50:	e59f0138 	ldr	r0, [pc, #312]	; 34801b90 <boot_prep_linux+0x148>
34801a54:	eb00184a 	bl	34807b84 <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
34801a58:	e5983000 	ldr	r3, [r8]
	if (!commandline)
34801a5c:	e3500000 	cmp	r0, #0
	params->hdr.size = tag_size (tag_core);
34801a60:	e59fe12c 	ldr	lr, [pc, #300]	; 34801b94 <boot_prep_linux+0x14c>
	params = tag_next (params);
34801a64:	e59f412c 	ldr	r4, [pc, #300]	; 34801b98 <boot_prep_linux+0x150>
	params = (struct tag *)bd->bi_boot_params;
34801a68:	e5935008 	ldr	r5, [r3, #8]
	params->hdr.size = tag_size (tag_core);
34801a6c:	e3a03005 	mov	r3, #5
34801a70:	e8854008 	stm	r5, {r3, lr}
	params->u.core.flags = 0;
34801a74:	e3a03000 	mov	r3, #0
34801a78:	e5853008 	str	r3, [r5, #8]
	params->u.core.pagesize = 0;
34801a7c:	e585300c 	str	r3, [r5, #12]
	params->u.core.rootdev = 0;
34801a80:	e5853010 	str	r3, [r5, #16]
	params = tag_next (params);
34801a84:	e2853014 	add	r3, r5, #20
34801a88:	e5843000 	str	r3, [r4]
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
34801a8c:	e5983000 	ldr	r3, [r8]
	if (!commandline)
34801a90:	0a000014 	beq	34801ae8 <boot_prep_linux+0xa0>
34801a94:	e1a07000 	mov	r7, r0
	for (p = commandline; *p == ' '; p++);
34801a98:	e4d03001 	ldrb	r3, [r0], #1
34801a9c:	e3530020 	cmp	r3, #32
34801aa0:	0afffffb 	beq	34801a94 <boot_prep_linux+0x4c>
	if (*p == '\0')
34801aa4:	e3530000 	cmp	r3, #0
34801aa8:	0a00000e 	beq	34801ae8 <boot_prep_linux+0xa0>
	params->hdr.tag = ATAG_CMDLINE;
34801aac:	e59f30e8 	ldr	r3, [pc, #232]	; 34801b9c <boot_prep_linux+0x154>
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801ab0:	e1a00007 	mov	r0, r7
	params->hdr.tag = ATAG_CMDLINE;
34801ab4:	e5853018 	str	r3, [r5, #24]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801ab8:	eb006786 	bl	3481b8d8 <strlen>
34801abc:	e280000d 	add	r0, r0, #13
	strcpy (params->u.cmdline.cmdline, p);
34801ac0:	e1a01007 	mov	r1, r7
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801ac4:	e1a00120 	lsr	r0, r0, #2
	params->hdr.size =
34801ac8:	e5850014 	str	r0, [r5, #20]
	strcpy (params->u.cmdline.cmdline, p);
34801acc:	e5940000 	ldr	r0, [r4]
34801ad0:	e2800008 	add	r0, r0, #8
34801ad4:	eb006721 	bl	3481b760 <strcpy>
	params = tag_next (params);
34801ad8:	e5943000 	ldr	r3, [r4]
34801adc:	e5932000 	ldr	r2, [r3]
34801ae0:	e0833102 	add	r3, r3, r2, lsl #2
34801ae4:	e5843000 	str	r3, [r4]
34801ae8:	e5942000 	ldr	r2, [r4]
		params->hdr.size = tag_size (tag_mem32);
34801aec:	e3a0e004 	mov	lr, #4
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801af0:	e5981000 	ldr	r1, [r8]
		params->hdr.tag = ATAG_MEM;
34801af4:	e59f50a4 	ldr	r5, [pc, #164]	; 34801ba0 <boot_prep_linux+0x158>
34801af8:	e2823010 	add	r3, r2, #16
34801afc:	e2820040 	add	r0, r2, #64	; 0x40
		params->u.mem.start = bd->bi_dram[i].start;
34801b00:	e591c018 	ldr	ip, [r1, #24]
34801b04:	e2833010 	add	r3, r3, #16
		params->hdr.tag = ATAG_MEM;
34801b08:	e503501c 	str	r5, [r3, #-28]	; 0xffffffe4
34801b0c:	e2811008 	add	r1, r1, #8
		params->hdr.size = tag_size (tag_mem32);
34801b10:	e503e020 	str	lr, [r3, #-32]	; 0xffffffe0
		params->u.mem.start = bd->bi_dram[i].start;
34801b14:	e503c014 	str	ip, [r3, #-20]	; 0xffffffec
		params->u.mem.size = bd->bi_dram[i].size;
34801b18:	e591c014 	ldr	ip, [r1, #20]
34801b1c:	e503c018 	str	ip, [r3, #-24]	; 0xffffffe8
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34801b20:	e1530000 	cmp	r3, r0
34801b24:	1afffff5 	bne	34801b00 <boot_prep_linux+0xb8>
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801b28:	e5960064 	ldr	r0, [r6, #100]	; 0x64
34801b2c:	e2821030 	add	r1, r2, #48	; 0x30
34801b30:	e5841000 	str	r1, [r4]
34801b34:	e3500000 	cmp	r0, #0
34801b38:	0a00000d 	beq	34801b74 <boot_prep_linux+0x12c>
34801b3c:	e5961068 	ldr	r1, [r6, #104]	; 0x68
34801b40:	e3510000 	cmp	r1, #0
34801b44:	0a00000a 	beq	34801b74 <boot_prep_linux+0x12c>
			setup_initrd_tag(gd->bd, images->rd_start,
34801b48:	e1a0c008 	mov	ip, r8
	params->u.initrd.size = initrd_end - initrd_start;
34801b4c:	e0601001 	rsb	r1, r0, r1
			setup_initrd_tag(gd->bd, images->rd_start,
34801b50:	e59cc000 	ldr	ip, [ip]
	params->hdr.tag = ATAG_INITRD2;
34801b54:	e59fc048 	ldr	ip, [pc, #72]	; 34801ba4 <boot_prep_linux+0x15c>
	params->u.initrd.start = initrd_start;
34801b58:	e5820038 	str	r0, [r2, #56]	; 0x38
	params->u.initrd.size = initrd_end - initrd_start;
34801b5c:	e582103c 	str	r1, [r2, #60]	; 0x3c
	params->hdr.tag = ATAG_INITRD2;
34801b60:	e582c034 	str	ip, [r2, #52]	; 0x34
	params->hdr.size = tag_size (tag_initrd);
34801b64:	e3a0c004 	mov	ip, #4
34801b68:	e582c030 	str	ip, [r2, #48]	; 0x30
	params = tag_next (params);
34801b6c:	e59f2024 	ldr	r2, [pc, #36]	; 34801b98 <boot_prep_linux+0x150>
34801b70:	e5823000 	str	r3, [r2]
			images->rd_end);
#endif
		setup_end_tag(gd->bd);
34801b74:	e1a03008 	mov	r3, r8
	params->hdr.tag = ATAG_NONE;
34801b78:	e3a02000 	mov	r2, #0
		setup_end_tag(gd->bd);
34801b7c:	e5933000 	ldr	r3, [r3]
	params->hdr.tag = ATAG_NONE;
34801b80:	e5943000 	ldr	r3, [r4]
34801b84:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
34801b88:	e5832000 	str	r2, [r3]
34801b8c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34801b90:	348216af 	.word	0x348216af
34801b94:	54410001 	.word	0x54410001
34801b98:	348285dc 	.word	0x348285dc
34801b9c:	54410009 	.word	0x54410009
34801ba0:	54410002 	.word	0x54410002
34801ba4:	54420005 	.word	0x54420005

34801ba8 <boot_jump_linux.isra.5>:
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
34801ba8:	e5983000 	ldr	r3, [r8]
static void boot_jump_linux(bootm_headers_t *images)
34801bac:	e92d4013 	push	{r0, r1, r4, lr}
34801bb0:	e1a04000 	mov	r4, r0
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801bb4:	e59f0058 	ldr	r0, [pc, #88]	; 34801c14 <boot_jump_linux.isra.5+0x6c>
	unsigned long machid = gd->bd->bi_arch_number;
34801bb8:	e5933004 	ldr	r3, [r3, #4]
34801bbc:	e58d3004 	str	r3, [sp, #4]
	s = getenv("machid");
34801bc0:	eb0017ef 	bl	34807b84 <getenv>
	if (s) {
34801bc4:	e3500000 	cmp	r0, #0
34801bc8:	0a000005 	beq	34801be4 <boot_jump_linux.isra.5+0x3c>
		strict_strtoul(s, 16, &machid);
34801bcc:	e3a01010 	mov	r1, #16
34801bd0:	e28d2004 	add	r2, sp, #4
34801bd4:	eb006b10 	bl	3481c81c <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
34801bd8:	e59d1004 	ldr	r1, [sp, #4]
34801bdc:	e59f0034 	ldr	r0, [pc, #52]	; 34801c18 <boot_jump_linux.isra.5+0x70>
34801be0:	eb001eed 	bl	3480979c <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801be4:	e3a0000f 	mov	r0, #15
34801be8:	eb002f4f 	bl	3480d92c <__show_boot_progress>
	printf("\nStarting kernel ...\n\n");
34801bec:	e59f0028 	ldr	r0, [pc, #40]	; 34801c1c <boot_jump_linux.isra.5+0x74>
34801bf0:	eb001ee9 	bl	3480979c <printf>
	cleanup_before_linux();
34801bf4:	ebfffca6 	bl	34800e94 <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
34801bf8:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
34801bfc:	e3a00000 	mov	r0, #0
34801c00:	e59d1004 	ldr	r1, [sp, #4]
34801c04:	e5932008 	ldr	r2, [r3, #8]
34801c08:	e12fff34 	blx	r4
}
34801c0c:	e28dd008 	add	sp, sp, #8
34801c10:	e8bd8010 	pop	{r4, pc}
34801c14:	348216b8 	.word	0x348216b8
34801c18:	348216bf 	.word	0x348216bf
34801c1c:	348216e4 	.word	0x348216e4

34801c20 <arch_lmb_reserve>:
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801c20:	e5982000 	ldr	r2, [r8]
34801c24:	e5983000 	ldr	r3, [r8]
	asm("mov %0, sp" : "=r"(ret) : );
34801c28:	e1a0100d 	mov	r1, sp
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801c2c:	e5922018 	ldr	r2, [r2, #24]
	sp -= 4096;
34801c30:	e2411a01 	sub	r1, r1, #4096	; 0x1000
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801c34:	e593301c 	ldr	r3, [r3, #28]
34801c38:	e0832002 	add	r2, r3, r2
	lmb_reserve(lmb, sp,
34801c3c:	e0612002 	rsb	r2, r1, r2
34801c40:	ea0065ec 	b	3481b3f8 <lmb_reserve>

34801c44 <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801c44:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801c48:	e2104030 	ands	r4, r0, #48	; 0x30
		return -1;
34801c4c:	13e04000 	mvnne	r4, #0
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801c50:	1a00000f 	bne	34801c94 <do_bootm_linux+0x50>

	if (flag & BOOTM_STATE_OS_PREP) {
34801c54:	e2106040 	ands	r6, r0, #64	; 0x40
34801c58:	e1a05003 	mov	r5, r3
34801c5c:	0a000002 	beq	34801c6c <do_bootm_linux+0x28>
		boot_prep_linux(images);
34801c60:	e1a00003 	mov	r0, r3
34801c64:	ebffff77 	bl	34801a48 <boot_prep_linux>
		return 0;
34801c68:	ea000009 	b	34801c94 <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
34801c6c:	e2104080 	ands	r4, r0, #128	; 0x80
34801c70:	0a000003 	beq	34801c84 <do_bootm_linux+0x40>
		boot_jump_linux(images);
34801c74:	e5930060 	ldr	r0, [r3, #96]	; 0x60
		return 0;
34801c78:	e1a04006 	mov	r4, r6
		boot_jump_linux(images);
34801c7c:	ebffffc9 	bl	34801ba8 <boot_jump_linux.isra.5>
		return 0;
34801c80:	ea000003 	b	34801c94 <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
34801c84:	e1a00003 	mov	r0, r3
34801c88:	ebffff6e 	bl	34801a48 <boot_prep_linux>
	boot_jump_linux(images);
34801c8c:	e5950060 	ldr	r0, [r5, #96]	; 0x60
34801c90:	ebffffc4 	bl	34801ba8 <boot_jump_linux.isra.5>
	return 0;
}
34801c94:	e1a00004 	mov	r0, r4
34801c98:	e8bd8070 	pop	{r4, r5, r6, pc}

34801c9c <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801c9c:	e5983040 	ldr	r3, [r8, #64]	; 0x40

	return 0;
}
34801ca0:	e3a00000 	mov	r0, #0
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801ca4:	e59f2008 	ldr	r2, [pc, #8]	; 34801cb4 <interrupt_init+0x18>
34801ca8:	e2833008 	add	r3, r3, #8
34801cac:	e5823000 	str	r3, [r2]
}
34801cb0:	e12fff1e 	bx	lr
34801cb4:	34800054 	.word	0x34800054

34801cb8 <enable_interrupts>:

void enable_interrupts (void)
{
34801cb8:	e12fff1e 	bx	lr

34801cbc <disable_interrupts>:
	return;
}
int disable_interrupts (void)
{
	return 0;
}
34801cbc:	e3a00000 	mov	r0, #0
34801cc0:	e12fff1e 	bx	lr

34801cc4 <bad_mode>:
#endif


void bad_mode (void)
{
34801cc4:	e92d4010 	push	{r4, lr}
	panic ("Resetting CPU ...\n");
34801cc8:	e59f0000 	ldr	r0, [pc]	; 34801cd0 <bad_mode+0xc>
34801ccc:	eb006b57 	bl	3481ca30 <panic>
34801cd0:	348216fb 	.word	0x348216fb

34801cd4 <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
34801cd4:	e92d4030 	push	{r4, r5, lr}
34801cd8:	e24dd08c 	sub	sp, sp, #140	; 0x8c
34801cdc:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
34801ce0:	e3a02080 	mov	r2, #128	; 0x80
34801ce4:	e28d0008 	add	r0, sp, #8
34801ce8:	e59f10f8 	ldr	r1, [pc, #248]	; 34801de8 <show_regs+0x114>
34801cec:	eb0067c2 	bl	3481bbfc <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801cf0:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34801cf4:	e5942038 	ldr	r2, [r4, #56]	; 0x38
34801cf8:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34801cfc:	e58d3004 	str	r3, [sp, #4]
34801d00:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34801d04:	e59f00e0 	ldr	r0, [pc, #224]	; 34801dec <show_regs+0x118>
	flags = condition_codes (regs);
34801d08:	e5945040 	ldr	r5, [r4, #64]	; 0x40
	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801d0c:	e58d3000 	str	r3, [sp]
34801d10:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34801d14:	eb001ea0 	bl	3480979c <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
34801d18:	e5943020 	ldr	r3, [r4, #32]
34801d1c:	e5942024 	ldr	r2, [r4, #36]	; 0x24
34801d20:	e5941028 	ldr	r1, [r4, #40]	; 0x28
34801d24:	e59f00c4 	ldr	r0, [pc, #196]	; 34801df0 <show_regs+0x11c>
34801d28:	eb001e9b 	bl	3480979c <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
34801d2c:	e5943010 	ldr	r3, [r4, #16]
34801d30:	e5942018 	ldr	r2, [r4, #24]
34801d34:	e594101c 	ldr	r1, [r4, #28]
34801d38:	e58d3000 	str	r3, [sp]
34801d3c:	e59f00b0 	ldr	r0, [pc, #176]	; 34801df4 <show_regs+0x120>
34801d40:	e5943014 	ldr	r3, [r4, #20]
34801d44:	eb001e94 	bl	3480979c <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
34801d48:	e5943000 	ldr	r3, [r4]
34801d4c:	e594100c 	ldr	r1, [r4, #12]
34801d50:	e5942008 	ldr	r2, [r4, #8]
34801d54:	e58d3000 	str	r3, [sp]
34801d58:	e59f0098 	ldr	r0, [pc, #152]	; 34801df8 <show_regs+0x124>
34801d5c:	e5943004 	ldr	r3, [r4, #4]
34801d60:	eb001e8d 	bl	3480979c <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801d64:	e3550000 	cmp	r5, #0
34801d68:	b3a0104e 	movlt	r1, #78	; 0x4e
34801d6c:	a3a0106e 	movge	r1, #110	; 0x6e
34801d70:	e3150101 	tst	r5, #1073741824	; 0x40000000
34801d74:	13a0205a 	movne	r2, #90	; 0x5a
34801d78:	03a0207a 	moveq	r2, #122	; 0x7a
34801d7c:	e3150202 	tst	r5, #536870912	; 0x20000000
34801d80:	13a03043 	movne	r3, #67	; 0x43
34801d84:	03a03063 	moveq	r3, #99	; 0x63
34801d88:	e3150201 	tst	r5, #268435456	; 0x10000000
34801d8c:	13a00056 	movne	r0, #86	; 0x56
34801d90:	03a00076 	moveq	r0, #118	; 0x76
34801d94:	e58d0000 	str	r0, [sp]
34801d98:	e59f005c 	ldr	r0, [pc, #92]	; 34801dfc <show_regs+0x128>
34801d9c:	eb001e7e 	bl	3480979c <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
34801da0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801da4:	e28dc088 	add	ip, sp, #136	; 0x88
34801da8:	e59f2050 	ldr	r2, [pc, #80]	; 34801e00 <show_regs+0x12c>
34801dac:	e59f0050 	ldr	r0, [pc, #80]	; 34801e04 <show_regs+0x130>
34801db0:	e3130080 	tst	r3, #128	; 0x80
34801db4:	01a01002 	moveq	r1, r2
34801db8:	11a01000 	movne	r1, r0
34801dbc:	e3130040 	tst	r3, #64	; 0x40
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
34801dc0:	e203301f 	and	r3, r3, #31
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801dc4:	11a02000 	movne	r2, r0
34801dc8:	e08c3103 	add	r3, ip, r3, lsl #2
34801dcc:	e59fc034 	ldr	ip, [pc, #52]	; 34801e08 <show_regs+0x134>
34801dd0:	e59f0034 	ldr	r0, [pc, #52]	; 34801e0c <show_regs+0x138>
34801dd4:	e58dc000 	str	ip, [sp]
34801dd8:	e5133080 	ldr	r3, [r3, #-128]	; 0xffffff80
34801ddc:	eb001e6e 	bl	3480979c <printf>
		thumb_mode (regs) ? " (T)" : "");
}
34801de0:	e28dd08c 	add	sp, sp, #140	; 0x8c
34801de4:	e8bd8030 	pop	{r4, r5, pc}
34801de8:	3481f5a0 	.word	0x3481f5a0
34801dec:	3482170e 	.word	0x3482170e
34801df0:	34821753 	.word	0x34821753
34801df4:	34821777 	.word	0x34821777
34801df8:	348217a7 	.word	0x348217a7
34801dfc:	348217d7 	.word	0x348217d7
34801e00:	34826fb9 	.word	0x34826fb9
34801e04:	348219f9 	.word	0x348219f9
34801e08:	34822afd 	.word	0x34822afd
34801e0c:	348217e7 	.word	0x348217e7

34801e10 <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
34801e10:	e92d4010 	push	{r4, lr}
34801e14:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
34801e18:	e59f000c 	ldr	r0, [pc, #12]	; 34801e2c <do_undefined_instruction+0x1c>
34801e1c:	eb001e5e 	bl	3480979c <printf>
	show_regs (pt_regs);
34801e20:	e1a00004 	mov	r0, r4
34801e24:	ebffffaa 	bl	34801cd4 <show_regs>
	bad_mode ();
34801e28:	ebffffa5 	bl	34801cc4 <bad_mode>
34801e2c:	34821806 	.word	0x34821806

34801e30 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
34801e30:	e92d4010 	push	{r4, lr}
34801e34:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
34801e38:	e59f000c 	ldr	r0, [pc, #12]	; 34801e4c <do_software_interrupt+0x1c>
34801e3c:	eb001e56 	bl	3480979c <printf>
	show_regs (pt_regs);
34801e40:	e1a00004 	mov	r0, r4
34801e44:	ebffffa2 	bl	34801cd4 <show_regs>
	bad_mode ();
34801e48:	ebffff9d 	bl	34801cc4 <bad_mode>
34801e4c:	3482181d 	.word	0x3482181d

34801e50 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
34801e50:	e92d4010 	push	{r4, lr}
34801e54:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
34801e58:	e59f000c 	ldr	r0, [pc, #12]	; 34801e6c <do_prefetch_abort+0x1c>
34801e5c:	eb001e4e 	bl	3480979c <printf>
	show_regs (pt_regs);
34801e60:	e1a00004 	mov	r0, r4
34801e64:	ebffff9a 	bl	34801cd4 <show_regs>
	bad_mode ();
34801e68:	ebffff95 	bl	34801cc4 <bad_mode>
34801e6c:	34821831 	.word	0x34821831

34801e70 <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
34801e70:	e92d4010 	push	{r4, lr}
34801e74:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
34801e78:	e59f000c 	ldr	r0, [pc, #12]	; 34801e8c <do_data_abort+0x1c>
34801e7c:	eb001e46 	bl	3480979c <printf>
	show_regs (pt_regs);
34801e80:	e1a00004 	mov	r0, r4
34801e84:	ebffff92 	bl	34801cd4 <show_regs>
	bad_mode ();
34801e88:	ebffff8d 	bl	34801cc4 <bad_mode>
34801e8c:	34821841 	.word	0x34821841

34801e90 <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
34801e90:	e92d4010 	push	{r4, lr}
34801e94:	e1a04000 	mov	r4, r0
	printf ("not used\n");
34801e98:	e59f000c 	ldr	r0, [pc, #12]	; 34801eac <do_not_used+0x1c>
34801e9c:	eb001e3e 	bl	3480979c <printf>
	show_regs (pt_regs);
34801ea0:	e1a00004 	mov	r0, r4
34801ea4:	ebffff8a 	bl	34801cd4 <show_regs>
	bad_mode ();
34801ea8:	ebffff85 	bl	34801cc4 <bad_mode>
34801eac:	3482184d 	.word	0x3482184d

34801eb0 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
34801eb0:	e92d4010 	push	{r4, lr}
34801eb4:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
34801eb8:	e59f000c 	ldr	r0, [pc, #12]	; 34801ecc <do_fiq+0x1c>
34801ebc:	eb001e36 	bl	3480979c <printf>
	show_regs (pt_regs);
34801ec0:	e1a00004 	mov	r0, r4
34801ec4:	ebffff82 	bl	34801cd4 <show_regs>
	bad_mode ();
34801ec8:	ebffff7d 	bl	34801cc4 <bad_mode>
34801ecc:	34821857 	.word	0x34821857

34801ed0 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
34801ed0:	e92d4010 	push	{r4, lr}
34801ed4:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
34801ed8:	e59f000c 	ldr	r0, [pc, #12]	; 34801eec <do_irq+0x1c>
34801edc:	eb001e2e 	bl	3480979c <printf>
	show_regs (pt_regs);
34801ee0:	e1a00004 	mov	r0, r4
34801ee4:	ebffff7a 	bl	34801cd4 <show_regs>
	bad_mode ();
34801ee8:	ebffff75 	bl	34801cc4 <bad_mode>
34801eec:	3482185c 	.word	0x3482185c

34801ef0 <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801ef0:	e92d4010 	push	{r4, lr}
	puts ("resetting ...\n");
34801ef4:	e59f001c 	ldr	r0, [pc, #28]	; 34801f18 <do_reset+0x28>
34801ef8:	eb001e1b 	bl	3480976c <puts>

	udelay (50000);				/* wait 50 ms */
34801efc:	e30c0350 	movw	r0, #50000	; 0xc350
34801f00:	eb0067c1 	bl	3481be0c <udelay>

	disable_interrupts();
34801f04:	ebffff6c 	bl	34801cbc <disable_interrupts>
	reset_cpu(0);
34801f08:	e3a00000 	mov	r0, #0
34801f0c:	ebfffe13 	bl	34801760 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
34801f10:	e3a00000 	mov	r0, #0
34801f14:	e8bd8010 	pop	{r4, pc}
34801f18:	3482195b 	.word	0x3482195b

34801f1c <__flush_cache>:
/* for now: just dummy functions to satisfy the linker */

#include <common.h>

void  __flush_cache(unsigned long start, unsigned long size)
{
34801f1c:	e12fff1e 	bx	lr

34801f20 <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
34801f20:	e3e01000 	mvn	r1, #0
34801f24:	e3a00000 	mov	r0, #0
34801f28:	eafffbaa 	b	34800dd8 <flush_cache>

34801f2c <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
34801f2c:	e59f0000 	ldr	r0, [pc]	; 34801f34 <__enable_caches+0x8>
34801f30:	ea001e0d 	b	3480976c <puts>
34801f34:	3482196a 	.word	0x3482196a

34801f38 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
34801f38:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34801f3c:	e3a03000 	mov	r3, #0
34801f40:	e58d3004 	str	r3, [sp, #4]
34801f44:	e59d3004 	ldr	r3, [sp, #4]
34801f48:	e3530063 	cmp	r3, #99	; 0x63
34801f4c:	ca000003 	bgt	34801f60 <cp_delay+0x28>
		nop();
34801f50:	e1a00000 	nop			; (mov r0, r0)
	for (i = 0; i < 100; i++)
34801f54:	e59d3004 	ldr	r3, [sp, #4]
34801f58:	e2833001 	add	r3, r3, #1
34801f5c:	eafffff7 	b	34801f40 <cp_delay+0x8>
	asm volatile("" : : : "memory");
}
34801f60:	e28dd008 	add	sp, sp, #8
34801f64:	e12fff1e 	bx	lr

34801f68 <__arm_init_before_mmu>:
{
34801f68:	e12fff1e 	bx	lr

34801f6c <icache_enable>:
{
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
34801f6c:	e92d4010 	push	{r4, lr}
	cp_delay();
34801f70:	ebfffff0 	bl	34801f38 <cp_delay>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34801f74:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | cache_bit);
34801f78:	e3844a01 	orr	r4, r4, #4096	; 0x1000
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34801f7c:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
34801f80:	e8bd8010 	pop	{r4, pc}

34801f84 <icache_disable>:
	cache_enable(CR_I);
}

void icache_disable(void)
{
34801f84:	e92d4010 	push	{r4, lr}
	cp_delay();
34801f88:	ebffffea 	bl	34801f38 <cp_delay>
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34801f8c:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg & ~cache_bit);
34801f90:	e3c44a01 	bic	r4, r4, #4096	; 0x1000
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34801f94:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	isb();
34801f98:	e8bd8010 	pop	{r4, pc}

34801f9c <icache_status>:
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34801f9c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
}
34801fa0:	e7e00650 	ubfx	r0, r0, #12, #1
34801fa4:	e12fff1e 	bx	lr

34801fa8 <dcache_enable>:
{
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
34801fa8:	e92d4070 	push	{r4, r5, r6, lr}
34801fac:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	if ((cache_bit == CR_C) && !mmu_enabled())
34801fb0:	e2134001 	ands	r4, r3, #1
34801fb4:	1a000025 	bne	34802050 <dcache_enable+0xa8>
	u32 *page_table = (u32 *)gd->tlb_addr;
34801fb8:	e598504c 	ldr	r5, [r8, #76]	; 0x4c
	arm_init_before_mmu();
34801fbc:	ebfffb6b 	bl	34800d70 <arm_init_before_mmu>
	for (i = 0; i < 4096; i++)
34801fc0:	e1a03004 	mov	r3, r4
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34801fc4:	e1a02a03 	lsl	r2, r3, #20
34801fc8:	e3822ec1 	orr	r2, r2, #3088	; 0xc10
34801fcc:	e3822002 	orr	r2, r2, #2
34801fd0:	e7852103 	str	r2, [r5, r3, lsl #2]
	for (i = 0; i < 4096; i++)
34801fd4:	e2833001 	add	r3, r3, #1
34801fd8:	e3530a01 	cmp	r3, #4096	; 0x1000
34801fdc:	1afffff8 	bne	34801fc4 <dcache_enable+0x1c>
	u32 *page_table = (u32 *)gd->tlb_addr;
34801fe0:	e1a0c008 	mov	ip, r8
34801fe4:	e3a00000 	mov	r0, #0
34801fe8:	e59ce04c 	ldr	lr, [ip, #76]	; 0x4c
	bd_t *bd = gd->bd;
34801fec:	e59c1000 	ldr	r1, [ip]
34801ff0:	e0811180 	add	r1, r1, r0, lsl #3
	for (i = bd->bi_dram[bank].start >> 20;
34801ff4:	e5913018 	ldr	r3, [r1, #24]
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34801ff8:	e591101c 	ldr	r1, [r1, #28]
	for (i = bd->bi_dram[bank].start >> 20;
34801ffc:	e1a02a23 	lsr	r2, r3, #20
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34802000:	e0833001 	add	r3, r3, r1
34802004:	e1a03a23 	lsr	r3, r3, #20
	for (i = bd->bi_dram[bank].start >> 20;
34802008:	e1520003 	cmp	r2, r3
3480200c:	2a000005 	bcs	34802028 <dcache_enable+0x80>
		page_table[i] = i << 20 | (3 << 10) | CACHE_SETUP;
34802010:	e1a01a02 	lsl	r1, r2, #20
34802014:	e3811ec1 	orr	r1, r1, #3088	; 0xc10
34802018:	e381100e 	orr	r1, r1, #14
3480201c:	e78e1102 	str	r1, [lr, r2, lsl #2]
	     i++) {
34802020:	e2822001 	add	r2, r2, #1
34802024:	eafffff7 	b	34802008 <dcache_enable+0x60>
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34802028:	e2800001 	add	r0, r0, #1
3480202c:	e3500003 	cmp	r0, #3
34802030:	1affffec 	bne	34801fe8 <dcache_enable+0x40>
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
34802034:	ee025f10 	mcr	15, 0, r5, cr2, cr0, {0}
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
34802038:	e3e03000 	mvn	r3, #0
3480203c:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
	cp_delay();
34802040:	ebffffbc 	bl	34801f38 <cp_delay>
34802044:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
34802048:	e3844001 	orr	r4, r4, #1
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
3480204c:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802050:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	cp_delay();
34802054:	ebffffb7 	bl	34801f38 <cp_delay>
	set_cr(reg | cache_bit);
34802058:	e3844004 	orr	r4, r4, #4
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
3480205c:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	isb();
34802060:	e8bd8070 	pop	{r4, r5, r6, pc}

34802064 <dcache_disable>:
	cache_enable(CR_C);
}

void dcache_disable(void)
{
34802064:	e92d4010 	push	{r4, lr}
	cp_delay();
34802068:	ebffffb2 	bl	34801f38 <cp_delay>
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
3480206c:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
		if ((reg & CR_C) != CR_C)
34802070:	e3140004 	tst	r4, #4
34802074:	08bd8010 	popeq	{r4, pc}
		flush_dcache_all();
34802078:	ebfffb31 	bl	34800d44 <flush_dcache_all>
	set_cr(reg & ~cache_bit);
3480207c:	e3c44005 	bic	r4, r4, #5
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802080:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	isb();
34802084:	e8bd8010 	pop	{r4, pc}

34802088 <dcache_status>:
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802088:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
}
3480208c:	e7e00150 	ubfx	r0, r0, #2, #1
34802090:	e12fff1e 	bx	lr

34802094 <print_num>:
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802094:	e1a02001 	mov	r2, r1
34802098:	e1a01000 	mov	r1, r0
3480209c:	e59f0000 	ldr	r0, [pc]	; 348020a4 <print_num+0x10>
348020a0:	ea001dbd 	b	3480979c <printf>
348020a4:	34821987 	.word	0x34821987

348020a8 <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348020a8:	e92d4070 	push	{r4, r5, r6, lr}
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348020ac:	e3a05000 	mov	r5, #0
	bd_t *bd = gd->bd;
348020b0:	e5984000 	ldr	r4, [r8]
	print_num("arch_number",	bd->bi_arch_number);
348020b4:	e59f00a4 	ldr	r0, [pc, #164]	; 34802160 <do_bdinfo+0xb8>
348020b8:	e5941004 	ldr	r1, [r4, #4]
348020bc:	e1a06004 	mov	r6, r4
348020c0:	ebfffff3 	bl	34802094 <print_num>
	print_num("boot_params",	(ulong)bd->bi_boot_params);
348020c4:	e5941008 	ldr	r1, [r4, #8]
348020c8:	e59f0094 	ldr	r0, [pc, #148]	; 34802164 <do_bdinfo+0xbc>
348020cc:	ebfffff0 	bl	34802094 <print_num>
		print_num("DRAM bank",	i);
348020d0:	e1a01005 	mov	r1, r5
348020d4:	e59f008c 	ldr	r0, [pc, #140]	; 34802168 <do_bdinfo+0xc0>
348020d8:	ebffffed 	bl	34802094 <print_num>
		print_num("-> start",	bd->bi_dram[i].start);
348020dc:	e5961018 	ldr	r1, [r6, #24]
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348020e0:	e2855001 	add	r5, r5, #1
		print_num("-> start",	bd->bi_dram[i].start);
348020e4:	e59f0080 	ldr	r0, [pc, #128]	; 3480216c <do_bdinfo+0xc4>
348020e8:	e2866008 	add	r6, r6, #8
348020ec:	ebffffe8 	bl	34802094 <print_num>
		print_num("-> size",	bd->bi_dram[i].size);
348020f0:	e5961014 	ldr	r1, [r6, #20]
348020f4:	e59f0074 	ldr	r0, [pc, #116]	; 34802170 <do_bdinfo+0xc8>
348020f8:	ebffffe5 	bl	34802094 <print_num>
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348020fc:	e3550003 	cmp	r5, #3
34802100:	1afffff2 	bne	348020d0 <do_bdinfo+0x28>

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
34802104:	e5941000 	ldr	r1, [r4]
34802108:	e59f0064 	ldr	r0, [pc, #100]	; 34802174 <do_bdinfo+0xcc>
3480210c:	eb001da2 	bl	3480979c <printf>
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
34802110:	e59f0060 	ldr	r0, [pc, #96]	; 34802178 <do_bdinfo+0xd0>
34802114:	e598104c 	ldr	r1, [r8, #76]	; 0x4c
34802118:	ebffffdd 	bl	34802094 <print_num>
#endif
	print_num("relocaddr", gd->relocaddr);
3480211c:	e59f0058 	ldr	r0, [pc, #88]	; 3480217c <do_bdinfo+0xd4>
34802120:	e5981034 	ldr	r1, [r8, #52]	; 0x34
34802124:	ebffffda 	bl	34802094 <print_num>
	print_num("reloc off", gd->reloc_off);
34802128:	e59f0050 	ldr	r0, [pc, #80]	; 34802180 <do_bdinfo+0xd8>
3480212c:	e5981048 	ldr	r1, [r8, #72]	; 0x48
34802130:	ebffffd7 	bl	34802094 <print_num>
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
34802134:	e59f0048 	ldr	r0, [pc, #72]	; 34802184 <do_bdinfo+0xdc>
34802138:	e5981040 	ldr	r1, [r8, #64]	; 0x40
3480213c:	ebffffd4 	bl	34802094 <print_num>
	print_num("sp start ", gd->start_addr_sp);
34802140:	e59f0040 	ldr	r0, [pc, #64]	; 34802188 <do_bdinfo+0xe0>
34802144:	e5981044 	ldr	r1, [r8, #68]	; 0x44
34802148:	ebffffd1 	bl	34802094 <print_num>
	print_num("FB base  ", gd->fb_base);
3480214c:	e59f0038 	ldr	r0, [pc, #56]	; 3480218c <do_bdinfo+0xe4>
34802150:	e5981018 	ldr	r1, [r8, #24]
34802154:	ebffffce 	bl	34802094 <print_num>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
34802158:	e3a00000 	mov	r0, #0
3480215c:	e8bd8070 	pop	{r4, r5, r6, pc}
34802160:	34821997 	.word	0x34821997
34802164:	348219a3 	.word	0x348219a3
34802168:	348219af 	.word	0x348219af
3480216c:	348219b9 	.word	0x348219b9
34802170:	348219c2 	.word	0x348219c2
34802174:	348219ca 	.word	0x348219ca
34802178:	348219e0 	.word	0x348219e0
3480217c:	348219e9 	.word	0x348219e9
34802180:	348219f3 	.word	0x348219f3
34802184:	348219fd 	.word	0x348219fd
34802188:	34821a04 	.word	0x34821a04
3480218c:	34821a0e 	.word	0x34821a0e

34802190 <do_go_exec>:
#ifdef CONFIG_CMD_GO

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
{
34802190:	e1a03000 	mov	r3, r0
34802194:	e1a00001 	mov	r0, r1
	return entry (argc, argv);
34802198:	e1a01002 	mov	r1, r2
3480219c:	e12fff13 	bx	r3

348021a0 <do_go>:
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
348021a0:	e3520001 	cmp	r2, #1
{
348021a4:	e92d4070 	push	{r4, r5, r6, lr}
		return CMD_RET_USAGE;
348021a8:	d3e04000 	mvnle	r4, #0
	if (argc < 2)
348021ac:	da000012 	ble	348021fc <do_go+0x5c>
348021b0:	e1a04003 	mov	r4, r3
348021b4:	e1a05002 	mov	r5, r2

	addr = simple_strtoul(argv[1], NULL, 16);
348021b8:	e5b40004 	ldr	r0, [r4, #4]!
348021bc:	e3a02010 	mov	r2, #16
348021c0:	e3a01000 	mov	r1, #0
348021c4:	eb006966 	bl	3481c764 <simple_strtoul>

	printf ("## Starting application at 0x%08lX ...\n", addr);
348021c8:	e1a01000 	mov	r1, r0
	addr = simple_strtoul(argv[1], NULL, 16);
348021cc:	e1a06000 	mov	r6, r0
	printf ("## Starting application at 0x%08lX ...\n", addr);
348021d0:	e59f002c 	ldr	r0, [pc, #44]	; 34802204 <do_go+0x64>
348021d4:	eb001d70 	bl	3480979c <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
348021d8:	e1a02004 	mov	r2, r4
348021dc:	e2451001 	sub	r1, r5, #1
348021e0:	e1a00006 	mov	r0, r6
348021e4:	ebffffe9 	bl	34802190 <do_go_exec>
	if (rc != 0) rcode = 1;
348021e8:	e2904000 	adds	r4, r0, #0

	printf ("## Application terminated, rc = 0x%lX\n", rc);
348021ec:	e1a01000 	mov	r1, r0
348021f0:	e59f0010 	ldr	r0, [pc, #16]	; 34802208 <do_go+0x68>
	if (rc != 0) rcode = 1;
348021f4:	13a04001 	movne	r4, #1
	printf ("## Application terminated, rc = 0x%lX\n", rc);
348021f8:	eb001d67 	bl	3480979c <printf>
	return rcode;
}
348021fc:	e1a00004 	mov	r0, r4
34802200:	e8bd8070 	pop	{r4, r5, r6, pc}
34802204:	34821a3a 	.word	0x34821a3a
34802208:	34821a62 	.word	0x34821a62

3480220c <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
3480220c:	e6bf0f30 	rev	r0, r0
34802210:	e12fff1e 	bx	lr

34802214 <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802214:	e92d4010 	push	{r4, lr}
34802218:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
3480221c:	e59f0010 	ldr	r0, [pc, #16]	; 34802234 <do_bootd+0x20>
34802220:	eb001657 	bl	34807b84 <getenv>
34802224:	e1a01004 	mov	r1, r4
34802228:	eb00301e 	bl	3480e2a8 <run_command>
		rcode = 1;
	return rcode;
}
3480222c:	e1a00fa0 	lsr	r0, r0, #31
34802230:	e8bd8010 	pop	{r4, pc}
34802234:	34821b29 	.word	0x34821b29

34802238 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34802238:	e3d02080 	bics	r2, r0, #128	; 0x80
3480223c:	1a00000a 	bne	3480226c <do_bootm_rtems+0x34>
{
34802240:	e92d4010 	push	{r4, lr}
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
34802244:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
34802248:	e59f0024 	ldr	r0, [pc, #36]	; 34802274 <do_bootm_rtems+0x3c>
3480224c:	e1a01004 	mov	r1, r4
34802250:	eb001d51 	bl	3480979c <printf>
34802254:	e3a0000f 	mov	r0, #15
34802258:	eb002db3 	bl	3480d92c <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
3480225c:	e5980000 	ldr	r0, [r8]
34802260:	e12fff34 	blx	r4

	return 1;
}
34802264:	e3a00001 	mov	r0, #1
34802268:	e8bd8010 	pop	{r4, pc}
3480226c:	e3a00001 	mov	r0, #1
34802270:	e12fff1e 	bx	lr
34802274:	34821b31 	.word	0x34821b31

34802278 <do_bootm_netbsd>:
{
34802278:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
3480227c:	e3d00080 	bics	r0, r0, #128	; 0x80
34802280:	1a000041 	bne	3480238c <do_bootm_netbsd+0x114>
34802284:	e1a07003 	mov	r7, r3
	hdr = images->legacy_hdr_os;
34802288:	e593a000 	ldr	sl, [r3]
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
3480228c:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
34802290:	e1a05002 	mov	r5, r2
34802294:	e1a09001 	mov	r9, r1
34802298:	e3530004 	cmp	r3, #4
3480229c:	0a000001 	beq	348022a8 <do_bootm_netbsd+0x30>
	os_hdr = NULL;
348022a0:	e3a0a000 	mov	sl, #0
348022a4:	ea000007 	b	348022c8 <do_bootm_netbsd+0x50>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
348022a8:	e28d300c 	add	r3, sp, #12
348022ac:	e28d2008 	add	r2, sp, #8
348022b0:	e3a01001 	mov	r1, #1
348022b4:	e1a0000a 	mov	r0, sl
348022b8:	eb002b37 	bl	3480cf9c <image_multi_getimg>
		if (kernel_len)
348022bc:	e59d300c 	ldr	r3, [sp, #12]
348022c0:	e3530000 	cmp	r3, #0
348022c4:	0afffff5 	beq	348022a0 <do_bootm_netbsd+0x28>
	if (argc > 2) {
348022c8:	e3590002 	cmp	r9, #2
348022cc:	da00001e 	ble	3480234c <do_bootm_netbsd+0xd4>
348022d0:	e3a06000 	mov	r6, #0
348022d4:	e3a04002 	mov	r4, #2
			len += strlen(argv[i]) + 1;
348022d8:	e7950104 	ldr	r0, [r5, r4, lsl #2]
		for (i = 2, len = 0; i < argc; i += 1)
348022dc:	e2844001 	add	r4, r4, #1
			len += strlen(argv[i]) + 1;
348022e0:	eb00657c 	bl	3481b8d8 <strlen>
		for (i = 2, len = 0; i < argc; i += 1)
348022e4:	e1540009 	cmp	r4, r9
			len += strlen(argv[i]) + 1;
348022e8:	e2800001 	add	r0, r0, #1
348022ec:	e0866000 	add	r6, r6, r0
		for (i = 2, len = 0; i < argc; i += 1)
348022f0:	1afffff8 	bne	348022d8 <do_bootm_netbsd+0x60>
		cmdline = malloc(len);
348022f4:	e1a00006 	mov	r0, r6
348022f8:	e2855004 	add	r5, r5, #4
348022fc:	eb001ef5 	bl	34809ed8 <malloc>
		for (i = 2, len = 0; i < argc; i += 1) {
34802300:	e3a0b002 	mov	fp, #2
		cmdline = malloc(len);
34802304:	e1a06000 	mov	r6, r0
		for (i = 2, len = 0; i < argc; i += 1) {
34802308:	e3a04000 	mov	r4, #0
				cmdline[len++] = ' ';
3480230c:	e3a03020 	mov	r3, #32
			strcpy(&cmdline[len], argv[i]);
34802310:	e5b51004 	ldr	r1, [r5, #4]!
34802314:	e0860004 	add	r0, r6, r4
34802318:	e58d3004 	str	r3, [sp, #4]
		for (i = 2, len = 0; i < argc; i += 1) {
3480231c:	e28bb001 	add	fp, fp, #1
			strcpy(&cmdline[len], argv[i]);
34802320:	eb00650e 	bl	3481b760 <strcpy>
			len += strlen(argv[i]);
34802324:	e5950000 	ldr	r0, [r5]
34802328:	eb00656a 	bl	3481b8d8 <strlen>
		for (i = 2, len = 0; i < argc; i += 1) {
3480232c:	e15b0009 	cmp	fp, r9
			len += strlen(argv[i]);
34802330:	e0844000 	add	r4, r4, r0
		for (i = 2, len = 0; i < argc; i += 1) {
34802334:	e59d3004 	ldr	r3, [sp, #4]
34802338:	0a000008 	beq	34802360 <do_bootm_netbsd+0xe8>
			if (i > 2)
3480233c:	e35b0002 	cmp	fp, #2
				cmdline[len++] = ' ';
34802340:	17c63004 	strbne	r3, [r6, r4]
34802344:	12844001 	addne	r4, r4, #1
34802348:	eafffff0 	b	34802310 <do_bootm_netbsd+0x98>
	} else if ((cmdline = getenv("bootargs")) == NULL) {
3480234c:	e59f0044 	ldr	r0, [pc, #68]	; 34802398 <do_bootm_netbsd+0x120>
34802350:	eb00160b 	bl	34807b84 <getenv>
		cmdline = "";
34802354:	e3500000 	cmp	r0, #0
34802358:	e59f603c 	ldr	r6, [pc, #60]	; 3480239c <do_bootm_netbsd+0x124>
3480235c:	11a06000 	movne	r6, r0
	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
34802360:	e5974060 	ldr	r4, [r7, #96]	; 0x60
	printf("## Transferring control to NetBSD stage-2 loader "
34802364:	e59f0034 	ldr	r0, [pc, #52]	; 348023a0 <do_bootm_netbsd+0x128>
34802368:	e1a01004 	mov	r1, r4
3480236c:	eb001d0a 	bl	3480979c <printf>
34802370:	e3a0000f 	mov	r0, #15
34802374:	eb002d6c 	bl	3480d92c <__show_boot_progress>
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
34802378:	e1a03006 	mov	r3, r6
3480237c:	e5980000 	ldr	r0, [r8]
34802380:	e59f2014 	ldr	r2, [pc, #20]	; 3480239c <do_bootm_netbsd+0x124>
34802384:	e1a0100a 	mov	r1, sl
34802388:	e12fff34 	blx	r4
}
3480238c:	e3a00001 	mov	r0, #1
34802390:	e28dd010 	add	sp, sp, #16
34802394:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34802398:	348216af 	.word	0x348216af
3480239c:	34822afd 	.word	0x34822afd
348023a0:	34821b6a 	.word	0x34821b6a

348023a4 <image_get_magic.isra.7>:
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
348023a4:	eaffff98 	b	3480220c <__fswab32>

348023a8 <image_get_size.isra.9>:
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
348023a8:	eaffff97 	b	3480220c <__fswab32>

348023ac <bootm_load_os.isra.14>:
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
348023ac:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
348023b0:	e1a07000 	mov	r7, r0
348023b4:	e5dd402c 	ldrb	r4, [sp, #44]	; 0x2c
348023b8:	e1a09001 	mov	r9, r1
348023bc:	e1a0a002 	mov	sl, r2
	const char *type_name = genimg_get_type_name(os.type);
348023c0:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
348023c4:	e59d5028 	ldr	r5, [sp, #40]	; 0x28
348023c8:	e59d6034 	ldr	r6, [sp, #52]	; 0x34
	ulong image_len = os.image_len;
348023cc:	e58d3004 	str	r3, [sp, #4]
	const char *type_name = genimg_get_type_name(os.type);
348023d0:	eb002b72 	bl	3480d1a0 <genimg_get_type_name>
	switch (comp) {
348023d4:	e3540000 	cmp	r4, #0
	const char *type_name = genimg_get_type_name(os.type);
348023d8:	e1a01000 	mov	r1, r0
	switch (comp) {
348023dc:	0a000002 	beq	348023ec <bootm_load_os.isra.14+0x40>
348023e0:	e3540001 	cmp	r4, #1
348023e4:	0a000016 	beq	34802444 <bootm_load_os.isra.14+0x98>
348023e8:	ea00002b 	b	3480249c <bootm_load_os.isra.14+0xf0>
		if (load == blob_start || load == image_start) {
348023ec:	e1550007 	cmp	r5, r7
348023f0:	1155000a 	cmpne	r5, sl
348023f4:	03a04001 	moveq	r4, #1
348023f8:	13a04000 	movne	r4, #0
348023fc:	1a000003 	bne	34802410 <bootm_load_os.isra.14+0x64>
			printf("   XIP %s ... ", type_name);
34802400:	e59f0104 	ldr	r0, [pc, #260]	; 3480250c <bootm_load_os.isra.14+0x160>
			no_overlap = 1;
34802404:	e3a04001 	mov	r4, #1
			printf("   XIP %s ... ", type_name);
34802408:	eb001ce3 	bl	3480979c <printf>
3480240c:	ea000006 	b	3480242c <bootm_load_os.isra.14+0x80>
			printf("   Loading %s ... ", type_name);
34802410:	e59f00f8 	ldr	r0, [pc, #248]	; 34802510 <bootm_load_os.isra.14+0x164>
34802414:	eb001ce0 	bl	3480979c <printf>
			memmove_wd((void *)load, (void *)image_start,
34802418:	e3a03801 	mov	r3, #65536	; 0x10000
3480241c:	e59d2004 	ldr	r2, [sp, #4]
34802420:	e1a0100a 	mov	r1, sl
34802424:	e1a00005 	mov	r0, r5
34802428:	eb002b36 	bl	3480d108 <memmove_wd>
		*load_end = load + image_len;
3480242c:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
34802430:	e59f00dc 	ldr	r0, [pc, #220]	; 34802514 <bootm_load_os.isra.14+0x168>
		*load_end = load + image_len;
34802434:	e0853003 	add	r3, r5, r3
34802438:	e5863000 	str	r3, [r6]
		puts("OK\n");
3480243c:	eb001cca 	bl	3480976c <puts>
34802440:	ea00001a 	b	348024b0 <bootm_load_os.isra.14+0x104>
		printf("   Uncompressing %s ... ", type_name);
34802444:	e59f00cc 	ldr	r0, [pc, #204]	; 34802518 <bootm_load_os.isra.14+0x16c>
34802448:	eb001cd3 	bl	3480979c <printf>
		if (gunzip((void *)load, unc_len,
3480244c:	e28d3004 	add	r3, sp, #4
34802450:	e1a0200a 	mov	r2, sl
34802454:	e3a01502 	mov	r1, #8388608	; 0x800000
34802458:	e1a00005 	mov	r0, r5
3480245c:	eb005fbe 	bl	3481a35c <gunzip>
34802460:	e3500000 	cmp	r0, #0
34802464:	0a000007 	beq	34802488 <bootm_load_os.isra.14+0xdc>
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
34802468:	e59f00ac 	ldr	r0, [pc, #172]	; 3480251c <bootm_load_os.isra.14+0x170>
3480246c:	eb001cbe 	bl	3480976c <puts>
			if (boot_progress)
34802470:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34802474:	e3530000 	cmp	r3, #0
34802478:	0a000020 	beq	34802500 <bootm_load_os.isra.14+0x154>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480247c:	e3e00005 	mvn	r0, #5
34802480:	eb002d29 	bl	3480d92c <__show_boot_progress>
34802484:	ea00001d 	b	34802500 <bootm_load_os.isra.14+0x154>
		*load_end = load + image_len;
34802488:	e59d3004 	ldr	r3, [sp, #4]
	int no_overlap = 0;
3480248c:	e1a04000 	mov	r4, r0
		*load_end = load + image_len;
34802490:	e0853003 	add	r3, r5, r3
34802494:	e5863000 	str	r3, [r6]
34802498:	ea000004 	b	348024b0 <bootm_load_os.isra.14+0x104>
		printf("Unimplemented compression type %d\n", comp);
3480249c:	e1a01004 	mov	r1, r4
348024a0:	e59f0078 	ldr	r0, [pc, #120]	; 34802520 <bootm_load_os.isra.14+0x174>
348024a4:	eb001cbc 	bl	3480979c <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
348024a8:	e3e00002 	mvn	r0, #2
348024ac:	ea000014 	b	34802504 <bootm_load_os.isra.14+0x158>
	flush_cache(load, (*load_end - load) * sizeof(ulong));
348024b0:	e5961000 	ldr	r1, [r6]
348024b4:	e1a00005 	mov	r0, r5
348024b8:	e0651001 	rsb	r1, r5, r1
348024bc:	e1a01101 	lsl	r1, r1, #2
348024c0:	ebfffa44 	bl	34800dd8 <flush_cache>
	puts("OK\n");
348024c4:	e59f0048 	ldr	r0, [pc, #72]	; 34802514 <bootm_load_os.isra.14+0x168>
348024c8:	eb001ca7 	bl	3480976c <puts>
	show_boot_progress(id);
348024cc:	e3a00007 	mov	r0, #7
348024d0:	eb002d15 	bl	3480d92c <__show_boot_progress>
348024d4:	e2240001 	eor	r0, r4, #1
	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
348024d8:	e1550009 	cmp	r5, r9
348024dc:	23a00000 	movcs	r0, #0
348024e0:	32000001 	andcc	r0, r0, #1
348024e4:	e3500000 	cmp	r0, #0
348024e8:	0a000005 	beq	34802504 <bootm_load_os.isra.14+0x158>
348024ec:	e5963000 	ldr	r3, [r6]
348024f0:	e1530007 	cmp	r3, r7
		return BOOTM_ERR_OVERLAP;
348024f4:	93a00000 	movls	r0, #0
348024f8:	83e00001 	mvnhi	r0, #1
348024fc:	ea000000 	b	34802504 <bootm_load_os.isra.14+0x158>
			return BOOTM_ERR_RESET;
34802500:	e3e00000 	mvn	r0, #0
}
34802504:	e28dd00c 	add	sp, sp, #12
34802508:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480250c:	34821bb3 	.word	0x34821bb3
34802510:	34821bc2 	.word	0x34821bc2
34802514:	34821bd5 	.word	0x34821bd5
34802518:	34821bd9 	.word	0x34821bd9
3480251c:	34821bf2 	.word	0x34821bf2
34802520:	34821c43 	.word	0x34821c43

34802524 <image_info>:
{
34802524:	e92d4070 	push	{r4, r5, r6, lr}
	printf("\n## Checking Image at %08lx ...\n", addr);
34802528:	e1a01000 	mov	r1, r0
{
3480252c:	e1a04000 	mov	r4, r0
	printf("\n## Checking Image at %08lx ...\n", addr);
34802530:	e59f0098 	ldr	r0, [pc, #152]	; 348025d0 <image_info+0xac>
34802534:	eb001c98 	bl	3480979c <printf>
	switch (genimg_get_format(hdr)) {
34802538:	e1a00004 	mov	r0, r4
3480253c:	eb002bad 	bl	3480d3f8 <genimg_get_format>
34802540:	e3500001 	cmp	r0, #1
34802544:	e1a05000 	mov	r5, r0
34802548:	1a00001b 	bne	348025bc <image_info+0x98>
		puts("   Legacy image found\n");
3480254c:	e59f0080 	ldr	r0, [pc, #128]	; 348025d4 <image_info+0xb0>
34802550:	eb001c85 	bl	3480976c <puts>
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
34802554:	e5940000 	ldr	r0, [r4]
34802558:	ebffff91 	bl	348023a4 <image_get_magic.isra.7>
		if (!image_check_magic(hdr)) {
3480255c:	e59f3074 	ldr	r3, [pc, #116]	; 348025d8 <image_info+0xb4>
34802560:	e1500003 	cmp	r0, r3
			puts("   Bad Magic Number\n");
34802564:	159f0070 	ldrne	r0, [pc, #112]	; 348025dc <image_info+0xb8>
		if (!image_check_magic(hdr)) {
34802568:	1a000004 	bne	34802580 <image_info+0x5c>
		if (!image_check_hcrc(hdr)) {
3480256c:	e1a00004 	mov	r0, r4
34802570:	eb002a5f 	bl	3480cef4 <image_check_hcrc>
34802574:	e3500000 	cmp	r0, #0
34802578:	1a000002 	bne	34802588 <image_info+0x64>
			puts("   Bad Header Checksum\n");
3480257c:	e59f005c 	ldr	r0, [pc, #92]	; 348025e0 <image_info+0xbc>
34802580:	eb001c79 	bl	3480976c <puts>
			return 1;
34802584:	ea00000f 	b	348025c8 <image_info+0xa4>
		image_print_contents(hdr);
34802588:	e1a00004 	mov	r0, r4
3480258c:	eb002b0f 	bl	3480d1d0 <image_print_contents>
		puts("   Verifying Checksum ... ");
34802590:	e59f004c 	ldr	r0, [pc, #76]	; 348025e4 <image_info+0xc0>
34802594:	eb001c74 	bl	3480976c <puts>
		if (!image_check_dcrc(hdr)) {
34802598:	e1a00004 	mov	r0, r4
3480259c:	eb002a68 	bl	3480cf44 <image_check_dcrc>
348025a0:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
348025a4:	059f003c 	ldreq	r0, [pc, #60]	; 348025e8 <image_info+0xc4>
		if (!image_check_dcrc(hdr)) {
348025a8:	0afffff4 	beq	34802580 <image_info+0x5c>
		puts("OK\n");
348025ac:	e59f0038 	ldr	r0, [pc, #56]	; 348025ec <image_info+0xc8>
		return 0;
348025b0:	e3a05000 	mov	r5, #0
		puts("OK\n");
348025b4:	eb001c6c 	bl	3480976c <puts>
		return 0;
348025b8:	ea000002 	b	348025c8 <image_info+0xa4>
	return 1;
348025bc:	e3a05001 	mov	r5, #1
		puts("Unknown image format!\n");
348025c0:	e59f0028 	ldr	r0, [pc, #40]	; 348025f0 <image_info+0xcc>
348025c4:	eb001c68 	bl	3480976c <puts>
}
348025c8:	e1a00005 	mov	r0, r5
348025cc:	e8bd8070 	pop	{r4, r5, r6, pc}
348025d0:	34821c66 	.word	0x34821c66
348025d4:	34821c87 	.word	0x34821c87
348025d8:	27051956 	.word	0x27051956
348025dc:	34821c9e 	.word	0x34821c9e
348025e0:	34821cb3 	.word	0x34821cb3
348025e4:	34821ccb 	.word	0x34821ccb
348025e8:	34821ce6 	.word	0x34821ce6
348025ec:	34821bd5 	.word	0x34821bd5
348025f0:	34821cf7 	.word	0x34821cf7

348025f4 <do_iminfo>:
	if (argc < 2) {
348025f4:	e3520001 	cmp	r2, #1
348025f8:	ca000002 	bgt	34802608 <do_iminfo+0x14>
		return image_info(load_addr);
348025fc:	e59f3048 	ldr	r3, [pc, #72]	; 3480264c <do_iminfo+0x58>
34802600:	e5930000 	ldr	r0, [r3]
34802604:	eaffffc6 	b	34802524 <image_info>
{
34802608:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480260c:	e1a07003 	mov	r7, r3
34802610:	e1a04002 	mov	r4, r2
34802614:	e3a06000 	mov	r6, #0
34802618:	e3a05001 	mov	r5, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
3480261c:	e3a02010 	mov	r2, #16
34802620:	e3a01000 	mov	r1, #0
34802624:	e7970105 	ldr	r0, [r7, r5, lsl #2]
	for (arg = 1; arg < argc; ++arg) {
34802628:	e2855001 	add	r5, r5, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
3480262c:	eb00684c 	bl	3481c764 <simple_strtoul>
		if (image_info(addr) != 0)
34802630:	ebffffbb 	bl	34802524 <image_info>
			rcode = 1;
34802634:	e3500000 	cmp	r0, #0
34802638:	13a06001 	movne	r6, #1
	for (arg = 1; arg < argc; ++arg) {
3480263c:	e1550004 	cmp	r5, r4
34802640:	1afffff5 	bne	3480261c <do_iminfo+0x28>
}
34802644:	e1a00006 	mov	r0, r6
34802648:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480264c:	348271b4 	.word	0x348271b4

34802650 <bootm_start.isra.13>:
static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34802650:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34802654:	e1a0a000 	mov	sl, r0
	memset((void *)&images, 0, sizeof(images));
34802658:	e59f4360 	ldr	r4, [pc, #864]	; 348029c0 <bootm_start.isra.13+0x370>
static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
3480265c:	e1a09002 	mov	r9, r2
	memset((void *)&images, 0, sizeof(images));
34802660:	e3a02f4b 	mov	r2, #300	; 0x12c
static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34802664:	e58d100c 	str	r1, [sp, #12]
	memset((void *)&images, 0, sizeof(images));
34802668:	e3a01000 	mov	r1, #0
3480266c:	e1a00004 	mov	r0, r4
34802670:	eb006541 	bl	3481bb7c <memset>
	images.verify = getenv_yesno("verify");
34802674:	e59f0348 	ldr	r0, [pc, #840]	; 348029c4 <bootm_start.isra.13+0x374>
34802678:	eb002a69 	bl	3480d024 <getenv_yesno>
3480267c:	e5840084 	str	r0, [r4, #132]	; 0x84
	lmb_init(&images->lmb);
34802680:	e284008c 	add	r0, r4, #140	; 0x8c
34802684:	eb00630f 	bl	3481b2c8 <lmb_init>
	mem_start = getenv_bootm_low();
34802688:	eb002a6f 	bl	3480d04c <getenv_bootm_low>
3480268c:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
34802690:	eb002a79 	bl	3480d07c <getenv_bootm_size>
	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802694:	e1a01005 	mov	r1, r5
34802698:	e1a02000 	mov	r2, r0
3480269c:	e284008c 	add	r0, r4, #140	; 0x8c
348026a0:	eb006312 	bl	3481b2f0 <lmb_add>
	arch_lmb_reserve(&images->lmb);
348026a4:	e284008c 	add	r0, r4, #140	; 0x8c
348026a8:	ebfffd5c 	bl	34801c20 <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
348026ac:	e284008c 	add	r0, r4, #140	; 0x8c
348026b0:	eb0063d3 	bl	3481b604 <__board_lmb_reserve>
	if (argc < 2) {
348026b4:	e59d300c 	ldr	r3, [sp, #12]
348026b8:	e3530001 	cmp	r3, #1
		img_addr = load_addr;
348026bc:	d59f3304 	ldrle	r3, [pc, #772]	; 348029c8 <bootm_start.isra.13+0x378>
348026c0:	d5935000 	ldrle	r5, [r3]
	if (argc < 2) {
348026c4:	da000004 	ble	348026dc <bootm_start.isra.13+0x8c>
		img_addr = simple_strtoul(argv[1], NULL, 16);
348026c8:	e3a02010 	mov	r2, #16
348026cc:	e3a01000 	mov	r1, #0
348026d0:	e5990004 	ldr	r0, [r9, #4]
348026d4:	eb006822 	bl	3481c764 <simple_strtoul>
348026d8:	e1a05000 	mov	r5, r0
348026dc:	e3a00001 	mov	r0, #1
	*os_data = *os_len = 0;
348026e0:	e3a0b000 	mov	fp, #0
348026e4:	eb002c90 	bl	3480d92c <__show_boot_progress>
	img_addr = genimg_get_image(img_addr);
348026e8:	e1a00005 	mov	r0, r5
348026ec:	eb002b46 	bl	3480d40c <genimg_get_image>
	*os_data = *os_len = 0;
348026f0:	e584b054 	str	fp, [r4, #84]	; 0x54
	img_addr = genimg_get_image(img_addr);
348026f4:	e1a05000 	mov	r5, r0
	*os_data = *os_len = 0;
348026f8:	e584b050 	str	fp, [r4, #80]	; 0x50
	switch (genimg_get_format((void *)img_addr)) {
348026fc:	e1a06000 	mov	r6, r0
34802700:	eb002b3c 	bl	3480d3f8 <genimg_get_format>
34802704:	e3500001 	cmp	r0, #1
34802708:	1a000034 	bne	348027e0 <bootm_start.isra.13+0x190>
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
3480270c:	e1a01005 	mov	r1, r5
34802710:	e59f02b4 	ldr	r0, [pc, #692]	; 348029cc <bootm_start.isra.13+0x37c>
34802714:	eb001c20 	bl	3480979c <printf>
		hdr = image_get_kernel(img_addr, images->verify);
34802718:	e59f32a0 	ldr	r3, [pc, #672]	; 348029c0 <bootm_start.isra.13+0x370>
3480271c:	e5950000 	ldr	r0, [r5]
34802720:	e593b084 	ldr	fp, [r3, #132]	; 0x84
34802724:	ebffff1e 	bl	348023a4 <image_get_magic.isra.7>
	if (!image_check_magic(hdr)) {
34802728:	e59f32a0 	ldr	r3, [pc, #672]	; 348029d0 <bootm_start.isra.13+0x380>
3480272c:	e1500003 	cmp	r0, r3
34802730:	0a000003 	beq	34802744 <bootm_start.isra.13+0xf4>
		puts("Bad Magic Number\n");
34802734:	e59f0298 	ldr	r0, [pc, #664]	; 348029d4 <bootm_start.isra.13+0x384>
34802738:	eb001c0b 	bl	3480976c <puts>
	show_boot_progress(-id);
3480273c:	e3e00000 	mvn	r0, #0
34802740:	ea000023 	b	348027d4 <bootm_start.isra.13+0x184>
	show_boot_progress(id);
34802744:	e3a00002 	mov	r0, #2
34802748:	eb002c77 	bl	3480d92c <__show_boot_progress>
	if (!image_check_hcrc(hdr)) {
3480274c:	e1a00005 	mov	r0, r5
34802750:	eb0029e7 	bl	3480cef4 <image_check_hcrc>
34802754:	e3500000 	cmp	r0, #0
34802758:	1a000003 	bne	3480276c <bootm_start.isra.13+0x11c>
		puts("Bad Header Checksum\n");
3480275c:	e59f0274 	ldr	r0, [pc, #628]	; 348029d8 <bootm_start.isra.13+0x388>
34802760:	eb001c01 	bl	3480976c <puts>
	show_boot_progress(-id);
34802764:	e3e00001 	mvn	r0, #1
34802768:	ea000019 	b	348027d4 <bootm_start.isra.13+0x184>
	show_boot_progress(id);
3480276c:	e3a00003 	mov	r0, #3
34802770:	eb002c6d 	bl	3480d92c <__show_boot_progress>
	image_print_contents(hdr);
34802774:	e1a00005 	mov	r0, r5
34802778:	eb002a94 	bl	3480d1d0 <image_print_contents>
	if (verify) {
3480277c:	e35b0000 	cmp	fp, #0
34802780:	0a00000b 	beq	348027b4 <bootm_start.isra.13+0x164>
		puts("   Verifying Checksum ... ");
34802784:	e59f0250 	ldr	r0, [pc, #592]	; 348029dc <bootm_start.isra.13+0x38c>
34802788:	eb001bf7 	bl	3480976c <puts>
		if (!image_check_dcrc(hdr)) {
3480278c:	e1a00005 	mov	r0, r5
34802790:	eb0029eb 	bl	3480cf44 <image_check_dcrc>
34802794:	e3500000 	cmp	r0, #0
34802798:	1a000003 	bne	348027ac <bootm_start.isra.13+0x15c>
			printf("Bad Data CRC\n");
3480279c:	e59f023c 	ldr	r0, [pc, #572]	; 348029e0 <bootm_start.isra.13+0x390>
348027a0:	eb001bfd 	bl	3480979c <printf>
	show_boot_progress(-id);
348027a4:	e3e00002 	mvn	r0, #2
348027a8:	ea000009 	b	348027d4 <bootm_start.isra.13+0x184>
		puts("OK\n");
348027ac:	e59f0230 	ldr	r0, [pc, #560]	; 348029e4 <bootm_start.isra.13+0x394>
348027b0:	eb001bed 	bl	3480976c <puts>
	show_boot_progress(id);
348027b4:	e3a00004 	mov	r0, #4
348027b8:	eb002c5b 	bl	3480d92c <__show_boot_progress>
348027bc:	e5d5101d 	ldrb	r1, [r5, #29]
	if (!image_check_target_arch(hdr)) {
348027c0:	e3510002 	cmp	r1, #2
348027c4:	0a000054 	beq	3480291c <bootm_start.isra.13+0x2cc>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
348027c8:	e59f0218 	ldr	r0, [pc, #536]	; 348029e8 <bootm_start.isra.13+0x398>
348027cc:	eb001bf2 	bl	3480979c <printf>
	show_boot_progress(-id);
348027d0:	e3e00003 	mvn	r0, #3
348027d4:	eb002c54 	bl	3480d92c <__show_boot_progress>
			return NULL;
348027d8:	e3a06000 	mov	r6, #0
348027dc:	ea000005 	b	348027f8 <bootm_start.isra.13+0x1a8>
		printf("Wrong Image Format for %s command\n", cmdtp->name);
348027e0:	e59a1000 	ldr	r1, [sl]
		return NULL;
348027e4:	e1a0600b 	mov	r6, fp
		printf("Wrong Image Format for %s command\n", cmdtp->name);
348027e8:	e59f01fc 	ldr	r0, [pc, #508]	; 348029ec <bootm_start.isra.13+0x39c>
348027ec:	eb001bea 	bl	3480979c <printf>
348027f0:	e3e0006b 	mvn	r0, #107	; 0x6b
348027f4:	eb002c4c 	bl	3480d92c <__show_boot_progress>
	if (images.os.image_len == 0) {
348027f8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348027fc:	e59f51bc 	ldr	r5, [pc, #444]	; 348029c0 <bootm_start.isra.13+0x370>
34802800:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
34802804:	059f01e4 	ldreq	r0, [pc, #484]	; 348029f0 <bootm_start.isra.13+0x3a0>
	if (images.os.image_len == 0) {
34802808:	0a000017 	beq	3480286c <bootm_start.isra.13+0x21c>
	switch (genimg_get_format(os_hdr)) {
3480280c:	e1a00006 	mov	r0, r6
34802810:	eb002af8 	bl	3480d3f8 <genimg_get_format>
34802814:	e3500001 	cmp	r0, #1
34802818:	e1a0a000 	mov	sl, r0
3480281c:	1a000011 	bne	34802868 <bootm_start.isra.13+0x218>
34802820:	e5d6701e 	ldrb	r7, [r6, #30]
		images.os.type = image_get_type(os_hdr);
34802824:	e5c5705d 	strb	r7, [r5, #93]	; 0x5d
34802828:	e5d6201f 	ldrb	r2, [r6, #31]
		images.os.comp = image_get_comp(os_hdr);
3480282c:	e5c5205c 	strb	r2, [r5, #92]	; 0x5c
34802830:	e5d6b01c 	ldrb	fp, [r6, #28]
		images.os.os = image_get_os(os_hdr);
34802834:	e5c5b05e 	strb	fp, [r5, #94]	; 0x5e
	return (image_get_size(hdr) + image_get_header_size());
34802838:	e596000c 	ldr	r0, [r6, #12]
3480283c:	ebfffed9 	bl	348023a8 <image_get_size.isra.9>
34802840:	e2862040 	add	r2, r6, #64	; 0x40
	return ((ulong)hdr + image_get_image_size(hdr));
34802844:	e0820000 	add	r0, r2, r0
		images.os.end = image_get_image_end(os_hdr);
34802848:	e585004c 	str	r0, [r5, #76]	; 0x4c
image_get_hdr_l(load)		/* image_get_load */
3480284c:	e5960010 	ldr	r0, [r6, #16]
34802850:	ebfffe6d 	bl	3480220c <__fswab32>
	if (images.legacy_hdr_valid) {
34802854:	e5952044 	ldr	r2, [r5, #68]	; 0x44
		images.os.load = image_get_load(os_hdr);
34802858:	e5850058 	str	r0, [r5, #88]	; 0x58
	if (images.legacy_hdr_valid) {
3480285c:	e3520000 	cmp	r2, #0
34802860:	1a000004 	bne	34802878 <bootm_start.isra.13+0x228>
34802864:	ea00000c 	b	3480289c <bootm_start.isra.13+0x24c>
		puts("ERROR: unknown image format type!\n");
34802868:	e59f0184 	ldr	r0, [pc, #388]	; 348029f4 <bootm_start.isra.13+0x3a4>
3480286c:	eb001bbe 	bl	3480976c <puts>
		return 1;
34802870:	e3a0a001 	mov	sl, #1
34802874:	ea00004e 	b	348029b4 <bootm_start.isra.13+0x364>
image_get_hdr_l(ep)		/* image_get_ep */
34802878:	e5950018 	ldr	r0, [r5, #24]
3480287c:	ebfffe62 	bl	3480220c <__fswab32>
	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802880:	e357000e 	cmp	r7, #14
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
34802884:	e5850060 	str	r0, [r5, #96]	; 0x60
		images.os.load = images.os.image_start;
34802888:	05952050 	ldreq	r2, [r5, #80]	; 0x50
		images.ep += images.os.load;
3480288c:	00800002 	addeq	r0, r0, r2
		images.os.load = images.os.image_start;
34802890:	05852058 	streq	r2, [r5, #88]	; 0x58
		images.ep += images.os.load;
34802894:	05850060 	streq	r0, [r5, #96]	; 0x60
34802898:	ea000001 	b	348028a4 <bootm_start.isra.13+0x254>
		puts("Could not find kernel entry point!\n");
3480289c:	e59f0154 	ldr	r0, [pc, #340]	; 348029f8 <bootm_start.isra.13+0x3a8>
348028a0:	ea000016 	b	34802900 <bootm_start.isra.13+0x2b0>
	if (((images.os.type == IH_TYPE_KERNEL) ||
348028a4:	e2472002 	sub	r2, r7, #2
348028a8:	e31200fd 	tst	r2, #253	; 0xfd
348028ac:	03a02001 	moveq	r2, #1
348028b0:	13a02000 	movne	r2, #0
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
348028b4:	e357000e 	cmp	r7, #14
348028b8:	11a03002 	movne	r3, r2
348028bc:	03823001 	orreq	r3, r2, #1
348028c0:	e3530000 	cmp	r3, #0
348028c4:	0a00000f 	beq	34802908 <bootm_start.isra.13+0x2b8>
	     (images.os.type == IH_TYPE_MULTI)) &&
348028c8:	e35b0005 	cmp	fp, #5
348028cc:	1a00000d 	bne	34802908 <bootm_start.isra.13+0x2b8>
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
348028d0:	e59f2124 	ldr	r2, [pc, #292]	; 348029fc <bootm_start.isra.13+0x3ac>
348028d4:	e1a01009 	mov	r1, r9
348028d8:	e59d000c 	ldr	r0, [sp, #12]
348028dc:	e2423004 	sub	r3, r2, #4
348028e0:	e58d2004 	str	r2, [sp, #4]
348028e4:	e58d3000 	str	r3, [sp]
348028e8:	e2422068 	sub	r2, r2, #104	; 0x68
348028ec:	e3a03002 	mov	r3, #2
348028f0:	eb002ac8 	bl	3480d418 <boot_get_ramdisk>
		if (ret) {
348028f4:	e3500000 	cmp	r0, #0
348028f8:	0a000002 	beq	34802908 <bootm_start.isra.13+0x2b8>
			puts("Ramdisk image is corrupt or invalid\n");
348028fc:	e59f00fc 	ldr	r0, [pc, #252]	; 34802a00 <bootm_start.isra.13+0x3b0>
34802900:	eb001b99 	bl	3480976c <puts>
34802904:	ea00002a 	b	348029b4 <bootm_start.isra.13+0x364>
	images.state = BOOTM_STATE_START;
34802908:	e3a03001 	mov	r3, #1
	images.os.start = (ulong)os_hdr;
3480290c:	e5846048 	str	r6, [r4, #72]	; 0x48
	images.state = BOOTM_STATE_START;
34802910:	e5843088 	str	r3, [r4, #136]	; 0x88
	return 0;
34802914:	e3a0a000 	mov	sl, #0
34802918:	ea000025 	b	348029b4 <bootm_start.isra.13+0x364>
	show_boot_progress(id);
3480291c:	e3a00005 	mov	r0, #5
34802920:	eb002c01 	bl	3480d92c <__show_boot_progress>
		switch (image_get_type(hdr)) {
34802924:	e5d5301e 	ldrb	r3, [r5, #30]
34802928:	e3530002 	cmp	r3, #2
3480292c:	1a000016 	bne	3480298c <bootm_start.isra.13+0x33c>
	return ((ulong)hdr + image_get_header_size());
34802930:	e2853040 	add	r3, r5, #64	; 0x40
	return image_get_size(hdr);
34802934:	e595000c 	ldr	r0, [r5, #12]
			*os_data = image_get_data(hdr);
34802938:	e5843050 	str	r3, [r4, #80]	; 0x50
3480293c:	ebfffe99 	bl	348023a8 <image_get_size.isra.9>
			*os_len = image_get_data_size(hdr);
34802940:	e5840054 	str	r0, [r4, #84]	; 0x54
34802944:	ea000006 	b	34802964 <bootm_start.isra.13+0x314>
		switch (image_get_type(hdr)) {
34802948:	e3530004 	cmp	r3, #4
3480294c:	1a000011 	bne	34802998 <bootm_start.isra.13+0x348>
			image_multi_getimg(hdr, 0, os_data, os_len);
34802950:	e59f30ac 	ldr	r3, [pc, #172]	; 34802a04 <bootm_start.isra.13+0x3b4>
34802954:	e3a01000 	mov	r1, #0
34802958:	e1a00005 	mov	r0, r5
3480295c:	e2432004 	sub	r2, r3, #4
34802960:	eb00298d 	bl	3480cf9c <image_multi_getimg>
		memmove(&images->legacy_hdr_os_copy, hdr,
34802964:	e3a02040 	mov	r2, #64	; 0x40
34802968:	e1a01005 	mov	r1, r5
3480296c:	e59f0094 	ldr	r0, [pc, #148]	; 34802a08 <bootm_start.isra.13+0x3b8>
34802970:	eb0064bc 	bl	3481bc68 <memmove>
		images->legacy_hdr_valid = 1;
34802974:	e3a03001 	mov	r3, #1
34802978:	e3a00006 	mov	r0, #6
		images->legacy_hdr_os = hdr;
3480297c:	e5845000 	str	r5, [r4]
		images->legacy_hdr_valid = 1;
34802980:	e5843044 	str	r3, [r4, #68]	; 0x44
34802984:	eb002be8 	bl	3480d92c <__show_boot_progress>
34802988:	eaffff9a 	b	348027f8 <bootm_start.isra.13+0x1a8>
		switch (image_get_type(hdr)) {
3480298c:	8affffed 	bhi	34802948 <bootm_start.isra.13+0x2f8>
34802990:	e3530001 	cmp	r3, #1
34802994:	ea000000 	b	3480299c <bootm_start.isra.13+0x34c>
34802998:	e353000e 	cmp	r3, #14
3480299c:	0affffe3 	beq	34802930 <bootm_start.isra.13+0x2e0>
			printf("Wrong Image Type for %s command\n",
348029a0:	e59a1000 	ldr	r1, [sl]
348029a4:	e59f0060 	ldr	r0, [pc, #96]	; 34802a0c <bootm_start.isra.13+0x3bc>
348029a8:	eb001b7b 	bl	3480979c <printf>
	show_boot_progress(-id);
348029ac:	e3e00004 	mvn	r0, #4
348029b0:	eaffff87 	b	348027d4 <bootm_start.isra.13+0x184>
}
348029b4:	e1a0000a 	mov	r0, sl
348029b8:	e28dd010 	add	sp, sp, #16
348029bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348029c0:	348285e0 	.word	0x348285e0
348029c4:	34821d0e 	.word	0x34821d0e
348029c8:	348271b4 	.word	0x348271b4
348029cc:	34821d15 	.word	0x34821d15
348029d0:	27051956 	.word	0x27051956
348029d4:	34821ca1 	.word	0x34821ca1
348029d8:	34821cb6 	.word	0x34821cb6
348029dc:	34821ccb 	.word	0x34821ccb
348029e0:	34821ce9 	.word	0x34821ce9
348029e4:	34821bd5 	.word	0x34821bd5
348029e8:	34821d47 	.word	0x34821d47
348029ec:	34821d87 	.word	0x34821d87
348029f0:	34821daa 	.word	0x34821daa
348029f4:	34821dca 	.word	0x34821dca
348029f8:	34821ded 	.word	0x34821ded
348029fc:	34828648 	.word	0x34828648
34802a00:	34821e11 	.word	0x34821e11
34802a04:	34828634 	.word	0x34828634
34802a08:	348285e4 	.word	0x348285e4
34802a0c:	34821d66 	.word	0x34821d66

34802a10 <__arch_preboot_os>:
{
34802a10:	e12fff1e 	bx	lr

34802a14 <do_bootm_subcommand>:
{
34802a14:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34802a18:	e1a04000 	mov	r4, r0
34802a1c:	e24dd030 	sub	sp, sp, #48	; 0x30
34802a20:	e1a07002 	mov	r7, r2
	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802a24:	e3a02007 	mov	r2, #7
{
34802a28:	e1a06003 	mov	r6, r3
	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802a2c:	e59f1204 	ldr	r1, [pc, #516]	; 34802c38 <do_bootm_subcommand+0x224>
34802a30:	e5930004 	ldr	r0, [r3, #4]
34802a34:	eb0019cf 	bl	34809178 <find_cmd_tbl>
	if (c) {
34802a38:	e3500000 	cmp	r0, #0
34802a3c:	0a000078 	beq	34802c24 <do_bootm_subcommand+0x210>
		state = (long)c->cmd;
34802a40:	e590500c 	ldr	r5, [r0, #12]
		if (state == BOOTM_STATE_START) {
34802a44:	e3550001 	cmp	r5, #1
34802a48:	1a000004 	bne	34802a60 <do_bootm_subcommand+0x4c>
			return bootm_start(cmdtp, flag, argc, argv);
34802a4c:	e2862004 	add	r2, r6, #4
34802a50:	e2471001 	sub	r1, r7, #1
34802a54:	e1a00004 	mov	r0, r4
34802a58:	ebfffefc 	bl	34802650 <bootm_start.isra.13>
34802a5c:	ea000073 	b	34802c30 <do_bootm_subcommand+0x21c>
	if (images.state >= state) {
34802a60:	e59f41d4 	ldr	r4, [pc, #468]	; 34802c3c <do_bootm_subcommand+0x228>
34802a64:	e5943088 	ldr	r3, [r4, #136]	; 0x88
34802a68:	e1530005 	cmp	r3, r5
34802a6c:	ba000002 	blt	34802a7c <do_bootm_subcommand+0x68>
		printf("Trying to execute a command out of order\n");
34802a70:	e59f01c8 	ldr	r0, [pc, #456]	; 34802c40 <do_bootm_subcommand+0x22c>
34802a74:	eb001b48 	bl	3480979c <printf>
34802a78:	ea000069 	b	34802c24 <do_bootm_subcommand+0x210>
	images.state |= state;
34802a7c:	e1853003 	orr	r3, r5, r3
	boot_fn = boot_os[images.os.os];
34802a80:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
	images.state |= state;
34802a84:	e5843088 	str	r3, [r4, #136]	; 0x88
	switch (state) {
34802a88:	e3550010 	cmp	r5, #16
	boot_fn = boot_os[images.os.os];
34802a8c:	e59f31b0 	ldr	r3, [pc, #432]	; 34802c44 <do_bootm_subcommand+0x230>
34802a90:	e7939102 	ldr	r9, [r3, r2, lsl #2]
	switch (state) {
34802a94:	0a00003c 	beq	34802b8c <do_bootm_subcommand+0x178>
34802a98:	ca000006 	bgt	34802ab8 <do_bootm_subcommand+0xa4>
34802a9c:	e3550002 	cmp	r5, #2
34802aa0:	0a00000b 	beq	34802ad4 <do_bootm_subcommand+0xc0>
34802aa4:	e3550004 	cmp	r5, #4
34802aa8:	0a00001e 	beq	34802b28 <do_bootm_subcommand+0x114>
34802aac:	e3550001 	cmp	r5, #1
34802ab0:	1a00005d 	bne	34802c2c <do_bootm_subcommand+0x218>
34802ab4:	ea000057 	b	34802c18 <do_bootm_subcommand+0x204>
34802ab8:	e3550040 	cmp	r5, #64	; 0x40
34802abc:	0a000044 	beq	34802bd4 <do_bootm_subcommand+0x1c0>
34802ac0:	e3550080 	cmp	r5, #128	; 0x80
34802ac4:	0a00004c 	beq	34802bfc <do_bootm_subcommand+0x1e8>
34802ac8:	e3550020 	cmp	r5, #32
34802acc:	1a000056 	bne	34802c2c <do_bootm_subcommand+0x218>
34802ad0:	ea000036 	b	34802bb0 <do_bootm_subcommand+0x19c>
			ret = bootm_load_os(images.os, &load_end, 0);
34802ad4:	e3a03000 	mov	r3, #0
34802ad8:	e2840048 	add	r0, r4, #72	; 0x48
34802adc:	e58d3010 	str	r3, [sp, #16]
34802ae0:	e28d301c 	add	r3, sp, #28
34802ae4:	e58d300c 	str	r3, [sp, #12]
34802ae8:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802aec:	e58d3008 	str	r3, [sp, #8]
34802af0:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802af4:	e58d3004 	str	r3, [sp, #4]
34802af8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802afc:	e58d3000 	str	r3, [sp]
34802b00:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802b04:	ebfffe28 	bl	348023ac <bootm_load_os.isra.14>
			if (ret)
34802b08:	e2505000 	subs	r5, r0, #0
34802b0c:	1a000042 	bne	34802c1c <do_bootm_subcommand+0x208>
					(load_end - images.os.load));
34802b10:	e5941058 	ldr	r1, [r4, #88]	; 0x58
			lmb_reserve(&images.lmb, images.os.load,
34802b14:	e284008c 	add	r0, r4, #140	; 0x8c
34802b18:	e59d201c 	ldr	r2, [sp, #28]
34802b1c:	e0612002 	rsb	r2, r1, r2
34802b20:	eb006234 	bl	3481b3f8 <lmb_reserve>
			break;
34802b24:	ea00003c 	b	34802c1c <do_bootm_subcommand+0x208>
			ulong rd_len = images.rd_end - images.rd_start;
34802b28:	e5941064 	ldr	r1, [r4, #100]	; 0x64
			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802b2c:	e2843074 	add	r3, r4, #116	; 0x74
			ulong rd_len = images.rd_end - images.rd_start;
34802b30:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802b34:	e284008c 	add	r0, r4, #140	; 0x8c
34802b38:	e58d3000 	str	r3, [sp]
34802b3c:	e2843070 	add	r3, r4, #112	; 0x70
34802b40:	e0612002 	rsb	r2, r1, r2
34802b44:	eb002abe 	bl	3480d644 <boot_ramdisk_high>
			if (ret)
34802b48:	e2505000 	subs	r5, r0, #0
34802b4c:	1a000032 	bne	34802c1c <do_bootm_subcommand+0x208>
			sprintf(str, "%lx", images.initrd_start);
34802b50:	e5942070 	ldr	r2, [r4, #112]	; 0x70
34802b54:	e28d001c 	add	r0, sp, #28
34802b58:	e59f10e8 	ldr	r1, [pc, #232]	; 34802c48 <do_bootm_subcommand+0x234>
34802b5c:	eb0067a9 	bl	3481ca08 <sprintf>
			setenv("initrd_start", str);
34802b60:	e28d101c 	add	r1, sp, #28
34802b64:	e59f00e0 	ldr	r0, [pc, #224]	; 34802c4c <do_bootm_subcommand+0x238>
34802b68:	eb001301 	bl	34807774 <setenv>
			sprintf(str, "%lx", images.initrd_end);
34802b6c:	e5942074 	ldr	r2, [r4, #116]	; 0x74
34802b70:	e28d001c 	add	r0, sp, #28
34802b74:	e59f10cc 	ldr	r1, [pc, #204]	; 34802c48 <do_bootm_subcommand+0x234>
34802b78:	eb0067a2 	bl	3481ca08 <sprintf>
			setenv("initrd_end", str);
34802b7c:	e28d101c 	add	r1, sp, #28
34802b80:	e59f00c8 	ldr	r0, [pc, #200]	; 34802c50 <do_bootm_subcommand+0x23c>
34802b84:	eb0012fa 	bl	34807774 <setenv>
			break;
34802b88:	ea000023 	b	34802c1c <do_bootm_subcommand+0x208>
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
34802b8c:	e1a00005 	mov	r0, r5
34802b90:	e1a03004 	mov	r3, r4
34802b94:	e1a02006 	mov	r2, r6
34802b98:	e1a01007 	mov	r1, r7
34802b9c:	e12fff39 	blx	r9
			if (ret)
34802ba0:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
34802ba4:	159f00a8 	ldrne	r0, [pc, #168]	; 34802c54 <do_bootm_subcommand+0x240>
			if (ret)
34802ba8:	0a00001b 	beq	34802c1c <do_bootm_subcommand+0x208>
34802bac:	ea000010 	b	34802bf4 <do_bootm_subcommand+0x1e0>
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
34802bb0:	e1a00005 	mov	r0, r5
34802bb4:	e1a03004 	mov	r3, r4
34802bb8:	e1a02006 	mov	r2, r6
34802bbc:	e1a01007 	mov	r1, r7
34802bc0:	e12fff39 	blx	r9
			if (ret)
34802bc4:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
34802bc8:	159f0088 	ldrne	r0, [pc, #136]	; 34802c58 <do_bootm_subcommand+0x244>
			if (ret)
34802bcc:	0a000012 	beq	34802c1c <do_bootm_subcommand+0x208>
34802bd0:	ea000007 	b	34802bf4 <do_bootm_subcommand+0x1e0>
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
34802bd4:	e1a00005 	mov	r0, r5
34802bd8:	e1a03004 	mov	r3, r4
34802bdc:	e1a02006 	mov	r2, r6
34802be0:	e1a01007 	mov	r1, r7
34802be4:	e12fff39 	blx	r9
			if (ret)
34802be8:	e2505000 	subs	r5, r0, #0
34802bec:	0a00000a 	beq	34802c1c <do_bootm_subcommand+0x208>
				printf("prep subcommand not supported\n");
34802bf0:	e59f0064 	ldr	r0, [pc, #100]	; 34802c5c <do_bootm_subcommand+0x248>
34802bf4:	eb001ae8 	bl	3480979c <printf>
34802bf8:	ea000007 	b	34802c1c <do_bootm_subcommand+0x208>
			disable_interrupts();
34802bfc:	ebfffc2e 	bl	34801cbc <disable_interrupts>
			arch_preboot_os();
34802c00:	ebffff82 	bl	34802a10 <__arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
34802c04:	e1a03004 	mov	r3, r4
34802c08:	e1a02006 	mov	r2, r6
34802c0c:	e1a01007 	mov	r1, r7
34802c10:	e1a00005 	mov	r0, r5
34802c14:	e12fff39 	blx	r9
	int ret = 0;
34802c18:	e3a05000 	mov	r5, #0
				return ret;
34802c1c:	e1a00005 	mov	r0, r5
34802c20:	ea000002 	b	34802c30 <do_bootm_subcommand+0x21c>
		return CMD_RET_USAGE;
34802c24:	e3e00000 	mvn	r0, #0
34802c28:	ea000000 	b	34802c30 <do_bootm_subcommand+0x21c>
	int ret = 0;
34802c2c:	e3a00000 	mov	r0, #0
}
34802c30:	e28dd030 	add	sp, sp, #48	; 0x30
34802c34:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34802c38:	3482703c 	.word	0x3482703c
34802c3c:	348285e0 	.word	0x348285e0
34802c40:	34821e36 	.word	0x34821e36
34802c44:	3481f620 	.word	0x3481f620
34802c48:	34821e60 	.word	0x34821e60
34802c4c:	34821e64 	.word	0x34821e64
34802c50:	34821e71 	.word	0x34821e71
34802c54:	34821e7c 	.word	0x34821e7c
34802c58:	34821e9e 	.word	0x34821e9e
34802c5c:	34821ebc 	.word	0x34821ebc

34802c60 <do_bootm>:
	if (argc > 1) {
34802c60:	e3520001 	cmp	r2, #1
{
34802c64:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34802c68:	e1a06003 	mov	r6, r3
34802c6c:	e24dd048 	sub	sp, sp, #72	; 0x48
	ulong		load_end = 0;
34802c70:	e3a03000 	mov	r3, #0
{
34802c74:	e1a07000 	mov	r7, r0
34802c78:	e1a09001 	mov	r9, r1
34802c7c:	e1a05002 	mov	r5, r2
	ulong		load_end = 0;
34802c80:	e58d3024 	str	r3, [sp, #36]	; 0x24
	if (argc > 1) {
34802c84:	da000015 	ble	34802ce0 <do_bootm+0x80>
		simple_strtoul(argv[1], &endp, 16);
34802c88:	e3a02010 	mov	r2, #16
34802c8c:	e28d1028 	add	r1, sp, #40	; 0x28
34802c90:	e5960004 	ldr	r0, [r6, #4]
34802c94:	eb0066b2 	bl	3481c764 <simple_strtoul>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
34802c98:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34802c9c:	e5d32000 	ldrb	r2, [r3]
34802ca0:	e352003a 	cmp	r2, #58	; 0x3a
34802ca4:	13520000 	cmpne	r2, #0
34802ca8:	13a03001 	movne	r3, #1
34802cac:	03a03000 	moveq	r3, #0
34802cb0:	e3520023 	cmp	r2, #35	; 0x23
34802cb4:	03a03000 	moveq	r3, #0
34802cb8:	12033001 	andne	r3, r3, #1
34802cbc:	e3530000 	cmp	r3, #0
34802cc0:	0a000006 	beq	34802ce0 <do_bootm+0x80>
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
34802cc4:	e1a00007 	mov	r0, r7
34802cc8:	e1a03006 	mov	r3, r6
34802ccc:	e1a02005 	mov	r2, r5
34802cd0:	e1a01009 	mov	r1, r9
34802cd4:	ebffff4e 	bl	34802a14 <do_bootm_subcommand>
34802cd8:	e1a07000 	mov	r7, r0
34802cdc:	ea00007d 	b	34802ed8 <do_bootm+0x278>
	if (bootm_start(cmdtp, flag, argc, argv))
34802ce0:	e1a00007 	mov	r0, r7
34802ce4:	e1a02006 	mov	r2, r6
34802ce8:	e1a01005 	mov	r1, r5
34802cec:	e3a0b001 	mov	fp, #1
34802cf0:	ebfffe56 	bl	34802650 <bootm_start.isra.13>
34802cf4:	e3500000 	cmp	r0, #0
		return 1;
34802cf8:	11a0700b 	movne	r7, fp
	if (bootm_start(cmdtp, flag, argc, argv))
34802cfc:	1a000075 	bne	34802ed8 <do_bootm+0x278>
34802d00:	e59f41dc 	ldr	r4, [pc, #476]	; 34802ee4 <do_bootm+0x284>
	iflag = disable_interrupts();
34802d04:	ebfffbec 	bl	34801cbc <disable_interrupts>
	ret = bootm_load_os(images.os, &load_end, 1);
34802d08:	e28d3024 	add	r3, sp, #36	; 0x24
	iflag = disable_interrupts();
34802d0c:	e1a0a000 	mov	sl, r0
	ret = bootm_load_os(images.os, &load_end, 1);
34802d10:	e58d300c 	str	r3, [sp, #12]
34802d14:	e2840048 	add	r0, r4, #72	; 0x48
34802d18:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802d1c:	e58db010 	str	fp, [sp, #16]
34802d20:	e58d3008 	str	r3, [sp, #8]
34802d24:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802d28:	e58d3004 	str	r3, [sp, #4]
34802d2c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802d30:	e58d3000 	str	r3, [sp]
34802d34:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802d38:	ebfffd9b 	bl	348023ac <bootm_load_os.isra.14>
	if (ret < 0) {
34802d3c:	e3500000 	cmp	r0, #0
34802d40:	aa00001d 	bge	34802dbc <do_bootm+0x15c>
		if (ret == BOOTM_ERR_RESET)
34802d44:	e3700001 	cmn	r0, #1
34802d48:	0a00000e 	beq	34802d88 <do_bootm+0x128>
		if (ret == BOOTM_ERR_OVERLAP) {
34802d4c:	e3700002 	cmn	r0, #2
34802d50:	1a000012 	bne	34802da0 <do_bootm+0x140>
			if (images.legacy_hdr_valid) {
34802d54:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34802d58:	e3530000 	cmp	r3, #0
34802d5c:	0a000005 	beq	34802d78 <do_bootm+0x118>
				if (image_get_type(hdr) == IH_TYPE_MULTI)
34802d60:	e5d43022 	ldrb	r3, [r4, #34]	; 0x22
34802d64:	e3530004 	cmp	r3, #4
34802d68:	1a000013 	bne	34802dbc <do_bootm+0x15c>
					puts("WARNING: legacy format multi "
34802d6c:	e59f0174 	ldr	r0, [pc, #372]	; 34802ee8 <do_bootm+0x288>
34802d70:	eb001a7d 	bl	3480976c <puts>
34802d74:	ea000010 	b	34802dbc <do_bootm+0x15c>
				puts("ERROR: new format image overwritten - "
34802d78:	e59f016c 	ldr	r0, [pc, #364]	; 34802eec <do_bootm+0x28c>
34802d7c:	eb001a7a 	bl	3480976c <puts>
34802d80:	e3e00070 	mvn	r0, #112	; 0x70
34802d84:	eb002ae8 	bl	3480d92c <__show_boot_progress>
				do_reset(cmdtp, flag, argc, argv);
34802d88:	e1a03006 	mov	r3, r6
34802d8c:	e1a02005 	mov	r2, r5
34802d90:	e1a01009 	mov	r1, r9
34802d94:	e1a00007 	mov	r0, r7
34802d98:	ebfffc54 	bl	34801ef0 <do_reset>
34802d9c:	ea000006 	b	34802dbc <do_bootm+0x15c>
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
34802da0:	e3700003 	cmn	r0, #3
34802da4:	1a000004 	bne	34802dbc <do_bootm+0x15c>
			if (iflag)
34802da8:	e35a0000 	cmp	sl, #0
34802dac:	0a000000 	beq	34802db4 <do_bootm+0x154>
				enable_interrupts();
34802db0:	ebfffbc0 	bl	34801cb8 <enable_interrupts>
34802db4:	e3e00006 	mvn	r0, #6
34802db8:	ea000035 	b	34802e94 <do_bootm+0x234>
	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
34802dbc:	e5941058 	ldr	r1, [r4, #88]	; 0x58
34802dc0:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34802dc4:	e59fb118 	ldr	fp, [pc, #280]	; 34802ee4 <do_bootm+0x284>
34802dc8:	e0612002 	rsb	r2, r1, r2
34802dcc:	e28b008c 	add	r0, fp, #140	; 0x8c
34802dd0:	eb006188 	bl	3481b3f8 <lmb_reserve>
	if (images.os.type == IH_TYPE_STANDALONE) {
34802dd4:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802dd8:	e3530001 	cmp	r3, #1
34802ddc:	1a00001a 	bne	34802e4c <do_bootm+0x1ec>
		if (iflag)
34802de0:	e35a0000 	cmp	sl, #0
34802de4:	0a000000 	beq	34802dec <do_bootm+0x18c>
			enable_interrupts();
34802de8:	ebfffbb2 	bl	34801cb8 <enable_interrupts>
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
34802dec:	e59f00fc 	ldr	r0, [pc, #252]	; 34802ef0 <do_bootm+0x290>
34802df0:	eb001363 	bl	34807b84 <getenv>
34802df4:	e3500000 	cmp	r0, #0
34802df8:	0a00000b 	beq	34802e2c <do_bootm+0x1cc>
34802dfc:	e59f10f0 	ldr	r1, [pc, #240]	; 34802ef4 <do_bootm+0x294>
34802e00:	eb006286 	bl	3481b820 <strcmp>
34802e04:	e2507000 	subs	r7, r0, #0
34802e08:	1a000007 	bne	34802e2c <do_bootm+0x1cc>
		sprintf(buf, "%lX", images.os.image_len);
34802e0c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
34802e10:	e28d0028 	add	r0, sp, #40	; 0x28
34802e14:	e59f10dc 	ldr	r1, [pc, #220]	; 34802ef8 <do_bootm+0x298>
34802e18:	eb0066fa 	bl	3481ca08 <sprintf>
		setenv("filesize", buf);
34802e1c:	e28d1028 	add	r1, sp, #40	; 0x28
34802e20:	e59f00d4 	ldr	r0, [pc, #212]	; 34802efc <do_bootm+0x29c>
34802e24:	eb001252 	bl	34807774 <setenv>
34802e28:	ea00002a 	b	34802ed8 <do_bootm+0x278>
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34802e2c:	e5940060 	ldr	r0, [r4, #96]	; 0x60
		return 0;
34802e30:	e3a07000 	mov	r7, #0
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34802e34:	ebfffcf4 	bl	3480220c <__fswab32>
	(*appl)(argc-1, &argv[1]);
34802e38:	e2861004 	add	r1, r6, #4
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34802e3c:	e1a03000 	mov	r3, r0
	(*appl)(argc-1, &argv[1]);
34802e40:	e2450001 	sub	r0, r5, #1
34802e44:	e12fff33 	blx	r3
34802e48:	ea000022 	b	34802ed8 <do_bootm+0x278>
	show_boot_progress(id);
34802e4c:	e3a00008 	mov	r0, #8
34802e50:	eb002ab5 	bl	3480d92c <__show_boot_progress>
	boot_fn = boot_os[images.os.os];
34802e54:	e5db205e 	ldrb	r2, [fp, #94]	; 0x5e
34802e58:	e59f30a0 	ldr	r3, [pc, #160]	; 34802f00 <do_bootm+0x2a0>
34802e5c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
	if (boot_fn == NULL) {
34802e60:	e3530000 	cmp	r3, #0
	boot_fn = boot_os[images.os.os];
34802e64:	e58d301c 	str	r3, [sp, #28]
	if (boot_fn == NULL) {
34802e68:	1a00000b 	bne	34802e9c <do_bootm+0x23c>
		if (iflag)
34802e6c:	e35a0000 	cmp	sl, #0
34802e70:	0a000000 	beq	34802e78 <do_bootm+0x218>
			enable_interrupts();
34802e74:	ebfffb8f 	bl	34801cb8 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
34802e78:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
34802e7c:	eb0028bb 	bl	3480d170 <genimg_get_os_name>
34802e80:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802e84:	e1a01000 	mov	r1, r0
34802e88:	e59f0074 	ldr	r0, [pc, #116]	; 34802f04 <do_bootm+0x2a4>
34802e8c:	eb001a42 	bl	3480979c <printf>
	show_boot_progress(-id);
34802e90:	e3e00007 	mvn	r0, #7
34802e94:	eb002aa4 	bl	3480d92c <__show_boot_progress>
34802e98:	ea00000d 	b	34802ed4 <do_bootm+0x274>
	arch_preboot_os();
34802e9c:	ebfffedb 	bl	34802a10 <__arch_preboot_os>
	boot_fn(0, argc, argv, &images);
34802ea0:	e1a0300b 	mov	r3, fp
34802ea4:	e1a02006 	mov	r2, r6
34802ea8:	e1a01005 	mov	r1, r5
34802eac:	e59dc01c 	ldr	ip, [sp, #28]
34802eb0:	e3a00000 	mov	r0, #0
34802eb4:	e12fff3c 	blx	ip
34802eb8:	e3e00008 	mvn	r0, #8
34802ebc:	eb002a9a 	bl	3480d92c <__show_boot_progress>
	do_reset(cmdtp, flag, argc, argv);
34802ec0:	e1a03006 	mov	r3, r6
34802ec4:	e1a02005 	mov	r2, r5
34802ec8:	e1a01009 	mov	r1, r9
34802ecc:	e1a00007 	mov	r0, r7
34802ed0:	ebfffc06 	bl	34801ef0 <do_reset>
	return 1;
34802ed4:	e3a07001 	mov	r7, #1
}
34802ed8:	e1a00007 	mov	r0, r7
34802edc:	e28dd048 	add	sp, sp, #72	; 0x48
34802ee0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34802ee4:	348285e0 	.word	0x348285e0
34802ee8:	34821edb 	.word	0x34821edb
34802eec:	34821f15 	.word	0x34821f15
34802ef0:	34821f5c 	.word	0x34821f5c
34802ef4:	34821f66 	.word	0x34821f66
34802ef8:	34821f69 	.word	0x34821f69
34802efc:	34821f6d 	.word	0x34821f6d
34802f00:	3481f620 	.word	0x3481f620
34802f04:	34821f76 	.word	0x34821f76

34802f08 <bootm_maybe_autostart>:
{
34802f08:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
34802f0c:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
34802f10:	e59f0058 	ldr	r0, [pc, #88]	; 34802f70 <bootm_maybe_autostart+0x68>
{
34802f14:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
34802f18:	eb001319 	bl	34807b84 <getenv>
	if (ep && !strcmp(ep, "yes")) {
34802f1c:	e3500000 	cmp	r0, #0
34802f20:	1a000001 	bne	34802f2c <bootm_maybe_autostart+0x24>
	return 0;
34802f24:	e3a00000 	mov	r0, #0
34802f28:	ea00000e 	b	34802f68 <bootm_maybe_autostart+0x60>
	if (ep && !strcmp(ep, "yes")) {
34802f2c:	e59f1040 	ldr	r1, [pc, #64]	; 34802f74 <bootm_maybe_autostart+0x6c>
34802f30:	eb00623a 	bl	3481b820 <strcmp>
34802f34:	e2504000 	subs	r4, r0, #0
34802f38:	1afffff9 	bne	34802f24 <bootm_maybe_autostart+0x1c>
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34802f3c:	e59f3034 	ldr	r3, [pc, #52]	; 34802f78 <bootm_maybe_autostart+0x70>
34802f40:	e59f0034 	ldr	r0, [pc, #52]	; 34802f7c <bootm_maybe_autostart+0x74>
		local_args[0] = (char *)cmd;
34802f44:	e58d6000 	str	r6, [sp]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34802f48:	e5931000 	ldr	r1, [r3]
		local_args[1] = NULL;
34802f4c:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34802f50:	eb001a11 	bl	3480979c <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
34802f54:	e1a0300d 	mov	r3, sp
34802f58:	e3a02001 	mov	r2, #1
34802f5c:	e1a01004 	mov	r1, r4
34802f60:	e1a00005 	mov	r0, r5
34802f64:	ebffff3d 	bl	34802c60 <do_bootm>
}
34802f68:	e28dd008 	add	sp, sp, #8
34802f6c:	e8bd8070 	pop	{r4, r5, r6, pc}
34802f70:	34821f5c 	.word	0x34821f5c
34802f74:	34821fa4 	.word	0x34821fa4
34802f78:	348271b4 	.word	0x348271b4
34802f7c:	34821fa8 	.word	0x34821fa8

34802f80 <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
34802f80:	e92d4010 	push	{r4, lr}
34802f84:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
34802f88:	e59f1048 	ldr	r1, [pc, #72]	; 34802fd8 <parse_argv+0x58>
34802f8c:	eb006223 	bl	3481b820 <strcmp>
34802f90:	e3500000 	cmp	r0, #0
34802f94:	0a00000b 	beq	34802fc8 <parse_argv+0x48>
		return 2;
	else if (strcmp(s, "on") == 0)
34802f98:	e59f103c 	ldr	r1, [pc, #60]	; 34802fdc <parse_argv+0x5c>
34802f9c:	e1a00004 	mov	r0, r4
34802fa0:	eb00621e 	bl	3481b820 <strcmp>
34802fa4:	e3500000 	cmp	r0, #0
34802fa8:	0a000008 	beq	34802fd0 <parse_argv+0x50>
		return 1;
	else if (strcmp(s, "off") == 0)
34802fac:	e59f102c 	ldr	r1, [pc, #44]	; 34802fe0 <parse_argv+0x60>
34802fb0:	e1a00004 	mov	r0, r4
34802fb4:	eb006219 	bl	3481b820 <strcmp>
34802fb8:	e2900000 	adds	r0, r0, #0
34802fbc:	13a00001 	movne	r0, #1
34802fc0:	e2600000 	rsb	r0, r0, #0
34802fc4:	e8bd8010 	pop	{r4, pc}
		return 2;
34802fc8:	e3a00002 	mov	r0, #2
34802fcc:	e8bd8010 	pop	{r4, pc}
		return 1;
34802fd0:	e3a00001 	mov	r0, #1
		return 0;

	return -1;
}
34802fd4:	e8bd8010 	pop	{r4, pc}
34802fd8:	3482235a 	.word	0x3482235a
34802fdc:	34826fb9 	.word	0x34826fb9
34802fe0:	348219f9 	.word	0x348219f9
	puts("No arch specific invalidate_icache_all available!\n");
34802fe4:	e59f0000 	ldr	r0, [pc]	; 34802fec <parse_argv+0x6c>
34802fe8:	ea0019df 	b	3480976c <puts>
34802fec:	34822360 	.word	0x34822360

34802ff0 <do_icache>:
	switch (argc) {
34802ff0:	e3520001 	cmp	r2, #1
{
34802ff4:	e92d4010 	push	{r4, lr}
	switch (argc) {
34802ff8:	0a000011 	beq	34803044 <do_icache+0x54>
34802ffc:	e3520002 	cmp	r2, #2
		return CMD_RET_USAGE;
34803000:	13e04000 	mvnne	r4, #0
	switch (argc) {
34803004:	1a000016 	bne	34803064 <do_icache+0x74>
		switch (parse_argv(argv[1])) {
34803008:	e5930004 	ldr	r0, [r3, #4]
3480300c:	ebffffdb 	bl	34802f80 <parse_argv>
34803010:	e3500001 	cmp	r0, #1
34803014:	e1a04000 	mov	r4, r0
34803018:	0a000005 	beq	34803034 <do_icache+0x44>
3480301c:	e3500002 	cmp	r0, #2
34803020:	0a000005 	beq	3480303c <do_icache+0x4c>
34803024:	e3500000 	cmp	r0, #0
34803028:	1a00000c 	bne	34803060 <do_icache+0x70>
			icache_disable();
3480302c:	ebfffbd4 	bl	34801f84 <icache_disable>
34803030:	ea00000b 	b	34803064 <do_icache+0x74>
			icache_enable();
34803034:	ebfffbcc 	bl	34801f6c <icache_enable>
34803038:	ea000008 	b	34803060 <do_icache+0x70>
			invalidate_icache_all();
3480303c:	ebfff737 	bl	34800d20 <invalidate_icache_all>
34803040:	ea000006 	b	34803060 <do_icache+0x70>
			icache_status() ? "ON" : "OFF");
34803044:	ebfffbd4 	bl	34801f9c <icache_status>
		printf("Instruction Cache is %s\n",
34803048:	e59f301c 	ldr	r3, [pc, #28]	; 3480306c <do_icache+0x7c>
3480304c:	e3500000 	cmp	r0, #0
34803050:	e59f1018 	ldr	r1, [pc, #24]	; 34803070 <do_icache+0x80>
34803054:	e59f0018 	ldr	r0, [pc, #24]	; 34803074 <do_icache+0x84>
34803058:	01a01003 	moveq	r1, r3
3480305c:	eb0019ce 	bl	3480979c <printf>
		switch (parse_argv(argv[1])) {
34803060:	e3a04000 	mov	r4, #0
}
34803064:	e1a00004 	mov	r0, r4
34803068:	e8bd8010 	pop	{r4, pc}
3480306c:	34822393 	.word	0x34822393
34803070:	34824fd8 	.word	0x34824fd8
34803074:	34822397 	.word	0x34822397
	puts("No arch specific flush_dcache_all available!\n");
34803078:	e59f0000 	ldr	r0, [pc]	; 34803080 <do_icache+0x90>
3480307c:	ea0019ba 	b	3480976c <puts>
34803080:	348223b0 	.word	0x348223b0

34803084 <do_dcache>:
	switch (argc) {
34803084:	e3520001 	cmp	r2, #1
{
34803088:	e92d4010 	push	{r4, lr}
	switch (argc) {
3480308c:	0a000011 	beq	348030d8 <do_dcache+0x54>
34803090:	e3520002 	cmp	r2, #2
		return CMD_RET_USAGE;
34803094:	13e04000 	mvnne	r4, #0
	switch (argc) {
34803098:	1a000016 	bne	348030f8 <do_dcache+0x74>
		switch (parse_argv(argv[1])) {
3480309c:	e5930004 	ldr	r0, [r3, #4]
348030a0:	ebffffb6 	bl	34802f80 <parse_argv>
348030a4:	e3500001 	cmp	r0, #1
348030a8:	e1a04000 	mov	r4, r0
348030ac:	0a000005 	beq	348030c8 <do_dcache+0x44>
348030b0:	e3500002 	cmp	r0, #2
348030b4:	0a000005 	beq	348030d0 <do_dcache+0x4c>
348030b8:	e3500000 	cmp	r0, #0
348030bc:	1a00000c 	bne	348030f4 <do_dcache+0x70>
			dcache_disable();
348030c0:	ebfffbe7 	bl	34802064 <dcache_disable>
348030c4:	ea00000b 	b	348030f8 <do_dcache+0x74>
			dcache_enable();
348030c8:	ebfffbb6 	bl	34801fa8 <dcache_enable>
348030cc:	ea000008 	b	348030f4 <do_dcache+0x70>
			flush_dcache_all();
348030d0:	ebfff71b 	bl	34800d44 <flush_dcache_all>
348030d4:	ea000006 	b	348030f4 <do_dcache+0x70>
			dcache_status() ? "ON" : "OFF");
348030d8:	ebfffbea 	bl	34802088 <dcache_status>
		printf("Data (writethrough) Cache is %s\n",
348030dc:	e59f301c 	ldr	r3, [pc, #28]	; 34803100 <do_dcache+0x7c>
348030e0:	e3500000 	cmp	r0, #0
348030e4:	e59f1018 	ldr	r1, [pc, #24]	; 34803104 <do_dcache+0x80>
348030e8:	e59f0018 	ldr	r0, [pc, #24]	; 34803108 <do_dcache+0x84>
348030ec:	01a01003 	moveq	r1, r3
348030f0:	eb0019a9 	bl	3480979c <printf>
		switch (parse_argv(argv[1])) {
348030f4:	e3a04000 	mov	r4, #0
}
348030f8:	e1a00004 	mov	r0, r4
348030fc:	e8bd8010 	pop	{r4, pc}
34803100:	34822393 	.word	0x34822393
34803104:	34824fd8 	.word	0x34824fd8
34803108:	348223de 	.word	0x348223de

3480310c <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char * const argv[])
{
3480310c:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
34803110:	eb002e53 	bl	3480ea64 <stdio_get_list>
34803114:	e1a06000 	mov	r6, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
34803118:	e59f0098 	ldr	r0, [pc, #152]	; 348031b8 <do_coninfo+0xac>
3480311c:	eb001992 	bl	3480976c <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
34803120:	e59f7094 	ldr	r7, [pc, #148]	; 348031bc <do_coninfo+0xb0>
	list_for_each(pos, list) {
34803124:	e5964000 	ldr	r4, [r6]
34803128:	e1540006 	cmp	r4, r6
3480312c:	0a00001e 	beq	348031ac <do_coninfo+0xa0>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
34803130:	e5142034 	ldr	r2, [r4, #-52]	; 0xffffffcc
		dev = list_entry(pos, struct stdio_dev, list);
34803134:	e2449034 	sub	r9, r4, #52	; 0x34
				printf ("%s ", stdio_names[l]);
34803138:	e59fa080 	ldr	sl, [pc, #128]	; 348031c0 <do_coninfo+0xb4>
		for (l = 0; l < MAX_FILES; l++) {
3480313c:	e3a05000 	mov	r5, #0
		printf ("%-8s %08x %c%c%c ",
34803140:	e3520000 	cmp	r2, #0
34803144:	b3a03053 	movlt	r3, #83	; 0x53
34803148:	a3a0302e 	movge	r3, #46	; 0x2e
3480314c:	e3120001 	tst	r2, #1
34803150:	13a01049 	movne	r1, #73	; 0x49
34803154:	03a0102e 	moveq	r1, #46	; 0x2e
34803158:	e3120002 	tst	r2, #2
3480315c:	e58d1000 	str	r1, [sp]
34803160:	13a0004f 	movne	r0, #79	; 0x4f
34803164:	03a0002e 	moveq	r0, #46	; 0x2e
34803168:	e58d0004 	str	r0, [sp, #4]
3480316c:	e244102c 	sub	r1, r4, #44	; 0x2c
34803170:	e59f004c 	ldr	r0, [pc, #76]	; 348031c4 <do_coninfo+0xb8>
34803174:	eb001988 	bl	3480979c <printf>
			if (stdio_devices[l] == dev) {
34803178:	e7973105 	ldr	r3, [r7, r5, lsl #2]
3480317c:	e1530009 	cmp	r3, r9
34803180:	1a000002 	bne	34803190 <do_coninfo+0x84>
				printf ("%s ", stdio_names[l]);
34803184:	e79a1105 	ldr	r1, [sl, r5, lsl #2]
34803188:	e59f0038 	ldr	r0, [pc, #56]	; 348031c8 <do_coninfo+0xbc>
3480318c:	eb001982 	bl	3480979c <printf>
		for (l = 0; l < MAX_FILES; l++) {
34803190:	e2855001 	add	r5, r5, #1
34803194:	e3550003 	cmp	r5, #3
34803198:	1afffff6 	bne	34803178 <do_coninfo+0x6c>
			}
		}
		putc ('\n');
3480319c:	e3a0000a 	mov	r0, #10
348031a0:	eb001965 	bl	3480973c <putc>
	list_for_each(pos, list) {
348031a4:	e5944000 	ldr	r4, [r4]
348031a8:	eaffffde 	b	34803128 <do_coninfo+0x1c>
	}
	return 0;
}
348031ac:	e3a00000 	mov	r0, #0
348031b0:	e28dd00c 	add	sp, sp, #12
348031b4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
348031b8:	348224dc 	.word	0x348224dc
348031bc:	3482a29c 	.word	0x3482a29c
348031c0:	3482773c 	.word	0x3482773c
348031c4:	348224f8 	.word	0x348224f8
348031c8:	34824caf 	.word	0x34824caf

348031cc <do_echo>:

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348031cc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
348031d0:	e3a07001 	mov	r7, #1
{
348031d4:	e1a09002 	mov	r9, r2
348031d8:	e1a0a003 	mov	sl, r3

	for (i = 1; i < argc; i++) {
348031dc:	e1a05007 	mov	r5, r7
348031e0:	e1550009 	cmp	r5, r9
348031e4:	aa00001d 	bge	34803260 <do_echo+0x94>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
348031e8:	e3550001 	cmp	r5, #1
		char *p = argv[i];
348031ec:	e79a4105 	ldr	r4, [sl, r5, lsl #2]
		if (i > 1)
348031f0:	da000001 	ble	348031fc <do_echo+0x30>
			putc(' ');
348031f4:	e3a00020 	mov	r0, #32
348031f8:	eb00194f 	bl	3480973c <putc>

		nls = strstr(p, "\\c");
348031fc:	e59f1074 	ldr	r1, [pc, #116]	; 34803278 <do_echo+0xac>
34803200:	e1a00004 	mov	r0, r4
34803204:	eb0062c0 	bl	3481bd0c <strstr>
		if (nls) {
34803208:	e2506000 	subs	r6, r0, #0
3480320c:	0a00000f 	beq	34803250 <do_echo+0x84>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803210:	e3a07000 	mov	r7, #0
				puts(prenls);
34803214:	e1a00004 	mov	r0, r4
				*nls = '\0';
34803218:	e5c67000 	strb	r7, [r6]
				puts(prenls);
3480321c:	eb001952 	bl	3480976c <puts>
				*nls = '\\';
34803220:	e1a04006 	mov	r4, r6
34803224:	e3a0305c 	mov	r3, #92	; 0x5c
34803228:	e4c43002 	strb	r3, [r4], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
3480322c:	e1a00004 	mov	r0, r4
34803230:	e59f1040 	ldr	r1, [pc, #64]	; 34803278 <do_echo+0xac>
34803234:	eb0062b4 	bl	3481bd0c <strstr>
			while (nls) {
34803238:	e2506000 	subs	r6, r0, #0
3480323c:	1afffff4 	bne	34803214 <do_echo+0x48>
			}
			puts(prenls);
34803240:	e1a00004 	mov	r0, r4
			putnl = 0;
34803244:	e1a07006 	mov	r7, r6
			puts(prenls);
34803248:	eb001947 	bl	3480976c <puts>
3480324c:	ea000001 	b	34803258 <do_echo+0x8c>
		} else {
			puts(p);
34803250:	e1a00004 	mov	r0, r4
34803254:	eb001944 	bl	3480976c <puts>
	for (i = 1; i < argc; i++) {
34803258:	e2855001 	add	r5, r5, #1
3480325c:	eaffffdf 	b	348031e0 <do_echo+0x14>
		}
	}

	if (putnl)
34803260:	e3570000 	cmp	r7, #0
34803264:	0a000001 	beq	34803270 <do_echo+0xa4>
		putc('\n');
34803268:	e3a0000a 	mov	r0, #10
3480326c:	eb001932 	bl	3480973c <putc>

	return 0;
}
34803270:	e3a00000 	mov	r0, #0
34803274:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803278:	34822538 	.word	0x34822538

3480327c <do_exit>:
int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
3480327c:	e3520001 	cmp	r2, #1
34803280:	da000008 	ble	348032a8 <do_exit+0x2c>
{
34803284:	e92d4010 	push	{r4, lr}
		r = simple_strtoul(argv[1], NULL, 10);
34803288:	e3a0200a 	mov	r2, #10
3480328c:	e3a01000 	mov	r1, #0
34803290:	e5930004 	ldr	r0, [r3, #4]
34803294:	eb006532 	bl	3481c764 <simple_strtoul>
34803298:	e1a03000 	mov	r3, r0

	return -r - 2;
}
3480329c:	e3e00001 	mvn	r0, #1
348032a0:	e0630000 	rsb	r0, r3, r0
348032a4:	e8bd8010 	pop	{r4, pc}
	r = 0;
348032a8:	e3a03000 	mov	r3, #0
}
348032ac:	e3e00001 	mvn	r0, #1
348032b0:	e0630000 	rsb	r0, r3, r0
348032b4:	e12fff1e 	bx	lr

348032b8 <do_help>:

#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348032b8:	e92d4007 	push	{r0, r1, r2, lr}
	return _do_help(&__u_boot_cmd_start,
			&__u_boot_cmd_end - &__u_boot_cmd_start,
348032bc:	e59fc02c 	ldr	ip, [pc, #44]	; 348032f0 <do_help+0x38>
348032c0:	e59fe02c 	ldr	lr, [pc, #44]	; 348032f4 <do_help+0x3c>
	return _do_help(&__u_boot_cmd_start,
348032c4:	e88d000c 	stm	sp, {r2, r3}
348032c8:	e1a03001 	mov	r3, r1
348032cc:	e59f1024 	ldr	r1, [pc, #36]	; 348032f8 <do_help+0x40>
348032d0:	e1a02000 	mov	r2, r0
			&__u_boot_cmd_end - &__u_boot_cmd_start,
348032d4:	e06ec00c 	rsb	ip, lr, ip
	return _do_help(&__u_boot_cmd_start,
348032d8:	e1a0000e 	mov	r0, lr
348032dc:	e1a0c1cc 	asr	ip, ip, #3
348032e0:	e0010c91 	mul	r1, r1, ip
348032e4:	eb0017ed 	bl	348092a0 <_do_help>
			cmdtp, flag, argc, argv);
}
348032e8:	e28dd00c 	add	sp, sp, #12
348032ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
348032f0:	348285d0 	.word	0x348285d0
348032f4:	34828180 	.word	0x34828180
348032f8:	aaaaaaab 	.word	0xaaaaaaab

348032fc <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
348032fc:	e92d4010 	push	{r4, lr}
34803300:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34803304:	e5d02000 	ldrb	r2, [r0]
		p = (long *)simple_strtoul(&s[1], NULL, 16);
34803308:	e3a01000 	mov	r1, #0
	if (s[0] == '*') {
3480330c:	e352002a 	cmp	r2, #42	; 0x2a
		p = (long *)simple_strtoul(&s[1], NULL, 16);
34803310:	e3a02010 	mov	r2, #16
	if (s[0] == '*') {
34803314:	1a00000e 	bne	34803354 <evalexp+0x58>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
34803318:	e2800001 	add	r0, r0, #1
3480331c:	eb006510 	bl	3481c764 <simple_strtoul>
		switch (w) {
34803320:	e3540002 	cmp	r4, #2
34803324:	0a000006 	beq	34803344 <evalexp+0x48>
34803328:	e3540004 	cmp	r4, #4
3480332c:	0a000006 	beq	3480334c <evalexp+0x50>
34803330:	e3540001 	cmp	r4, #1
	long l = 0;
34803334:	13a00000 	movne	r0, #0
		switch (w) {
34803338:	1a000006 	bne	34803358 <evalexp+0x5c>
		case 1: return((long)(*(unsigned char *)p));
3480333c:	e5d00000 	ldrb	r0, [r0]
34803340:	e8bd8010 	pop	{r4, pc}
		case 2: return((long)(*(unsigned short *)p));
34803344:	e1d000b0 	ldrh	r0, [r0]
34803348:	e8bd8010 	pop	{r4, pc}
		case 4: return(*p);
3480334c:	e5900000 	ldr	r0, [r0]
34803350:	e8bd8010 	pop	{r4, pc}
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
34803354:	eb006502 	bl	3481c764 <simple_strtoul>
	}

	return (l & ((1 << (w * 8)) - 1));
34803358:	e1a04184 	lsl	r4, r4, #3
3480335c:	e3e03000 	mvn	r3, #0
34803360:	e1c00413 	bic	r0, r0, r3, lsl r4
}
34803364:	e8bd8010 	pop	{r4, pc}

34803368 <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
34803368:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
3480336c:	e3a07000 	mov	r7, #0
34803370:	e59fa1cc 	ldr	sl, [pc, #460]	; 34803544 <binary_test+0x1dc>
{
34803374:	e1a0b000 	mov	fp, r0
34803378:	e1a05001 	mov	r5, r1
3480337c:	e1a06002 	mov	r6, r2
34803380:	e1a09003 	mov	r9, r3
	len = strlen(op);
34803384:	eb006153 	bl	3481b8d8 <strlen>
34803388:	e58d0000 	str	r0, [sp]
	for (optp = (op_tbl_t *)&op_table, i = 0;
3480338c:	e3570068 	cmp	r7, #104	; 0x68
34803390:	e08a3007 	add	r3, sl, r7
34803394:	e58d3004 	str	r3, [sp, #4]
34803398:	0a000062 	beq	34803528 <binary_test+0x1c0>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
3480339c:	e59d2000 	ldr	r2, [sp]
348033a0:	e1a0000b 	mov	r0, fp
348033a4:	e797100a 	ldr	r1, [r7, sl]
348033a8:	eb006126 	bl	3481b848 <strncmp>
348033ac:	e2504000 	subs	r4, r0, #0
348033b0:	1a00005a 	bne	34803520 <binary_test+0x1b8>
348033b4:	e797000a 	ldr	r0, [r7, sl]
348033b8:	eb006146 	bl	3481b8d8 <strlen>
348033bc:	e59d3000 	ldr	r3, [sp]
348033c0:	e1530000 	cmp	r3, r0
348033c4:	1a000055 	bne	34803520 <binary_test+0x1b8>
348033c8:	e59d3004 	ldr	r3, [sp, #4]
			if (w == 0) {
348033cc:	e3590000 	cmp	r9, #0
348033d0:	e5937004 	ldr	r7, [r3, #4]
348033d4:	1a00002a 	bne	34803484 <binary_test+0x11c>
	if (s[0] == '*') {
348033d8:	e5d53000 	ldrb	r3, [r5]
348033dc:	e353002a 	cmp	r3, #42	; 0x2a
348033e0:	1a000004 	bne	348033f8 <binary_test+0x90>
		return (char *)simple_strtoul(&s[1], NULL, 16);
348033e4:	e2850001 	add	r0, r5, #1
348033e8:	e3a02010 	mov	r2, #16
348033ec:	e1a01004 	mov	r1, r4
348033f0:	eb0064db 	bl	3481c764 <simple_strtoul>
348033f4:	e1a05000 	mov	r5, r0
	if (s[0] == '*') {
348033f8:	e5d63000 	ldrb	r3, [r6]
348033fc:	e353002a 	cmp	r3, #42	; 0x2a
34803400:	11a01006 	movne	r1, r6
34803404:	1a000004 	bne	3480341c <binary_test+0xb4>
		return (char *)simple_strtoul(&s[1], NULL, 16);
34803408:	e3a01000 	mov	r1, #0
3480340c:	e3a02010 	mov	r2, #16
34803410:	e2860001 	add	r0, r6, #1
34803414:	eb0064d2 	bl	3481c764 <simple_strtoul>
34803418:	e1a01000 	mov	r1, r0
	p = strcmp(l, r);
3480341c:	e1a00005 	mov	r0, r5
34803420:	eb0060fe 	bl	3481b820 <strcmp>
	switch (op) {
34803424:	e3570005 	cmp	r7, #5
34803428:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
3480342c:	ea000041 	b	34803538 <binary_test+0x1d0>
34803430:	34803448 	.word	0x34803448
34803434:	34803454 	.word	0x34803454
34803438:	34803460 	.word	0x34803460
3480343c:	34803468 	.word	0x34803468
34803440:	34803470 	.word	0x34803470
34803444:	34803478 	.word	0x34803478
	case EQ: return (p == 0);
34803448:	e16f4f10 	clz	r4, r0
3480344c:	e1a042a4 	lsr	r4, r4, #5
34803450:	ea000038 	b	34803538 <binary_test+0x1d0>
	case NE: return (p != 0);
34803454:	e2904000 	adds	r4, r0, #0
34803458:	13a04001 	movne	r4, #1
3480345c:	ea000035 	b	34803538 <binary_test+0x1d0>
	case LT: return (p < 0);
34803460:	e1a04fa0 	lsr	r4, r0, #31
34803464:	ea000033 	b	34803538 <binary_test+0x1d0>
	case GT: return (p > 0);
34803468:	e3500000 	cmp	r0, #0
3480346c:	ea000020 	b	348034f4 <binary_test+0x18c>
	case LE: return (p <= 0);
34803470:	e3500000 	cmp	r0, #0
34803474:	ea000022 	b	34803504 <binary_test+0x19c>
	case GE: return (p >= 0);
34803478:	e1e04000 	mvn	r4, r0
3480347c:	e1a04fa4 	lsr	r4, r4, #31
34803480:	ea00002c 	b	34803538 <binary_test+0x1d0>
	l = evalexp (s, w);
34803484:	e1a01009 	mov	r1, r9
34803488:	e1a00005 	mov	r0, r5
3480348c:	ebffff9a 	bl	348032fc <evalexp>
	r = evalexp (t, w);
34803490:	e1a01009 	mov	r1, r9
	l = evalexp (s, w);
34803494:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
34803498:	e1a00006 	mov	r0, r6
3480349c:	ebffff96 	bl	348032fc <evalexp>
	switch (op) {
348034a0:	e3570005 	cmp	r7, #5
348034a4:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
348034a8:	ea000022 	b	34803538 <binary_test+0x1d0>
348034ac:	348034c4 	.word	0x348034c4
348034b0:	348034d4 	.word	0x348034d4
348034b4:	348034e0 	.word	0x348034e0
348034b8:	348034f0 	.word	0x348034f0
348034bc:	34803500 	.word	0x34803500
348034c0:	34803510 	.word	0x34803510
	case EQ: return (l == r);
348034c4:	e0604005 	rsb	r4, r0, r5
348034c8:	e16f4f14 	clz	r4, r4
348034cc:	e1a042a4 	lsr	r4, r4, #5
348034d0:	ea000018 	b	34803538 <binary_test+0x1d0>
	case NE: return (l != r);
348034d4:	e0554000 	subs	r4, r5, r0
348034d8:	13a04001 	movne	r4, #1
348034dc:	ea000015 	b	34803538 <binary_test+0x1d0>
	case LT: return (l < r);
348034e0:	e1550000 	cmp	r5, r0
348034e4:	a3a04000 	movge	r4, #0
348034e8:	b3a04001 	movlt	r4, #1
348034ec:	ea000011 	b	34803538 <binary_test+0x1d0>
	case GT: return (l > r);
348034f0:	e1550000 	cmp	r5, r0
348034f4:	d3a04000 	movle	r4, #0
348034f8:	c3a04001 	movgt	r4, #1
348034fc:	ea00000d 	b	34803538 <binary_test+0x1d0>
	case LE: return (l <= r);
34803500:	e1550000 	cmp	r5, r0
34803504:	c3a04000 	movgt	r4, #0
34803508:	d3a04001 	movle	r4, #1
3480350c:	ea000009 	b	34803538 <binary_test+0x1d0>
	case GE: return (l >= r);
34803510:	e1550000 	cmp	r5, r0
34803514:	b3a04000 	movlt	r4, #0
34803518:	a3a04001 	movge	r4, #1
3480351c:	ea000005 	b	34803538 <binary_test+0x1d0>
34803520:	e2877008 	add	r7, r7, #8
34803524:	eaffff98 	b	3480338c <binary_test+0x24>
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
34803528:	e3a04000 	mov	r4, #0
	printf("Unknown operator '%s'\n", op);
3480352c:	e1a0100b 	mov	r1, fp
34803530:	e59f0010 	ldr	r0, [pc, #16]	; 34803548 <binary_test+0x1e0>
34803534:	eb001898 	bl	3480979c <printf>
}
34803538:	e1a00004 	mov	r0, r4
3480353c:	e28dd008 	add	sp, sp, #8
34803540:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803544:	3481f66c 	.word	0x3481f66c
34803548:	34822636 	.word	0x34822636

3480354c <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
3480354c:	e3520004 	cmp	r2, #4
34803550:	1a00001c 	bne	348035c8 <do_itest+0x7c>
{
34803554:	e92d4010 	push	{r4, lr}
34803558:	e1a01002 	mov	r1, r2

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
3480355c:	e5930000 	ldr	r0, [r3]
34803560:	e1a04003 	mov	r4, r3
34803564:	eb0017ab 	bl	34809418 <cmd_get_data_size>
34803568:	e2802002 	add	r2, r0, #2
3480356c:	e1a03000 	mov	r3, r0
34803570:	e3520006 	cmp	r2, #6
34803574:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
34803578:	ea00000c 	b	348035b0 <do_itest+0x64>
3480357c:	34803598 	.word	0x34803598
34803580:	348035b0 	.word	0x348035b0
34803584:	348035b0 	.word	0x348035b0
34803588:	3480359c 	.word	0x3480359c
3480358c:	3480359c 	.word	0x3480359c
34803590:	348035b0 	.word	0x348035b0
34803594:	3480359c 	.word	0x3480359c
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
34803598:	e3a03000 	mov	r3, #0
3480359c:	e594200c 	ldr	r2, [r4, #12]
348035a0:	e5941004 	ldr	r1, [r4, #4]
348035a4:	e5940008 	ldr	r0, [r4, #8]
348035a8:	ebffff6e 	bl	34803368 <binary_test>
		break;
348035ac:	ea000002 	b	348035bc <do_itest+0x70>
	case -1:
	default:
		puts("Invalid data width specifier\n");
348035b0:	e59f0018 	ldr	r0, [pc, #24]	; 348035d0 <do_itest+0x84>
348035b4:	eb00186c 	bl	3480976c <puts>
		value = 0;
348035b8:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
348035bc:	e16f0f10 	clz	r0, r0
348035c0:	e1a002a0 	lsr	r0, r0, #5
348035c4:	e8bd8010 	pop	{r4, pc}
		return CMD_RET_USAGE;
348035c8:	e3e00000 	mvn	r0, #0
348035cc:	e12fff1e 	bx	lr
348035d0:	3482264d 	.word	0x3482264d

348035d4 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init (void)
{
	os_data_state = 0;
348035d4:	e59f3010 	ldr	r3, [pc, #16]	; 348035ec <bin_data_init+0x18>
348035d8:	e3a02000 	mov	r2, #0
348035dc:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
348035e0:	e5932008 	ldr	r2, [r3, #8]
348035e4:	e5832004 	str	r2, [r3, #4]
348035e8:	e12fff1e 	bx	lr
348035ec:	3482870c 	.word	0x3482870c

348035f0 <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
348035f0:	e92d4010 	push	{r4, lr}
	if (tstc())
348035f4:	eb001844 	bl	3480970c <tstc>
348035f8:	e3500000 	cmp	r0, #0
348035fc:	0a000001 	beq	34803608 <getcxmodem+0x18>
		return (getc());
	return -1;
}
34803600:	e8bd4010 	pop	{r4, lr}
		return (getc());
34803604:	ea001834 	b	348096dc <getc>
}
34803608:	e3e00000 	mvn	r0, #0
3480360c:	e8bd8010 	pop	{r4, pc}

34803610 <load_serial_ymodem>:
static ulong load_serial_ymodem (ulong offset)
{
34803610:	e92d4070 	push	{r4, r5, r6, lr}
34803614:	e24dde43 	sub	sp, sp, #1072	; 0x430
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
34803618:	e3a03002 	mov	r3, #2
{
3480361c:	e1a06000 	mov	r6, r0
	res = xyzModem_stream_open (&info, &err);
34803620:	e1a0100d 	mov	r1, sp
34803624:	e28d0004 	add	r0, sp, #4
	info.mode = xyzModem_ymodem;
34803628:	e58d3008 	str	r3, [sp, #8]
	res = xyzModem_stream_open (&info, &err);
3480362c:	eb002e75 	bl	3480f008 <xyzModem_stream_open>
	if (!res) {
34803630:	e3500000 	cmp	r0, #0
34803634:	01a05000 	moveq	r5, r0
34803638:	01a04005 	moveq	r4, r5
3480363c:	1a00000b 	bne	34803670 <load_serial_ymodem+0x60>

		while ((res =
34803640:	e1a0200d 	mov	r2, sp
34803644:	e3a01b01 	mov	r1, #1024	; 0x400
34803648:	e28d0030 	add	r0, sp, #48	; 0x30
3480364c:	eb002ebf 	bl	3480f150 <xyzModem_stream_read>
34803650:	e2502000 	subs	r2, r0, #0
34803654:	da00000b 	ble	34803688 <load_serial_ymodem+0x78>
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
34803658:	e0850006 	add	r0, r5, r6
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
3480365c:	e28d1030 	add	r1, sp, #48	; 0x30
			size += res;
34803660:	e0844002 	add	r4, r4, r2
			addr += res;
34803664:	e0855002 	add	r5, r5, r2
				memcpy ((char *) (store_addr), ymodemBuf,
34803668:	eb006163 	bl	3481bbfc <memcpy>
3480366c:	eafffff3 	b	34803640 <load_serial_ymodem+0x30>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
34803670:	e59d0000 	ldr	r0, [sp]
	size = 0;
34803674:	e3a04000 	mov	r4, #0
		printf ("%s\n", xyzModem_error (err));
34803678:	eb002f86 	bl	3480f498 <xyzModem_error>
3480367c:	e1a01000 	mov	r1, r0
34803680:	e59f0058 	ldr	r0, [pc, #88]	; 348036e0 <load_serial_ymodem+0xd0>
34803684:	eb001844 	bl	3480979c <printf>
	}

	xyzModem_stream_close (&err);
34803688:	e1a0000d 	mov	r0, sp
3480368c:	eb002f47 	bl	3480f3b0 <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
34803690:	e59f104c 	ldr	r1, [pc, #76]	; 348036e4 <load_serial_ymodem+0xd4>
34803694:	e3a00000 	mov	r0, #0
34803698:	eb002f59 	bl	3480f404 <xyzModem_stream_terminate>


	flush_cache (offset, size);
3480369c:	e1a01004 	mov	r1, r4
348036a0:	e1a00006 	mov	r0, r6
348036a4:	ebfff5cb 	bl	34800dd8 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
348036a8:	e1a02004 	mov	r2, r4
348036ac:	e1a01004 	mov	r1, r4
348036b0:	e59f0030 	ldr	r0, [pc, #48]	; 348036e8 <load_serial_ymodem+0xd8>
348036b4:	eb001838 	bl	3480979c <printf>
	sprintf (buf, "%X", size);
348036b8:	e1a02004 	mov	r2, r4
348036bc:	e59f1028 	ldr	r1, [pc, #40]	; 348036ec <load_serial_ymodem+0xdc>
348036c0:	e28d0010 	add	r0, sp, #16
348036c4:	eb0064cf 	bl	3481ca08 <sprintf>
	setenv ("filesize", buf);
348036c8:	e28d1010 	add	r1, sp, #16
348036cc:	e59f001c 	ldr	r0, [pc, #28]	; 348036f0 <load_serial_ymodem+0xe0>
348036d0:	eb001027 	bl	34807774 <setenv>

	return offset;
}
348036d4:	e1a00006 	mov	r0, r6
348036d8:	e28dde43 	add	sp, sp, #1072	; 0x430
348036dc:	e8bd8070 	pop	{r4, r5, r6, pc}
348036e0:	34824c10 	.word	0x34824c10
348036e4:	348035f0 	.word	0x348035f0
348036e8:	348226e9 	.word	0x348226e9
348036ec:	34822711 	.word	0x34822711
348036f0:	34821f6d 	.word	0x34821f6d

348036f4 <bin_data_char>:
	switch (os_data_state) {
348036f4:	e59f3018 	ldr	r3, [pc, #24]	; 34803714 <bin_data_char+0x20>
348036f8:	e5932000 	ldr	r2, [r3]
348036fc:	e3520000 	cmp	r2, #0
		*os_data_addr++ = new_char;
34803700:	05932004 	ldreq	r2, [r3, #4]
34803704:	02821001 	addeq	r1, r2, #1
34803708:	05c20000 	strbeq	r0, [r2]
3480370c:	05831004 	streq	r1, [r3, #4]
34803710:	e12fff1e 	bx	lr
34803714:	3482870c 	.word	0x3482870c

34803718 <load_serial>:
{
34803718:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int	line_count =  0;
3480371c:	e3a06000 	mov	r6, #0
		if (do_echo)
34803720:	e59f91d0 	ldr	r9, [pc, #464]	; 348038f8 <load_serial+0x1e0>
	ulong	end_addr   =  0;
34803724:	e1a05006 	mov	r5, r6
	ulong	start_addr = ~0;
34803728:	e3e04000 	mvn	r4, #0
{
3480372c:	e24ddd0d 	sub	sp, sp, #832	; 0x340
34803730:	e58d0008 	str	r0, [sp, #8]
34803734:	e1a0b009 	mov	fp, r9
34803738:	e28daf4e 	add	sl, sp, #312	; 0x138
3480373c:	e1a0700a 	mov	r7, sl
		c = getc();		/* read character		*/
34803740:	eb0017e5 	bl	348096dc <getc>
		if (do_echo)
34803744:	e5991000 	ldr	r1, [r9]
		c = getc();		/* read character		*/
34803748:	e6ef2070 	uxtb	r2, r0
		if (do_echo)
3480374c:	e3510000 	cmp	r1, #0
34803750:	0a000003 	beq	34803764 <load_serial+0x4c>
			putc (c);	/* ... and echo it		*/
34803754:	e1a00002 	mov	r0, r2
34803758:	e58d200c 	str	r2, [sp, #12]
3480375c:	eb0017f6 	bl	3480973c <putc>
34803760:	e59d200c 	ldr	r2, [sp, #12]
		switch (c) {
34803764:	e3520003 	cmp	r2, #3
34803768:	0a00005f 	beq	348038ec <load_serial+0x1d4>
3480376c:	ca000002 	bgt	3480377c <load_serial+0x64>
34803770:	e3520000 	cmp	r2, #0
34803774:	0a00005c 	beq	348038ec <load_serial+0x1d4>
34803778:	ea000003 	b	3480378c <load_serial+0x74>
3480377c:	e352000a 	cmp	r2, #10
34803780:	0a00000f 	beq	348037c4 <load_serial+0xac>
34803784:	e352000d 	cmp	r2, #13
34803788:	0a00000d 	beq	348037c4 <load_serial+0xac>
			*p = c;
3480378c:	e4ca2001 	strb	r2, [sl], #1
	    if (gd->jt[XF_getc] != getc) {
34803790:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34803794:	e5921004 	ldr	r1, [r2, #4]
34803798:	e59f215c 	ldr	r2, [pc, #348]	; 348038fc <load_serial+0x1e4>
3480379c:	e1510002 	cmp	r1, r2
348037a0:	1a000003 	bne	348037b4 <load_serial+0x9c>
	for (p=buf; p < buf+len; ++p) {
348037a4:	e28d3fcf 	add	r3, sp, #828	; 0x33c
348037a8:	e15a0003 	cmp	sl, r3
348037ac:	1affffe3 	bne	34803740 <load_serial+0x28>
348037b0:	ea000003 	b	348037c4 <load_serial+0xac>
		if (ctrlc()) {
348037b4:	eb00181a 	bl	34809824 <ctrlc>
348037b8:	e3500000 	cmp	r0, #0
348037bc:	0afffff8 	beq	348037a4 <load_serial+0x8c>
348037c0:	ea000049 	b	348038ec <load_serial+0x1d4>
	return (p - buf);
348037c4:	e067300a 	rsb	r3, r7, sl
	*p = '\0';
348037c8:	e3a02000 	mov	r2, #0
	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
348037cc:	e3530000 	cmp	r3, #0
	*p = '\0';
348037d0:	e5ca2000 	strb	r2, [sl]
	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
348037d4:	ba000044 	blt	348038ec <load_serial+0x1d4>
		type = srec_decode (record, &binlen, &addr, binbuf);
348037d8:	e28d3038 	add	r3, sp, #56	; 0x38
348037dc:	e28d2014 	add	r2, sp, #20
348037e0:	e28d1010 	add	r1, sp, #16
348037e4:	e1a00007 	mov	r0, r7
348037e8:	eb002b81 	bl	3480e5f4 <srec_decode>
		if (type < 0) {
348037ec:	e3500000 	cmp	r0, #0
348037f0:	ba00003d 	blt	348038ec <load_serial+0x1d4>
		switch (type) {
348037f4:	e2400001 	sub	r0, r0, #1
348037f8:	e3500008 	cmp	r0, #8
348037fc:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
34803800:	ea00002d 	b	348038bc <load_serial+0x1a4>
34803804:	34803828 	.word	0x34803828
34803808:	34803828 	.word	0x34803828
3480380c:	34803828 	.word	0x34803828
34803810:	348038bc 	.word	0x348038bc
34803814:	348038bc 	.word	0x348038bc
34803818:	348038bc 	.word	0x348038bc
3480381c:	34803864 	.word	0x34803864
34803820:	34803864 	.word	0x34803864
34803824:	34803864 	.word	0x34803864
		    store_addr = addr + offset;
34803828:	e59d0014 	ldr	r0, [sp, #20]
			memcpy ((char *)(store_addr), binbuf, binlen);
3480382c:	e28d1038 	add	r1, sp, #56	; 0x38
		    store_addr = addr + offset;
34803830:	e59d3008 	ldr	r3, [sp, #8]
			memcpy ((char *)(store_addr), binbuf, binlen);
34803834:	e59d2010 	ldr	r2, [sp, #16]
		    store_addr = addr + offset;
34803838:	e0837000 	add	r7, r3, r0
			memcpy ((char *)(store_addr), binbuf, binlen);
3480383c:	e1a00007 	mov	r0, r7
34803840:	eb0060ed 	bl	3481bbfc <memcpy>
34803844:	e59d0010 	ldr	r0, [sp, #16]
34803848:	e1540007 	cmp	r4, r7
3480384c:	21a04007 	movcs	r4, r7
34803850:	e2400001 	sub	r0, r0, #1
		    if ((store_addr + binlen - 1) > end_addr)
34803854:	e0800007 	add	r0, r0, r7
34803858:	e1550000 	cmp	r5, r0
3480385c:	31a05000 	movcc	r5, r0
34803860:	ea000015 	b	348038bc <load_serial+0x1a4>
34803864:	e2856001 	add	r6, r5, #1
		    udelay (10000);
34803868:	e3020710 	movw	r0, #10000	; 0x2710
		    size = end_addr - start_addr + 1;
3480386c:	e0646006 	rsb	r6, r4, r6
		    udelay (10000);
34803870:	eb006165 	bl	3481be0c <udelay>
		    printf ("\n"
34803874:	e1a03006 	mov	r3, r6
34803878:	e1a02005 	mov	r2, r5
3480387c:	e1a01004 	mov	r1, r4
34803880:	e58d6000 	str	r6, [sp]
34803884:	e59f0074 	ldr	r0, [pc, #116]	; 34803900 <load_serial+0x1e8>
34803888:	eb0017c3 	bl	3480979c <printf>
		    flush_cache (start_addr, size);
3480388c:	e1a01006 	mov	r1, r6
34803890:	e1a00004 	mov	r0, r4
34803894:	ebfff54f 	bl	34800dd8 <flush_cache>
		    sprintf(buf, "%lX", size);
34803898:	e1a02006 	mov	r2, r6
3480389c:	e59f1060 	ldr	r1, [pc, #96]	; 34803904 <load_serial+0x1ec>
348038a0:	e28d0018 	add	r0, sp, #24
348038a4:	eb006457 	bl	3481ca08 <sprintf>
		    setenv("filesize", buf);
348038a8:	e28d1018 	add	r1, sp, #24
348038ac:	e59f0054 	ldr	r0, [pc, #84]	; 34803908 <load_serial+0x1f0>
348038b0:	eb000faf 	bl	34807774 <setenv>
		    return (addr);
348038b4:	e59d0014 	ldr	r0, [sp, #20]
348038b8:	ea00000c 	b	348038f0 <load_serial+0x1d8>
		if (!do_echo) {	/* print a '.' every 100 lines */
348038bc:	e59b3000 	ldr	r3, [fp]
348038c0:	e3530000 	cmp	r3, #0
348038c4:	1affff9b 	bne	34803738 <load_serial+0x20>
			if ((++line_count % 100) == 0)
348038c8:	e2866001 	add	r6, r6, #1
348038cc:	e3a01064 	mov	r1, #100	; 0x64
348038d0:	e1a00006 	mov	r0, r6
348038d4:	fa006f14 	blx	3481f52c <__aeabi_idivmod>
348038d8:	e3510000 	cmp	r1, #0
348038dc:	1affff95 	bne	34803738 <load_serial+0x20>
				putc ('.');
348038e0:	e3a0002e 	mov	r0, #46	; 0x2e
348038e4:	eb001794 	bl	3480973c <putc>
348038e8:	eaffff92 	b	34803738 <load_serial+0x20>
	return (~0);			/* Download aborted		*/
348038ec:	e3e00000 	mvn	r0, #0
}
348038f0:	e28ddd0d 	add	sp, sp, #832	; 0x340
348038f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348038f8:	348270e4 	.word	0x348270e4
348038fc:	348096dc 	.word	0x348096dc
34803900:	34822714 	.word	0x34822714
34803904:	34821f69 	.word	0x34821f69
34803908:	34821f6d 	.word	0x34821f6d

3480390c <do_load_serial>:
{
3480390c:	e92d4070 	push	{r4, r5, r6, lr}
34803910:	e1a05002 	mov	r5, r2
	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803914:	e59f00b4 	ldr	r0, [pc, #180]	; 348039d0 <do_load_serial+0xc4>
{
34803918:	e1a04003 	mov	r4, r3
	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
3480391c:	eb001098 	bl	34807b84 <getenv>
34803920:	e3500000 	cmp	r0, #0
34803924:	e59f10a8 	ldr	r1, [pc, #168]	; 348039d4 <do_load_serial+0xc8>
34803928:	0a000003 	beq	3480393c <do_load_serial+0x30>
3480392c:	e5d03000 	ldrb	r3, [r0]
34803930:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
34803934:	03a03001 	moveq	r3, #1
	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803938:	0a000000 	beq	34803940 <do_load_serial+0x34>
		do_echo = 0;
3480393c:	e3a03000 	mov	r3, #0
	if (argc == 2) {
34803940:	e3550002 	cmp	r5, #2
		do_echo = 0;
34803944:	e5813000 	str	r3, [r1]
	long offset = 0;
34803948:	13a04000 	movne	r4, #0
	if (argc == 2) {
3480394c:	1a000004 	bne	34803964 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
34803950:	e5940004 	ldr	r0, [r4, #4]
34803954:	e3a02010 	mov	r2, #16
34803958:	e3a01000 	mov	r1, #0
3480395c:	eb0063cc 	bl	3481c894 <simple_strtol>
34803960:	e1a04000 	mov	r4, r0
	printf ("## Ready for S-Record download ...\n");
34803964:	e59f006c 	ldr	r0, [pc, #108]	; 348039d8 <do_load_serial+0xcc>
34803968:	eb00178b 	bl	3480979c <printf>
	addr = load_serial (offset);
3480396c:	e1a00004 	mov	r0, r4
34803970:	e3a04064 	mov	r4, #100	; 0x64
34803974:	ebffff67 	bl	34803718 <load_serial>
34803978:	e1a05000 	mov	r5, r0
		if (tstc()) {
3480397c:	eb001762 	bl	3480970c <tstc>
34803980:	e3500000 	cmp	r0, #0
34803984:	0a000000 	beq	3480398c <do_load_serial+0x80>
			(void) getc();
34803988:	eb001753 	bl	348096dc <getc>
		udelay(1000);
3480398c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34803990:	eb00611d 	bl	3481be0c <udelay>
	for (i=0; i<100; ++i) {
34803994:	e2544001 	subs	r4, r4, #1
34803998:	1afffff7 	bne	3480397c <do_load_serial+0x70>
	if (addr == ~0) {
3480399c:	e3750001 	cmn	r5, #1
348039a0:	1a000003 	bne	348039b4 <do_load_serial+0xa8>
		printf ("## S-Record download aborted\n");
348039a4:	e59f0030 	ldr	r0, [pc, #48]	; 348039dc <do_load_serial+0xd0>
348039a8:	eb00177b 	bl	3480979c <printf>
		rcode = 1;
348039ac:	e3a00001 	mov	r0, #1
348039b0:	e8bd8070 	pop	{r4, r5, r6, pc}
		printf ("## Start Addr      = 0x%08lX\n", addr);
348039b4:	e1a01005 	mov	r1, r5
348039b8:	e59f0020 	ldr	r0, [pc, #32]	; 348039e0 <do_load_serial+0xd4>
348039bc:	eb001776 	bl	3480979c <printf>
		load_addr = addr;
348039c0:	e59f301c 	ldr	r3, [pc, #28]	; 348039e4 <do_load_serial+0xd8>
	int rcode = 0;
348039c4:	e1a00004 	mov	r0, r4
		load_addr = addr;
348039c8:	e5835000 	str	r5, [r3]
}
348039cc:	e8bd8070 	pop	{r4, r5, r6, pc}
348039d0:	34822779 	.word	0x34822779
348039d4:	348270e4 	.word	0x348270e4
348039d8:	34822784 	.word	0x34822784
348039dc:	348227a8 	.word	0x348227a8
348039e0:	348227c6 	.word	0x348227c6
348039e4:	348271b4 	.word	0x348271b4

348039e8 <send_pad>:
	int count = his_pad_count;
348039e8:	e59f3024 	ldr	r3, [pc, #36]	; 34803a14 <send_pad+0x2c>
{
348039ec:	e92d4070 	push	{r4, r5, r6, lr}
348039f0:	e1a04003 	mov	r4, r3
348039f4:	e593500c 	ldr	r5, [r3, #12]
	while (count-- > 0)
348039f8:	e3550000 	cmp	r5, #0
348039fc:	da000003 	ble	34803a10 <send_pad+0x28>
		putc (his_pad_char);
34803a00:	e5d40010 	ldrb	r0, [r4, #16]
34803a04:	e2455001 	sub	r5, r5, #1
34803a08:	eb00174b 	bl	3480973c <putc>
34803a0c:	eafffff9 	b	348039f8 <send_pad+0x10>
}
34803a10:	e8bd8070 	pop	{r4, r5, r6, pc}
34803a14:	3482870c 	.word	0x3482870c

34803a18 <ktrans>:
	if ((in & 0x60) == 0x40) {
34803a18:	e2003060 	and	r3, r0, #96	; 0x60
34803a1c:	e3530040 	cmp	r3, #64	; 0x40
34803a20:	1a000001 	bne	34803a2c <ktrans+0x14>
		return (char) (in & ~0x40);
34803a24:	e20000bf 	and	r0, r0, #191	; 0xbf
34803a28:	e12fff1e 	bx	lr
	} else if ((in & 0x7f) == 0x3f) {
34803a2c:	e200307f 	and	r3, r0, #127	; 0x7f
34803a30:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
34803a34:	03800040 	orreq	r0, r0, #64	; 0x40
}
34803a38:	e12fff1e 	bx	lr

34803a3c <chk1>:
{
34803a3c:	e2400001 	sub	r0, r0, #1
	int total = 0;
34803a40:	e3a03000 	mov	r3, #0
	while (*buffer) {
34803a44:	e5f02001 	ldrb	r2, [r0, #1]!
34803a48:	e3520000 	cmp	r2, #0
		total += *buffer++;
34803a4c:	10833002 	addne	r3, r3, r2
34803a50:	1afffffb 	bne	34803a44 <chk1+0x8>
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
34803a54:	e7e10353 	ubfx	r0, r3, #6, #2
34803a58:	e0830000 	add	r0, r3, r0
}
34803a5c:	e200003f 	and	r0, r0, #63	; 0x3f
34803a60:	e12fff1e 	bx	lr

34803a64 <s1_sendpacket>:
{
34803a64:	e92d4010 	push	{r4, lr}
34803a68:	e1a04000 	mov	r4, r0
34803a6c:	e2444001 	sub	r4, r4, #1
	send_pad ();
34803a70:	ebffffdc 	bl	348039e8 <send_pad>
	while (*packet) {
34803a74:	e5f40001 	ldrb	r0, [r4, #1]!
34803a78:	e3500000 	cmp	r0, #0
34803a7c:	0a000001 	beq	34803a88 <s1_sendpacket+0x24>
		putc (*packet++);
34803a80:	eb00172d 	bl	3480973c <putc>
34803a84:	eafffffa 	b	34803a74 <s1_sendpacket+0x10>
}
34803a88:	e8bd8010 	pop	{r4, pc}

34803a8c <send_ack>:
{
34803a8c:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803a90:	e3a03001 	mov	r3, #1
34803a94:	e59f4048 	ldr	r4, [pc, #72]	; 34803ae4 <send_ack+0x58>
	a_b[2] = tochar (n);
34803a98:	e2800020 	add	r0, r0, #32
	a_b[4] = '\0';
34803a9c:	e3a05000 	mov	r5, #0
	a_b[0] = START_CHAR;
34803aa0:	e5c43011 	strb	r3, [r4, #17]
	a_b[1] = tochar (3);
34803aa4:	e3a03023 	mov	r3, #35	; 0x23
34803aa8:	e5c43012 	strb	r3, [r4, #18]
	a_b[3] = ACK_TYPE;
34803aac:	e3a03059 	mov	r3, #89	; 0x59
	a_b[2] = tochar (n);
34803ab0:	e5c40013 	strb	r0, [r4, #19]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803ab4:	e2840012 	add	r0, r4, #18
	a_b[3] = ACK_TYPE;
34803ab8:	e5c43014 	strb	r3, [r4, #20]
	a_b[4] = '\0';
34803abc:	e5c45015 	strb	r5, [r4, #21]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803ac0:	ebffffdd 	bl	34803a3c <chk1>
	a_b[5] = his_eol;
34803ac4:	e5d43029 	ldrb	r3, [r4, #41]	; 0x29
	a_b[4] = tochar (chk1 (&a_b[1]));
34803ac8:	e2800020 	add	r0, r0, #32
34803acc:	e5c40015 	strb	r0, [r4, #21]
	s1_sendpacket (a_b);
34803ad0:	e2840011 	add	r0, r4, #17
	a_b[6] = '\0';
34803ad4:	e5c45017 	strb	r5, [r4, #23]
	a_b[5] = his_eol;
34803ad8:	e5c43016 	strb	r3, [r4, #22]
}
34803adc:	e8bd4070 	pop	{r4, r5, r6, lr}
	s1_sendpacket (a_b);
34803ae0:	eaffffdf 	b	34803a64 <s1_sendpacket>
34803ae4:	3482870c 	.word	0x3482870c

34803ae8 <send_nack>:
{
34803ae8:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803aec:	e3a03001 	mov	r3, #1
34803af0:	e59f4048 	ldr	r4, [pc, #72]	; 34803b40 <send_nack+0x58>
	a_b[2] = tochar (n);
34803af4:	e2800020 	add	r0, r0, #32
	a_b[4] = '\0';
34803af8:	e3a05000 	mov	r5, #0
	a_b[0] = START_CHAR;
34803afc:	e5c43011 	strb	r3, [r4, #17]
	a_b[1] = tochar (3);
34803b00:	e3a03023 	mov	r3, #35	; 0x23
34803b04:	e5c43012 	strb	r3, [r4, #18]
	a_b[3] = NACK_TYPE;
34803b08:	e3a0304e 	mov	r3, #78	; 0x4e
	a_b[2] = tochar (n);
34803b0c:	e5c40013 	strb	r0, [r4, #19]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803b10:	e2840012 	add	r0, r4, #18
	a_b[3] = NACK_TYPE;
34803b14:	e5c43014 	strb	r3, [r4, #20]
	a_b[4] = '\0';
34803b18:	e5c45015 	strb	r5, [r4, #21]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803b1c:	ebffffc6 	bl	34803a3c <chk1>
	a_b[5] = his_eol;
34803b20:	e5d43029 	ldrb	r3, [r4, #41]	; 0x29
	a_b[4] = tochar (chk1 (&a_b[1]));
34803b24:	e2800020 	add	r0, r0, #32
34803b28:	e5c40015 	strb	r0, [r4, #21]
	s1_sendpacket (a_b);
34803b2c:	e2840011 	add	r0, r4, #17
	a_b[6] = '\0';
34803b30:	e5c45017 	strb	r5, [r4, #23]
	a_b[5] = his_eol;
34803b34:	e5c43016 	strb	r3, [r4, #22]
}
34803b38:	e8bd4070 	pop	{r4, r5, r6, lr}
	s1_sendpacket (a_b);
34803b3c:	eaffffc8 	b	34803a64 <s1_sendpacket>
34803b40:	3482870c 	.word	0x3482870c

34803b44 <k_data_init>:
	k_data_escape = 0;
34803b44:	e59f300c 	ldr	r3, [pc, #12]	; 34803b58 <k_data_init+0x14>
34803b48:	e3a02000 	mov	r2, #0
34803b4c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	os_data_init ();
34803b50:	e5933030 	ldr	r3, [r3, #48]	; 0x30
34803b54:	e12fff13 	bx	r3
34803b58:	3482870c 	.word	0x3482870c

34803b5c <k_data_save>:
	k_data_escape_saved = k_data_escape;
34803b5c:	e59f3018 	ldr	r3, [pc, #24]	; 34803b7c <k_data_save+0x20>
34803b60:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
34803b64:	e5832034 	str	r2, [r3, #52]	; 0x34
	os_data_state_saved = os_data_state;
34803b68:	e5932000 	ldr	r2, [r3]
34803b6c:	e5832038 	str	r2, [r3, #56]	; 0x38
	os_data_addr_saved = os_data_addr;
34803b70:	e5932004 	ldr	r2, [r3, #4]
34803b74:	e583203c 	str	r2, [r3, #60]	; 0x3c
34803b78:	e12fff1e 	bx	lr
34803b7c:	3482870c 	.word	0x3482870c

34803b80 <k_data_restore>:
	k_data_escape = k_data_escape_saved;
34803b80:	e59f3018 	ldr	r3, [pc, #24]	; 34803ba0 <k_data_restore+0x20>
34803b84:	e5932034 	ldr	r2, [r3, #52]	; 0x34
34803b88:	e583202c 	str	r2, [r3, #44]	; 0x2c
	os_data_state = os_data_state_saved;
34803b8c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
34803b90:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
34803b94:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
34803b98:	e5832004 	str	r2, [r3, #4]
34803b9c:	e12fff1e 	bx	lr
34803ba0:	3482870c 	.word	0x3482870c

34803ba4 <k_data_char>:
{
34803ba4:	e92d4070 	push	{r4, r5, r6, lr}
	if (k_data_escape) {
34803ba8:	e59f4040 	ldr	r4, [pc, #64]	; 34803bf0 <k_data_char+0x4c>
34803bac:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
34803bb0:	e3520000 	cmp	r2, #0
34803bb4:	0a000004 	beq	34803bcc <k_data_char+0x28>
		os_data_char (ktrans (new_char));
34803bb8:	ebffff96 	bl	34803a18 <ktrans>
34803bbc:	e5945040 	ldr	r5, [r4, #64]	; 0x40
34803bc0:	e12fff35 	blx	r5
		k_data_escape = 0;
34803bc4:	e3a03000 	mov	r3, #0
34803bc8:	ea000003 	b	34803bdc <k_data_char+0x38>
		if (new_char == his_quote) {
34803bcc:	e5d42044 	ldrb	r2, [r4, #68]	; 0x44
34803bd0:	e1520000 	cmp	r2, r0
34803bd4:	1a000002 	bne	34803be4 <k_data_char+0x40>
			k_data_escape = 1;
34803bd8:	e3a03001 	mov	r3, #1
34803bdc:	e584302c 	str	r3, [r4, #44]	; 0x2c
34803be0:	e8bd8070 	pop	{r4, r5, r6, pc}
			os_data_char (new_char);
34803be4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
}
34803be8:	e8bd4070 	pop	{r4, r5, r6, lr}
			os_data_char (new_char);
34803bec:	e12fff13 	bx	r3
34803bf0:	3482870c 	.word	0x3482870c

34803bf4 <handle_send_packet>:
{
34803bf4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	his_eol = END_CHAR;		/* default end of line character */
34803bf8:	e3a0300d 	mov	r3, #13
34803bfc:	e59f41a8 	ldr	r4, [pc, #424]	; 34803dac <handle_send_packet+0x1b8>
{
34803c00:	e1a07000 	mov	r7, r0
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803c04:	e59f51a0 	ldr	r5, [pc, #416]	; 34803dac <handle_send_packet+0x1b8>
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803c08:	e5942048 	ldr	r2, [r4, #72]	; 0x48
	his_eol = END_CHAR;		/* default end of line character */
34803c0c:	e5c43029 	strb	r3, [r4, #41]	; 0x29
	his_pad_count = 0;
34803c10:	e3a03000 	mov	r3, #0
34803c14:	e584300c 	str	r3, [r4, #12]
	his_pad_char = '\0';
34803c18:	e5c43010 	strb	r3, [r4, #16]
	his_quote = K_ESCAPE;
34803c1c:	e3a03023 	mov	r3, #35	; 0x23
34803c20:	e5c43044 	strb	r3, [r4, #68]	; 0x44
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803c24:	e284305f 	add	r3, r4, #95	; 0x5f
34803c28:	e1520003 	cmp	r2, r3
		--send_ptr;
34803c2c:	0284305e 	addeq	r3, r4, #94	; 0x5e
34803c30:	05843048 	streq	r3, [r4, #72]	; 0x48
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803c34:	e285304c 	add	r3, r5, #76	; 0x4c
34803c38:	e5946048 	ldr	r6, [r4, #72]	; 0x48
34803c3c:	e0636006 	rsb	r6, r3, r6
		if (bytes-- <= 0)
34803c40:	e3560000 	cmp	r6, #0
	int length = 3;
34803c44:	d3a05003 	movle	r5, #3
		if (bytes-- <= 0)
34803c48:	da000040 	ble	34803d50 <handle_send_packet+0x15c>
		if (bytes-- <= 0)
34803c4c:	e3560001 	cmp	r6, #1
		a_b[++length] = tochar (94);
34803c50:	e3a0307e 	mov	r3, #126	; 0x7e
34803c54:	e5c53015 	strb	r3, [r5, #21]
34803c58:	03a05004 	moveq	r5, #4
		if (bytes-- <= 0)
34803c5c:	0a00003b 	beq	34803d50 <handle_send_packet+0x15c>
		if (bytes-- <= 0)
34803c60:	e3560002 	cmp	r6, #2
		a_b[++length] = tochar (1);
34803c64:	e3a03021 	mov	r3, #33	; 0x21
34803c68:	e5c53016 	strb	r3, [r5, #22]
34803c6c:	03a05005 	moveq	r5, #5
		if (bytes-- <= 0)
34803c70:	0a000036 	beq	34803d50 <handle_send_packet+0x15c>
		his_pad_count = untochar (send_parms[2]);
34803c74:	e5d5304e 	ldrb	r3, [r5, #78]	; 0x4e
		if (bytes-- <= 0)
34803c78:	e3560003 	cmp	r6, #3
		his_pad_count = untochar (send_parms[2]);
34803c7c:	e2433020 	sub	r3, r3, #32
34803c80:	e6ef3073 	uxtb	r3, r3
34803c84:	e585300c 	str	r3, [r5, #12]
		a_b[++length] = tochar (0);
34803c88:	e3a03020 	mov	r3, #32
34803c8c:	e5c53017 	strb	r3, [r5, #23]
34803c90:	03a05006 	moveq	r5, #6
		if (bytes-- <= 0)
34803c94:	0a00002d 	beq	34803d50 <handle_send_packet+0x15c>
		his_pad_char = ktrans (send_parms[3]);
34803c98:	e5d5004f 	ldrb	r0, [r5, #79]	; 0x4f
34803c9c:	ebffff5d 	bl	34803a18 <ktrans>
		if (bytes-- <= 0)
34803ca0:	e3560004 	cmp	r6, #4
		a_b[++length] = 0x40;	/* He should ignore this */
34803ca4:	e3a03040 	mov	r3, #64	; 0x40
		his_pad_char = ktrans (send_parms[3]);
34803ca8:	e5c50010 	strb	r0, [r5, #16]
		a_b[++length] = 0x40;	/* He should ignore this */
34803cac:	e5c53018 	strb	r3, [r5, #24]
34803cb0:	03a05007 	moveq	r5, #7
		if (bytes-- <= 0)
34803cb4:	0a000025 	beq	34803d50 <handle_send_packet+0x15c>
		his_eol = untochar (send_parms[4]);
34803cb8:	e5d53050 	ldrb	r3, [r5, #80]	; 0x50
		if (bytes-- <= 0)
34803cbc:	e3560005 	cmp	r6, #5
		his_eol = untochar (send_parms[4]);
34803cc0:	e2433020 	sub	r3, r3, #32
34803cc4:	e5c53029 	strb	r3, [r5, #41]	; 0x29
		a_b[++length] = tochar (END_CHAR);
34803cc8:	e3a0302d 	mov	r3, #45	; 0x2d
34803ccc:	e5c53019 	strb	r3, [r5, #25]
34803cd0:	03a05008 	moveq	r5, #8
		if (bytes-- <= 0)
34803cd4:	0a00001d 	beq	34803d50 <handle_send_packet+0x15c>
		his_quote = send_parms[5];
34803cd8:	e5d53051 	ldrb	r3, [r5, #81]	; 0x51
		if (bytes-- <= 0)
34803cdc:	e3560006 	cmp	r6, #6
		his_quote = send_parms[5];
34803ce0:	e5c53044 	strb	r3, [r5, #68]	; 0x44
		a_b[++length] = '#';
34803ce4:	e3a03023 	mov	r3, #35	; 0x23
34803ce8:	e5c5301a 	strb	r3, [r5, #26]
34803cec:	03a05009 	moveq	r5, #9
		if (bytes-- <= 0)
34803cf0:	0a000016 	beq	34803d50 <handle_send_packet+0x15c>
		if (bytes-- <= 0)
34803cf4:	e3560007 	cmp	r6, #7
		a_b[++length] = 'N';
34803cf8:	e3a0204e 	mov	r2, #78	; 0x4e
34803cfc:	e5c5201b 	strb	r2, [r5, #27]
		if (bytes-- <= 0)
34803d00:	e2463008 	sub	r3, r6, #8
		a_b[++length] = 'N';
34803d04:	03a0500a 	moveq	r5, #10
		if (bytes-- <= 0)
34803d08:	0a000010 	beq	34803d50 <handle_send_packet+0x15c>
		if (bytes-- <= 0)
34803d0c:	e3530000 	cmp	r3, #0
		a_b[++length] = '1';
34803d10:	e3a01031 	mov	r1, #49	; 0x31
34803d14:	e5c5101c 	strb	r1, [r5, #28]
34803d18:	03a0500b 	moveq	r5, #11
		if (bytes-- <= 0)
34803d1c:	0a00000b 	beq	34803d50 <handle_send_packet+0x15c>
		if (bytes-- <= 0)
34803d20:	e3530001 	cmp	r3, #1
		a_b[++length] = 'N';
34803d24:	e5c5201d 	strb	r2, [r5, #29]
34803d28:	03a0500c 	moveq	r5, #12
		if (bytes-- <= 0)
34803d2c:	0a000007 	beq	34803d50 <handle_send_packet+0x15c>
		a_b[++length] = tochar (2);	/* only long packets */
34803d30:	e3a03022 	mov	r3, #34	; 0x22
		a_b[++length] = tochar (94);	/* large packet lsb */
34803d34:	e3a05010 	mov	r5, #16
		a_b[++length] = tochar (2);	/* only long packets */
34803d38:	e5c4301e 	strb	r3, [r4, #30]
		a_b[++length] = tochar (0);	/* no windows */
34803d3c:	e3a03020 	mov	r3, #32
34803d40:	e5c4301f 	strb	r3, [r4, #31]
		a_b[++length] = tochar (94);	/* large packet msb */
34803d44:	e3a0307e 	mov	r3, #126	; 0x7e
34803d48:	e5c43020 	strb	r3, [r4, #32]
		a_b[++length] = tochar (94);	/* large packet lsb */
34803d4c:	e5c43021 	strb	r3, [r4, #33]	; 0x21
	a_b[0] = START_CHAR;
34803d50:	e3a03001 	mov	r3, #1
	a_b[2] = tochar (n);
34803d54:	e2877020 	add	r7, r7, #32
	a_b[0] = START_CHAR;
34803d58:	e5c43011 	strb	r3, [r4, #17]
	a_b[++length] = '\0';
34803d5c:	e2856001 	add	r6, r5, #1
	a_b[1] = tochar (length);
34803d60:	e2853020 	add	r3, r5, #32
	a_b[2] = tochar (n);
34803d64:	e5c47013 	strb	r7, [r4, #19]
	a_b[1] = tochar (length);
34803d68:	e5c43012 	strb	r3, [r4, #18]
	a_b[++length] = '\0';
34803d6c:	e0846006 	add	r6, r4, r6
	a_b[3] = ACK_TYPE;
34803d70:	e3a03059 	mov	r3, #89	; 0x59
	a_b[++length] = '\0';
34803d74:	e3a07000 	mov	r7, #0
	a_b[length] = tochar (chk1 (&a_b[1]));
34803d78:	e59f0030 	ldr	r0, [pc, #48]	; 34803db0 <handle_send_packet+0x1bc>
	a_b[++length] = his_eol;
34803d7c:	e0845005 	add	r5, r4, r5
	a_b[3] = ACK_TYPE;
34803d80:	e5c43014 	strb	r3, [r4, #20]
	a_b[++length] = '\0';
34803d84:	e5c67011 	strb	r7, [r6, #17]
	a_b[length] = tochar (chk1 (&a_b[1]));
34803d88:	ebffff2b 	bl	34803a3c <chk1>
	a_b[++length] = his_eol;
34803d8c:	e5d43029 	ldrb	r3, [r4, #41]	; 0x29
	a_b[length] = tochar (chk1 (&a_b[1]));
34803d90:	e2800020 	add	r0, r0, #32
34803d94:	e5c60011 	strb	r0, [r6, #17]
	a_b[++length] = '\0';
34803d98:	e5c57014 	strb	r7, [r5, #20]
	a_b[++length] = his_eol;
34803d9c:	e5c53013 	strb	r3, [r5, #19]
	s1_sendpacket (a_b);
34803da0:	e59f000c 	ldr	r0, [pc, #12]	; 34803db4 <handle_send_packet+0x1c0>
}
34803da4:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	s1_sendpacket (a_b);
34803da8:	eaffff2d 	b	34803a64 <s1_sendpacket>
34803dac:	3482870c 	.word	0x3482870c
34803db0:	3482871e 	.word	0x3482871e
34803db4:	3482871d 	.word	0x3482871d

34803db8 <do_load_serial_bin>:
{
34803db8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34803dbc:	e24dd028 	sub	sp, sp, #40	; 0x28
	if ((s = getenv("loadaddr")) != NULL) {
34803dc0:	e59f0400 	ldr	r0, [pc, #1024]	; 348041c8 <do_load_serial_bin+0x410>
{
34803dc4:	e1a05002 	mov	r5, r2
34803dc8:	e1a04003 	mov	r4, r3
	if ((s = getenv("loadaddr")) != NULL) {
34803dcc:	eb000f6c 	bl	34807b84 <getenv>
34803dd0:	e3500000 	cmp	r0, #0
	offset = CONFIG_SYS_LOAD_ADDR;
34803dd4:	03a07309 	moveq	r7, #603979776	; 0x24000000
	if ((s = getenv("loadaddr")) != NULL) {
34803dd8:	0a000003 	beq	34803dec <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
34803ddc:	e3a02010 	mov	r2, #16
34803de0:	e3a01000 	mov	r1, #0
34803de4:	eb00625e 	bl	3481c764 <simple_strtoul>
34803de8:	e1a07000 	mov	r7, r0
	if (argc >= 2) {
34803dec:	e3550001 	cmp	r5, #1
	load_baudrate = current_baudrate = gd->baudrate;
34803df0:	e598a008 	ldr	sl, [r8, #8]
	if (argc >= 2) {
34803df4:	da00001b 	ble	34803e68 <do_load_serial_bin+0xb0>
		offset = simple_strtoul(argv[1], NULL, 16);
34803df8:	e3a02010 	mov	r2, #16
34803dfc:	e3a01000 	mov	r1, #0
34803e00:	e5940004 	ldr	r0, [r4, #4]
34803e04:	eb006256 	bl	3481c764 <simple_strtoul>
	if (argc == 3) {
34803e08:	e3550003 	cmp	r5, #3
		offset = simple_strtoul(argv[1], NULL, 16);
34803e0c:	e1a07000 	mov	r7, r0
	if (argc == 3) {
34803e10:	1a000014 	bne	34803e68 <do_load_serial_bin+0xb0>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
34803e14:	e3a0200a 	mov	r2, #10
34803e18:	e3a01000 	mov	r1, #0
34803e1c:	e5940008 	ldr	r0, [r4, #8]
34803e20:	eb00624f 	bl	3481c764 <simple_strtoul>
		if (load_baudrate == 0)
34803e24:	e2509000 	subs	r9, r0, #0
34803e28:	0a00000e 	beq	34803e68 <do_load_serial_bin+0xb0>
	if (load_baudrate != current_baudrate) {
34803e2c:	e159000a 	cmp	r9, sl
34803e30:	0a00000d 	beq	34803e6c <do_load_serial_bin+0xb4>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
34803e34:	e1a01009 	mov	r1, r9
34803e38:	e59f038c 	ldr	r0, [pc, #908]	; 348041cc <do_load_serial_bin+0x414>
34803e3c:	eb001656 	bl	3480979c <printf>
		udelay(50000);
34803e40:	e30c0350 	movw	r0, #50000	; 0xc350
34803e44:	eb005ff0 	bl	3481be0c <udelay>
		gd->baudrate = load_baudrate;
34803e48:	e5889008 	str	r9, [r8, #8]
		serial_setbrg ();
34803e4c:	eb002ae7 	bl	3480e9f0 <serial_setbrg>
		udelay(50000);
34803e50:	e30c0350 	movw	r0, #50000	; 0xc350
34803e54:	eb005fec 	bl	3481be0c <udelay>
			if (getc() == '\r')
34803e58:	eb00161f 	bl	348096dc <getc>
34803e5c:	e350000d 	cmp	r0, #13
34803e60:	1afffffc 	bne	34803e58 <do_load_serial_bin+0xa0>
34803e64:	ea000000 	b	34803e6c <do_load_serial_bin+0xb4>
	load_baudrate = current_baudrate = gd->baudrate;
34803e68:	e1a0900a 	mov	r9, sl
	if (strcmp(argv[0],"loady")==0) {
34803e6c:	e59f135c 	ldr	r1, [pc, #860]	; 348041d0 <do_load_serial_bin+0x418>
34803e70:	e5940000 	ldr	r0, [r4]
34803e74:	eb005e69 	bl	3481b820 <strcmp>
34803e78:	e2504000 	subs	r4, r0, #0
		printf ("## Ready for binary (ymodem) download "
34803e7c:	e1a02009 	mov	r2, r9
34803e80:	e1a01007 	mov	r1, r7
	if (strcmp(argv[0],"loady")==0) {
34803e84:	1a000004 	bne	34803e9c <do_load_serial_bin+0xe4>
		printf ("## Ready for binary (ymodem) download "
34803e88:	e59f0344 	ldr	r0, [pc, #836]	; 348041d4 <do_load_serial_bin+0x41c>
34803e8c:	eb001642 	bl	3480979c <printf>
		addr = load_serial_ymodem (offset);
34803e90:	e1a00007 	mov	r0, r7
34803e94:	ebfffddd 	bl	34803610 <load_serial_ymodem>
34803e98:	ea0000b9 	b	34804184 <do_load_serial_bin+0x3cc>
		printf ("## Ready for binary (kermit) download "
34803e9c:	e59f0334 	ldr	r0, [pc, #820]	; 348041d8 <do_load_serial_bin+0x420>
	his_pad_count = 0;
34803ea0:	e3a04000 	mov	r4, #0
		printf ("## Ready for binary (kermit) download "
34803ea4:	eb00163c 	bl	3480979c <printf>
	bin_start_address = (char *) addr;
34803ea8:	e59f632c 	ldr	r6, [pc, #812]	; 348041dc <do_load_serial_bin+0x424>
	last_n = -1;
34803eac:	e3e05000 	mvn	r5, #0
	os_data_init = bin_data_init;
34803eb0:	e59f3328 	ldr	r3, [pc, #808]	; 348041e0 <do_load_serial_bin+0x428>
	bin_start_address = (char *) addr;
34803eb4:	e5867008 	str	r7, [r6, #8]
	os_data_init = bin_data_init;
34803eb8:	e5863030 	str	r3, [r6, #48]	; 0x30
	os_data_char = bin_data_char;
34803ebc:	e59f3320 	ldr	r3, [pc, #800]	; 348041e4 <do_load_serial_bin+0x42c>
	his_pad_count = 0;
34803ec0:	e586400c 	str	r4, [r6, #12]
	his_pad_char = '\0';
34803ec4:	e5c64010 	strb	r4, [r6, #16]
	os_data_char = bin_data_char;
34803ec8:	e5863040 	str	r3, [r6, #64]	; 0x40
	his_eol = END_CHAR;		/* default end of line character */
34803ecc:	e3a0300d 	mov	r3, #13
34803ed0:	e5c63029 	strb	r3, [r6, #41]	; 0x29
	his_quote = K_ESCAPE;
34803ed4:	e3a03023 	mov	r3, #35	; 0x23
34803ed8:	e5c63044 	strb	r3, [r6, #68]	; 0x44
	k_data_init ();
34803edc:	ebffff18 	bl	34803b44 <k_data_init>
	k_data_save ();
34803ee0:	ebffff1d 	bl	34803b5c <k_data_save>
		send_ptr = send_parms;
34803ee4:	e59f22fc 	ldr	r2, [pc, #764]	; 348041e8 <do_load_serial_bin+0x430>
34803ee8:	e5862048 	str	r2, [r6, #72]	; 0x48
			switch (getc ()) {
34803eec:	eb0015fa 	bl	348096dc <getc>
34803ef0:	e3500001 	cmp	r0, #1
34803ef4:	0a000003 	beq	34803f08 <do_load_serial_bin+0x150>
34803ef8:	e3500003 	cmp	r0, #3
34803efc:	1afffffa 	bne	34803eec <do_load_serial_bin+0x134>
				return (0);
34803f00:	e3a05000 	mov	r5, #0
34803f04:	ea00007b 	b	348040f8 <do_load_serial_bin+0x340>
		new_char = getc ();
34803f08:	eb0015f3 	bl	348096dc <getc>
		if ((new_char & 0xE0) == 0)
34803f0c:	e31000e0 	tst	r0, #224	; 0xe0
		new_char = getc ();
34803f10:	e1a0b000 	mov	fp, r0
		if ((new_char & 0xE0) == 0)
34803f14:	0a000064 	beq	348040ac <do_load_serial_bin+0x2f4>
		new_char = getc ();
34803f18:	eb0015ef 	bl	348096dc <getc>
		if ((new_char & 0xE0) == 0)
34803f1c:	e31000e0 	tst	r0, #224	; 0xe0
34803f20:	0a000061 	beq	348040ac <do_load_serial_bin+0x2f4>
		sum += new_char & 0xff;
34803f24:	e6ef3070 	uxtb	r3, r0
		n = untochar (new_char);
34803f28:	e2434020 	sub	r4, r3, #32
		sum += new_char & 0xff;
34803f2c:	e58d3004 	str	r3, [sp, #4]
		n = untochar (new_char);
34803f30:	e6ef4074 	uxtb	r4, r4
		if (n == last_n) {
34803f34:	e1540005 	cmp	r4, r5
34803f38:	1a000001 	bne	34803f44 <do_load_serial_bin+0x18c>
			k_data_restore ();
34803f3c:	ebffff0f 	bl	34803b80 <k_data_restore>
34803f40:	ea000000 	b	34803f48 <do_load_serial_bin+0x190>
			k_data_save ();
34803f44:	ebffff04 	bl	34803b5c <k_data_save>
		new_char = getc ();
34803f48:	eb0015e3 	bl	348096dc <getc>
		if ((new_char & 0xE0) == 0)
34803f4c:	e31000e0 	tst	r0, #224	; 0xe0
34803f50:	0a000054 	beq	348040a8 <do_load_serial_bin+0x2f0>
		sum += new_char & 0xff;
34803f54:	e59d2004 	ldr	r2, [sp, #4]
		sum += new_char & 0xff;
34803f58:	e6ef307b 	uxtb	r3, fp
		sum += new_char & 0xff;
34803f5c:	e6efb070 	uxtb	fp, r0
		sum += new_char & 0xff;
34803f60:	e0835002 	add	r5, r3, r2
		length = untochar (new_char);
34803f64:	e2433020 	sub	r3, r3, #32
34803f68:	e6ef3073 	uxtb	r3, r3
		sum += new_char & 0xff;
34803f6c:	e085500b 	add	r5, r5, fp
		--length;
34803f70:	e2433002 	sub	r3, r3, #2
		if (length == -2) {
34803f74:	e3730002 	cmn	r3, #2
34803f78:	1a00002d 	bne	34804034 <do_load_serial_bin+0x27c>
			new_char = getc ();
34803f7c:	eb0015d6 	bl	348096dc <getc>
			if ((new_char & 0xE0) == 0)
34803f80:	e31000e0 	tst	r0, #224	; 0xe0
34803f84:	0a000047 	beq	348040a8 <do_load_serial_bin+0x2f0>
			sum += new_char & 0xff;
34803f88:	e6ef0070 	uxtb	r0, r0
34803f8c:	e0855000 	add	r5, r5, r0
			len_hi = untochar (new_char);
34803f90:	e2400020 	sub	r0, r0, #32
34803f94:	e6ef2070 	uxtb	r2, r0
34803f98:	e58d2004 	str	r2, [sp, #4]
			new_char = getc ();
34803f9c:	eb0015ce 	bl	348096dc <getc>
			if ((new_char & 0xE0) == 0)
34803fa0:	e31000e0 	tst	r0, #224	; 0xe0
34803fa4:	e59d2004 	ldr	r2, [sp, #4]
34803fa8:	0a00003e 	beq	348040a8 <do_load_serial_bin+0x2f0>
			sum += new_char & 0xff;
34803fac:	e6ef0070 	uxtb	r0, r0
			length = len_hi * 95 + len_lo;
34803fb0:	e3a0305f 	mov	r3, #95	; 0x5f
			sum += new_char & 0xff;
34803fb4:	e0855000 	add	r5, r5, r0
			len_lo = untochar (new_char);
34803fb8:	e2400020 	sub	r0, r0, #32
34803fbc:	e6ef0070 	uxtb	r0, r0
			length = len_hi * 95 + len_lo;
34803fc0:	e0230293 	mla	r3, r3, r2, r0
34803fc4:	e58d3004 	str	r3, [sp, #4]
			new_char = getc ();
34803fc8:	eb0015c3 	bl	348096dc <getc>
			if ((new_char & 0xE0) == 0)
34803fcc:	e31000e0 	tst	r0, #224	; 0xe0
			new_char = getc ();
34803fd0:	e6ef1070 	uxtb	r1, r0
			if ((new_char & 0xE0) == 0)
34803fd4:	e59d3004 	ldr	r3, [sp, #4]
34803fd8:	0a000032 	beq	348040a8 <do_load_serial_bin+0x2f0>
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34803fdc:	e7e12355 	ubfx	r2, r5, #6, #2
34803fe0:	e0822005 	add	r2, r2, r5
34803fe4:	e202203f 	and	r2, r2, #63	; 0x3f
34803fe8:	e2822020 	add	r2, r2, #32
34803fec:	e1510002 	cmp	r1, r2
			sum += new_char & 0xff;
34803ff0:	00855001 	addeq	r5, r5, r1
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34803ff4:	1a00002b 	bne	348040a8 <do_load_serial_bin+0x2f0>
34803ff8:	ea00000d 	b	34804034 <do_load_serial_bin+0x27c>
34803ffc:	e58d3004 	str	r3, [sp, #4]
			new_char = getc ();
34804000:	eb0015b5 	bl	348096dc <getc>
			if ((new_char & 0xE0) == 0)
34804004:	e31000e0 	tst	r0, #224	; 0xe0
			new_char = getc ();
34804008:	e6ef2070 	uxtb	r2, r0
			if ((new_char & 0xE0) == 0)
3480400c:	0a000025 	beq	348040a8 <do_load_serial_bin+0x2f0>
			--length;
34804010:	e59d3004 	ldr	r3, [sp, #4]
			if (k_state == DATA_TYPE) {
34804014:	e35b0044 	cmp	fp, #68	; 0x44
			sum += new_char & 0xff;
34804018:	e0855002 	add	r5, r5, r2
			--length;
3480401c:	e2433001 	sub	r3, r3, #1
			if (k_state == DATA_TYPE) {
34804020:	1a000006 	bne	34804040 <do_load_serial_bin+0x288>
				k_data_char (new_char);
34804024:	e1a00002 	mov	r0, r2
34804028:	e58d3004 	str	r3, [sp, #4]
3480402c:	ebfffedc 	bl	34803ba4 <k_data_char>
34804030:	e59d3004 	ldr	r3, [sp, #4]
		while (length > 1) {
34804034:	e3530001 	cmp	r3, #1
34804038:	caffffef 	bgt	34803ffc <do_load_serial_bin+0x244>
3480403c:	ea00000b 	b	34804070 <do_load_serial_bin+0x2b8>
			} else if (k_state == SEND_TYPE) {
34804040:	e35b0053 	cmp	fp, #83	; 0x53
34804044:	1afffffa 	bne	34804034 <do_load_serial_bin+0x27c>
				*send_ptr++ = new_char;
34804048:	e5961048 	ldr	r1, [r6, #72]	; 0x48
3480404c:	e2810001 	add	r0, r1, #1
34804050:	e5860048 	str	r0, [r6, #72]	; 0x48
34804054:	e5c12000 	strb	r2, [r1]
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
34804058:	e59f118c 	ldr	r1, [pc, #396]	; 348041ec <do_load_serial_bin+0x434>
3480405c:	e5962048 	ldr	r2, [r6, #72]	; 0x48
34804060:	e1520001 	cmp	r2, r1
					--send_ptr;
34804064:	22422001 	subcs	r2, r2, #1
34804068:	25012018 	strcs	r2, [r1, #-24]	; 0xffffffe8
3480406c:	eafffff0 	b	34804034 <do_load_serial_bin+0x27c>
		new_char = getc ();
34804070:	eb001599 	bl	348096dc <getc>
		if ((new_char & 0xE0) == 0)
34804074:	e31000e0 	tst	r0, #224	; 0xe0
34804078:	0a00000a 	beq	348040a8 <do_load_serial_bin+0x2f0>
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
3480407c:	e7e13355 	ubfx	r3, r5, #6, #2
34804080:	e6ef0070 	uxtb	r0, r0
34804084:	e0835005 	add	r5, r3, r5
34804088:	e205503f 	and	r5, r5, #63	; 0x3f
3480408c:	e2855020 	add	r5, r5, #32
34804090:	e1500005 	cmp	r0, r5
34804094:	1a000003 	bne	348040a8 <do_load_serial_bin+0x2f0>
		new_char = getc ();
34804098:	eb00158f 	bl	348096dc <getc>
		if (new_char != END_CHAR) {
3480409c:	e6ef0070 	uxtb	r0, r0
348040a0:	e350000d 	cmp	r0, #13
348040a4:	0a000008 	beq	348040cc <do_load_serial_bin+0x314>
		n = untochar (new_char);
348040a8:	e1a05004 	mov	r5, r4
			k_data_restore ();
348040ac:	ebfffeb3 	bl	34803b80 <k_data_restore>
			send_nack (n);
348040b0:	e1a00004 	mov	r0, r4
348040b4:	ebfffe8b 	bl	34803ae8 <send_nack>
348040b8:	e1a02004 	mov	r2, r4
348040bc:	e1a04005 	mov	r4, r5
		n = untochar (new_char);
348040c0:	e1a05004 	mov	r5, r4
348040c4:	e1a04002 	mov	r4, r2
348040c8:	eaffff85 	b	34803ee4 <do_load_serial_bin+0x12c>
		} else if (k_state == SEND_TYPE) {
348040cc:	e35b0053 	cmp	fp, #83	; 0x53
			handle_send_packet (n);
348040d0:	e1a00004 	mov	r0, r4
		} else if (k_state == SEND_TYPE) {
348040d4:	1a000002 	bne	348040e4 <do_load_serial_bin+0x32c>
			handle_send_packet (n);
348040d8:	ebfffec5 	bl	34803bf4 <handle_send_packet>
		n = untochar (new_char);
348040dc:	e1a02004 	mov	r2, r4
348040e0:	eafffff6 	b	348040c0 <do_load_serial_bin+0x308>
			send_ack (n);
348040e4:	ebfffe68 	bl	34803a8c <send_ack>
	while (!done) {
348040e8:	e35b0042 	cmp	fp, #66	; 0x42
348040ec:	1afffffa 	bne	348040dc <do_load_serial_bin+0x324>
	return ((ulong) os_data_addr - (ulong) bin_start_address);
348040f0:	e9960028 	ldmib	r6, {r3, r5}
348040f4:	e0435005 	sub	r5, r3, r5
				return (0);
348040f8:	e3a04064 	mov	r4, #100	; 0x64
		if (tstc()) {
348040fc:	eb001582 	bl	3480970c <tstc>
34804100:	e3500000 	cmp	r0, #0
34804104:	0a000000 	beq	3480410c <do_load_serial_bin+0x354>
			(void) getc();
34804108:	eb001573 	bl	348096dc <getc>
		udelay(1000);
3480410c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34804110:	eb005f3d 	bl	3481be0c <udelay>
	for (i=0; i<100; ++i) {
34804114:	e2544001 	subs	r4, r4, #1
34804118:	1afffff7 	bne	348040fc <do_load_serial_bin+0x344>
	flush_cache (offset, size);
3480411c:	e1a01005 	mov	r1, r5
34804120:	e1a00007 	mov	r0, r7
34804124:	ebfff32b 	bl	34800dd8 <flush_cache>
	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34804128:	e1a02005 	mov	r2, r5
3480412c:	e1a01005 	mov	r1, r5
34804130:	e59f00b8 	ldr	r0, [pc, #184]	; 348041f0 <do_load_serial_bin+0x438>
34804134:	eb001598 	bl	3480979c <printf>
	sprintf(buf, "%X", size);
34804138:	e1a02005 	mov	r2, r5
3480413c:	e59f10b0 	ldr	r1, [pc, #176]	; 348041f4 <do_load_serial_bin+0x43c>
34804140:	e28d0008 	add	r0, sp, #8
34804144:	e59f50ac 	ldr	r5, [pc, #172]	; 348041f8 <do_load_serial_bin+0x440>
34804148:	eb00622e 	bl	3481ca08 <sprintf>
	setenv("filesize", buf);
3480414c:	e28d1008 	add	r1, sp, #8
34804150:	e59f00a4 	ldr	r0, [pc, #164]	; 348041fc <do_load_serial_bin+0x444>
34804154:	eb000d86 	bl	34807774 <setenv>
		if (addr == ~0) {
34804158:	e3770001 	cmn	r7, #1
3480415c:	1a000004 	bne	34804174 <do_load_serial_bin+0x3bc>
			printf ("## Binary (kermit) download aborted\n");
34804160:	e59f0098 	ldr	r0, [pc, #152]	; 34804200 <do_load_serial_bin+0x448>
			load_addr = 0;
34804164:	e5854000 	str	r4, [r5]
			rcode = 1;
34804168:	e3a04001 	mov	r4, #1
			printf ("## Binary (kermit) download aborted\n");
3480416c:	eb00158a 	bl	3480979c <printf>
34804170:	ea000003 	b	34804184 <do_load_serial_bin+0x3cc>
			printf ("## Start Addr      = 0x%08lX\n", addr);
34804174:	e1a01007 	mov	r1, r7
34804178:	e59f0084 	ldr	r0, [pc, #132]	; 34804204 <do_load_serial_bin+0x44c>
3480417c:	eb001586 	bl	3480979c <printf>
			load_addr = addr;
34804180:	e5857000 	str	r7, [r5]
	if (load_baudrate != current_baudrate) {
34804184:	e159000a 	cmp	r9, sl
34804188:	0a00000b 	beq	348041bc <do_load_serial_bin+0x404>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
3480418c:	e1a0100a 	mov	r1, sl
34804190:	e59f0070 	ldr	r0, [pc, #112]	; 34804208 <do_load_serial_bin+0x450>
34804194:	eb001580 	bl	3480979c <printf>
		udelay (50000);
34804198:	e30c0350 	movw	r0, #50000	; 0xc350
3480419c:	eb005f1a 	bl	3481be0c <udelay>
		gd->baudrate = current_baudrate;
348041a0:	e588a008 	str	sl, [r8, #8]
		serial_setbrg ();
348041a4:	eb002a11 	bl	3480e9f0 <serial_setbrg>
		udelay (50000);
348041a8:	e30c0350 	movw	r0, #50000	; 0xc350
348041ac:	eb005f16 	bl	3481be0c <udelay>
			if (getc() == 0x1B) /* ESC */
348041b0:	eb001549 	bl	348096dc <getc>
348041b4:	e350001b 	cmp	r0, #27
348041b8:	1afffffc 	bne	348041b0 <do_load_serial_bin+0x3f8>
}
348041bc:	e1a00004 	mov	r0, r4
348041c0:	e28dd028 	add	sp, sp, #40	; 0x28
348041c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348041c8:	34821665 	.word	0x34821665
348041cc:	348227e4 	.word	0x348227e4
348041d0:	34822816 	.word	0x34822816
348041d4:	3482281c 	.word	0x3482281c
348041d8:	3482285b 	.word	0x3482285b
348041dc:	3482870c 	.word	0x3482870c
348041e0:	348035d4 	.word	0x348035d4
348041e4:	348036f4 	.word	0x348036f4
348041e8:	34828758 	.word	0x34828758
348041ec:	3482876c 	.word	0x3482876c
348041f0:	348226e9 	.word	0x348226e9
348041f4:	34822711 	.word	0x34822711
348041f8:	348271b4 	.word	0x348271b4
348041fc:	34821f6d 	.word	0x34821f6d
34804200:	3482289a 	.word	0x3482289a
34804204:	348227c6 	.word	0x348227c6
34804208:	348228bf 	.word	0x348228bf

3480420c <do_mem_mw>:
int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
3480420c:	e2421003 	sub	r1, r2, #3
34804210:	e3510001 	cmp	r1, #1
34804214:	8a000026 	bhi	348042b4 <do_mem_mw+0xa8>
{
34804218:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
3480421c:	e3a01004 	mov	r1, #4
34804220:	e5930000 	ldr	r0, [r3]
34804224:	e1a05003 	mov	r5, r3
34804228:	e1a06002 	mov	r6, r2
3480422c:	eb001479 	bl	34809418 <cmd_get_data_size>
34804230:	e2507000 	subs	r7, r0, #0
34804234:	da000020 	ble	348042bc <do_mem_mw+0xb0>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804238:	e3a02010 	mov	r2, #16
3480423c:	e3a01000 	mov	r1, #0
34804240:	e5950004 	ldr	r0, [r5, #4]
34804244:	eb006146 	bl	3481c764 <simple_strtoul>
	addr += base_address;
34804248:	e59f3074 	ldr	r3, [pc, #116]	; 348042c4 <do_mem_mw+0xb8>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
3480424c:	e3a02010 	mov	r2, #16
34804250:	e3a01000 	mov	r1, #0
	addr += base_address;
34804254:	e5934000 	ldr	r4, [r3]
34804258:	e0804004 	add	r4, r0, r4
	writeval = simple_strtoul(argv[2], NULL, 16);
3480425c:	e5950008 	ldr	r0, [r5, #8]
34804260:	eb00613f 	bl	3481c764 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
34804264:	e3560004 	cmp	r6, #4
	writeval = simple_strtoul(argv[2], NULL, 16);
34804268:	e1a09000 	mov	r9, r0
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
3480426c:	13a00001 	movne	r0, #1
	if (argc == 4) {
34804270:	1a00000b 	bne	348042a4 <do_mem_mw+0x98>
		count = simple_strtoul(argv[3], NULL, 16);
34804274:	e3a02010 	mov	r2, #16
34804278:	e3a01000 	mov	r1, #0
3480427c:	e595000c 	ldr	r0, [r5, #12]
34804280:	eb006137 	bl	3481c764 <simple_strtoul>
34804284:	ea000006 	b	348042a4 <do_mem_mw+0x98>
	}

	while (count-- > 0) {
		if (size == 4)
34804288:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
3480428c:	05849000 	streq	r9, [r4]
		if (size == 4)
34804290:	0a000002 	beq	348042a0 <do_mem_mw+0x94>
		else if (size == 2)
34804294:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
34804298:	01c490b0 	strheq	r9, [r4]
		else
			*((u_char *)addr) = (u_char)writeval;
3480429c:	15c49000 	strbne	r9, [r4]
348042a0:	e0844007 	add	r4, r4, r7
	while (count-- > 0) {
348042a4:	e2500001 	subs	r0, r0, #1
348042a8:	2afffff6 	bcs	34804288 <do_mem_mw+0x7c>
		addr += size;
	}
	return 0;
348042ac:	e3a00000 	mov	r0, #0
348042b0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return CMD_RET_USAGE;
348042b4:	e3e00000 	mvn	r0, #0
}
348042b8:	e12fff1e 	bx	lr
		return 1;
348042bc:	e3a00001 	mov	r0, #1
}
348042c0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348042c4:	3482876c 	.word	0x3482876c

348042c8 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
348042c8:	e3520002 	cmp	r2, #2
348042cc:	da000034 	ble	348043a4 <do_mem_loop+0xdc>
{
348042d0:	e92d4070 	push	{r4, r5, r6, lr}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348042d4:	e3a01004 	mov	r1, #4
348042d8:	e5930000 	ldr	r0, [r3]
348042dc:	e1a05003 	mov	r5, r3
348042e0:	eb00144c 	bl	34809418 <cmd_get_data_size>
348042e4:	e2506000 	subs	r6, r0, #0
348042e8:	ba00002f 	blt	348043ac <do_mem_loop+0xe4>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
348042ec:	e3a02010 	mov	r2, #16
348042f0:	e3a01000 	mov	r1, #0
348042f4:	e5950004 	ldr	r0, [r5, #4]
348042f8:	eb006119 	bl	3481c764 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
348042fc:	e3a02010 	mov	r2, #16
	addr = simple_strtoul(argv[1], NULL, 16);
34804300:	e1a04000 	mov	r4, r0
	length = simple_strtoul(argv[2], NULL, 16);
34804304:	e3a01000 	mov	r1, #0
34804308:	e5950008 	ldr	r0, [r5, #8]
3480430c:	eb006114 	bl	3481c764 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
34804310:	e3500001 	cmp	r0, #1
34804314:	1a000009 	bne	34804340 <do_mem_loop+0x78>
		if (size == 4) {
34804318:	e3560004 	cmp	r6, #4
3480431c:	1a000001 	bne	34804328 <do_mem_loop+0x60>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
34804320:	e5943000 	ldr	r3, [r4]
34804324:	eafffffd 	b	34804320 <do_mem_loop+0x58>
		}
		if (size == 2) {
34804328:	e3560002 	cmp	r6, #2
3480432c:	1a000001 	bne	34804338 <do_mem_loop+0x70>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
34804330:	e1d430b0 	ldrh	r3, [r4]
34804334:	eafffffd 	b	34804330 <do_mem_loop+0x68>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
34804338:	e5d43000 	ldrb	r3, [r4]
3480433c:	eafffffd 	b	34804338 <do_mem_loop+0x70>
	}

	if (size == 4) {
34804340:	e3560004 	cmp	r6, #4
34804344:	1a000006 	bne	34804364 <do_mem_loop+0x9c>
		for (;;) {
			longp = (uint *)addr;
34804348:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
3480434c:	e1a03000 	mov	r3, r0
34804350:	e2533001 	subs	r3, r3, #1
34804354:	3afffffb 	bcc	34804348 <do_mem_loop+0x80>
				*longp++;
34804358:	e5921000 	ldr	r1, [r2]
3480435c:	e2822004 	add	r2, r2, #4
34804360:	eafffffa 	b	34804350 <do_mem_loop+0x88>
		}
	}
	if (size == 2) {
34804364:	e3560002 	cmp	r6, #2
34804368:	10800004 	addne	r0, r0, r4
3480436c:	1a000006 	bne	3480438c <do_mem_loop+0xc4>
		for (;;) {
			shortp = (ushort *)addr;
34804370:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
34804374:	e1a03000 	mov	r3, r0
34804378:	e2533001 	subs	r3, r3, #1
3480437c:	3afffffb 	bcc	34804370 <do_mem_loop+0xa8>
				*shortp++;
34804380:	e1d210b0 	ldrh	r1, [r2]
34804384:	e2822002 	add	r2, r2, #2
34804388:	eafffffa 	b	34804378 <do_mem_loop+0xb0>
		}
	}
	for (;;) {
		cp = (u_char *)addr;
3480438c:	e1a03004 	mov	r3, r4
		i = length;
		while (i-- > 0)
34804390:	e1530000 	cmp	r3, r0
34804394:	0afffffc 	beq	3480438c <do_mem_loop+0xc4>
			*cp++;
34804398:	e5d32000 	ldrb	r2, [r3]
3480439c:	e2833001 	add	r3, r3, #1
348043a0:	eafffffa 	b	34804390 <do_mem_loop+0xc8>
		return CMD_RET_USAGE;
348043a4:	e3e00000 	mvn	r0, #0
	}
}
348043a8:	e12fff1e 	bx	lr
		return 1;
348043ac:	e3a00001 	mov	r0, #1
}
348043b0:	e8bd8070 	pop	{r4, r5, r6, pc}

348043b4 <do_mem_md>:
{
348043b4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc < 2)
348043b8:	e3520001 	cmp	r2, #1
	length = dp_last_length;
348043bc:	e59f90b4 	ldr	r9, [pc, #180]	; 34804478 <do_mem_md+0xc4>
		return CMD_RET_USAGE;
348043c0:	d3e00000 	mvnle	r0, #0
	addr = dp_last_addr;
348043c4:	e59f50b0 	ldr	r5, [pc, #176]	; 3480447c <do_mem_md+0xc8>
	length = dp_last_length;
348043c8:	e599a000 	ldr	sl, [r9]
348043cc:	e58d900c 	str	r9, [sp, #12]
	size = dp_last_size;
348043d0:	e9950050 	ldmib	r5, {r4, r6}
	if (argc < 2)
348043d4:	da000025 	ble	34804470 <do_mem_md+0xbc>
	if ((flag & CMD_FLAG_REPEAT) == 0) {
348043d8:	e2117001 	ands	r7, r1, #1
348043dc:	e1a09003 	mov	r9, r3
348043e0:	e1a0b002 	mov	fp, r2
348043e4:	1a000012 	bne	34804434 <do_mem_md+0x80>
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348043e8:	e3a01004 	mov	r1, #4
348043ec:	e5930000 	ldr	r0, [r3]
348043f0:	eb001408 	bl	34809418 <cmd_get_data_size>
348043f4:	e2506000 	subs	r6, r0, #0
			return 1;
348043f8:	b3a00001 	movlt	r0, #1
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348043fc:	ba00001b 	blt	34804470 <do_mem_md+0xbc>
		addr = simple_strtoul(argv[1], NULL, 16);
34804400:	e3a02010 	mov	r2, #16
34804404:	e1a01007 	mov	r1, r7
34804408:	e5990004 	ldr	r0, [r9, #4]
3480440c:	eb0060d4 	bl	3481c764 <simple_strtoul>
		addr += base_address;
34804410:	e5954000 	ldr	r4, [r5]
		if (argc > 2)
34804414:	e35b0002 	cmp	fp, #2
		addr += base_address;
34804418:	e0804004 	add	r4, r0, r4
		if (argc > 2)
3480441c:	0a000004 	beq	34804434 <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
34804420:	e3a02010 	mov	r2, #16
34804424:	e1a01007 	mov	r1, r7
34804428:	e5990008 	ldr	r0, [r9, #8]
3480442c:	eb0060cc 	bl	3481c764 <simple_strtoul>
34804430:	e1a0a000 	mov	sl, r0
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804434:	e1a01006 	mov	r1, r6
34804438:	e3a00010 	mov	r0, #16
3480443c:	fa006b95 	blx	3481f298 <__divsi3>
34804440:	e1a0300a 	mov	r3, sl
34804444:	e58d0000 	str	r0, [sp]
34804448:	e1a01004 	mov	r1, r4
3480444c:	e1a00004 	mov	r0, r4
34804450:	e1a02006 	mov	r2, r6
		addr += size*length;
34804454:	e024469a 	mla	r4, sl, r6, r4
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804458:	eb0056e5 	bl	34819ff4 <print_buffer>
	dp_last_length = length;
3480445c:	e59d300c 	ldr	r3, [sp, #12]
	return (rc);
34804460:	e3a00000 	mov	r0, #0
	dp_last_addr = addr;
34804464:	e5854004 	str	r4, [r5, #4]
	dp_last_size = size;
34804468:	e5856008 	str	r6, [r5, #8]
	dp_last_length = length;
3480446c:	e583a000 	str	sl, [r3]
}
34804470:	e28dd010 	add	sp, sp, #16
34804474:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34804478:	348270e8 	.word	0x348270e8
3480447c:	3482876c 	.word	0x3482876c

34804480 <do_mem_cmp>:
	if (argc != 4)
34804480:	e3520004 	cmp	r2, #4
34804484:	1a000047 	bne	348045a8 <do_mem_cmp+0x128>
{
34804488:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480448c:	e1a01002 	mov	r1, r2
34804490:	e24dd018 	sub	sp, sp, #24
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804494:	e5930000 	ldr	r0, [r3]
34804498:	e1a09003 	mov	r9, r3
3480449c:	eb0013dd 	bl	34809418 <cmd_get_data_size>
348044a0:	e2506000 	subs	r6, r0, #0
		return 1;
348044a4:	b3a00001 	movlt	r0, #1
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348044a8:	ba000040 	blt	348045b0 <do_mem_cmp+0x130>
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
348044ac:	e3560004 	cmp	r6, #4
348044b0:	059f7100 	ldreq	r7, [pc, #256]	; 348045b8 <do_mem_cmp+0x138>
348044b4:	0a000003 	beq	348044c8 <do_mem_cmp+0x48>
348044b8:	e59f30fc 	ldr	r3, [pc, #252]	; 348045bc <do_mem_cmp+0x13c>
348044bc:	e3560002 	cmp	r6, #2
348044c0:	e59f70f8 	ldr	r7, [pc, #248]	; 348045c0 <do_mem_cmp+0x140>
348044c4:	11a07003 	movne	r7, r3
	addr1 += base_address;
348044c8:	e59f40f4 	ldr	r4, [pc, #244]	; 348045c4 <do_mem_cmp+0x144>
	addr1 = simple_strtoul(argv[1], NULL, 16);
348044cc:	e3a02010 	mov	r2, #16
348044d0:	e3a01000 	mov	r1, #0
348044d4:	e5990004 	ldr	r0, [r9, #4]
348044d8:	eb0060a1 	bl	3481c764 <simple_strtoul>
	addr1 += base_address;
348044dc:	e5942000 	ldr	r2, [r4]
	addr2 = simple_strtoul(argv[2], NULL, 16);
348044e0:	e3a01000 	mov	r1, #0
	addr1 += base_address;
348044e4:	e0805002 	add	r5, r0, r2
	addr2 = simple_strtoul(argv[2], NULL, 16);
348044e8:	e3a02010 	mov	r2, #16
348044ec:	e5990008 	ldr	r0, [r9, #8]
348044f0:	eb00609b 	bl	3481c764 <simple_strtoul>
	addr2 += base_address;
348044f4:	e594c000 	ldr	ip, [r4]
	count = simple_strtoul(argv[3], NULL, 16);
348044f8:	e3a02010 	mov	r2, #16
348044fc:	e3a01000 	mov	r1, #0
	addr2 += base_address;
34804500:	e080400c 	add	r4, r0, ip
	count = simple_strtoul(argv[3], NULL, 16);
34804504:	e599000c 	ldr	r0, [r9, #12]
34804508:	eb006095 	bl	3481c764 <simple_strtoul>
	addr2 += base_address;
3480450c:	e1a0c004 	mov	ip, r4
	count = simple_strtoul(argv[3], NULL, 16);
34804510:	e1a01000 	mov	r1, r0
	addr1 += base_address;
34804514:	e1a02005 	mov	r2, r5
34804518:	e06c0005 	rsb	r0, ip, r5
	for (ngood = 0; ngood < count; ++ngood) {
3480451c:	e3a04000 	mov	r4, #0
34804520:	e065500c 	rsb	r5, r5, ip
34804524:	e1540001 	cmp	r4, r1
34804528:	0a000018 	beq	34804590 <do_mem_cmp+0x110>
		if (size == 4) {
3480452c:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
34804530:	05923000 	ldreq	r3, [r2]
			word2 = *(ulong *)addr2;
34804534:	059ce000 	ldreq	lr, [ip]
		if (size == 4) {
34804538:	0a000004 	beq	34804550 <do_mem_cmp+0xd0>
		} else if (size == 2) {
3480453c:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
34804540:	01d230b0 	ldrheq	r3, [r2]
			word2 = *(ushort *)addr2;
34804544:	01dce0b0 	ldrheq	lr, [ip]
			word1 = *(u_char *)addr1;
34804548:	17d0300c 	ldrbne	r3, [r0, ip]
			word2 = *(u_char *)addr2;
3480454c:	17d5e002 	ldrbne	lr, [r5, r2]
		if (word1 != word2) {
34804550:	e153000e 	cmp	r3, lr
34804554:	0a000009 	beq	34804580 <do_mem_cmp+0x100>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804558:	e88d1088 	stm	sp, {r3, r7, ip}
3480455c:	e1a01007 	mov	r1, r7
34804560:	e58de010 	str	lr, [sp, #16]
34804564:	e1a03006 	mov	r3, r6
34804568:	e58d600c 	str	r6, [sp, #12]
3480456c:	e59f0054 	ldr	r0, [pc, #84]	; 348045c8 <do_mem_cmp+0x148>
34804570:	eb001489 	bl	3480979c <printf>
			break;
34804574:	e1a01004 	mov	r1, r4
			rcode = 1;
34804578:	e3a04001 	mov	r4, #1
			break;
3480457c:	ea000004 	b	34804594 <do_mem_cmp+0x114>
34804580:	e0822006 	add	r2, r2, r6
34804584:	e08cc006 	add	ip, ip, r6
	for (ngood = 0; ngood < count; ++ngood) {
34804588:	e2844001 	add	r4, r4, #1
3480458c:	eaffffe4 	b	34804524 <do_mem_cmp+0xa4>
	int     rcode = 0;
34804590:	e3a04000 	mov	r4, #0
	printf("Total of %ld %s(s) were the same\n", ngood, type);
34804594:	e1a02007 	mov	r2, r7
34804598:	e59f002c 	ldr	r0, [pc, #44]	; 348045cc <do_mem_cmp+0x14c>
3480459c:	eb00147e 	bl	3480979c <printf>
	return rcode;
348045a0:	e1a00004 	mov	r0, r4
348045a4:	ea000001 	b	348045b0 <do_mem_cmp+0x130>
		return CMD_RET_USAGE;
348045a8:	e3e00000 	mvn	r0, #0
}
348045ac:	e12fff1e 	bx	lr
348045b0:	e28dd018 	add	sp, sp, #24
348045b4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348045b8:	34822a2b 	.word	0x34822a2b
348045bc:	34822a22 	.word	0x34822a22
348045c0:	34822a27 	.word	0x34822a27
348045c4:	3482876c 	.word	0x3482876c
348045c8:	34822a30 	.word	0x34822a30
348045cc:	34822a62 	.word	0x34822a62

348045d0 <do_mem_base>:
	if (argc > 1) {
348045d0:	e3520001 	cmp	r2, #1
{
348045d4:	e92d4010 	push	{r4, lr}
348045d8:	e59f4028 	ldr	r4, [pc, #40]	; 34804608 <do_mem_base+0x38>
	if (argc > 1) {
348045dc:	da000004 	ble	348045f4 <do_mem_base+0x24>
		base_address = simple_strtoul(argv[1], NULL, 16);
348045e0:	e3a02010 	mov	r2, #16
348045e4:	e3a01000 	mov	r1, #0
348045e8:	e5930004 	ldr	r0, [r3, #4]
348045ec:	eb00605c 	bl	3481c764 <simple_strtoul>
348045f0:	e5840000 	str	r0, [r4]
	printf("Base Address: 0x%08lx\n", base_address);
348045f4:	e5941000 	ldr	r1, [r4]
348045f8:	e59f000c 	ldr	r0, [pc, #12]	; 3480460c <do_mem_base+0x3c>
348045fc:	eb001466 	bl	3480979c <printf>
}
34804600:	e3a00000 	mov	r0, #0
34804604:	e8bd8010 	pop	{r4, pc}
34804608:	3482876c 	.word	0x3482876c
3480460c:	34822a84 	.word	0x34822a84

34804610 <do_mem_cp>:
	if (argc != 4)
34804610:	e3520004 	cmp	r2, #4
34804614:	1a00002c 	bne	348046cc <do_mem_cp+0xbc>
{
34804618:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480461c:	e1a01002 	mov	r1, r2
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804620:	e5930000 	ldr	r0, [r3]
34804624:	e1a06003 	mov	r6, r3
34804628:	eb00137a 	bl	34809418 <cmd_get_data_size>
3480462c:	e2507000 	subs	r7, r0, #0
34804630:	ba000027 	blt	348046d4 <do_mem_cp+0xc4>
	addr += base_address;
34804634:	e59f40a0 	ldr	r4, [pc, #160]	; 348046dc <do_mem_cp+0xcc>
	addr = simple_strtoul(argv[1], NULL, 16);
34804638:	e3a02010 	mov	r2, #16
3480463c:	e3a01000 	mov	r1, #0
34804640:	e5960004 	ldr	r0, [r6, #4]
34804644:	eb006046 	bl	3481c764 <simple_strtoul>
	addr += base_address;
34804648:	e5942000 	ldr	r2, [r4]
	dest = simple_strtoul(argv[2], NULL, 16);
3480464c:	e3a01000 	mov	r1, #0
	addr += base_address;
34804650:	e0805002 	add	r5, r0, r2
	dest = simple_strtoul(argv[2], NULL, 16);
34804654:	e3a02010 	mov	r2, #16
34804658:	e5960008 	ldr	r0, [r6, #8]
3480465c:	eb006040 	bl	3481c764 <simple_strtoul>
	dest += base_address;
34804660:	e5944000 	ldr	r4, [r4]
	count = simple_strtoul(argv[3], NULL, 16);
34804664:	e3a02010 	mov	r2, #16
34804668:	e3a01000 	mov	r1, #0
	dest += base_address;
3480466c:	e0804004 	add	r4, r0, r4
	count = simple_strtoul(argv[3], NULL, 16);
34804670:	e596000c 	ldr	r0, [r6, #12]
34804674:	eb00603a 	bl	3481c764 <simple_strtoul>
	if (count == 0) {
34804678:	e3500000 	cmp	r0, #0
3480467c:	11a03004 	movne	r3, r4
34804680:	10632005 	rsbne	r2, r3, r5
34804684:	1a00000c 	bne	348046bc <do_mem_cp+0xac>
		puts ("Zero length ???\n");
34804688:	e59f0050 	ldr	r0, [pc, #80]	; 348046e0 <do_mem_cp+0xd0>
3480468c:	eb001436 	bl	3480976c <puts>
34804690:	ea00000f 	b	348046d4 <do_mem_cp+0xc4>
		if (size == 4)
34804694:	e3570004 	cmp	r7, #4
			*((ulong  *)dest) = *((ulong  *)addr);
34804698:	07921003 	ldreq	r1, [r2, r3]
3480469c:	05831000 	streq	r1, [r3]
		if (size == 4)
348046a0:	0a000004 	beq	348046b8 <do_mem_cp+0xa8>
		else if (size == 2)
348046a4:	e3570002 	cmp	r7, #2
			*((ushort *)dest) = *((ushort *)addr);
348046a8:	019210b3 	ldrheq	r1, [r2, r3]
			*((u_char *)dest) = *((u_char *)addr);
348046ac:	17d21003 	ldrbne	r1, [r2, r3]
			*((ushort *)dest) = *((ushort *)addr);
348046b0:	01c310b0 	strheq	r1, [r3]
			*((u_char *)dest) = *((u_char *)addr);
348046b4:	15c31000 	strbne	r1, [r3]
348046b8:	e0833007 	add	r3, r3, r7
	while (count-- > 0) {
348046bc:	e2500001 	subs	r0, r0, #1
348046c0:	2afffff3 	bcs	34804694 <do_mem_cp+0x84>
	return 0;
348046c4:	e3a00000 	mov	r0, #0
348046c8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return CMD_RET_USAGE;
348046cc:	e3e00000 	mvn	r0, #0
}
348046d0:	e12fff1e 	bx	lr
		return 1;
348046d4:	e3a00001 	mov	r0, #1
}
348046d8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348046dc:	3482876c 	.word	0x3482876c
348046e0:	34822a9b 	.word	0x34822a9b

348046e4 <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
348046e4:	e3520001 	cmp	r2, #1
{
348046e8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348046ec:	e1a06002 	mov	r6, r2
	if (argc > 1)
348046f0:	da000055 	ble	3480484c <do_mem_mtest+0x168>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348046f4:	e3a02010 	mov	r2, #16
348046f8:	e3a01000 	mov	r1, #0
348046fc:	e5930004 	ldr	r0, [r3, #4]
34804700:	e1a05003 	mov	r5, r3
34804704:	eb006016 	bl	3481c764 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
34804708:	e3560002 	cmp	r6, #2
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
3480470c:	e58d0000 	str	r0, [sp]
	if (argc > 2)
34804710:	0a00004f 	beq	34804854 <do_mem_mtest+0x170>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
34804714:	e3a02010 	mov	r2, #16
34804718:	e3a01000 	mov	r1, #0
3480471c:	e5950008 	ldr	r0, [r5, #8]
34804720:	eb00600f 	bl	3481c764 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
34804724:	e3560003 	cmp	r6, #3
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
34804728:	e58d0004 	str	r0, [sp, #4]
	if (argc > 3)
3480472c:	0a00004a 	beq	3480485c <do_mem_mtest+0x178>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804730:	e3a02010 	mov	r2, #16
34804734:	e3a01000 	mov	r1, #0
34804738:	e595000c 	ldr	r0, [r5, #12]
3480473c:	eb006008 	bl	3481c764 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
34804740:	e3560004 	cmp	r6, #4
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804744:	e1a04000 	mov	r4, r0
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34804748:	03a09000 	moveq	r9, #0
	if (argc > 4)
3480474c:	0a000004 	beq	34804764 <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
34804750:	e3a02010 	mov	r2, #16
34804754:	e3a01000 	mov	r1, #0
34804758:	e5950010 	ldr	r0, [r5, #16]
3480475c:	eb006000 	bl	3481c764 <simple_strtoul>
34804760:	e1a09000 	mov	r9, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
34804764:	e3a06001 	mov	r6, #1
	ulong	errs = 0;
34804768:	e3a05000 	mov	r5, #0
	int iterations = 1;
3480476c:	e1a0a006 	mov	sl, r6
	for (;;) {
		if (ctrlc()) {
34804770:	eb00142b 	bl	34809824 <ctrlc>
34804774:	e3500000 	cmp	r0, #0
34804778:	0a000003 	beq	3480478c <do_mem_mtest+0xa8>
			putc ('\n');
3480477c:	e3a0000a 	mov	r0, #10
34804780:	eb0013ed 	bl	3480973c <putc>
			return 1;
34804784:	e3a00001 	mov	r0, #1
34804788:	ea000036 	b	34804868 <do_mem_mtest+0x184>
		}

		if (iteration_limit && iterations > iteration_limit) {
3480478c:	e3590000 	cmp	r9, #0
34804790:	115a0009 	cmpne	sl, r9
34804794:	da000006 	ble	348047b4 <do_mem_mtest+0xd0>
			printf("Tested %d iteration(s) with %lu errors.\n",
34804798:	e1a02005 	mov	r2, r5
3480479c:	e24a1001 	sub	r1, sl, #1
348047a0:	e59f00c8 	ldr	r0, [pc, #200]	; 34804870 <do_mem_mtest+0x18c>
348047a4:	eb0013fc 	bl	3480979c <printf>
				iterations-1, errs);
			return errs != 0;
348047a8:	e2950000 	adds	r0, r5, #0
348047ac:	13a00001 	movne	r0, #1
348047b0:	ea00002c 	b	34804868 <do_mem_mtest+0x184>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
348047b4:	e59f20b8 	ldr	r2, [pc, #184]	; 34804874 <do_mem_mtest+0x190>
348047b8:	e1a01004 	mov	r1, r4
348047bc:	e59f00b4 	ldr	r0, [pc, #180]	; 34804878 <do_mem_mtest+0x194>
348047c0:	eb0013f5 	bl	3480979c <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
348047c4:	e59d3000 	ldr	r3, [sp]
348047c8:	e1a02004 	mov	r2, r4
348047cc:	e59d1004 	ldr	r1, [sp, #4]
348047d0:	e1530001 	cmp	r3, r1
			WATCHDOG_RESET();
			*addr = val;
348047d4:	34832004 	strcc	r2, [r3], #4
			val  += incr;
348047d8:	30822006 	addcc	r2, r2, r6
348047dc:	3afffffa 	bcc	348047cc <do_mem_mtest+0xe8>
		}

		puts ("Reading...");
348047e0:	e59f0094 	ldr	r0, [pc, #148]	; 3480487c <do_mem_mtest+0x198>

		for (addr=start,val=pattern; addr<end; addr++) {
348047e4:	e1a0b004 	mov	fp, r4
		puts ("Reading...");
348047e8:	eb0013df 	bl	3480976c <puts>
		for (addr=start,val=pattern; addr<end; addr++) {
348047ec:	e59d7000 	ldr	r7, [sp]
348047f0:	e59d3004 	ldr	r3, [sp, #4]
348047f4:	e1570003 	cmp	r7, r3
348047f8:	2a00000d 	bcs	34804834 <do_mem_mtest+0x150>
			WATCHDOG_RESET();
			readback = *addr;
348047fc:	e5972000 	ldr	r2, [r7]
			if (readback != val) {
34804800:	e152000b 	cmp	r2, fp
34804804:	0a000007 	beq	34804828 <do_mem_mtest+0x144>
				printf ("\nMem error @ 0x%08X: "
34804808:	e1a0300b 	mov	r3, fp
3480480c:	e1a01007 	mov	r1, r7
34804810:	e59f0068 	ldr	r0, [pc, #104]	; 34804880 <do_mem_mtest+0x19c>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
34804814:	e2855001 	add	r5, r5, #1
				printf ("\nMem error @ 0x%08X: "
34804818:	eb0013df 	bl	3480979c <printf>
				if (ctrlc()) {
3480481c:	eb001400 	bl	34809824 <ctrlc>
34804820:	e3500000 	cmp	r0, #0
34804824:	1affffd4 	bne	3480477c <do_mem_mtest+0x98>
					putc ('\n');
					return 1;
				}
			}
			val += incr;
34804828:	e08bb006 	add	fp, fp, r6
		for (addr=start,val=pattern; addr<end; addr++) {
3480482c:	e2877004 	add	r7, r7, #4
34804830:	eaffffee 	b	348047f0 <do_mem_mtest+0x10c>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
34804834:	e3540000 	cmp	r4, #0
		++iterations;
34804838:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
3480483c:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
34804840:	a1e04004 	mvnge	r4, r4
		}
		incr = -incr;
34804844:	e2666000 	rsb	r6, r6, #0
	}
34804848:	eaffffc8 	b	34804770 <do_mem_mtest+0x8c>
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
3480484c:	e3a03202 	mov	r3, #536870912	; 0x20000000
34804850:	e58d3000 	str	r3, [sp]
34804854:	e3a03425 	mov	r3, #620756992	; 0x25000000
34804858:	e58d3004 	str	r3, [sp, #4]
		iteration_limit = 0;
3480485c:	e3a04000 	mov	r4, #0
34804860:	e1a09004 	mov	r9, r4
34804864:	eaffffbe 	b	34804764 <do_mem_mtest+0x80>
#endif
	return 0;	/* not reached */
}
34804868:	e28dd008 	add	sp, sp, #8
3480486c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34804870:	34822aac 	.word	0x34822aac
34804874:	34822afd 	.word	0x34822afd
34804878:	34822ad5 	.word	0x34822ad5
3480487c:	34822afe 	.word	0x34822afe
34804880:	34822b09 	.word	0x34822b09

34804884 <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
34804884:	e3520002 	cmp	r2, #2
34804888:	da000022 	ble	34804918 <do_mem_crc+0x94>
{
3480488c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
34804890:	e3a01000 	mov	r1, #0
34804894:	e1a09002 	mov	r9, r2
34804898:	e5930004 	ldr	r0, [r3, #4]
3480489c:	e3a02010 	mov	r2, #16
348048a0:	e1a04003 	mov	r4, r3
348048a4:	eb005fae 	bl	3481c764 <simple_strtoul>
	addr += base_address;
348048a8:	e59f3078 	ldr	r3, [pc, #120]	; 34804928 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
348048ac:	e3a02010 	mov	r2, #16
348048b0:	e3a01000 	mov	r1, #0
	addr += base_address;
348048b4:	e5935000 	ldr	r5, [r3]
348048b8:	e0805005 	add	r5, r0, r5
	length = simple_strtoul (argv[2], NULL, 16);
348048bc:	e5940008 	ldr	r0, [r4, #8]
348048c0:	eb005fa7 	bl	3481c764 <simple_strtoul>

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
348048c4:	e3a03801 	mov	r3, #65536	; 0x10000
348048c8:	e1a02000 	mov	r2, r0
	length = simple_strtoul (argv[2], NULL, 16);
348048cc:	e1a06000 	mov	r6, r0
	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
348048d0:	e1a01005 	mov	r1, r5
348048d4:	e3a00000 	mov	r0, #0
348048d8:	eb005567 	bl	34819e7c <crc32_wd>
348048dc:	e2462001 	sub	r2, r6, #1

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
348048e0:	e1a03000 	mov	r3, r0
	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
348048e4:	e1a07000 	mov	r7, r0
	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
348048e8:	e0822005 	add	r2, r2, r5
348048ec:	e1a01005 	mov	r1, r5
348048f0:	e59f0034 	ldr	r0, [pc, #52]	; 3480492c <do_mem_crc+0xa8>
348048f4:	eb0013a8 	bl	3480979c <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
348048f8:	e3590003 	cmp	r9, #3
348048fc:	0a000007 	beq	34804920 <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
34804900:	e3a02010 	mov	r2, #16
34804904:	e3a01000 	mov	r1, #0
34804908:	e594000c 	ldr	r0, [r4, #12]
3480490c:	eb005f94 	bl	3481c764 <simple_strtoul>
		*ptr = crc;
34804910:	e5807000 	str	r7, [r0]
34804914:	ea000001 	b	34804920 <do_mem_crc+0x9c>
		return CMD_RET_USAGE;
34804918:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
3480491c:	e12fff1e 	bx	lr
	return 0;
34804920:	e3a00000 	mov	r0, #0
}
34804924:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34804928:	3482876c 	.word	0x3482876c
3480492c:	34822b3b 	.word	0x34822b3b

34804930 <mod_mem.isra.0>:
	if (argc != 2)
34804930:	e3520002 	cmp	r2, #2
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
34804934:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
		return CMD_RET_USAGE;
34804938:	13e00000 	mvnne	r0, #0
	if (argc != 2)
3480493c:	1a000047 	bne	34804a60 <mod_mem.isra.0+0x130>
	addr = mm_last_addr;
34804940:	e59f6120 	ldr	r6, [pc, #288]	; 34804a68 <mod_mem.isra.0+0x138>
	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804944:	e2117001 	ands	r7, r1, #1
34804948:	e1a0a003 	mov	sl, r3
3480494c:	e1a09000 	mov	r9, r0
	addr = mm_last_addr;
34804950:	e596400c 	ldr	r4, [r6, #12]
	size = mm_last_size;
34804954:	e5965010 	ldr	r5, [r6, #16]
	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804958:	1a00000b 	bne	3480498c <mod_mem.isra.0+0x5c>
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
3480495c:	e3a01004 	mov	r1, #4
34804960:	e5930000 	ldr	r0, [r3]
34804964:	eb0012ab 	bl	34809418 <cmd_get_data_size>
34804968:	e2505000 	subs	r5, r0, #0
			return 1;
3480496c:	b3a00001 	movlt	r0, #1
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804970:	ba00003a 	blt	34804a60 <mod_mem.isra.0+0x130>
		addr = simple_strtoul(argv[1], NULL, 16);
34804974:	e3a02010 	mov	r2, #16
34804978:	e1a01007 	mov	r1, r7
3480497c:	e59a0004 	ldr	r0, [sl, #4]
34804980:	eb005f77 	bl	3481c764 <simple_strtoul>
		addr += base_address;
34804984:	e5964000 	ldr	r4, [r6]
34804988:	e0804004 	add	r4, r0, r4
		printf("%08lx:", addr);
3480498c:	e1a01004 	mov	r1, r4
34804990:	e59f00d4 	ldr	r0, [pc, #212]	; 34804a6c <mod_mem.isra.0+0x13c>
34804994:	eb001380 	bl	3480979c <printf>
		if (size == 4)
34804998:	e3550004 	cmp	r5, #4
			printf(" %08x", *((uint   *)addr));
3480499c:	05941000 	ldreq	r1, [r4]
348049a0:	059f00c8 	ldreq	r0, [pc, #200]	; 34804a70 <mod_mem.isra.0+0x140>
		if (size == 4)
348049a4:	0a000004 	beq	348049bc <mod_mem.isra.0+0x8c>
		else if (size == 2)
348049a8:	e3550002 	cmp	r5, #2
			printf(" %04x", *((ushort *)addr));
348049ac:	01d410b0 	ldrheq	r1, [r4]
348049b0:	059f00bc 	ldreq	r0, [pc, #188]	; 34804a74 <mod_mem.isra.0+0x144>
			printf(" %02x", *((u_char *)addr));
348049b4:	15d41000 	ldrbne	r1, [r4]
348049b8:	159f00b8 	ldrne	r0, [pc, #184]	; 34804a78 <mod_mem.isra.0+0x148>
348049bc:	eb001376 	bl	3480979c <printf>
		nbytes = readline (" ? ");
348049c0:	e59f00b4 	ldr	r0, [pc, #180]	; 34804a7c <mod_mem.isra.0+0x14c>
348049c4:	eb00260e 	bl	3480e204 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
348049c8:	e3500000 	cmp	r0, #0
348049cc:	0a00001e 	beq	34804a4c <mod_mem.isra.0+0x11c>
348049d0:	e3500001 	cmp	r0, #1
348049d4:	e59f70a4 	ldr	r7, [pc, #164]	; 34804a80 <mod_mem.isra.0+0x150>
348049d8:	1a000002 	bne	348049e8 <mod_mem.isra.0+0xb8>
348049dc:	e5d73000 	ldrb	r3, [r7]
348049e0:	e353002d 	cmp	r3, #45	; 0x2d
348049e4:	0a000014 	beq	34804a3c <mod_mem.isra.0+0x10c>
			i = simple_strtoul(console_buffer, &endp, 16);
348049e8:	e3a02010 	mov	r2, #16
348049ec:	e28d1004 	add	r1, sp, #4
348049f0:	e59f0088 	ldr	r0, [pc, #136]	; 34804a80 <mod_mem.isra.0+0x150>
348049f4:	eb005f5a 	bl	3481c764 <simple_strtoul>
			nbytes = endp - console_buffer;
348049f8:	e59d3004 	ldr	r3, [sp, #4]
			if (nbytes) {
348049fc:	e0533007 	subs	r3, r3, r7
34804a00:	0a000009 	beq	34804a2c <mod_mem.isra.0+0xfc>
				if (size == 4)
34804a04:	e3550004 	cmp	r5, #4
					*((uint   *)addr) = i;
34804a08:	05840000 	streq	r0, [r4]
				if (size == 4)
34804a0c:	0a000002 	beq	34804a1c <mod_mem.isra.0+0xec>
				else if (size == 2)
34804a10:	e3550002 	cmp	r5, #2
					*((ushort *)addr) = i;
34804a14:	01c400b0 	strheq	r0, [r4]
					*((u_char *)addr) = i;
34804a18:	15c40000 	strbne	r0, [r4]
				if (incrflag)
34804a1c:	e3590000 	cmp	r9, #0
					addr += size;
34804a20:	10844005 	addne	r4, r4, r5
	} while (nbytes);
34804a24:	e3530000 	cmp	r3, #0
34804a28:	1affffd7 	bne	3480498c <mod_mem.isra.0+0x5c>
	mm_last_addr = addr;
34804a2c:	e586400c 	str	r4, [r6, #12]
	return 0;
34804a30:	e3a00000 	mov	r0, #0
	mm_last_size = size;
34804a34:	e5865010 	str	r5, [r6, #16]
34804a38:	ea000008 	b	34804a60 <mod_mem.isra.0+0x130>
			if (incrflag)
34804a3c:	e3590000 	cmp	r9, #0
34804a40:	0affffd1 	beq	3480498c <mod_mem.isra.0+0x5c>
				addr += nbytes ? -size : size;
34804a44:	e2653000 	rsb	r3, r5, #0
34804a48:	ea000002 	b	34804a58 <mod_mem.isra.0+0x128>
			if (incrflag)
34804a4c:	e3590000 	cmp	r9, #0
34804a50:	0affffcd 	beq	3480498c <mod_mem.isra.0+0x5c>
				addr += nbytes ? -size : size;
34804a54:	e1a03005 	mov	r3, r5
34804a58:	e0844003 	add	r4, r4, r3
34804a5c:	eaffffca 	b	3480498c <mod_mem.isra.0+0x5c>
}
34804a60:	e28dd00c 	add	sp, sp, #12
34804a64:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34804a68:	3482876c 	.word	0x3482876c
34804a6c:	34822b60 	.word	0x34822b60
34804a70:	34825dc4 	.word	0x34825dc4
34804a74:	34822b67 	.word	0x34822b67
34804a78:	34822b6d 	.word	0x34822b6d
34804a7c:	34822b73 	.word	0x34822b73
34804a80:	3482a154 	.word	0x3482a154

34804a84 <do_mem_mm>:
	return mod_mem (cmdtp, 1, flag, argc, argv);
34804a84:	e3a00001 	mov	r0, #1
34804a88:	eaffffa8 	b	34804930 <mod_mem.isra.0>

34804a8c <do_mem_nm>:
	return mod_mem (cmdtp, 0, flag, argc, argv);
34804a8c:	e3a00000 	mov	r0, #0
34804a90:	eaffffa6 	b	34804930 <mod_mem.isra.0>

34804a94 <do_mmcops>:

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
34804a94:	e3520001 	cmp	r2, #1
{
34804a98:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc < 2)
34804a9c:	ca000001 	bgt	34804aa8 <do_mmcops+0x14>
		return CMD_RET_USAGE;
34804aa0:	e3e06000 	mvn	r6, #0
34804aa4:	ea0000e8 	b	34804e4c <do_mmcops+0x3b8>

	if (curr_device < 0) {
34804aa8:	e59f53a8 	ldr	r5, [pc, #936]	; 34804e58 <do_mmcops+0x3c4>
34804aac:	e1a04003 	mov	r4, r3
34804ab0:	e1a07002 	mov	r7, r2
34804ab4:	e5953000 	ldr	r3, [r5]
34804ab8:	e3530000 	cmp	r3, #0
34804abc:	aa000005 	bge	34804ad8 <do_mmcops+0x44>
		if (get_mmc_num() > 0)
34804ac0:	eb0036fd 	bl	348126bc <get_mmc_num>
34804ac4:	e3500000 	cmp	r0, #0
			curr_device = 0;
34804ac8:	c3a03000 	movgt	r3, #0
		else {
			puts("No MMC device available\n");
34804acc:	d59f0388 	ldrle	r0, [pc, #904]	; 34804e5c <do_mmcops+0x3c8>
			curr_device = 0;
34804ad0:	c5853000 	strgt	r3, [r5]
		if (get_mmc_num() > 0)
34804ad4:	da000026 	ble	34804b74 <do_mmcops+0xe0>
			return 1;
		}
	}

	if (strcmp(argv[1], "rescan") == 0) {
34804ad8:	e59f1380 	ldr	r1, [pc, #896]	; 34804e60 <do_mmcops+0x3cc>
34804adc:	e5940004 	ldr	r0, [r4, #4]
34804ae0:	eb005b4e 	bl	3481b820 <strcmp>
34804ae4:	e2506000 	subs	r6, r0, #0
34804ae8:	1a00000a 	bne	34804b18 <do_mmcops+0x84>
		struct mmc *mmc = find_mmc_device(curr_device);
34804aec:	e5950000 	ldr	r0, [r5]
34804af0:	eb0031de 	bl	34811270 <find_mmc_device>

		if (!mmc) {
34804af4:	e2503000 	subs	r3, r0, #0
			printf("no mmc device at slot %x\n", curr_device);
34804af8:	059f3358 	ldreq	r3, [pc, #856]	; 34804e58 <do_mmcops+0x3c4>
34804afc:	05931000 	ldreq	r1, [r3]
		if (!mmc) {
34804b00:	0a00009c 	beq	34804d78 <do_mmcops+0x2e4>
			return 1;
		}

		mmc->has_init = 0;
34804b04:	e5836034 	str	r6, [r3, #52]	; 0x34

		if (mmc_init(mmc))
34804b08:	eb00368d 	bl	34812544 <mmc_init>
34804b0c:	e2906000 	adds	r6, r0, #0
34804b10:	13a06001 	movne	r6, #1
34804b14:	ea0000cc 	b	34804e4c <do_mmcops+0x3b8>
			return 1;
		else
			return 0;
	} else if (strncmp(argv[1], "part", 4) == 0) {
34804b18:	e3a02004 	mov	r2, #4
34804b1c:	e59f1340 	ldr	r1, [pc, #832]	; 34804e64 <do_mmcops+0x3d0>
34804b20:	e5940004 	ldr	r0, [r4, #4]
34804b24:	eb005b47 	bl	3481b848 <strncmp>
34804b28:	e2506000 	subs	r6, r0, #0
34804b2c:	1a000012 	bne	34804b7c <do_mmcops+0xe8>
		block_dev_desc_t *mmc_dev;
		struct mmc *mmc = find_mmc_device(curr_device);
34804b30:	e59f4320 	ldr	r4, [pc, #800]	; 34804e58 <do_mmcops+0x3c4>
34804b34:	e5950000 	ldr	r0, [r5]
34804b38:	eb0031cc 	bl	34811270 <find_mmc_device>

		if (!mmc) {
34804b3c:	e3500000 	cmp	r0, #0
			printf("no mmc device at slot %x\n", curr_device);
34804b40:	05941000 	ldreq	r1, [r4]
		if (!mmc) {
34804b44:	0a00008b 	beq	34804d78 <do_mmcops+0x2e4>
			return 1;
		}
		mmc_init(mmc);
34804b48:	eb00367d 	bl	34812544 <mmc_init>
		mmc_dev = mmc_get_dev(curr_device);
34804b4c:	e5940000 	ldr	r0, [r4]
34804b50:	eb0036b2 	bl	34812620 <mmc_get_dev>
		if (mmc_dev != NULL &&
34804b54:	e2503000 	subs	r3, r0, #0
34804b58:	0a000004 	beq	34804b70 <do_mmcops+0xdc>
34804b5c:	e5d3300b 	ldrb	r3, [r3, #11]
34804b60:	e35300ff 	cmp	r3, #255	; 0xff
34804b64:	0a000001 	beq	34804b70 <do_mmcops+0xdc>
				mmc_dev->type != DEV_TYPE_UNKNOWN) {
			print_part(mmc_dev);
34804b68:	eb002af8 	bl	3480f750 <print_part>
			return 0;
34804b6c:	ea0000b6 	b	34804e4c <do_mmcops+0x3b8>
		}

		puts("get mmc type error!\n");
34804b70:	e59f02f0 	ldr	r0, [pc, #752]	; 34804e68 <do_mmcops+0x3d4>
34804b74:	eb0012fc 	bl	3480976c <puts>
34804b78:	ea000080 	b	34804d80 <do_mmcops+0x2ec>
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
34804b7c:	e59f12e8 	ldr	r1, [pc, #744]	; 34804e6c <do_mmcops+0x3d8>
34804b80:	e5940004 	ldr	r0, [r4, #4]
34804b84:	eb005b25 	bl	3481b820 <strcmp>
34804b88:	e2506000 	subs	r6, r0, #0
34804b8c:	1a000002 	bne	34804b9c <do_mmcops+0x108>
		print_mmc_devices('\n');
34804b90:	e3a0000a 	mov	r0, #10
34804b94:	eb0036ae 	bl	34812654 <print_mmc_devices>
		return 0;
34804b98:	ea0000ab 	b	34804e4c <do_mmcops+0x3b8>
	} else if (strcmp(argv[1], "dev") == 0) {
34804b9c:	e59f12cc 	ldr	r1, [pc, #716]	; 34804e70 <do_mmcops+0x3dc>
34804ba0:	e5940004 	ldr	r0, [r4, #4]
34804ba4:	eb005b1d 	bl	3481b820 <strcmp>
34804ba8:	e2506000 	subs	r6, r0, #0
34804bac:	1a000043 	bne	34804cc0 <do_mmcops+0x22c>
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804bb0:	e3570002 	cmp	r7, #2
			dev = curr_device;
34804bb4:	05957000 	ldreq	r7, [r5]
		if (argc == 2)
34804bb8:	0a000006 	beq	34804bd8 <do_mmcops+0x144>
		else if (argc == 3)
34804bbc:	e3570003 	cmp	r7, #3
34804bc0:	1a000006 	bne	34804be0 <do_mmcops+0x14c>
			dev = simple_strtoul(argv[2], NULL, 10);
34804bc4:	e3a0200a 	mov	r2, #10
34804bc8:	e1a01006 	mov	r1, r6
34804bcc:	e5940008 	ldr	r0, [r4, #8]
34804bd0:	eb005ee3 	bl	3481c764 <simple_strtoul>
34804bd4:	e1a07000 	mov	r7, r0
		int dev, part = -1;
34804bd8:	e3e04000 	mvn	r4, #0
34804bdc:	ea00000f 	b	34804c20 <do_mmcops+0x18c>
		else if (argc == 4) {
34804be0:	e3570004 	cmp	r7, #4
34804be4:	1affffad 	bne	34804aa0 <do_mmcops+0xc>
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804be8:	e3a0200a 	mov	r2, #10
34804bec:	e1a01006 	mov	r1, r6
34804bf0:	e5940008 	ldr	r0, [r4, #8]
34804bf4:	eb005eda 	bl	3481c764 <simple_strtoul>
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804bf8:	e1a01006 	mov	r1, r6
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804bfc:	e1a07000 	mov	r7, r0
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804c00:	e3a0200a 	mov	r2, #10
34804c04:	e594000c 	ldr	r0, [r4, #12]
34804c08:	eb005ed5 	bl	3481c764 <simple_strtoul>
			if (part > PART_ACCESS_MASK) {
34804c0c:	e3500007 	cmp	r0, #7
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804c10:	e1a04000 	mov	r4, r0
				printf("#part_num shouldn't be larger"
34804c14:	c3a01007 	movgt	r1, #7
34804c18:	c59f0254 	ldrgt	r0, [pc, #596]	; 34804e74 <do_mmcops+0x3e0>
			if (part > PART_ACCESS_MASK) {
34804c1c:	ca000056 	bgt	34804d7c <do_mmcops+0x2e8>
				return 1;
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
34804c20:	e1a00007 	mov	r0, r7
34804c24:	eb003191 	bl	34811270 <find_mmc_device>
		if (!mmc) {
34804c28:	e2509000 	subs	r9, r0, #0
			printf("no mmc device at slot %x\n", dev);
34804c2c:	01a01007 	moveq	r1, r7
		if (!mmc) {
34804c30:	0a000050 	beq	34804d78 <do_mmcops+0x2e4>
			return 1;
		}

		mmc_init(mmc);
34804c34:	eb003642 	bl	34812544 <mmc_init>
		if (part != -1) {
34804c38:	e3740001 	cmn	r4, #1
34804c3c:	0a000012 	beq	34804c8c <do_mmcops+0x1f8>
			int ret;
			if (mmc->part_config == MMCPART_NOAVAILABLE) {
34804c40:	e5d93082 	ldrb	r3, [r9, #130]	; 0x82
34804c44:	e35300ff 	cmp	r3, #255	; 0xff
34804c48:	1a000002 	bne	34804c58 <do_mmcops+0x1c4>
				printf("Card doesn't support part_switch\n");
34804c4c:	e59f0224 	ldr	r0, [pc, #548]	; 34804e78 <do_mmcops+0x3e4>
34804c50:	eb0012d1 	bl	3480979c <printf>
34804c54:	ea000049 	b	34804d80 <do_mmcops+0x2ec>
				return 1;
			}

			if (part != mmc->part_num) {
34804c58:	e5d93083 	ldrb	r3, [r9, #131]	; 0x83
34804c5c:	e1540003 	cmp	r4, r3
34804c60:	0a000009 	beq	34804c8c <do_mmcops+0x1f8>
				ret = mmc_switch_part(dev, part);
34804c64:	e1a01004 	mov	r1, r4
34804c68:	e1a00007 	mov	r0, r7
34804c6c:	eb0033b2 	bl	34811b3c <mmc_switch_part>
				if (!ret)
34804c70:	e3500000 	cmp	r0, #0
					mmc->part_num = part;

				printf("switch to partions #%d, %s\n",
34804c74:	e1a01004 	mov	r1, r4
					mmc->part_num = part;
34804c78:	05c94083 	strbeq	r4, [r9, #131]	; 0x83
				printf("switch to partions #%d, %s\n",
34804c7c:	059f21f8 	ldreq	r2, [pc, #504]	; 34804e7c <do_mmcops+0x3e8>
34804c80:	159f21f8 	ldrne	r2, [pc, #504]	; 34804e80 <do_mmcops+0x3ec>
34804c84:	e59f01f8 	ldr	r0, [pc, #504]	; 34804e84 <do_mmcops+0x3f0>
34804c88:	eb0012c3 	bl	3480979c <printf>
						part, (!ret) ? "OK" : "ERROR");
			}
		}
		curr_device = dev;
		if (mmc->part_config == MMCPART_NOAVAILABLE)
34804c8c:	e5d93082 	ldrb	r3, [r9, #130]	; 0x82
		curr_device = dev;
34804c90:	e5857000 	str	r7, [r5]
		if (mmc->part_config == MMCPART_NOAVAILABLE)
34804c94:	e35300ff 	cmp	r3, #255	; 0xff
34804c98:	1a000003 	bne	34804cac <do_mmcops+0x218>
			printf("mmc%d is current device\n", curr_device);
34804c9c:	e1a01007 	mov	r1, r7
34804ca0:	e59f01e0 	ldr	r0, [pc, #480]	; 34804e88 <do_mmcops+0x3f4>
34804ca4:	eb0012bc 	bl	3480979c <printf>
34804ca8:	ea000067 	b	34804e4c <do_mmcops+0x3b8>
		else
			printf("mmc%d(part %d) is current device\n",
34804cac:	e5d92083 	ldrb	r2, [r9, #131]	; 0x83
34804cb0:	e1a01007 	mov	r1, r7
34804cb4:	e59f01d0 	ldr	r0, [pc, #464]	; 34804e8c <do_mmcops+0x3f8>
34804cb8:	eb0012b7 	bl	3480979c <printf>
34804cbc:	ea000062 	b	34804e4c <do_mmcops+0x3b8>
				curr_device, mmc->part_num);

		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
34804cc0:	e59f11c8 	ldr	r1, [pc, #456]	; 34804e90 <do_mmcops+0x3fc>
34804cc4:	e5940004 	ldr	r0, [r4, #4]
34804cc8:	eb005ad4 	bl	3481b820 <strcmp>
34804ccc:	e3500000 	cmp	r0, #0
		state = MMC_READ;
34804cd0:	03a09001 	moveq	r9, #1
	if (strcmp(argv[1], "read") == 0)
34804cd4:	0a00000b 	beq	34804d08 <do_mmcops+0x274>
	else if (strcmp(argv[1], "write") == 0)
34804cd8:	e59f11b4 	ldr	r1, [pc, #436]	; 34804e94 <do_mmcops+0x400>
34804cdc:	e5940004 	ldr	r0, [r4, #4]
34804ce0:	eb005ace 	bl	3481b820 <strcmp>
34804ce4:	e3500000 	cmp	r0, #0
		state = MMC_WRITE;
34804ce8:	03a09002 	moveq	r9, #2
	else if (strcmp(argv[1], "write") == 0)
34804cec:	0a000005 	beq	34804d08 <do_mmcops+0x274>
	else if (strcmp(argv[1], "erase") == 0)
34804cf0:	e59f11a0 	ldr	r1, [pc, #416]	; 34804e98 <do_mmcops+0x404>
34804cf4:	e5940004 	ldr	r0, [r4, #4]
34804cf8:	eb005ac8 	bl	3481b820 <strcmp>
34804cfc:	e3500000 	cmp	r0, #0
34804d00:	1affff66 	bne	34804aa0 <do_mmcops+0xc>
		state = MMC_ERASE;
34804d04:	e3a09003 	mov	r9, #3
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804d08:	e5950000 	ldr	r0, [r5]
34804d0c:	eb003157 	bl	34811270 <find_mmc_device>
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
34804d10:	e3590003 	cmp	r9, #3
		struct mmc *mmc = find_mmc_device(curr_device);
34804d14:	e1a07000 	mov	r7, r0
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
34804d18:	03a0a000 	moveq	sl, #0
		int idx = 2;
34804d1c:	03a03002 	moveq	r3, #2
		if (state != MMC_ERASE) {
34804d20:	0a000005 	beq	34804d3c <do_mmcops+0x2a8>
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804d24:	e3a02010 	mov	r2, #16
34804d28:	e3a01000 	mov	r1, #0
34804d2c:	e5940008 	ldr	r0, [r4, #8]
34804d30:	eb005e8b 	bl	3481c764 <simple_strtoul>
			++idx;
34804d34:	e3a03003 	mov	r3, #3
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804d38:	e1a0a000 	mov	sl, r0
		blk = simple_strtoul(argv[idx], NULL, 16);
34804d3c:	e1a06103 	lsl	r6, r3, #2
34804d40:	e3a02010 	mov	r2, #16
34804d44:	e3a01000 	mov	r1, #0
34804d48:	e7940103 	ldr	r0, [r4, r3, lsl #2]
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804d4c:	e0846006 	add	r6, r4, r6
		blk = simple_strtoul(argv[idx], NULL, 16);
34804d50:	eb005e83 	bl	3481c764 <simple_strtoul>
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804d54:	e3a02010 	mov	r2, #16
		blk = simple_strtoul(argv[idx], NULL, 16);
34804d58:	e1a0b000 	mov	fp, r0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804d5c:	e3a01000 	mov	r1, #0
34804d60:	e5960004 	ldr	r0, [r6, #4]
34804d64:	eb005e7e 	bl	3481c764 <simple_strtoul>

		if (!mmc) {
34804d68:	e3570000 	cmp	r7, #0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804d6c:	e1a06000 	mov	r6, r0
		if (!mmc) {
34804d70:	1a000004 	bne	34804d88 <do_mmcops+0x2f4>
			printf("no mmc device at slot %x\n", curr_device);
34804d74:	e5951000 	ldr	r1, [r5]
34804d78:	e59f011c 	ldr	r0, [pc, #284]	; 34804e9c <do_mmcops+0x408>
34804d7c:	eb001286 	bl	3480979c <printf>
			return 1;
34804d80:	e3a06001 	mov	r6, #1
34804d84:	ea000030 	b	34804e4c <do_mmcops+0x3b8>
		}

		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
34804d88:	e58d0000 	str	r0, [sp]
34804d8c:	e1a0300b 	mov	r3, fp
34804d90:	e5952000 	ldr	r2, [r5]
34804d94:	e5941004 	ldr	r1, [r4, #4]
34804d98:	e59f0100 	ldr	r0, [pc, #256]	; 34804ea0 <do_mmcops+0x40c>
34804d9c:	eb00127e 	bl	3480979c <printf>
				argv[1], curr_device, blk, cnt);

		mmc_init(mmc);
34804da0:	e1a00007 	mov	r0, r7
34804da4:	eb0035e6 	bl	34812544 <mmc_init>

		switch (state) {
34804da8:	e3590002 	cmp	r9, #2
34804dac:	0a00000d 	beq	34804de8 <do_mmcops+0x354>
34804db0:	e3590003 	cmp	r9, #3
34804db4:	0a000013 	beq	34804e08 <do_mmcops+0x374>
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34804db8:	e59f0098 	ldr	r0, [pc, #152]	; 34804e58 <do_mmcops+0x3c4>
34804dbc:	e1a0100b 	mov	r1, fp
34804dc0:	e5975100 	ldr	r5, [r7, #256]	; 0x100
34804dc4:	e1a0300a 	mov	r3, sl
34804dc8:	e1a02006 	mov	r2, r6
34804dcc:	e5900000 	ldr	r0, [r0]
34804dd0:	e12fff35 	blx	r5
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
34804dd4:	e1a01486 	lsl	r1, r6, #9
			n = mmc->block_dev.block_read(curr_device, blk,
34804dd8:	e1a05000 	mov	r5, r0
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
34804ddc:	e1a0000a 	mov	r0, sl
34804de0:	ebffeffc 	bl	34800dd8 <flush_cache>
			break;
34804de4:	ea00000e 	b	34804e24 <do_mmcops+0x390>
		case MMC_WRITE:
			n = mmc->block_dev.block_write(curr_device, blk,
34804de8:	e59f0068 	ldr	r0, [pc, #104]	; 34804e58 <do_mmcops+0x3c4>
34804dec:	e1a0300a 	mov	r3, sl
34804df0:	e5975104 	ldr	r5, [r7, #260]	; 0x104
34804df4:	e1a02006 	mov	r2, r6
34804df8:	e1a0100b 	mov	r1, fp
34804dfc:	e5900000 	ldr	r0, [r0]
34804e00:	e12fff35 	blx	r5
34804e04:	ea000005 	b	34804e20 <do_mmcops+0x38c>
						      cnt, addr);
			break;
		case MMC_ERASE:
			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
34804e08:	e59f0048 	ldr	r0, [pc, #72]	; 34804e58 <do_mmcops+0x3c4>
34804e0c:	e1a02006 	mov	r2, r6
34804e10:	e5973108 	ldr	r3, [r7, #264]	; 0x108
34804e14:	e1a0100b 	mov	r1, fp
34804e18:	e5900000 	ldr	r0, [r0]
34804e1c:	e12fff33 	blx	r3
34804e20:	e1a05000 	mov	r5, r0
			break;
		default:
			BUG();
		}

		printf("%d blocks %s: %s\n",
34804e24:	e59f2050 	ldr	r2, [pc, #80]	; 34804e7c <do_mmcops+0x3e8>
34804e28:	e1550006 	cmp	r5, r6
34804e2c:	e59f304c 	ldr	r3, [pc, #76]	; 34804e80 <do_mmcops+0x3ec>
34804e30:	e1a01005 	mov	r1, r5
34804e34:	e59f0068 	ldr	r0, [pc, #104]	; 34804ea4 <do_mmcops+0x410>
34804e38:	01a03002 	moveq	r3, r2
34804e3c:	e5942004 	ldr	r2, [r4, #4]
34804e40:	eb001255 	bl	3480979c <printf>
				n, argv[1], (n == cnt) ? "OK" : "ERROR");
		return (n == cnt) ? 0 : 1;
34804e44:	e0556006 	subs	r6, r5, r6
34804e48:	13a06001 	movne	r6, #1
	}

	return CMD_RET_USAGE;
}
34804e4c:	e1a00006 	mov	r0, r6
34804e50:	e28dd008 	add	sp, sp, #8
34804e54:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34804e58:	348270ec 	.word	0x348270ec
34804e5c:	34822e32 	.word	0x34822e32
34804e60:	34822e4b 	.word	0x34822e4b
34804e64:	34823dd8 	.word	0x34823dd8
34804e68:	34822e6c 	.word	0x34822e6c
34804e6c:	34822e81 	.word	0x34822e81
34804e70:	34822e86 	.word	0x34822e86
34804e74:	34822e8a 	.word	0x34822e8a
34804e78:	34822eb1 	.word	0x34822eb1
34804e7c:	34822e2f 	.word	0x34822e2f
34804e80:	34822e29 	.word	0x34822e29
34804e84:	34822ed3 	.word	0x34822ed3
34804e88:	34822eef 	.word	0x34822eef
34804e8c:	34822f08 	.word	0x34822f08
34804e90:	34822f2a 	.word	0x34822f2a
34804e94:	34822f2f 	.word	0x34822f2f
34804e98:	34822f35 	.word	0x34822f35
34804e9c:	34822e52 	.word	0x34822e52
34804ea0:	34822f3b 	.word	0x34822f3b
34804ea4:	34822f68 	.word	0x34822f68

34804ea8 <do_mmcinfo>:
{
34804ea8:	e92d4013 	push	{r0, r1, r4, lr}
	if (curr_device < 0) {
34804eac:	e59f412c 	ldr	r4, [pc, #300]	; 34804fe0 <do_mmcinfo+0x138>
34804eb0:	e5943000 	ldr	r3, [r4]
34804eb4:	e3530000 	cmp	r3, #0
34804eb8:	aa000007 	bge	34804edc <do_mmcinfo+0x34>
		if (get_mmc_num() > 0)
34804ebc:	eb0035fe 	bl	348126bc <get_mmc_num>
34804ec0:	e3500000 	cmp	r0, #0
			curr_device = 0;
34804ec4:	c3a03000 	movgt	r3, #0
34804ec8:	c5843000 	strgt	r3, [r4]
		if (get_mmc_num() > 0)
34804ecc:	ca000002 	bgt	34804edc <do_mmcinfo+0x34>
			puts("No MMC device available\n");
34804ed0:	e59f010c 	ldr	r0, [pc, #268]	; 34804fe4 <do_mmcinfo+0x13c>
34804ed4:	eb001224 	bl	3480976c <puts>
34804ed8:	ea00003d 	b	34804fd4 <do_mmcinfo+0x12c>
	mmc = find_mmc_device(curr_device);
34804edc:	e5940000 	ldr	r0, [r4]
34804ee0:	eb0030e2 	bl	34811270 <find_mmc_device>
	if (mmc) {
34804ee4:	e2504000 	subs	r4, r0, #0
34804ee8:	0a000035 	beq	34804fc4 <do_mmcinfo+0x11c>
		mmc_init(mmc);
34804eec:	eb003594 	bl	34812544 <mmc_init>
	printf("Device: %s\n", mmc->name);
34804ef0:	e2841008 	add	r1, r4, #8
34804ef4:	e59f00ec 	ldr	r0, [pc, #236]	; 34804fe8 <do_mmcinfo+0x140>
34804ef8:	eb001227 	bl	3480979c <printf>
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
34804efc:	e5d41073 	ldrb	r1, [r4, #115]	; 0x73
34804f00:	e59f00e4 	ldr	r0, [pc, #228]	; 34804fec <do_mmcinfo+0x144>
34804f04:	eb001224 	bl	3480979c <printf>
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
34804f08:	e5941070 	ldr	r1, [r4, #112]	; 0x70
34804f0c:	e59f00dc 	ldr	r0, [pc, #220]	; 34804ff0 <do_mmcinfo+0x148>
34804f10:	e7ef1451 	ubfx	r1, r1, #8, #16
34804f14:	eb001220 	bl	3480979c <printf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34804f18:	e5942074 	ldr	r2, [r4, #116]	; 0x74
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
34804f1c:	e5d41070 	ldrb	r1, [r4, #112]	; 0x70
34804f20:	e59f00cc 	ldr	r0, [pc, #204]	; 34804ff4 <do_mmcinfo+0x14c>
34804f24:	e6ef3072 	uxtb	r3, r2
34804f28:	e58d3004 	str	r3, [sp, #4]
34804f2c:	e7e73452 	ubfx	r3, r2, #8, #8
34804f30:	e58d3000 	str	r3, [sp]
34804f34:	e7e73852 	ubfx	r3, r2, #16, #8
34804f38:	e1a02c22 	lsr	r2, r2, #24
34804f3c:	eb001216 	bl	3480979c <printf>
	printf("Tran Speed: %d\n", mmc->tran_speed);
34804f40:	e5941084 	ldr	r1, [r4, #132]	; 0x84
34804f44:	e59f00ac 	ldr	r0, [pc, #172]	; 34804ff8 <do_mmcinfo+0x150>
34804f48:	eb001213 	bl	3480979c <printf>
	printf("Rd Block Len: %d\n", mmc->read_bl_len);
34804f4c:	e5941088 	ldr	r1, [r4, #136]	; 0x88
34804f50:	e59f00a4 	ldr	r0, [pc, #164]	; 34804ffc <do_mmcinfo+0x154>
34804f54:	eb001210 	bl	3480979c <printf>
	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
34804f58:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34804f5c:	e59f009c 	ldr	r0, [pc, #156]	; 34805000 <do_mmcinfo+0x158>
34804f60:	e59f109c 	ldr	r1, [pc, #156]	; 34805004 <do_mmcinfo+0x15c>
34804f64:	e3120802 	tst	r2, #131072	; 0x20000
34804f68:	e202300f 	and	r3, r2, #15
34804f6c:	01a01000 	moveq	r1, r0
34804f70:	e7e32252 	ubfx	r2, r2, #4, #4
34804f74:	e59f008c 	ldr	r0, [pc, #140]	; 34805008 <do_mmcinfo+0x160>
34804f78:	eb001207 	bl	3480979c <printf>
	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
34804f7c:	e5941040 	ldr	r1, [r4, #64]	; 0x40
34804f80:	e59f3084 	ldr	r3, [pc, #132]	; 3480500c <do_mmcinfo+0x164>
34804f84:	e59f2084 	ldr	r2, [pc, #132]	; 34805010 <do_mmcinfo+0x168>
34804f88:	e3510000 	cmp	r1, #0
34804f8c:	e59f0080 	ldr	r0, [pc, #128]	; 34805014 <do_mmcinfo+0x16c>
34804f90:	01a01003 	moveq	r1, r3
34804f94:	11a01002 	movne	r1, r2
34804f98:	eb0011ff 	bl	3480979c <printf>
	puts("Capacity: ");
34804f9c:	e59f0074 	ldr	r0, [pc, #116]	; 34805018 <do_mmcinfo+0x170>
34804fa0:	eb0011f1 	bl	3480976c <puts>
	print_size(mmc->capacity, "\n");
34804fa4:	e1c409d8 	ldrd	r0, [r4, #152]	; 0x98
34804fa8:	e59f206c 	ldr	r2, [pc, #108]	; 3480501c <do_mmcinfo+0x174>
34804fac:	eb0053c4 	bl	34819ec4 <print_size>
	printf("Bus Width: %d-bit\n", mmc->bus_width);
34804fb0:	e5941044 	ldr	r1, [r4, #68]	; 0x44
34804fb4:	e59f0064 	ldr	r0, [pc, #100]	; 34805020 <do_mmcinfo+0x178>
34804fb8:	eb0011f7 	bl	3480979c <printf>
		return 0;
34804fbc:	e3a00000 	mov	r0, #0
34804fc0:	ea000004 	b	34804fd8 <do_mmcinfo+0x130>
		printf("no mmc device at slot %x\n", curr_device);
34804fc4:	e59f3014 	ldr	r3, [pc, #20]	; 34804fe0 <do_mmcinfo+0x138>
34804fc8:	e59f0054 	ldr	r0, [pc, #84]	; 34805024 <do_mmcinfo+0x17c>
34804fcc:	e5931000 	ldr	r1, [r3]
34804fd0:	eb0011f1 	bl	3480979c <printf>
34804fd4:	e3a00001 	mov	r0, #1
}
34804fd8:	e28dd008 	add	sp, sp, #8
34804fdc:	e8bd8010 	pop	{r4, pc}
34804fe0:	348270ec 	.word	0x348270ec
34804fe4:	34822e32 	.word	0x34822e32
34804fe8:	34822f85 	.word	0x34822f85
34804fec:	34822f91 	.word	0x34822f91
34804ff0:	34822fa6 	.word	0x34822fa6
34804ff4:	34822faf 	.word	0x34822faf
34804ff8:	34822fc2 	.word	0x34822fc2
34804ffc:	34822fd2 	.word	0x34822fd2
34805000:	34822f7a 	.word	0x34822f7a
34805004:	348254e6 	.word	0x348254e6
34805008:	34822fe4 	.word	0x34822fe4
3480500c:	34822f82 	.word	0x34822f82
34805010:	34822f7e 	.word	0x34822f7e
34805014:	34822ff6 	.word	0x34822ff6
34805018:	34823009 	.word	0x34823009
3480501c:	34824f42 	.word	0x34824f42
34805020:	34823014 	.word	0x34823014
34805024:	34822e52 	.word	0x34822e52

34805028 <list_del>:
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805028:	e890000c 	ldm	r0, {r2, r3}
	next->prev = prev;
3480502c:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805030:	e5832000 	str	r2, [r3]
	entry->next = LIST_POISON1;
34805034:	e3a03000 	mov	r3, #0
34805038:	e5803000 	str	r3, [r0]
	entry->prev = LIST_POISON2;
3480503c:	e5803004 	str	r3, [r0, #4]
34805040:	e12fff1e 	bx	lr

34805044 <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
34805044:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805048:	e3a02000 	mov	r2, #0
{
3480504c:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805050:	eb005dc3 	bl	3481c764 <simple_strtoul>

	switch (**retptr) {
34805054:	e5942000 	ldr	r2, [r4]
34805058:	e5d23000 	ldrb	r3, [r2]
3480505c:	e353004d 	cmp	r3, #77	; 0x4d
34805060:	0a00000c 	beq	34805098 <memsize_parse+0x54>
34805064:	8a000004 	bhi	3480507c <memsize_parse+0x38>
34805068:	e3530047 	cmp	r3, #71	; 0x47
3480506c:	0a000008 	beq	34805094 <memsize_parse+0x50>
34805070:	e353004b 	cmp	r3, #75	; 0x4b
34805074:	0a000008 	beq	3480509c <memsize_parse+0x58>
34805078:	e8bd8010 	pop	{r4, pc}
3480507c:	e353006b 	cmp	r3, #107	; 0x6b
34805080:	0a000005 	beq	3480509c <memsize_parse+0x58>
34805084:	e353006d 	cmp	r3, #109	; 0x6d
34805088:	0a000002 	beq	34805098 <memsize_parse+0x54>
3480508c:	e3530067 	cmp	r3, #103	; 0x67
34805090:	18bd8010 	popne	{r4, pc}
		case 'G':
		case 'g':
			ret <<= 10;
34805094:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
34805098:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
3480509c:	e2822001 	add	r2, r2, #1
			ret <<= 10;
348050a0:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
348050a4:	e5842000 	str	r2, [r4]
		default:
			break;
	}

	return ret;
}
348050a8:	e8bd8010 	pop	{r4, pc}

348050ac <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
348050ac:	e92d4070 	push	{r4, r5, r6, lr}
348050b0:	e1a06000 	mov	r6, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
348050b4:	e5904000 	ldr	r4, [r0]
348050b8:	e5945000 	ldr	r5, [r4]
348050bc:	e1540006 	cmp	r4, r6
348050c0:	0a000006 	beq	348050e0 <part_delall+0x34>
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
348050c4:	e1a00004 	mov	r0, r4
348050c8:	ebffffd6 	bl	34805028 <list_del>
		free(part_tmp);
348050cc:	e1a00004 	mov	r0, r4
	list_for_each_safe(entry, n, head) {
348050d0:	e1a04005 	mov	r4, r5
		free(part_tmp);
348050d4:	eb0012f5 	bl	34809cb0 <free>
	list_for_each_safe(entry, n, head) {
348050d8:	e5955000 	ldr	r5, [r5]
348050dc:	eafffff6 	b	348050bc <part_delall+0x10>
	}
}
348050e0:	e8bd8070 	pop	{r4, r5, r6, pc}

348050e4 <memsize_format>:
	if ((size % SIZE_GB) == 0)
348050e4:	e3c13103 	bic	r3, r1, #-1073741824	; 0xc0000000
{
348050e8:	e1a02001 	mov	r2, r1
	if ((size % SIZE_GB) == 0)
348050ec:	e3530000 	cmp	r3, #0
		sprintf(buf, "%ug", size/SIZE_GB);
348050f0:	01a02f21 	lsreq	r2, r1, #30
348050f4:	059f102c 	ldreq	r1, [pc, #44]	; 34805128 <memsize_format+0x44>
	if ((size % SIZE_GB) == 0)
348050f8:	0a000009 	beq	34805124 <memsize_format+0x40>
	else if ((size % SIZE_MB) == 0)
348050fc:	e7f33052 	ubfx	r3, r2, #0, #20
34805100:	e3530000 	cmp	r3, #0
		sprintf(buf, "%um", size/SIZE_MB);
34805104:	01a02a22 	lsreq	r2, r2, #20
34805108:	059f101c 	ldreq	r1, [pc, #28]	; 3480512c <memsize_format+0x48>
	else if ((size % SIZE_MB) == 0)
3480510c:	0a000004 	beq	34805124 <memsize_format+0x40>
	else if (size % SIZE_KB == 0)
34805110:	e7e93052 	ubfx	r3, r2, #0, #10
34805114:	e3530000 	cmp	r3, #0
		sprintf(buf, "%uk", size/SIZE_KB);
34805118:	059f1010 	ldreq	r1, [pc, #16]	; 34805130 <memsize_format+0x4c>
3480511c:	01a02522 	lsreq	r2, r2, #10
		sprintf(buf, "%u", size);
34805120:	159f100c 	ldrne	r1, [pc, #12]	; 34805134 <memsize_format+0x50>
34805124:	ea005e37 	b	3481ca08 <sprintf>
34805128:	34823164 	.word	0x34823164
3480512c:	34823168 	.word	0x34823168
34805130:	3482316c 	.word	0x3482316c
34805134:	34823170 	.word	0x34823170

34805138 <mtd_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* mtd_part_info(struct mtd_device *dev, unsigned int part_num)
{
34805138:	e92d4007 	push	{r0, r1, r2, lr}
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
3480513c:	e3500000 	cmp	r0, #0
34805140:	0a00001c 	beq	348051b8 <mtd_part_info+0x80>

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
34805144:	e1d030bc 	ldrh	r3, [r0, #12]
34805148:	e1510003 	cmp	r1, r3
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
3480514c:	31a03000 	movcc	r3, r0
34805150:	33a02000 	movcc	r2, #0
34805154:	35b30010 	ldrcc	r0, [r3, #16]!
	if (part_num >= dev->num_parts) {
34805158:	3a000013 	bcc	348051ac <mtd_part_info+0x74>
				part_num, MTD_DEV_TYPE(dev->id->type),
3480515c:	e5900008 	ldr	r0, [r0, #8]
34805160:	e5d02008 	ldrb	r2, [r0, #8]
		printf("invalid partition number %d for device %s%d (%s)\n",
34805164:	e3520002 	cmp	r2, #2
34805168:	059f2050 	ldreq	r2, [pc, #80]	; 348051c0 <mtd_part_info+0x88>
3480516c:	0a000004 	beq	34805184 <mtd_part_info+0x4c>
				part_num, MTD_DEV_TYPE(dev->id->type),
34805170:	e59fc04c 	ldr	ip, [pc, #76]	; 348051c4 <mtd_part_info+0x8c>
34805174:	e3520004 	cmp	r2, #4
34805178:	e59f3048 	ldr	r3, [pc, #72]	; 348051c8 <mtd_part_info+0x90>
3480517c:	11a0200c 	movne	r2, ip
34805180:	01a02003 	moveq	r2, r3
		printf("invalid partition number %d for device %s%d (%s)\n",
34805184:	e5d03009 	ldrb	r3, [r0, #9]
34805188:	e5900010 	ldr	r0, [r0, #16]
3480518c:	e58d0000 	str	r0, [sp]
34805190:	e59f0034 	ldr	r0, [pc, #52]	; 348051cc <mtd_part_info+0x94>
34805194:	eb001180 	bl	3480979c <printf>
34805198:	ea000005 	b	348051b4 <mtd_part_info+0x7c>
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
3480519c:	e1520001 	cmp	r2, r1
348051a0:	0a000004 	beq	348051b8 <mtd_part_info+0x80>
	list_for_each(entry, &dev->parts) {
348051a4:	e5900000 	ldr	r0, [r0]
348051a8:	e2822001 	add	r2, r2, #1
348051ac:	e1500003 	cmp	r0, r3
348051b0:	1afffff9 	bne	3480519c <mtd_part_info+0x64>
		return NULL;
348051b4:	e3a00000 	mov	r0, #0
			return part;
		}
	}

	return NULL;
}
348051b8:	e28dd00c 	add	sp, sp, #12
348051bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
348051c0:	34823535 	.word	0x34823535
348051c4:	34823173 	.word	0x34823173
348051c8:	34823532 	.word	0x34823532
348051cc:	34823177 	.word	0x34823177

348051d0 <index_partitions>:
{
348051d0:	e92d4030 	push	{r4, r5, lr}
348051d4:	e24dd014 	sub	sp, sp, #20
	if (current_mtd_dev) {
348051d8:	e59f4098 	ldr	r4, [pc, #152]	; 34805278 <index_partitions+0xa8>
348051dc:	e5945000 	ldr	r5, [r4]
348051e0:	e3550000 	cmp	r5, #0
		list_for_each(dentry, &devices) {
348051e4:	11a00004 	movne	r0, r4
		mtddevnum = 0;
348051e8:	13a03000 	movne	r3, #0
		list_for_each(dentry, &devices) {
348051ec:	15b01004 	ldrne	r1, [r0, #4]!
	if (current_mtd_dev) {
348051f0:	0a000018 	beq	34805258 <index_partitions+0x88>
		list_for_each(dentry, &devices) {
348051f4:	e1510000 	cmp	r1, r0
348051f8:	0a000011 	beq	34805244 <index_partitions+0x74>
			if (dev == current_mtd_dev) {
348051fc:	e1510005 	cmp	r1, r5
34805200:	1a00000a 	bne	34805230 <index_partitions+0x60>
				mtddevnum += current_mtd_partnum;
34805204:	e59f206c 	ldr	r2, [pc, #108]	; 34805278 <index_partitions+0xa8>
				sprintf(buf, "%d", mtddevnum);
34805208:	e1a0000d 	mov	r0, sp
3480520c:	e59f1068 	ldr	r1, [pc, #104]	; 3480527c <index_partitions+0xac>
				mtddevnum += current_mtd_partnum;
34805210:	e5d2200c 	ldrb	r2, [r2, #12]
34805214:	e0832002 	add	r2, r3, r2
				sprintf(buf, "%d", mtddevnum);
34805218:	e6ff2072 	uxth	r2, r2
3480521c:	eb005df9 	bl	3481ca08 <sprintf>
				setenv("mtddevnum", buf);
34805220:	e1a0100d 	mov	r1, sp
34805224:	e59f0054 	ldr	r0, [pc, #84]	; 34805280 <index_partitions+0xb0>
34805228:	eb000951 	bl	34807774 <setenv>
				break;
3480522c:	ea000004 	b	34805244 <index_partitions+0x74>
			mtddevnum += dev->num_parts;
34805230:	e1d120bc 	ldrh	r2, [r1, #12]
		list_for_each(dentry, &devices) {
34805234:	e5911000 	ldr	r1, [r1]
			mtddevnum += dev->num_parts;
34805238:	e0833002 	add	r3, r3, r2
3480523c:	e6ff3073 	uxth	r3, r3
34805240:	eaffffeb 	b	348051f4 <index_partitions+0x24>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34805244:	e5d4100c 	ldrb	r1, [r4, #12]
34805248:	e5940000 	ldr	r0, [r4]
3480524c:	ebffffb9 	bl	34805138 <mtd_part_info>
		setenv("mtddevname", part->name);
34805250:	e5901008 	ldr	r1, [r0, #8]
34805254:	ea000003 	b	34805268 <index_partitions+0x98>
		setenv("mtddevnum", NULL);
34805258:	e1a01005 	mov	r1, r5
3480525c:	e59f001c 	ldr	r0, [pc, #28]	; 34805280 <index_partitions+0xb0>
34805260:	eb000943 	bl	34807774 <setenv>
		setenv("mtddevname", NULL);
34805264:	e1a01005 	mov	r1, r5
34805268:	e59f0014 	ldr	r0, [pc, #20]	; 34805284 <index_partitions+0xb4>
3480526c:	eb000940 	bl	34807774 <setenv>
}
34805270:	e28dd014 	add	sp, sp, #20
34805274:	e8bd8030 	pop	{r4, r5, pc}
34805278:	34828780 	.word	0x34828780
3480527c:	3482483f 	.word	0x3482483f
34805280:	348231a9 	.word	0x348231a9
34805284:	348231b3 	.word	0x348231b3

34805288 <current_save>:
{
34805288:	e92d4030 	push	{r4, r5, lr}
3480528c:	e24dd01c 	sub	sp, sp, #28
	if (current_mtd_dev) {
34805290:	e59f5088 	ldr	r5, [pc, #136]	; 34805320 <current_save+0x98>
34805294:	e5954000 	ldr	r4, [r5]
34805298:	e3540000 	cmp	r4, #0
3480529c:	0a000018 	beq	34805304 <current_save+0x7c>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_mtd_dev->id->type),
348052a0:	e5941008 	ldr	r1, [r4, #8]
348052a4:	e1a00005 	mov	r0, r5
348052a8:	e5d12008 	ldrb	r2, [r1, #8]
348052ac:	e3520002 	cmp	r2, #2
348052b0:	059f206c 	ldreq	r2, [pc, #108]	; 34805324 <current_save+0x9c>
348052b4:	0a000004 	beq	348052cc <current_save+0x44>
348052b8:	e59fc068 	ldr	ip, [pc, #104]	; 34805328 <current_save+0xa0>
348052bc:	e3520004 	cmp	r2, #4
348052c0:	e59f3064 	ldr	r3, [pc, #100]	; 3480532c <current_save+0xa4>
348052c4:	11a0200c 	movne	r2, ip
348052c8:	01a02003 	moveq	r2, r3
348052cc:	e5d13009 	ldrb	r3, [r1, #9]
348052d0:	e5d0100c 	ldrb	r1, [r0, #12]
348052d4:	e28d0008 	add	r0, sp, #8
348052d8:	e58d1000 	str	r1, [sp]
348052dc:	e59f104c 	ldr	r1, [pc, #76]	; 34805330 <current_save+0xa8>
348052e0:	eb005dc8 	bl	3481ca08 <sprintf>
		setenv("partition", buf);
348052e4:	e28d1008 	add	r1, sp, #8
348052e8:	e59f0044 	ldr	r0, [pc, #68]	; 34805334 <current_save+0xac>
348052ec:	eb000920 	bl	34807774 <setenv>
		strncpy(last_partition, buf, 16);
348052f0:	e3a02010 	mov	r2, #16
348052f4:	e28d1008 	add	r1, sp, #8
348052f8:	e59f0038 	ldr	r0, [pc, #56]	; 34805338 <current_save+0xb0>
348052fc:	eb00591d 	bl	3481b778 <strncpy>
34805300:	ea000003 	b	34805314 <current_save+0x8c>
		setenv("partition", NULL);
34805304:	e1a01004 	mov	r1, r4
34805308:	e59f0024 	ldr	r0, [pc, #36]	; 34805334 <current_save+0xac>
3480530c:	eb000918 	bl	34807774 <setenv>
		last_partition[0] = '\0';
34805310:	e5c5400d 	strb	r4, [r5, #13]
	index_partitions();
34805314:	ebffffad 	bl	348051d0 <index_partitions>
}
34805318:	e28dd01c 	add	sp, sp, #28
3480531c:	e8bd8030 	pop	{r4, r5, pc}
34805320:	34828780 	.word	0x34828780
34805324:	34823535 	.word	0x34823535
34805328:	34823173 	.word	0x34823173
3480532c:	34823532 	.word	0x34823532
34805330:	348231be 	.word	0x348231be
34805334:	34823deb 	.word	0x34823deb
34805338:	3482878d 	.word	0x3482878d

3480533c <part_sort_add>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3480533c:	e5903010 	ldr	r3, [r0, #16]
{
34805340:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	if (list_empty(&dev->parts)) {
34805344:	e2807010 	add	r7, r0, #16
{
34805348:	e1a05001 	mov	r5, r1
3480534c:	e1a04000 	mov	r4, r0
	if (list_empty(&dev->parts)) {
34805350:	e1530007 	cmp	r3, r7
	part->dev = dev;
34805354:	e5850024 	str	r0, [r5, #36]	; 0x24
	next->prev = new;
34805358:	05831004 	streq	r1, [r3, #4]
	new->next = next;
3480535c:	05813000 	streq	r3, [r1]
	new->prev = prev;
34805360:	05813004 	streq	r3, [r1, #4]
	prev->next = new;
34805364:	05841010 	streq	r1, [r4, #16]
34805368:	0a00002d 	beq	34805424 <part_sort_add+0xe8>
	if (dev == current_mtd_dev)
3480536c:	e59f60c8 	ldr	r6, [pc, #200]	; 3480543c <part_sort_add+0x100>
34805370:	e5963000 	ldr	r3, [r6]
34805374:	e1500003 	cmp	r0, r3
	curr_pi = NULL;
34805378:	13a00000 	movne	r0, #0
	if (dev == current_mtd_dev)
3480537c:	1a000001 	bne	34805388 <part_sort_add+0x4c>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34805380:	e5d6100c 	ldrb	r1, [r6, #12]
34805384:	ebffff6b 	bl	34805138 <mtd_part_info>
	list_for_each(entry, &dev->parts) {
34805388:	e5943010 	ldr	r3, [r4, #16]
3480538c:	e1530007 	cmp	r3, r7
34805390:	0a00001e 	beq	34805410 <part_sort_add+0xd4>
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34805394:	e5951014 	ldr	r1, [r5, #20]
34805398:	e5932014 	ldr	r2, [r3, #20]
3480539c:	e1510002 	cmp	r1, r2
348053a0:	1a000005 	bne	348053bc <part_sort_add+0x80>
348053a4:	e3510000 	cmp	r1, #0
348053a8:	1a000004 	bne	348053c0 <part_sort_add+0x84>
			printf("cannot add second partition at offset 0\n");
348053ac:	e59f008c 	ldr	r0, [pc, #140]	; 34805440 <part_sort_add+0x104>
348053b0:	eb0010f9 	bl	3480979c <printf>
			return 1;
348053b4:	e3a00001 	mov	r0, #1
348053b8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		if (new_pi->offset <= pi->offset) {
348053bc:	8a000011 	bhi	34805408 <part_sort_add+0xcc>
	__list_add(new, head->prev, head);
348053c0:	e5931004 	ldr	r1, [r3, #4]
			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348053c4:	e3500000 	cmp	r0, #0
	next->prev = new;
348053c8:	e5835004 	str	r5, [r3, #4]
	new->next = next;
348053cc:	e5853000 	str	r3, [r5]
			dev->num_parts++;
348053d0:	e1d430bc 	ldrh	r3, [r4, #12]
	new->prev = prev;
348053d4:	e5851004 	str	r1, [r5, #4]
	prev->next = new;
348053d8:	e5815000 	str	r5, [r1]
348053dc:	e2833001 	add	r3, r3, #1
348053e0:	e1c430bc 	strh	r3, [r4, #12]
			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348053e4:	0a000011 	beq	34805430 <part_sort_add+0xf4>
348053e8:	e5903014 	ldr	r3, [r0, #20]
348053ec:	e1520003 	cmp	r2, r3
348053f0:	8a00000e 	bhi	34805430 <part_sort_add+0xf4>
				current_mtd_partnum++;
348053f4:	e5d6300c 	ldrb	r3, [r6, #12]
348053f8:	e2833001 	add	r3, r3, #1
348053fc:	e5c6300c 	strb	r3, [r6, #12]
				current_save();
34805400:	ebffffa0 	bl	34805288 <current_save>
34805404:	ea00000a 	b	34805434 <part_sort_add+0xf8>
	list_for_each(entry, &dev->parts) {
34805408:	e5933000 	ldr	r3, [r3]
3480540c:	eaffffde 	b	3480538c <part_sort_add+0x50>
	__list_add(new, head->prev, head);
34805410:	e5942014 	ldr	r2, [r4, #20]
	next->prev = new;
34805414:	e5845014 	str	r5, [r4, #20]
	new->next = next;
34805418:	e5853000 	str	r3, [r5]
	new->prev = prev;
3480541c:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
34805420:	e5825000 	str	r5, [r2]
	dev->num_parts++;
34805424:	e1d430bc 	ldrh	r3, [r4, #12]
34805428:	e2833001 	add	r3, r3, #1
3480542c:	e1c430bc 	strh	r3, [r4, #12]
	index_partitions();
34805430:	ebffff66 	bl	348051d0 <index_partitions>
	return 0;
34805434:	e3a00000 	mov	r0, #0
}
34805438:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480543c:	34828780 	.word	0x34828780
34805440:	348231c6 	.word	0x348231c6

34805444 <device_del>:
{
34805444:	e92d4010 	push	{r4, lr}
34805448:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
3480544c:	e2800010 	add	r0, r0, #16
34805450:	ebffff15 	bl	348050ac <part_delall>
	list_del(&dev->link);
34805454:	e1a00004 	mov	r0, r4
34805458:	ebfffef2 	bl	34805028 <list_del>
	free(dev);
3480545c:	e1a00004 	mov	r0, r4
34805460:	eb001212 	bl	34809cb0 <free>
	if (dev == current_mtd_dev) {
34805464:	e59f3038 	ldr	r3, [pc, #56]	; 348054a4 <device_del+0x60>
34805468:	e5932000 	ldr	r2, [r3]
3480546c:	e1540002 	cmp	r4, r2
34805470:	1a000008 	bne	34805498 <device_del+0x54>
	return head->next == head;
34805474:	e1a02003 	mov	r2, r3
34805478:	e5b21004 	ldr	r1, [r2, #4]!
		if (list_empty(&devices)) {
3480547c:	e1510002 	cmp	r1, r2
34805480:	e3a02000 	mov	r2, #0
			current_mtd_dev = NULL;
34805484:	05832000 	streq	r2, [r3]
			current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34805488:	15831000 	strne	r1, [r3]
			current_mtd_partnum = 0;
3480548c:	15c3200c 	strbne	r2, [r3, #12]
		current_save();
34805490:	ebffff7c 	bl	34805288 <current_save>
34805494:	ea000000 	b	3480549c <device_del+0x58>
	index_partitions();
34805498:	ebffff4c 	bl	348051d0 <index_partitions>
}
3480549c:	e3a00000 	mov	r0, #0
348054a0:	e8bd8010 	pop	{r4, pc}
348054a4:	34828780 	.word	0x34828780

348054a8 <generate_mtdparts_save.constprop.8>:
static int generate_mtdparts_save(char *buf, u32 buflen)
348054a8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348054ac:	e24dd030 	sub	sp, sp, #48	; 0x30
348054b0:	e59f72b8 	ldr	r7, [pc, #696]	; 34805770 <generate_mtdparts_save.constprop.8+0x2c8>
	if (list_empty(&devices)) {
348054b4:	e5972004 	ldr	r2, [r7, #4]
348054b8:	e2873004 	add	r3, r7, #4
348054bc:	e58d300c 	str	r3, [sp, #12]
348054c0:	e1520003 	cmp	r2, r3
		buf[0] = '\0';
348054c4:	03a04000 	moveq	r4, #0
348054c8:	05c7401d 	strbeq	r4, [r7, #29]
	if (list_empty(&devices)) {
348054cc:	0a00009b 	beq	34805740 <generate_mtdparts_save.constprop.8+0x298>
	sprintf(p, "mtdparts=");
348054d0:	e59f129c 	ldr	r1, [pc, #668]	; 34805774 <generate_mtdparts_save.constprop.8+0x2cc>
348054d4:	e287001d 	add	r0, r7, #29
348054d8:	eb005d4a 	bl	3481ca08 <sprintf>
	list_for_each(dentry, &devices) {
348054dc:	e5979004 	ldr	r9, [r7, #4]
	u32 maxlen = buflen - 1;
348054e0:	e30041ff 	movw	r4, #511	; 0x1ff
	p += 9;
348054e4:	e2876026 	add	r6, r7, #38	; 0x26
	list_for_each(dentry, &devices) {
348054e8:	e59d300c 	ldr	r3, [sp, #12]
348054ec:	e1590003 	cmp	r9, r3
348054f0:	0a00008c 	beq	34805728 <generate_mtdparts_save.constprop.8+0x280>
		len = strlen(dev->id->mtd_id) + 1;
348054f4:	e5993008 	ldr	r3, [r9, #8]
348054f8:	e5930010 	ldr	r0, [r3, #16]
348054fc:	eb0058f5 	bl	3481b8d8 <strlen>
34805500:	e280b001 	add	fp, r0, #1
34805504:	e1a0a000 	mov	sl, r0
		if (len > maxlen)
34805508:	e15b0004 	cmp	fp, r4
3480550c:	8a000088 	bhi	34805734 <generate_mtdparts_save.constprop.8+0x28c>
		memcpy(p, dev->id->mtd_id, len - 1);
34805510:	e5993008 	ldr	r3, [r9, #8]
34805514:	e1a02000 	mov	r2, r0
34805518:	e1a00006 	mov	r0, r6
		p += len - 1;
3480551c:	e086500a 	add	r5, r6, sl
		*(p++) = ':';
34805520:	e2855001 	add	r5, r5, #1
		maxlen -= len;
34805524:	e06b4004 	rsb	r4, fp, r4
		memcpy(p, dev->id->mtd_id, len - 1);
34805528:	e5931010 	ldr	r1, [r3, #16]
3480552c:	eb0059b2 	bl	3481bbfc <memcpy>
		*(p++) = ':';
34805530:	e3a0303a 	mov	r3, #58	; 0x3a
34805534:	e7c6300a 	strb	r3, [r6, sl]
		list_for_each(pentry, &dev->parts) {
34805538:	e1a03009 	mov	r3, r9
3480553c:	e5b36010 	ldr	r6, [r3, #16]!
34805540:	e58d3004 	str	r3, [sp, #4]
		part_cnt = 0;
34805544:	e3a03000 	mov	r3, #0
		prev_part = NULL;
34805548:	e1a0a003 	mov	sl, r3
		part_cnt = 0;
3480554c:	e58d3000 	str	r3, [sp]
		list_for_each(pentry, &dev->parts) {
34805550:	e59d3004 	ldr	r3, [sp, #4]
34805554:	e1560003 	cmp	r6, r3
34805558:	0a000065 	beq	348056f4 <generate_mtdparts_save.constprop.8+0x24c>
			offset = part->offset;
3480555c:	e5963014 	ldr	r3, [r6, #20]
			memsize_format(tmpbuf, size);
34805560:	e28d0010 	add	r0, sp, #16
34805564:	e5961010 	ldr	r1, [r6, #16]
			offset = part->offset;
34805568:	e58d3008 	str	r3, [sp, #8]
			part_cnt++;
3480556c:	e59d3000 	ldr	r3, [sp]
34805570:	e2833001 	add	r3, r3, #1
34805574:	e58d3000 	str	r3, [sp]
			memsize_format(tmpbuf, size);
34805578:	ebfffed9 	bl	348050e4 <memsize_format>
			len = strlen(tmpbuf);
3480557c:	e28d0010 	add	r0, sp, #16
34805580:	eb0058d4 	bl	3481b8d8 <strlen>
			if (len > maxlen)
34805584:	e1500004 	cmp	r0, r4
			len = strlen(tmpbuf);
34805588:	e1a0b000 	mov	fp, r0
			if (len > maxlen)
3480558c:	8a000068 	bhi	34805734 <generate_mtdparts_save.constprop.8+0x28c>
			memcpy(p, tmpbuf, len);
34805590:	e1a02000 	mov	r2, r0
34805594:	e28d1010 	add	r1, sp, #16
34805598:	e1a00005 	mov	r0, r5
			maxlen -= len;
3480559c:	e06b4004 	rsb	r4, fp, r4
			memcpy(p, tmpbuf, len);
348055a0:	eb005995 	bl	3481bbfc <memcpy>
			if ((!prev_part && (offset != 0)) ||
348055a4:	e59d2008 	ldr	r2, [sp, #8]
348055a8:	e16f3f1a 	clz	r3, sl
348055ac:	e1a032a3 	lsr	r3, r3, #5
			p += len;
348055b0:	e085500b 	add	r5, r5, fp
			if ((!prev_part && (offset != 0)) ||
348055b4:	e3520000 	cmp	r2, #0
348055b8:	03a03000 	moveq	r3, #0
348055bc:	e3530000 	cmp	r3, #0
348055c0:	1a000007 	bne	348055e4 <generate_mtdparts_save.constprop.8+0x13c>
348055c4:	e35a0000 	cmp	sl, #0
348055c8:	0a000019 	beq	34805634 <generate_mtdparts_save.constprop.8+0x18c>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {
348055cc:	e59a2014 	ldr	r2, [sl, #20]
348055d0:	e59a3010 	ldr	r3, [sl, #16]
348055d4:	e0833002 	add	r3, r3, r2
348055d8:	e5962014 	ldr	r2, [r6, #20]
348055dc:	e1530002 	cmp	r3, r2
348055e0:	0a000013 	beq	34805634 <generate_mtdparts_save.constprop.8+0x18c>
				memsize_format(tmpbuf, offset);
348055e4:	e59d1008 	ldr	r1, [sp, #8]
348055e8:	e28d0010 	add	r0, sp, #16
348055ec:	ebfffebc 	bl	348050e4 <memsize_format>
				len = strlen(tmpbuf) + 1;
348055f0:	e28d0010 	add	r0, sp, #16
348055f4:	eb0058b7 	bl	3481b8d8 <strlen>
348055f8:	e280b001 	add	fp, r0, #1
348055fc:	e1a0a000 	mov	sl, r0
				if (len > maxlen)
34805600:	e15b0004 	cmp	fp, r4
34805604:	8a00004a 	bhi	34805734 <generate_mtdparts_save.constprop.8+0x28c>
				*(p++) = '@';
34805608:	e2853001 	add	r3, r5, #1
3480560c:	e3a02040 	mov	r2, #64	; 0x40
34805610:	e5c52000 	strb	r2, [r5]
				memcpy(p, tmpbuf, len - 1);
34805614:	e28d1010 	add	r1, sp, #16
34805618:	e1a02000 	mov	r2, r0
3480561c:	e1a00003 	mov	r0, r3
34805620:	e58d3008 	str	r3, [sp, #8]
				maxlen -= len;
34805624:	e06b4004 	rsb	r4, fp, r4
				memcpy(p, tmpbuf, len - 1);
34805628:	eb005973 	bl	3481bbfc <memcpy>
				p += len - 1;
3480562c:	e59d3008 	ldr	r3, [sp, #8]
34805630:	e083500a 	add	r5, r3, sl
			if(!part->auto_name) {
34805634:	e5d6300c 	ldrb	r3, [r6, #12]
34805638:	e3530000 	cmp	r3, #0
3480563c:	1a000013 	bne	34805690 <generate_mtdparts_save.constprop.8+0x1e8>
				len = strlen(part->name) + 2;
34805640:	e5960008 	ldr	r0, [r6, #8]
34805644:	eb0058a3 	bl	3481b8d8 <strlen>
34805648:	e2803002 	add	r3, r0, #2
3480564c:	e1a0a000 	mov	sl, r0
				if (len > maxlen)
34805650:	e1530004 	cmp	r3, r4
34805654:	e58d3008 	str	r3, [sp, #8]
34805658:	8a000035 	bhi	34805734 <generate_mtdparts_save.constprop.8+0x28c>
				*(p++) = '(';
3480565c:	e285b001 	add	fp, r5, #1
34805660:	e3a02028 	mov	r2, #40	; 0x28
34805664:	e5c52000 	strb	r2, [r5]
				memcpy(p, part->name, len - 2);
34805668:	e1a02000 	mov	r2, r0
3480566c:	e5961008 	ldr	r1, [r6, #8]
34805670:	e1a0000b 	mov	r0, fp
34805674:	eb005960 	bl	3481bbfc <memcpy>
				maxlen -= len;
34805678:	e59d3008 	ldr	r3, [sp, #8]
				p += len - 2;
3480567c:	e08b500a 	add	r5, fp, sl
				*(p++) = ')';
34805680:	e2855001 	add	r5, r5, #1
34805684:	e3a02029 	mov	r2, #41	; 0x29
34805688:	e7cb200a 	strb	r2, [fp, sl]
				maxlen -= len;
3480568c:	e0634004 	rsb	r4, r3, r4
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
34805690:	e596301c 	ldr	r3, [r6, #28]
34805694:	e3530000 	cmp	r3, #0
34805698:	0a000008 	beq	348056c0 <generate_mtdparts_save.constprop.8+0x218>
				if (len > maxlen)
3480569c:	e3540001 	cmp	r4, #1
348056a0:	9a000023 	bls	34805734 <generate_mtdparts_save.constprop.8+0x28c>
				*(p++) = 'r';
348056a4:	e1a03005 	mov	r3, r5
348056a8:	e3a02072 	mov	r2, #114	; 0x72
348056ac:	e4c32002 	strb	r2, [r3], #2
				*(p++) = 'o';
348056b0:	e3a0206f 	mov	r2, #111	; 0x6f
348056b4:	e5c52001 	strb	r2, [r5, #1]
				maxlen -= 2;
348056b8:	e2444002 	sub	r4, r4, #2
				*(p++) = 'o';
348056bc:	e1a05003 	mov	r5, r3
			if (dev->num_parts > part_cnt) {
348056c0:	e1d930bc 	ldrh	r3, [r9, #12]
348056c4:	e59d2000 	ldr	r2, [sp]
348056c8:	e1530002 	cmp	r3, r2
348056cc:	9a000005 	bls	348056e8 <generate_mtdparts_save.constprop.8+0x240>
				if (1 > maxlen)
348056d0:	e3540000 	cmp	r4, #0
348056d4:	0a000016 	beq	34805734 <generate_mtdparts_save.constprop.8+0x28c>
				*(p++) = ',';
348056d8:	e3a0302c 	mov	r3, #44	; 0x2c
				maxlen--;
348056dc:	e2444001 	sub	r4, r4, #1
				*(p++) = ',';
348056e0:	e5c53000 	strb	r3, [r5]
348056e4:	e2855001 	add	r5, r5, #1
		list_for_each(pentry, &dev->parts) {
348056e8:	e1a0a006 	mov	sl, r6
348056ec:	e5966000 	ldr	r6, [r6]
348056f0:	eaffff96 	b	34805550 <generate_mtdparts_save.constprop.8+0xa8>
		if (dentry->next != &devices) {
348056f4:	e5993000 	ldr	r3, [r9]
		list_for_each(pentry, &dev->parts) {
348056f8:	e1a06005 	mov	r6, r5
		if (dentry->next != &devices) {
348056fc:	e59d200c 	ldr	r2, [sp, #12]
34805700:	e1530002 	cmp	r3, r2
34805704:	0a000005 	beq	34805720 <generate_mtdparts_save.constprop.8+0x278>
			if (1 > maxlen)
34805708:	e3540000 	cmp	r4, #0
3480570c:	0a000008 	beq	34805734 <generate_mtdparts_save.constprop.8+0x28c>
			*(p++) = ';';
34805710:	e2856001 	add	r6, r5, #1
			maxlen--;
34805714:	e2444001 	sub	r4, r4, #1
			*(p++) = ';';
34805718:	e3a0303b 	mov	r3, #59	; 0x3b
3480571c:	e5c53000 	strb	r3, [r5]
	list_for_each(dentry, &devices) {
34805720:	e5999000 	ldr	r9, [r9]
34805724:	eaffff6f 	b	348054e8 <generate_mtdparts_save.constprop.8+0x40>
	*p = '\0';
34805728:	e3a04000 	mov	r4, #0
3480572c:	e5c64000 	strb	r4, [r6]
34805730:	ea000002 	b	34805740 <generate_mtdparts_save.constprop.8+0x298>
	return 1;
34805734:	e3a04001 	mov	r4, #1
	last_parts[0] = '\0';
34805738:	e3a03000 	mov	r3, #0
3480573c:	e5c7301d 	strb	r3, [r7, #29]
	if ((buf[0] != '\0') && (ret == 0))
34805740:	e5d7301d 	ldrb	r3, [r7, #29]
34805744:	e2241001 	eor	r1, r4, #1
		setenv("mtdparts", NULL);
34805748:	e59f0028 	ldr	r0, [pc, #40]	; 34805778 <generate_mtdparts_save.constprop.8+0x2d0>
	if ((buf[0] != '\0') && (ret == 0))
3480574c:	e3530000 	cmp	r3, #0
34805750:	03a01000 	moveq	r1, #0
34805754:	12011001 	andne	r1, r1, #1
34805758:	e3510000 	cmp	r1, #0
		setenv("mtdparts", buf);
3480575c:	159f1018 	ldrne	r1, [pc, #24]	; 3480577c <generate_mtdparts_save.constprop.8+0x2d4>
		setenv("mtdparts", NULL);
34805760:	eb000803 	bl	34807774 <setenv>
}
34805764:	e1a00004 	mov	r0, r4
34805768:	e28dd030 	add	sp, sp, #48	; 0x30
3480576c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805770:	34828780 	.word	0x34828780
34805774:	348231ef 	.word	0x348231ef
34805778:	348231f9 	.word	0x348231f9
3480577c:	3482879d 	.word	0x3482879d

34805780 <device_delall.constprop.10>:
static int device_delall(struct list_head *head)
34805780:	e92d4070 	push	{r4, r5, r6, lr}
	list_for_each_safe(entry, n, head) {
34805784:	e59f5044 	ldr	r5, [pc, #68]	; 348057d0 <device_delall.constprop.10+0x50>
34805788:	e5b54004 	ldr	r4, [r5, #4]!
3480578c:	e5946000 	ldr	r6, [r4]
34805790:	e1540005 	cmp	r4, r5
34805794:	e59f3034 	ldr	r3, [pc, #52]	; 348057d0 <device_delall.constprop.10+0x50>
34805798:	0a000008 	beq	348057c0 <device_delall.constprop.10+0x40>
		list_del(entry);
3480579c:	e1a00004 	mov	r0, r4
348057a0:	ebfffe20 	bl	34805028 <list_del>
		part_delall(&dev_tmp->parts);
348057a4:	e2840010 	add	r0, r4, #16
348057a8:	ebfffe3f 	bl	348050ac <part_delall>
		free(dev_tmp);
348057ac:	e1a00004 	mov	r0, r4
	list_for_each_safe(entry, n, head) {
348057b0:	e1a04006 	mov	r4, r6
		free(dev_tmp);
348057b4:	eb00113d 	bl	34809cb0 <free>
	list_for_each_safe(entry, n, head) {
348057b8:	e5966000 	ldr	r6, [r6]
348057bc:	eafffff3 	b	34805790 <device_delall.constprop.10+0x10>
	list->next = list;
348057c0:	e5834004 	str	r4, [r3, #4]
}
348057c4:	e3a00000 	mov	r0, #0
	list->prev = list;
348057c8:	e5834008 	str	r4, [r3, #8]
348057cc:	e8bd8070 	pop	{r4, r5, r6, pc}
348057d0:	34828780 	.word	0x34828780

348057d4 <mtd_devices_init>:
	last_parts[0] = '\0';
348057d4:	e59f3018 	ldr	r3, [pc, #24]	; 348057f4 <mtd_devices_init+0x20>
348057d8:	e3a02000 	mov	r2, #0
{
348057dc:	e92d4010 	push	{r4, lr}
	last_parts[0] = '\0';
348057e0:	e5c3201d 	strb	r2, [r3, #29]
	current_mtd_dev = NULL;
348057e4:	e5832000 	str	r2, [r3]
	current_save();
348057e8:	ebfffea6 	bl	34805288 <current_save>
}
348057ec:	e8bd4010 	pop	{r4, lr}
	return device_delall(&devices);
348057f0:	eaffffe2 	b	34805780 <device_delall.constprop.10>
348057f4:	34828780 	.word	0x34828780

348057f8 <get_mtd_info.constprop.11>:
	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
348057f8:	e3500002 	cmp	r0, #2
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
348057fc:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
34805800:	e1a04002 	mov	r4, r2
34805804:	e1a03001 	mov	r3, r1
	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805808:	059f204c 	ldreq	r2, [pc, #76]	; 3480585c <get_mtd_info.constprop.11+0x64>
3480580c:	0a000003 	beq	34805820 <get_mtd_info.constprop.11+0x28>
34805810:	e59f1048 	ldr	r1, [pc, #72]	; 34805860 <get_mtd_info.constprop.11+0x68>
34805814:	e3500004 	cmp	r0, #4
34805818:	e59f2044 	ldr	r2, [pc, #68]	; 34805864 <get_mtd_info.constprop.11+0x6c>
3480581c:	11a02001 	movne	r2, r1
34805820:	e59f1040 	ldr	r1, [pc, #64]	; 34805868 <get_mtd_info.constprop.11+0x70>
34805824:	e1a0000d 	mov	r0, sp
34805828:	eb005c76 	bl	3481ca08 <sprintf>
	*mtd = get_mtd_device_nm(mtd_dev);
3480582c:	e1a0000d 	mov	r0, sp
34805830:	eb003658 	bl	34813198 <get_mtd_device_nm>
	if (IS_ERR(*mtd)) {
34805834:	e3700a01 	cmn	r0, #4096	; 0x1000
	*mtd = get_mtd_device_nm(mtd_dev);
34805838:	e5840000 	str	r0, [r4]
	return 0;
3480583c:	93a00000 	movls	r0, #0
	if (IS_ERR(*mtd)) {
34805840:	9a000003 	bls	34805854 <get_mtd_info.constprop.11+0x5c>
		printf("Device %s not found!\n", mtd_dev);
34805844:	e1a0100d 	mov	r1, sp
34805848:	e59f001c 	ldr	r0, [pc, #28]	; 3480586c <get_mtd_info.constprop.11+0x74>
3480584c:	eb000fd2 	bl	3480979c <printf>
		return 1;
34805850:	e3a00001 	mov	r0, #1
}
34805854:	e28dd010 	add	sp, sp, #16
34805858:	e8bd8010 	pop	{r4, pc}
3480585c:	34823535 	.word	0x34823535
34805860:	34823173 	.word	0x34823173
34805864:	34823532 	.word	0x34823532
34805868:	34823202 	.word	0x34823202
3480586c:	34823207 	.word	0x34823207

34805870 <part_validate>:
	if (part->size == SIZE_REMAINING)
34805870:	e5913010 	ldr	r3, [r1, #16]
34805874:	e5912014 	ldr	r2, [r1, #20]
{
34805878:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480587c:	e1a05001 	mov	r5, r1
	if (part->size == SIZE_REMAINING)
34805880:	e3730001 	cmn	r3, #1
34805884:	e590300c 	ldr	r3, [r0, #12]
{
34805888:	e1a04000 	mov	r4, r0
		part->size = id->size - part->offset;
3480588c:	00621003 	rsbeq	r1, r2, r3
34805890:	05851010 	streq	r1, [r5, #16]
	if (part->offset > id->size) {
34805894:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34805898:	85901010 	ldrhi	r1, [r0, #16]
3480589c:	859f0204 	ldrhi	r0, [pc, #516]	; 34805aa8 <part_validate+0x238>
	if (part->offset > id->size) {
348058a0:	8a00007b 	bhi	34805a94 <part_validate+0x224>
	if ((part->offset + part->size) <= part->offset) {
348058a4:	e5951010 	ldr	r1, [r5, #16]
348058a8:	e0821001 	add	r1, r2, r1
348058ac:	e1510002 	cmp	r1, r2
348058b0:	8a00000b 	bhi	348058e4 <part_validate+0x74>
				MTD_DEV_TYPE(id->type), id->num, part->name);
348058b4:	e5d42008 	ldrb	r2, [r4, #8]
		printf("%s%d: partition (%s) size too big\n",
348058b8:	e3520002 	cmp	r2, #2
348058bc:	059f11e8 	ldreq	r1, [pc, #488]	; 34805aac <part_validate+0x23c>
348058c0:	0a000003 	beq	348058d4 <part_validate+0x64>
				MTD_DEV_TYPE(id->type), id->num, part->name);
348058c4:	e59f31e4 	ldr	r3, [pc, #484]	; 34805ab0 <part_validate+0x240>
348058c8:	e3520004 	cmp	r2, #4
348058cc:	e59f11e0 	ldr	r1, [pc, #480]	; 34805ab4 <part_validate+0x244>
348058d0:	01a01003 	moveq	r1, r3
		printf("%s%d: partition (%s) size too big\n",
348058d4:	e5953008 	ldr	r3, [r5, #8]
348058d8:	e5d42009 	ldrb	r2, [r4, #9]
348058dc:	e59f01d4 	ldr	r0, [pc, #468]	; 34805ab8 <part_validate+0x248>
348058e0:	ea00006b 	b	34805a94 <part_validate+0x224>
	if (part->offset + part->size > id->size) {
348058e4:	e1510003 	cmp	r1, r3
348058e8:	9a000003 	bls	348058fc <part_validate+0x8c>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
348058ec:	e5941010 	ldr	r1, [r4, #16]
348058f0:	e59f01c4 	ldr	r0, [pc, #452]	; 34805abc <part_validate+0x24c>
348058f4:	eb000fa8 	bl	3480979c <printf>
348058f8:	ea000066 	b	34805a98 <part_validate+0x228>
	struct mtd_info *mtd = NULL;
348058fc:	e28d2008 	add	r2, sp, #8
34805900:	e3a03000 	mov	r3, #0
34805904:	e5223004 	str	r3, [r2, #-4]!
	if (get_mtd_info(id->type, id->num, &mtd))
34805908:	e5d41009 	ldrb	r1, [r4, #9]
3480590c:	e5d40008 	ldrb	r0, [r4, #8]
34805910:	ebffffb8 	bl	348057f8 <get_mtd_info.constprop.11>
34805914:	e2506000 	subs	r6, r0, #0
34805918:	1a00005e 	bne	34805a98 <part_validate+0x228>
	part->sector_size = mtd->erasesize;
3480591c:	e59dc004 	ldr	ip, [sp, #4]
	if (!mtd->numeraseregions) {
34805920:	e59c002c 	ldr	r0, [ip, #44]	; 0x2c
	part->sector_size = mtd->erasesize;
34805924:	e59c7010 	ldr	r7, [ip, #16]
	if (!mtd->numeraseregions) {
34805928:	e3500000 	cmp	r0, #0
	part->sector_size = mtd->erasesize;
3480592c:	e5857020 	str	r7, [r5, #32]
	if (!mtd->numeraseregions) {
34805930:	1a000015 	bne	3480598c <part_validate+0x11c>
		if ((unsigned long)part->offset % mtd->erasesize) {
34805934:	e1a01007 	mov	r1, r7
34805938:	e5950014 	ldr	r0, [r5, #20]
3480593c:	fa00664e 	blx	3481f27c <__aeabi_uidivmod>
34805940:	e3510000 	cmp	r1, #0
34805944:	0a00000b 	beq	34805978 <part_validate+0x108>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805948:	e5d42008 	ldrb	r2, [r4, #8]
			printf("%s%d: partition (%s) start offset"
3480594c:	e3520002 	cmp	r2, #2
34805950:	059f1154 	ldreq	r1, [pc, #340]	; 34805aac <part_validate+0x23c>
34805954:	0a000003 	beq	34805968 <part_validate+0xf8>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805958:	e59f3150 	ldr	r3, [pc, #336]	; 34805ab0 <part_validate+0x240>
3480595c:	e3520004 	cmp	r2, #4
34805960:	e59f114c 	ldr	r1, [pc, #332]	; 34805ab4 <part_validate+0x244>
34805964:	01a01003 	moveq	r1, r3
			printf("%s%d: partition (%s) start offset"
34805968:	e5953008 	ldr	r3, [r5, #8]
3480596c:	e5d42009 	ldrb	r2, [r4, #9]
34805970:	e59f0148 	ldr	r0, [pc, #328]	; 34805ac0 <part_validate+0x250>
34805974:	ea000046 	b	34805a94 <part_validate+0x224>
		if (part->size % mtd->erasesize) {
34805978:	e1a01007 	mov	r1, r7
3480597c:	e5950010 	ldr	r0, [r5, #16]
34805980:	fa00663d 	blx	3481f27c <__aeabi_uidivmod>
34805984:	e3510000 	cmp	r1, #0
34805988:	ea000035 	b	34805a64 <part_validate+0x1f4>
	if (!mtd->numeraseregions) {
3480598c:	e1a01006 	mov	r1, r6
34805990:	e3a09018 	mov	r9, #24
		for (i = 0; i < mtd->numeraseregions; i++) {
34805994:	e1510000 	cmp	r1, r0
34805998:	aa000011 	bge	348059e4 <part_validate+0x174>
3480599c:	e0020199 	mul	r2, r9, r1
			start = mtd->eraseregions[i].offset;
348059a0:	e59c3030 	ldr	r3, [ip, #48]	; 0x30
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059a4:	e3a0e000 	mov	lr, #0
			start = mtd->eraseregions[i].offset;
348059a8:	e0837002 	add	r7, r3, r2
348059ac:	e7932002 	ldr	r2, [r3, r2]
348059b0:	e597a00c 	ldr	sl, [r7, #12]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059b4:	e15e000a 	cmp	lr, sl
348059b8:	0a000007 	beq	348059dc <part_validate+0x16c>
				if (part->offset == start)
348059bc:	e595b014 	ldr	fp, [r5, #20]
348059c0:	e15b0002 	cmp	fp, r2
348059c4:	03a0c000 	moveq	ip, #0
348059c8:	0a000011 	beq	34805a14 <part_validate+0x1a4>
				start += mtd->eraseregions[i].erasesize;
348059cc:	e597b008 	ldr	fp, [r7, #8]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059d0:	e28ee001 	add	lr, lr, #1
				start += mtd->eraseregions[i].erasesize;
348059d4:	e082200b 	add	r2, r2, fp
348059d8:	eafffff5 	b	348059b4 <part_validate+0x144>
		for (i = 0; i < mtd->numeraseregions; i++) {
348059dc:	e2811001 	add	r1, r1, #1
348059e0:	eaffffeb 	b	34805994 <part_validate+0x124>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
348059e4:	e5d42008 	ldrb	r2, [r4, #8]
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
348059e8:	e3520002 	cmp	r2, #2
348059ec:	059f10b8 	ldreq	r1, [pc, #184]	; 34805aac <part_validate+0x23c>
348059f0:	0a000003 	beq	34805a04 <part_validate+0x194>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
348059f4:	e59f30b4 	ldr	r3, [pc, #180]	; 34805ab0 <part_validate+0x240>
348059f8:	e3520004 	cmp	r2, #4
348059fc:	e59f10b0 	ldr	r1, [pc, #176]	; 34805ab4 <part_validate+0x244>
34805a00:	01a01003 	moveq	r1, r3
		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34805a04:	e5953008 	ldr	r3, [r5, #8]
34805a08:	e5d42009 	ldrb	r2, [r4, #9]
34805a0c:	e59f00b0 	ldr	r0, [pc, #176]	; 34805ac4 <part_validate+0x254>
34805a10:	ea00001f 	b	34805a94 <part_validate+0x224>
			start = mtd->eraseregions[i].offset;
34805a14:	e5931000 	ldr	r1, [r3]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805a18:	e3a0e000 	mov	lr, #0
34805a1c:	e593900c 	ldr	r9, [r3, #12]
34805a20:	e15e0009 	cmp	lr, r9
34805a24:	0a000007 	beq	34805a48 <part_validate+0x1d8>
				if ((part->offset + part->size) == start)
34805a28:	e5957010 	ldr	r7, [r5, #16]
34805a2c:	e0827007 	add	r7, r2, r7
34805a30:	e1570001 	cmp	r7, r1
34805a34:	0a000018 	beq	34805a9c <part_validate+0x22c>
				start += mtd->eraseregions[i].erasesize;
34805a38:	e5937008 	ldr	r7, [r3, #8]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805a3c:	e28ee001 	add	lr, lr, #1
				start += mtd->eraseregions[i].erasesize;
34805a40:	e0811007 	add	r1, r1, r7
34805a44:	eafffff5 	b	34805a20 <part_validate+0x1b0>
		for (i = 0; i < mtd->numeraseregions; i++) {
34805a48:	e28cc001 	add	ip, ip, #1
34805a4c:	e2833018 	add	r3, r3, #24
34805a50:	e15c0000 	cmp	ip, r0
34805a54:	baffffee 	blt	34805a14 <part_validate+0x1a4>
		if ((part->offset + part->size) == start)
34805a58:	e5953010 	ldr	r3, [r5, #16]
34805a5c:	e0822003 	add	r2, r2, r3
34805a60:	e1520001 	cmp	r2, r1
34805a64:	0a00000c 	beq	34805a9c <part_validate+0x22c>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805a68:	e5d42008 	ldrb	r2, [r4, #8]
		printf("%s%d: partition (%s) size alignment incorrect\n",
34805a6c:	e3520002 	cmp	r2, #2
34805a70:	059f1034 	ldreq	r1, [pc, #52]	; 34805aac <part_validate+0x23c>
34805a74:	0a000003 	beq	34805a88 <part_validate+0x218>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805a78:	e59f3030 	ldr	r3, [pc, #48]	; 34805ab0 <part_validate+0x240>
34805a7c:	e3520004 	cmp	r2, #4
34805a80:	e59f102c 	ldr	r1, [pc, #44]	; 34805ab4 <part_validate+0x244>
34805a84:	01a01003 	moveq	r1, r3
		printf("%s%d: partition (%s) size alignment incorrect\n",
34805a88:	e5953008 	ldr	r3, [r5, #8]
34805a8c:	e5d42009 	ldrb	r2, [r4, #9]
34805a90:	e59f0030 	ldr	r0, [pc, #48]	; 34805ac8 <part_validate+0x258>
34805a94:	eb000f40 	bl	3480979c <printf>
		return 1;
34805a98:	e3a06001 	mov	r6, #1
}
34805a9c:	e1a00006 	mov	r0, r6
34805aa0:	e28dd008 	add	sp, sp, #8
34805aa4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805aa8:	3482321d 	.word	0x3482321d
34805aac:	34823535 	.word	0x34823535
34805ab0:	34823532 	.word	0x34823532
34805ab4:	34823173 	.word	0x34823173
34805ab8:	34823245 	.word	0x34823245
34805abc:	34823268 	.word	0x34823268
34805ac0:	3482328d 	.word	0x3482328d
34805ac4:	348232f2 	.word	0x348232f2
34805ac8:	348232c3 	.word	0x348232c3

34805acc <mtd_device_validate>:
{
34805acc:	e92d4013 	push	{r0, r1, r4, lr}
	struct mtd_info *mtd = NULL;
34805ad0:	e3a03000 	mov	r3, #0
{
34805ad4:	e1a04002 	mov	r4, r2
	struct mtd_info *mtd = NULL;
34805ad8:	e28d2008 	add	r2, sp, #8
34805adc:	e5223004 	str	r3, [r2, #-4]!
	if (get_mtd_info(type, num, &mtd))
34805ae0:	ebffff44 	bl	348057f8 <get_mtd_info.constprop.11>
34805ae4:	e3500000 	cmp	r0, #0
	*size = mtd->size;
34805ae8:	059d3004 	ldreq	r3, [sp, #4]
		return 1;
34805aec:	13a00001 	movne	r0, #1
	*size = mtd->size;
34805af0:	05933008 	ldreq	r3, [r3, #8]
34805af4:	05843000 	streq	r3, [r4]
}
34805af8:	e28dd008 	add	sp, sp, #8
34805afc:	e8bd8010 	pop	{r4, pc}

34805b00 <device_find>:
	list_for_each(entry, &devices) {
34805b00:	e59f2040 	ldr	r2, [pc, #64]	; 34805b48 <device_find+0x48>
{
34805b04:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	list_for_each(entry, &devices) {
34805b08:	e5b23004 	ldr	r3, [r2, #4]!
34805b0c:	e1530002 	cmp	r3, r2
34805b10:	0a000008 	beq	34805b38 <device_find+0x38>
		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805b14:	e593c008 	ldr	ip, [r3, #8]
34805b18:	e5dce008 	ldrb	lr, [ip, #8]
34805b1c:	e15e0000 	cmp	lr, r0
34805b20:	1a000002 	bne	34805b30 <device_find+0x30>
34805b24:	e5dcc009 	ldrb	ip, [ip, #9]
34805b28:	e15c0001 	cmp	ip, r1
34805b2c:	0a000003 	beq	34805b40 <device_find+0x40>
	list_for_each(entry, &devices) {
34805b30:	e5933000 	ldr	r3, [r3]
34805b34:	eafffff4 	b	34805b0c <device_find+0xc>
	return NULL;
34805b38:	e3a00000 	mov	r0, #0
34805b3c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
34805b40:	e1a00003 	mov	r0, r3
}
34805b44:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
34805b48:	34828780 	.word	0x34828780

34805b4c <device_parse>:
{
34805b4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34805b50:	e24dd030 	sub	sp, sp, #48	; 0x30
	LIST_HEAD(tmp_list);
34805b54:	e28d3028 	add	r3, sp, #40	; 0x28
	if (ret)
34805b58:	e251a000 	subs	sl, r1, #0
	if (!(p = strchr(mtd_id, ':'))) {
34805b5c:	e3a0103a 	mov	r1, #58	; 0x3a
{
34805b60:	e1a09000 	mov	r9, r0
	LIST_HEAD(tmp_list);
34805b64:	e58d3028 	str	r3, [sp, #40]	; 0x28
34805b68:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	*retdev = NULL;
34805b6c:	e3a03000 	mov	r3, #0
34805b70:	e5823000 	str	r3, [r2]
		*ret = NULL;
34805b74:	158a3000 	strne	r3, [sl]
{
34805b78:	e58d2018 	str	r2, [sp, #24]
	if (!(p = strchr(mtd_id, ':'))) {
34805b7c:	eb005740 	bl	3481b884 <strchr>
34805b80:	e3500000 	cmp	r0, #0
		printf("no <mtd-id> identifier\n");
34805b84:	059f046c 	ldreq	r0, [pc, #1132]	; 34805ff8 <device_parse+0x4ac>
	if (!(p = strchr(mtd_id, ':'))) {
34805b88:	0a0000f0 	beq	34805f50 <device_parse+0x404>
	list_for_each(entry, &mtdids) {
34805b8c:	e59fb468 	ldr	fp, [pc, #1128]	; 34805ffc <device_parse+0x4b0>
	p++;
34805b90:	e2804001 	add	r4, r0, #1
	mtd_id_len = p - mtd_id + 1;
34805b94:	e0695000 	rsb	r5, r9, r0
	list_for_each(entry, &mtdids) {
34805b98:	e5bb6220 	ldr	r6, [fp, #544]!	; 0x220
34805b9c:	e156000b 	cmp	r6, fp
34805ba0:	0a00010c 	beq	34805fd8 <device_parse+0x48c>
		if (mtd_id_len != strlen(id->mtd_id))
34805ba4:	e5960010 	ldr	r0, [r6, #16]
34805ba8:	eb00574a 	bl	3481b8d8 <strlen>
34805bac:	e1550000 	cmp	r5, r0
34805bb0:	1a000010 	bne	34805bf8 <device_parse+0xac>
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
34805bb4:	e1a02005 	mov	r2, r5
34805bb8:	e1a01009 	mov	r1, r9
34805bbc:	e5960010 	ldr	r0, [r6, #16]
34805bc0:	eb005720 	bl	3481b848 <strncmp>
34805bc4:	e2507000 	subs	r7, r0, #0
34805bc8:	1a00000a 	bne	34805bf8 <device_parse+0xac>
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805bcc:	e5d61009 	ldrb	r1, [r6, #9]
34805bd0:	e5d60008 	ldrb	r0, [r6, #8]
34805bd4:	ebffffc9 	bl	34805b00 <device_find>
34805bd8:	e3500000 	cmp	r0, #0
	offset = 0;
34805bdc:	058d7008 	streq	r7, [sp, #8]
		part = list_entry(dev->parts.prev, struct part_info, link);
34805be0:	15903014 	ldrne	r3, [r0, #20]
		offset = part->offset + part->size;
34805be4:	15932010 	ldrne	r2, [r3, #16]
34805be8:	15933014 	ldrne	r3, [r3, #20]
34805bec:	10823003 	addne	r3, r2, r3
34805bf0:	158d3008 	strne	r3, [sp, #8]
34805bf4:	ea000001 	b	34805c00 <device_parse+0xb4>
	list_for_each(entry, &mtdids) {
34805bf8:	e5966000 	ldr	r6, [r6]
34805bfc:	eaffffe6 	b	34805b9c <device_parse+0x50>
34805c00:	e3a00001 	mov	r0, #1
34805c04:	e3a03000 	mov	r3, #0
34805c08:	e58d300c 	str	r3, [sp, #12]
	while (p && (*p != '\0') && (*p != ';')) {
34805c0c:	e3540000 	cmp	r4, #0
34805c10:	e1dd20bc 	ldrh	r2, [sp, #12]
34805c14:	0a00009f 	beq	34805e98 <device_parse+0x34c>
34805c18:	e5d43000 	ldrb	r3, [r4]
34805c1c:	e3530000 	cmp	r3, #0
34805c20:	1353003b 	cmpne	r3, #59	; 0x3b
34805c24:	0a00009b 	beq	34805e98 <device_parse+0x34c>
	p = partdef;
34805c28:	e58d4024 	str	r4, [sp, #36]	; 0x24
	if (*p == '-') {
34805c2c:	e5d43000 	ldrb	r3, [r4]
34805c30:	e353002d 	cmp	r3, #45	; 0x2d
		p++;
34805c34:	02844001 	addeq	r4, r4, #1
		size = SIZE_REMAINING;
34805c38:	03e0b000 	mvneq	fp, #0
		p++;
34805c3c:	058d4024 	streq	r4, [sp, #36]	; 0x24
	if (*p == '-') {
34805c40:	0a000009 	beq	34805c6c <device_parse+0x120>
		size = memsize_parse(p, &p);
34805c44:	e28d1024 	add	r1, sp, #36	; 0x24
34805c48:	e1a00004 	mov	r0, r4
34805c4c:	ebfffcfc 	bl	34805044 <memsize_parse>
		if (size < MIN_PART_SIZE) {
34805c50:	e3500a01 	cmp	r0, #4096	; 0x1000
		size = memsize_parse(p, &p);
34805c54:	e1a0b000 	mov	fp, r0
		if (size < MIN_PART_SIZE) {
34805c58:	2a000003 	bcs	34805c6c <device_parse+0x120>
			printf("partition size too small (%lx)\n", size);
34805c5c:	e1a01000 	mov	r1, r0
34805c60:	e59f0398 	ldr	r0, [pc, #920]	; 34806000 <device_parse+0x4b4>
34805c64:	eb000ecc 	bl	3480979c <printf>
34805c68:	ea00003c 	b	34805d60 <device_parse+0x214>
	if (*p == '@') {
34805c6c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805c70:	e5d03000 	ldrb	r3, [r0]
34805c74:	e3530040 	cmp	r3, #64	; 0x40
	offset = OFFSET_NOT_SPECIFIED;
34805c78:	13e03000 	mvnne	r3, #0
34805c7c:	158d3010 	strne	r3, [sp, #16]
	if (*p == '@') {
34805c80:	1a000004 	bne	34805c98 <device_parse+0x14c>
		p++;
34805c84:	e2800001 	add	r0, r0, #1
34805c88:	e28d1030 	add	r1, sp, #48	; 0x30
34805c8c:	e521000c 	str	r0, [r1, #-12]!
		offset = memsize_parse(p, &p);
34805c90:	ebfffceb 	bl	34805044 <memsize_parse>
34805c94:	e58d0010 	str	r0, [sp, #16]
	if (*p == '(') {
34805c98:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
34805c9c:	e5d93000 	ldrb	r3, [r9]
34805ca0:	e3530028 	cmp	r3, #40	; 0x28
		name_len = 22;
34805ca4:	13a03016 	movne	r3, #22
		name = NULL;
34805ca8:	13a09000 	movne	r9, #0
		name_len = 22;
34805cac:	158d3004 	strne	r3, [sp, #4]
	if (*p == '(') {
34805cb0:	1a000015 	bne	34805d0c <device_parse+0x1c0>
		name = ++p;
34805cb4:	e2899001 	add	r9, r9, #1
		if ((p = strchr(name, ')')) == NULL) {
34805cb8:	e3a01029 	mov	r1, #41	; 0x29
34805cbc:	e1a00009 	mov	r0, r9
		name = ++p;
34805cc0:	e58d9024 	str	r9, [sp, #36]	; 0x24
		if ((p = strchr(name, ')')) == NULL) {
34805cc4:	eb0056ee 	bl	3481b884 <strchr>
34805cc8:	e3500000 	cmp	r0, #0
34805ccc:	e1a04000 	mov	r4, r0
34805cd0:	e58d0024 	str	r0, [sp, #36]	; 0x24
34805cd4:	1a000004 	bne	34805cec <device_parse+0x1a0>
			printf("no closing ) found in partition name\n");
34805cd8:	e59f0324 	ldr	r0, [pc, #804]	; 34806004 <device_parse+0x4b8>
34805cdc:	eb000eae 	bl	3480979c <printf>
	*retpart = NULL;
34805ce0:	e1a05004 	mov	r5, r4
			return 1;
34805ce4:	e3a03001 	mov	r3, #1
34805ce8:	ea000050 	b	34805e30 <device_parse+0x2e4>
		name_len = p - name + 1;
34805cec:	e0693000 	rsb	r3, r9, r0
34805cf0:	e2833001 	add	r3, r3, #1
		if ((name_len - 1) == 0) {
34805cf4:	e3530001 	cmp	r3, #1
		name_len = p - name + 1;
34805cf8:	e58d3004 	str	r3, [sp, #4]
		p++;
34805cfc:	12844001 	addne	r4, r4, #1
			printf("empty partition name\n");
34805d00:	059f0300 	ldreq	r0, [pc, #768]	; 34806008 <device_parse+0x4bc>
		p++;
34805d04:	158d4024 	strne	r4, [sp, #36]	; 0x24
		if ((name_len - 1) == 0) {
34805d08:	0a000013 	beq	34805d5c <device_parse+0x210>
	if (strncmp(p, "ro", 2) == 0) {
34805d0c:	e59f12f8 	ldr	r1, [pc, #760]	; 3480600c <device_parse+0x4c0>
34805d10:	e3a02002 	mov	r2, #2
34805d14:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805d18:	eb0056ca 	bl	3481b848 <strncmp>
34805d1c:	e3500000 	cmp	r0, #0
		p += 2;
34805d20:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
	mask_flags = 0;
34805d24:	13a03000 	movne	r3, #0
		p += 2;
34805d28:	02833002 	addeq	r3, r3, #2
34805d2c:	058d3024 	streq	r3, [sp, #36]	; 0x24
		mask_flags |= MTD_WRITEABLE_CMD;
34805d30:	03a03001 	moveq	r3, #1
	if (*p == ',') {
34805d34:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
	mask_flags = 0;
34805d38:	e58d3014 	str	r3, [sp, #20]
	if (*p == ',') {
34805d3c:	e5d41000 	ldrb	r1, [r4]
34805d40:	e351002c 	cmp	r1, #44	; 0x2c
34805d44:	1a000007 	bne	34805d68 <device_parse+0x21c>
		if (size == SIZE_REMAINING) {
34805d48:	e37b0001 	cmn	fp, #1
		*ret = ++p;
34805d4c:	12844001 	addne	r4, r4, #1
34805d50:	158d4024 	strne	r4, [sp, #36]	; 0x24
		if (size == SIZE_REMAINING) {
34805d54:	1a00000c 	bne	34805d8c <device_parse+0x240>
			printf("no partitions allowed after a fill-up partition\n");
34805d58:	e59f02b0 	ldr	r0, [pc, #688]	; 34806010 <device_parse+0x4c4>
34805d5c:	eb000e8e 	bl	3480979c <printf>
			*ret = NULL;
34805d60:	e3a04000 	mov	r4, #0
34805d64:	eaffffdd 	b	34805ce0 <device_parse+0x194>
	} else if ((*p == ';') || (*p == '\0')) {
34805d68:	e351003b 	cmp	r1, #59	; 0x3b
34805d6c:	13510000 	cmpne	r1, #0
34805d70:	03a05001 	moveq	r5, #1
34805d74:	13a05000 	movne	r5, #0
34805d78:	0a000003 	beq	34805d8c <device_parse+0x240>
		printf("unexpected character '%c' at the end of partition\n", *p);
34805d7c:	e59f0290 	ldr	r0, [pc, #656]	; 34806014 <device_parse+0x4c8>
		*ret = NULL;
34805d80:	e1a04005 	mov	r4, r5
		printf("unexpected character '%c' at the end of partition\n", *p);
34805d84:	eb000e84 	bl	3480979c <printf>
34805d88:	eaffffd5 	b	34805ce4 <device_parse+0x198>
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
34805d8c:	e59d3004 	ldr	r3, [sp, #4]
34805d90:	e2832028 	add	r2, r3, #40	; 0x28
34805d94:	e1a00002 	mov	r0, r2
34805d98:	e58d201c 	str	r2, [sp, #28]
34805d9c:	eb00104d 	bl	34809ed8 <malloc>
	if (!part) {
34805da0:	e2505000 	subs	r5, r0, #0
34805da4:	e59d201c 	ldr	r2, [sp, #28]
34805da8:	1a000002 	bne	34805db8 <device_parse+0x26c>
		printf("out of memory\n");
34805dac:	e59f0264 	ldr	r0, [pc, #612]	; 34806018 <device_parse+0x4cc>
34805db0:	eb000e79 	bl	3480979c <printf>
34805db4:	eaffffca 	b	34805ce4 <device_parse+0x198>
	memset(part, 0, sizeof(struct part_info) + name_len);
34805db8:	e3a01000 	mov	r1, #0
34805dbc:	eb00576e 	bl	3481bb7c <memset>
	part->offset = offset;
34805dc0:	e59d3010 	ldr	r3, [sp, #16]
	if (name) {
34805dc4:	e3590000 	cmp	r9, #0
	part->name = (char *)(part + 1);
34805dc8:	e2850028 	add	r0, r5, #40	; 0x28
	part->size = size;
34805dcc:	e585b010 	str	fp, [r5, #16]
	part->name = (char *)(part + 1);
34805dd0:	e5850008 	str	r0, [r5, #8]
	part->offset = offset;
34805dd4:	e5853014 	str	r3, [r5, #20]
	part->mask_flags = mask_flags;
34805dd8:	e59d3014 	ldr	r3, [sp, #20]
34805ddc:	e585301c 	str	r3, [r5, #28]
	if (name) {
34805de0:	0a000005 	beq	34805dfc <device_parse+0x2b0>
		strncpy(part->name, name, name_len - 1);
34805de4:	e59d3004 	ldr	r3, [sp, #4]
34805de8:	e1a01009 	mov	r1, r9
34805dec:	e2432001 	sub	r2, r3, #1
34805df0:	eb005660 	bl	3481b778 <strncpy>
		part->auto_name = 0;
34805df4:	e3a03000 	mov	r3, #0
34805df8:	ea000004 	b	34805e10 <device_parse+0x2c4>
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
34805dfc:	e59d3010 	ldr	r3, [sp, #16]
34805e00:	e1a0200b 	mov	r2, fp
34805e04:	e59f1210 	ldr	r1, [pc, #528]	; 3480601c <device_parse+0x4d0>
34805e08:	eb005afe 	bl	3481ca08 <sprintf>
		part->auto_name = 1;
34805e0c:	e3a03001 	mov	r3, #1
34805e10:	e5c5300c 	strb	r3, [r5, #12]
	part->name[name_len - 1] = '\0';
34805e14:	e5952008 	ldr	r2, [r5, #8]
34805e18:	e59d3004 	ldr	r3, [sp, #4]
34805e1c:	e0822003 	add	r2, r2, r3
34805e20:	e3a03000 	mov	r3, #0
34805e24:	e5423001 	strb	r3, [r2, #-1]
	list->next = list;
34805e28:	e5855000 	str	r5, [r5]
	list->prev = list;
34805e2c:	e5855004 	str	r5, [r5, #4]
		if ((part_parse(p, &p, &part) != 0) || (!part))
34805e30:	e3550000 	cmp	r5, #0
34805e34:	03833001 	orreq	r3, r3, #1
34805e38:	e3130001 	tst	r3, #1
34805e3c:	1a000017 	bne	34805ea0 <device_parse+0x354>
		if (part->offset == OFFSET_NOT_SPECIFIED)
34805e40:	e5959014 	ldr	r9, [r5, #20]
		if (part_validate(id, part) != 0)
34805e44:	e1a01005 	mov	r1, r5
34805e48:	e1a00006 	mov	r0, r6
		if (part->offset == OFFSET_NOT_SPECIFIED)
34805e4c:	e3790001 	cmn	r9, #1
			part->offset = offset;
34805e50:	059d3008 	ldreq	r3, [sp, #8]
34805e54:	05853014 	streq	r3, [r5, #20]
34805e58:	01a09003 	moveq	r9, r3
		if (part_validate(id, part) != 0)
34805e5c:	ebfffe83 	bl	34805870 <part_validate>
34805e60:	e3500000 	cmp	r0, #0
34805e64:	1a00000d 	bne	34805ea0 <device_parse+0x354>
		offset += part->size;
34805e68:	e5953010 	ldr	r3, [r5, #16]
	new->next = next;
34805e6c:	e28d2028 	add	r2, sp, #40	; 0x28
34805e70:	e0893003 	add	r3, r9, r3
34805e74:	e58d3008 	str	r3, [sp, #8]
	__list_add(new, head->prev, head);
34805e78:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
	next->prev = new;
34805e7c:	e58d502c 	str	r5, [sp, #44]	; 0x2c
	new->prev = prev;
34805e80:	e885000c 	stm	r5, {r2, r3}
	prev->next = new;
34805e84:	e5835000 	str	r5, [r3]
34805e88:	e59d300c 	ldr	r3, [sp, #12]
34805e8c:	e2833001 	add	r3, r3, #1
34805e90:	e58d300c 	str	r3, [sp, #12]
34805e94:	eaffff5c 	b	34805c0c <device_parse+0xc0>
	if (err == 1) {
34805e98:	e3500001 	cmp	r0, #1
34805e9c:	1a000002 	bne	34805eac <device_parse+0x360>
		part_delall(&tmp_list);
34805ea0:	e28d0028 	add	r0, sp, #40	; 0x28
34805ea4:	ebfffc80 	bl	348050ac <part_delall>
34805ea8:	ea00004e 	b	34805fe8 <device_parse+0x49c>
	if (num_parts == 0) {
34805eac:	e3520000 	cmp	r2, #0
34805eb0:	1a00000c 	bne	34805ee8 <device_parse+0x39c>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34805eb4:	e5d62008 	ldrb	r2, [r6, #8]
		printf("no partitions for device %s%d (%s)\n",
34805eb8:	e3520002 	cmp	r2, #2
34805ebc:	059f115c 	ldreq	r1, [pc, #348]	; 34806020 <device_parse+0x4d4>
34805ec0:	0a000003 	beq	34805ed4 <device_parse+0x388>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34805ec4:	e59f3158 	ldr	r3, [pc, #344]	; 34806024 <device_parse+0x4d8>
34805ec8:	e3520004 	cmp	r2, #4
34805ecc:	e59f1154 	ldr	r1, [pc, #340]	; 34806028 <device_parse+0x4dc>
34805ed0:	01a01003 	moveq	r1, r3
		printf("no partitions for device %s%d (%s)\n",
34805ed4:	e5963010 	ldr	r3, [r6, #16]
34805ed8:	e5d62009 	ldrb	r2, [r6, #9]
34805edc:	e59f0148 	ldr	r0, [pc, #328]	; 3480602c <device_parse+0x4e0>
34805ee0:	eb000e2d 	bl	3480979c <printf>
34805ee4:	ea00003f 	b	34805fe8 <device_parse+0x49c>
	if (p) {
34805ee8:	e3540000 	cmp	r4, #0
34805eec:	0a000012 	beq	34805f3c <device_parse+0x3f0>
		if (*p == ';') {
34805ef0:	e5d41000 	ldrb	r1, [r4]
34805ef4:	e351003b 	cmp	r1, #59	; 0x3b
34805ef8:	1a000003 	bne	34805f0c <device_parse+0x3c0>
			if (ret)
34805efc:	e35a0000 	cmp	sl, #0
				*ret = ++p;
34805f00:	12844001 	addne	r4, r4, #1
			if (ret)
34805f04:	1a000004 	bne	34805f1c <device_parse+0x3d0>
34805f08:	ea00000b 	b	34805f3c <device_parse+0x3f0>
		} else if (*p == '\0') {
34805f0c:	e3510000 	cmp	r1, #0
34805f10:	1a000003 	bne	34805f24 <device_parse+0x3d8>
			if (ret)
34805f14:	e35a0000 	cmp	sl, #0
34805f18:	0a000007 	beq	34805f3c <device_parse+0x3f0>
				*ret = p;
34805f1c:	e58a4000 	str	r4, [sl]
34805f20:	ea000005 	b	34805f3c <device_parse+0x3f0>
			printf("unexpected character '%c' at the end of device\n", *p);
34805f24:	e59f0104 	ldr	r0, [pc, #260]	; 34806030 <device_parse+0x4e4>
34805f28:	eb000e1b 	bl	3480979c <printf>
			if (ret)
34805f2c:	e35a0000 	cmp	sl, #0
				*ret = NULL;
34805f30:	13a03000 	movne	r3, #0
34805f34:	158a3000 	strne	r3, [sl]
34805f38:	ea00002a 	b	34805fe8 <device_parse+0x49c>
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
34805f3c:	e3a00018 	mov	r0, #24
34805f40:	eb000fe4 	bl	34809ed8 <malloc>
34805f44:	e2504000 	subs	r4, r0, #0
34805f48:	1a000002 	bne	34805f58 <device_parse+0x40c>
		printf("out of memory\n");
34805f4c:	e59f00c4 	ldr	r0, [pc, #196]	; 34806018 <device_parse+0x4cc>
34805f50:	eb000e11 	bl	3480979c <printf>
34805f54:	ea000023 	b	34805fe8 <device_parse+0x49c>
	memset(dev, 0, sizeof(struct mtd_device));
34805f58:	e3a02018 	mov	r2, #24
34805f5c:	e3a01000 	mov	r1, #0
34805f60:	eb005705 	bl	3481bb7c <memset>
	dev->id = id;
34805f64:	e5846008 	str	r6, [r4, #8]
	list_for_each_safe(entry, n, &tmp_list) {
34805f68:	e28d6030 	add	r6, sp, #48	; 0x30
	list->next = list;
34805f6c:	e5844000 	str	r4, [r4]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34805f70:	e3a03000 	mov	r3, #0
	list_for_each_safe(entry, n, &tmp_list) {
34805f74:	e5365008 	ldr	r5, [r6, #-8]!
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34805f78:	e1c430bc 	strh	r3, [r4, #12]
	INIT_LIST_HEAD(&dev->parts);
34805f7c:	e2843010 	add	r3, r4, #16
34805f80:	e5843010 	str	r3, [r4, #16]
	list_for_each_safe(entry, n, &tmp_list) {
34805f84:	e5959000 	ldr	r9, [r5]
	list->prev = list;
34805f88:	e5843014 	str	r3, [r4, #20]
34805f8c:	e5844004 	str	r4, [r4, #4]
34805f90:	e1550006 	cmp	r5, r6
34805f94:	0a00000c 	beq	34805fcc <device_parse+0x480>
		list_del(entry);
34805f98:	e1a00005 	mov	r0, r5
34805f9c:	ebfffc21 	bl	34805028 <list_del>
		if (part_sort_add(dev, part) != 0) {
34805fa0:	e1a01005 	mov	r1, r5
34805fa4:	e1a00004 	mov	r0, r4
34805fa8:	ebfffce3 	bl	3480533c <part_sort_add>
34805fac:	e3500000 	cmp	r0, #0
34805fb0:	0a000002 	beq	34805fc0 <device_parse+0x474>
			device_del(dev);
34805fb4:	e1a00004 	mov	r0, r4
34805fb8:	ebfffd21 	bl	34805444 <device_del>
34805fbc:	ea000009 	b	34805fe8 <device_parse+0x49c>
	list_for_each_safe(entry, n, &tmp_list) {
34805fc0:	e1a05009 	mov	r5, r9
34805fc4:	e5999000 	ldr	r9, [r9]
34805fc8:	eafffff0 	b	34805f90 <device_parse+0x444>
	*retdev = dev;
34805fcc:	e59d3018 	ldr	r3, [sp, #24]
34805fd0:	e5834000 	str	r4, [r3]
	return 0;
34805fd4:	ea000004 	b	34805fec <device_parse+0x4a0>
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
34805fd8:	e1a02009 	mov	r2, r9
34805fdc:	e1a01005 	mov	r1, r5
34805fe0:	e59f004c 	ldr	r0, [pc, #76]	; 34806034 <device_parse+0x4e8>
34805fe4:	eb000dec 	bl	3480979c <printf>
		return 1;
34805fe8:	e3a07001 	mov	r7, #1
}
34805fec:	e1a00007 	mov	r0, r7
34805ff0:	e28dd030 	add	sp, sp, #48	; 0x30
34805ff4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805ff8:	348235c8 	.word	0x348235c8
34805ffc:	34828780 	.word	0x34828780
34806000:	34823329 	.word	0x34823329
34806004:	34823349 	.word	0x34823349
34806008:	3482336f 	.word	0x3482336f
3480600c:	34823385 	.word	0x34823385
34806010:	34823388 	.word	0x34823388
34806014:	348233b9 	.word	0x348233b9
34806018:	348233ec 	.word	0x348233ec
3480601c:	348233fb 	.word	0x348233fb
34806020:	34823535 	.word	0x34823535
34806024:	34823532 	.word	0x34823532
34806028:	34823173 	.word	0x34823173
3480602c:	3482340b 	.word	0x3482340b
34806030:	3482342f 	.word	0x3482342f
34806034:	3482345f 	.word	0x3482345f

34806038 <mtd_id_parse>:
{
34806038:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480603c:	e1a07003 	mov	r7, r3
	*dev_type = 0;
34806040:	e3a03000 	mov	r3, #0
{
34806044:	e1a04001 	mov	r4, r1
34806048:	e1a05002 	mov	r5, r2
3480604c:	e1a06000 	mov	r6, r0
	*dev_type = 0;
34806050:	e5c23000 	strb	r3, [r2]
	if (strncmp(p, "nand", 4) == 0) {
34806054:	e3a02004 	mov	r2, #4
34806058:	e59f10d4 	ldr	r1, [pc, #212]	; 34806134 <mtd_id_parse+0xfc>
	const char *p = id;
3480605c:	e58d0004 	str	r0, [sp, #4]
	if (strncmp(p, "nand", 4) == 0) {
34806060:	eb0055f8 	bl	3481b848 <strncmp>
34806064:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NAND;
34806068:	03a03002 	moveq	r3, #2
3480606c:	05c53000 	strbeq	r3, [r5]
		p += 4;
34806070:	059d3004 	ldreq	r3, [sp, #4]
34806074:	02833004 	addeq	r3, r3, #4
34806078:	0a000013 	beq	348060cc <mtd_id_parse+0x94>
	} else if (strncmp(p, "nor", 3) == 0) {
3480607c:	e3a02003 	mov	r2, #3
34806080:	e59f10b0 	ldr	r1, [pc, #176]	; 34806138 <mtd_id_parse+0x100>
34806084:	e59d0004 	ldr	r0, [sp, #4]
34806088:	eb0055ee 	bl	3481b848 <strncmp>
3480608c:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NOR;
34806090:	03a03001 	moveq	r3, #1
34806094:	05c53000 	strbeq	r3, [r5]
		p += 3;
34806098:	059d3004 	ldreq	r3, [sp, #4]
3480609c:	02833003 	addeq	r3, r3, #3
348060a0:	0a000009 	beq	348060cc <mtd_id_parse+0x94>
	} else if (strncmp(p, "onenand", 7) == 0) {
348060a4:	e3a02007 	mov	r2, #7
348060a8:	e59f108c 	ldr	r1, [pc, #140]	; 3480613c <mtd_id_parse+0x104>
348060ac:	e59d0004 	ldr	r0, [sp, #4]
348060b0:	eb0055e4 	bl	3481b848 <strncmp>
348060b4:	e3500000 	cmp	r0, #0
348060b8:	1a00000d 	bne	348060f4 <mtd_id_parse+0xbc>
		*dev_type = MTD_DEV_TYPE_ONENAND;
348060bc:	e3a03004 	mov	r3, #4
348060c0:	e5c53000 	strb	r3, [r5]
		p += 7;
348060c4:	e59d3004 	ldr	r3, [sp, #4]
348060c8:	e2833007 	add	r3, r3, #7
348060cc:	e58d3004 	str	r3, [sp, #4]
	if (!isdigit(*p)) {
348060d0:	e59d0004 	ldr	r0, [sp, #4]
348060d4:	e59f2064 	ldr	r2, [pc, #100]	; 34806140 <mtd_id_parse+0x108>
348060d8:	e5d03000 	ldrb	r3, [r0]
348060dc:	e7d23003 	ldrb	r3, [r2, r3]
348060e0:	e3130004 	tst	r3, #4
348060e4:	1a000007 	bne	34806108 <mtd_id_parse+0xd0>
		printf("incorrect device number in %s\n", id);
348060e8:	e1a01006 	mov	r1, r6
348060ec:	e59f0050 	ldr	r0, [pc, #80]	; 34806144 <mtd_id_parse+0x10c>
348060f0:	ea000001 	b	348060fc <mtd_id_parse+0xc4>
		printf("incorrect device type in %s\n", id);
348060f4:	e59f004c 	ldr	r0, [pc, #76]	; 34806148 <mtd_id_parse+0x110>
348060f8:	e1a01006 	mov	r1, r6
		printf("incorrect device number in %s\n", id);
348060fc:	eb000da6 	bl	3480979c <printf>
		return 1;
34806100:	e3a00001 	mov	r0, #1
34806104:	ea000008 	b	3480612c <mtd_id_parse+0xf4>
	*dev_num = simple_strtoul(p, (char **)&p, 0);
34806108:	e3a02000 	mov	r2, #0
3480610c:	e28d1004 	add	r1, sp, #4
34806110:	eb005993 	bl	3481c764 <simple_strtoul>
	if (ret_id)
34806114:	e3540000 	cmp	r4, #0
	*dev_num = simple_strtoul(p, (char **)&p, 0);
34806118:	e5c70000 	strb	r0, [r7]
		*ret_id = p;
3480611c:	159d3004 	ldrne	r3, [sp, #4]
	return 0;
34806120:	13a00000 	movne	r0, #0
34806124:	01a00004 	moveq	r0, r4
		*ret_id = p;
34806128:	15843000 	strne	r3, [r4]
}
3480612c:	e28dd00c 	add	sp, sp, #12
34806130:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34806134:	34823535 	.word	0x34823535
34806138:	34823173 	.word	0x34823173
3480613c:	34823532 	.word	0x34823532
34806140:	34820934 	.word	0x34820934
34806144:	34823497 	.word	0x34823497
34806148:	3482347a 	.word	0x3482347a

3480614c <find_dev_and_part>:
{
3480614c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34806150:	e1a0a003 	mov	sl, r3
	list_for_each(dentry, &devices) {
34806154:	e59f3184 	ldr	r3, [pc, #388]	; 348062e0 <find_dev_and_part+0x194>
{
34806158:	e1a05002 	mov	r5, r2
3480615c:	e1a0b000 	mov	fp, r0
34806160:	e1a06001 	mov	r6, r1
34806164:	e3a02000 	mov	r2, #0
	list_for_each(dentry, &devices) {
34806168:	e5b37004 	ldr	r7, [r3, #4]!
3480616c:	e1570003 	cmp	r7, r3
34806170:	e3a01000 	mov	r1, #0
34806174:	0a000017 	beq	348061d8 <find_dev_and_part+0x8c>
		*part_num = 0;
34806178:	e5c52000 	strb	r2, [r5]
		*dev = list_entry(dentry, struct mtd_device, link);
3480617c:	e5867000 	str	r7, [r6]
		list_for_each(pentry, &(*dev)->parts) {
34806180:	e5979010 	ldr	r9, [r7, #16]
34806184:	e5961000 	ldr	r1, [r6]
34806188:	e2811010 	add	r1, r1, #16
3480618c:	e1590001 	cmp	r9, r1
34806190:	0a00000e 	beq	348061d0 <find_dev_and_part+0x84>
			*part = list_entry(pentry, struct part_info, link);
34806194:	e58a9000 	str	r9, [sl]
			if (strcmp((*part)->name, id) == 0)
34806198:	e1a0100b 	mov	r1, fp
3480619c:	e5990008 	ldr	r0, [r9, #8]
348061a0:	e58d2004 	str	r2, [sp, #4]
348061a4:	e58d3000 	str	r3, [sp]
348061a8:	eb00559c 	bl	3481b820 <strcmp>
348061ac:	e2504000 	subs	r4, r0, #0
348061b0:	0a000047 	beq	348062d4 <find_dev_and_part+0x188>
			(*part_num)++;
348061b4:	e5d51000 	ldrb	r1, [r5]
		list_for_each(pentry, &(*dev)->parts) {
348061b8:	e59d2004 	ldr	r2, [sp, #4]
348061bc:	e59d3000 	ldr	r3, [sp]
			(*part_num)++;
348061c0:	e2811001 	add	r1, r1, #1
348061c4:	e5c51000 	strb	r1, [r5]
		list_for_each(pentry, &(*dev)->parts) {
348061c8:	e5999000 	ldr	r9, [r9]
348061cc:	eaffffec 	b	34806184 <find_dev_and_part+0x38>
	list_for_each(dentry, &devices) {
348061d0:	e5977000 	ldr	r7, [r7]
348061d4:	eaffffe4 	b	3480616c <find_dev_and_part+0x20>
	*dev = NULL;
348061d8:	e5861000 	str	r1, [r6]
	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
348061dc:	e28d300b 	add	r3, sp, #11
	*part = NULL;
348061e0:	e58a1000 	str	r1, [sl]
	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
348061e4:	e28d200a 	add	r2, sp, #10
	*part_num = 0;
348061e8:	e5c51000 	strb	r1, [r5]
	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
348061ec:	e1a0000b 	mov	r0, fp
348061f0:	e28d100c 	add	r1, sp, #12
	p = id;
348061f4:	e58db00c 	str	fp, [sp, #12]
	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
348061f8:	ebffff8e 	bl	34806038 <mtd_id_parse>
348061fc:	e2504000 	subs	r4, r0, #0
34806200:	1a000032 	bne	348062d0 <find_dev_and_part+0x184>
	if ((*p++ != ',') || (*p == '\0')) {
34806204:	e59d300c 	ldr	r3, [sp, #12]
34806208:	e2830001 	add	r0, r3, #1
3480620c:	e58d000c 	str	r0, [sp, #12]
34806210:	e5d32000 	ldrb	r2, [r3]
34806214:	e352002c 	cmp	r2, #44	; 0x2c
34806218:	1a000002 	bne	34806228 <find_dev_and_part+0xdc>
3480621c:	e5d33001 	ldrb	r3, [r3, #1]
34806220:	e3530000 	cmp	r3, #0
34806224:	1a000002 	bne	34806234 <find_dev_and_part+0xe8>
		printf("no partition number specified\n");
34806228:	e59f00b4 	ldr	r0, [pc, #180]	; 348062e4 <find_dev_and_part+0x198>
3480622c:	eb000d5a 	bl	3480979c <printf>
34806230:	ea000026 	b	348062d0 <find_dev_and_part+0x184>
	pnum = simple_strtoul(p, (char **)&p, 0);
34806234:	e28d100c 	add	r1, sp, #12
34806238:	e1a02004 	mov	r2, r4
3480623c:	eb005948 	bl	3481c764 <simple_strtoul>
	if (*p != '\0') {
34806240:	e59d300c 	ldr	r3, [sp, #12]
	pnum = simple_strtoul(p, (char **)&p, 0);
34806244:	e1a09000 	mov	r9, r0
	if (*p != '\0') {
34806248:	e5d31000 	ldrb	r1, [r3]
3480624c:	e3510000 	cmp	r1, #0
34806250:	0a000002 	beq	34806260 <find_dev_and_part+0x114>
		printf("unexpected trailing character '%c'\n", *p);
34806254:	e59f008c 	ldr	r0, [pc, #140]	; 348062e8 <find_dev_and_part+0x19c>
34806258:	eb000d4f 	bl	3480979c <printf>
3480625c:	ea00001b 	b	348062d0 <find_dev_and_part+0x184>
	if ((*dev = device_find(type, dnum)) == NULL) {
34806260:	e5dd700a 	ldrb	r7, [sp, #10]
34806264:	e5ddb00b 	ldrb	fp, [sp, #11]
34806268:	e1a00007 	mov	r0, r7
3480626c:	e1a0100b 	mov	r1, fp
34806270:	ebfffe22 	bl	34805b00 <device_find>
34806274:	e3500000 	cmp	r0, #0
34806278:	e5860000 	str	r0, [r6]
3480627c:	1a00000a 	bne	348062ac <find_dev_and_part+0x160>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
34806280:	e3570002 	cmp	r7, #2
34806284:	059f1060 	ldreq	r1, [pc, #96]	; 348062ec <find_dev_and_part+0x1a0>
34806288:	0a000003 	beq	3480629c <find_dev_and_part+0x150>
3480628c:	e59f305c 	ldr	r3, [pc, #92]	; 348062f0 <find_dev_and_part+0x1a4>
34806290:	e3570004 	cmp	r7, #4
34806294:	e59f1058 	ldr	r1, [pc, #88]	; 348062f4 <find_dev_and_part+0x1a8>
34806298:	01a01003 	moveq	r1, r3
3480629c:	e1a0200b 	mov	r2, fp
348062a0:	e59f0050 	ldr	r0, [pc, #80]	; 348062f8 <find_dev_and_part+0x1ac>
348062a4:	eb000d3c 	bl	3480979c <printf>
348062a8:	ea000008 	b	348062d0 <find_dev_and_part+0x184>
	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
348062ac:	e6ef1079 	uxtb	r1, r9
348062b0:	ebfffba0 	bl	34805138 <mtd_part_info>
348062b4:	e3500000 	cmp	r0, #0
348062b8:	e58a0000 	str	r0, [sl]
	pnum = simple_strtoul(p, (char **)&p, 0);
348062bc:	15c59000 	strbne	r9, [r5]
	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
348062c0:	1a000003 	bne	348062d4 <find_dev_and_part+0x188>
		printf("no such partition\n");
348062c4:	e59f0030 	ldr	r0, [pc, #48]	; 348062fc <find_dev_and_part+0x1b0>
348062c8:	eb000d33 	bl	3480979c <printf>
		*dev = NULL;
348062cc:	e5864000 	str	r4, [r6]
		return 1;
348062d0:	e3a04001 	mov	r4, #1
}
348062d4:	e1a00004 	mov	r0, r4
348062d8:	e28dd010 	add	sp, sp, #16
348062dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348062e0:	34828780 	.word	0x34828780
348062e4:	348234b6 	.word	0x348234b6
348062e8:	348234d5 	.word	0x348234d5
348062ec:	34823535 	.word	0x34823535
348062f0:	34823532 	.word	0x34823532
348062f4:	34823173 	.word	0x34823173
348062f8:	348234f9 	.word	0x348234f9
348062fc:	3482350e 	.word	0x3482350e

34806300 <mtdparts_init>:
{
34806300:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34806304:	e24dd028 	sub	sp, sp, #40	; 0x28
	if (!initialized) {
34806308:	e59f456c 	ldr	r4, [pc, #1388]	; 3480687c <mtdparts_init+0x57c>
3480630c:	e5945228 	ldr	r5, [r4, #552]	; 0x228
34806310:	e3550000 	cmp	r5, #0
34806314:	1a000013 	bne	34806368 <mtdparts_init+0x68>
	list->next = list;
34806318:	e2843e22 	add	r3, r4, #544	; 0x220
		memset(last_ids, 0, MTDIDS_MAXLEN);
3480631c:	e3a02080 	mov	r2, #128	; 0x80
34806320:	e5843220 	str	r3, [r4, #544]	; 0x220
34806324:	e1a01005 	mov	r1, r5
	list->prev = list;
34806328:	e5843224 	str	r3, [r4, #548]	; 0x224
3480632c:	e2840f8b 	add	r0, r4, #556	; 0x22c
	list->next = list;
34806330:	e2843004 	add	r3, r4, #4
34806334:	e5843004 	str	r3, [r4, #4]
	list->prev = list;
34806338:	e5843008 	str	r3, [r4, #8]
3480633c:	eb00560e 	bl	3481bb7c <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
34806340:	e3a02c02 	mov	r2, #512	; 0x200
34806344:	e1a01005 	mov	r1, r5
34806348:	e284001d 	add	r0, r4, #29
3480634c:	eb00560a 	bl	3481bb7c <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
34806350:	e3a02010 	mov	r2, #16
34806354:	e1a01005 	mov	r1, r5
34806358:	e284000d 	add	r0, r4, #13
3480635c:	eb005606 	bl	3481bb7c <memset>
		initialized = 1;
34806360:	e3a03001 	mov	r3, #1
34806364:	e5843228 	str	r3, [r4, #552]	; 0x228
	ids = getenv("mtdids");
34806368:	e59f0510 	ldr	r0, [pc, #1296]	; 34806880 <mtdparts_init+0x580>
3480636c:	eb000604 	bl	34807b84 <getenv>
34806370:	e1a07000 	mov	r7, r0
	parts = getenv("mtdparts");
34806374:	e59f0508 	ldr	r0, [pc, #1288]	; 34806884 <mtdparts_init+0x584>
34806378:	eb000601 	bl	34807b84 <getenv>
3480637c:	e1a09000 	mov	r9, r0
	current_partition = getenv("partition");
34806380:	e59f0500 	ldr	r0, [pc, #1280]	; 34806888 <mtdparts_init+0x588>
34806384:	eb0005fe 	bl	34807b84 <getenv>
	if (current_partition)
34806388:	e2501000 	subs	r1, r0, #0
	tmp_ep[0] = '\0';
3480638c:	e3a03000 	mov	r3, #0
34806390:	e5cd3018 	strb	r3, [sp, #24]
	if (current_partition)
34806394:	0a000002 	beq	348063a4 <mtdparts_init+0xa4>
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
34806398:	e3a02010 	mov	r2, #16
3480639c:	e28d0018 	add	r0, sp, #24
348063a0:	eb0054f4 	bl	3481b778 <strncpy>
	if (!ids) {
348063a4:	e3570000 	cmp	r7, #0
348063a8:	1a000003 	bne	348063bc <mtdparts_init+0xbc>
			ids = mtdids_default;
348063ac:	e59f74d8 	ldr	r7, [pc, #1240]	; 3480688c <mtdparts_init+0x58c>
			setenv("mtdids", (char *)ids);
348063b0:	e59f14d4 	ldr	r1, [pc, #1236]	; 3480688c <mtdparts_init+0x58c>
348063b4:	e59f04c4 	ldr	r0, [pc, #1220]	; 34806880 <mtdparts_init+0x580>
348063b8:	eb0004ed 	bl	34807774 <setenv>
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
348063bc:	e1a00007 	mov	r0, r7
348063c0:	eb005544 	bl	3481b8d8 <strlen>
348063c4:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
348063c8:	83a01080 	movhi	r1, #128	; 0x80
348063cc:	859f04bc 	ldrhi	r0, [pc, #1212]	; 34806890 <mtdparts_init+0x590>
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
348063d0:	8a00000a 	bhi	34806400 <mtdparts_init+0x100>
	if (!parts)
348063d4:	e3590000 	cmp	r9, #0
348063d8:	1a000002 	bne	348063e8 <mtdparts_init+0xe8>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
348063dc:	e59f04b0 	ldr	r0, [pc, #1200]	; 34806894 <mtdparts_init+0x594>
348063e0:	eb000ced 	bl	3480979c <printf>
348063e4:	ea000008 	b	3480640c <mtdparts_init+0x10c>
	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
348063e8:	e1a00009 	mov	r0, r9
348063ec:	eb005539 	bl	3481b8d8 <strlen>
348063f0:	e3500c02 	cmp	r0, #512	; 0x200
348063f4:	3a000004 	bcc	3480640c <mtdparts_init+0x10c>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
348063f8:	e59f0498 	ldr	r0, [pc, #1176]	; 34806898 <mtdparts_init+0x598>
348063fc:	e3a01c02 	mov	r1, #512	; 0x200
34806400:	eb000ce5 	bl	3480979c <printf>
		return 1;
34806404:	e3a00001 	mov	r0, #1
34806408:	ea000119 	b	34806874 <mtdparts_init+0x574>
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
3480640c:	e5d4322c 	ldrb	r3, [r4, #556]	; 0x22c
34806410:	e3530000 	cmp	r3, #0
34806414:	1a000004 	bne	3480642c <mtdparts_init+0x12c>
	list_for_each_safe(entry, n, &mtdids) {
34806418:	e5945220 	ldr	r5, [r4, #544]	; 0x220
	const char *p = ids;
3480641c:	e58d7010 	str	r7, [sp, #16]
	list_for_each_safe(entry, n, &mtdids) {
34806420:	e59f3474 	ldr	r3, [pc, #1140]	; 3480689c <mtdparts_init+0x59c>
34806424:	e595a000 	ldr	sl, [r5]
34806428:	ea000006 	b	34806448 <mtdparts_init+0x148>
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
3480642c:	e1a01007 	mov	r1, r7
34806430:	e59f0468 	ldr	r0, [pc, #1128]	; 348068a0 <mtdparts_init+0x5a0>
34806434:	eb0054f9 	bl	3481b820 <strcmp>
34806438:	e3500000 	cmp	r0, #0
3480643c:	1afffff5 	bne	34806418 <mtdparts_init+0x118>
		ids_changed = 0;
34806440:	e1a05000 	mov	r5, r0
34806444:	ea000072 	b	34806614 <mtdparts_init+0x314>
	list_for_each_safe(entry, n, &mtdids) {
34806448:	e59f642c 	ldr	r6, [pc, #1068]	; 3480687c <mtdparts_init+0x57c>
3480644c:	e1550003 	cmp	r5, r3
34806450:	e286be22 	add	fp, r6, #544	; 0x220
34806454:	0a000008 	beq	3480647c <mtdparts_init+0x17c>
		list_del(entry);
34806458:	e1a00005 	mov	r0, r5
3480645c:	e58d3000 	str	r3, [sp]
34806460:	ebfffaf0 	bl	34805028 <list_del>
		free(id_tmp);
34806464:	e1a00005 	mov	r0, r5
	list_for_each_safe(entry, n, &mtdids) {
34806468:	e1a0500a 	mov	r5, sl
		free(id_tmp);
3480646c:	eb000e0f 	bl	34809cb0 <free>
	list_for_each_safe(entry, n, &mtdids) {
34806470:	e59aa000 	ldr	sl, [sl]
34806474:	e59d3000 	ldr	r3, [sp]
34806478:	eafffff2 	b	34806448 <mtdparts_init+0x148>
	last_ids[0] = '\0';
3480647c:	e3a03000 	mov	r3, #0
	list->next = list;
34806480:	e5865220 	str	r5, [r6, #544]	; 0x220
34806484:	e5c6322c 	strb	r3, [r6, #556]	; 0x22c
	int ret = 1;
34806488:	e3a03001 	mov	r3, #1
	list->prev = list;
3480648c:	e5865224 	str	r5, [r6, #548]	; 0x224
		list_for_each(entry, &mtdids) {
34806490:	e58d6000 	str	r6, [sp]
	while(p && (*p != '\0')) {
34806494:	e59d0010 	ldr	r0, [sp, #16]
34806498:	e3500000 	cmp	r0, #0
3480649c:	1a000007 	bne	348064c0 <mtdparts_init+0x1c0>
	if (ret == 1) {
348064a0:	e3530001 	cmp	r3, #1
348064a4:	0a00004f 	beq	348065e8 <mtdparts_init+0x2e8>
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
348064a8:	e3a02080 	mov	r2, #128	; 0x80
348064ac:	e1a01007 	mov	r1, r7
348064b0:	e59f03e8 	ldr	r0, [pc, #1000]	; 348068a0 <mtdparts_init+0x5a0>
		ids_changed = 1;
348064b4:	e3a05001 	mov	r5, #1
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
348064b8:	eb0054ae 	bl	3481b778 <strncpy>
348064bc:	ea000054 	b	34806614 <mtdparts_init+0x314>
	while(p && (*p != '\0')) {
348064c0:	e5d02000 	ldrb	r2, [r0]
348064c4:	e3520000 	cmp	r2, #0
348064c8:	0afffff4 	beq	348064a0 <mtdparts_init+0x1a0>
		if (mtd_id_parse(p, &p, &type, &num) != 0)
348064cc:	e28d300f 	add	r3, sp, #15
348064d0:	e28d200e 	add	r2, sp, #14
348064d4:	e28d1010 	add	r1, sp, #16
348064d8:	ebfffed6 	bl	34806038 <mtd_id_parse>
348064dc:	e3500000 	cmp	r0, #0
348064e0:	1a000040 	bne	348065e8 <mtdparts_init+0x2e8>
		if (*p != '=') {
348064e4:	e59d3010 	ldr	r3, [sp, #16]
348064e8:	e5d32000 	ldrb	r2, [r3]
348064ec:	e352003d 	cmp	r2, #61	; 0x3d
			printf("mtdids: incorrect <dev-num>\n");
348064f0:	159f03ac 	ldrne	r0, [pc, #940]	; 348068a4 <mtdparts_init+0x5a4>
348064f4:	1a00002f 	bne	348065b8 <mtdparts_init+0x2b8>
		p++;
348064f8:	e2833001 	add	r3, r3, #1
		if (mtd_device_validate(type, num, &size) != 0)
348064fc:	e28d2014 	add	r2, sp, #20
34806500:	e5dd100f 	ldrb	r1, [sp, #15]
34806504:	e5dd000e 	ldrb	r0, [sp, #14]
		p++;
34806508:	e58d3010 	str	r3, [sp, #16]
		if (mtd_device_validate(type, num, &size) != 0)
3480650c:	ebfffd6e 	bl	34805acc <mtd_device_validate>
34806510:	e3500000 	cmp	r0, #0
34806514:	0a000001 	beq	34806520 <mtdparts_init+0x220>
			mtd_devices_init();
34806518:	ebfffcad 	bl	348057d4 <mtd_devices_init>
3480651c:	eaffffb8 	b	34806404 <mtdparts_init+0x104>
		mtd_id = p;
34806520:	e59da010 	ldr	sl, [sp, #16]
		if ((p = strchr(mtd_id, ',')) != NULL) {
34806524:	e3a0102c 	mov	r1, #44	; 0x2c
34806528:	e1a0000a 	mov	r0, sl
3480652c:	eb0054d4 	bl	3481b884 <strchr>
34806530:	e3500000 	cmp	r0, #0
34806534:	e58d0010 	str	r0, [sp, #16]
			mtd_id_len = p - mtd_id + 1;
34806538:	106a3000 	rsbne	r3, sl, r0
			p++;
3480653c:	12800001 	addne	r0, r0, #1
			mtd_id_len = p - mtd_id + 1;
34806540:	12836001 	addne	r6, r3, #1
			p++;
34806544:	158d0010 	strne	r0, [sp, #16]
34806548:	1a000002 	bne	34806558 <mtdparts_init+0x258>
			mtd_id_len = strlen(mtd_id) + 1;
3480654c:	e1a0000a 	mov	r0, sl
34806550:	eb0054e0 	bl	3481b8d8 <strlen>
34806554:	e2806001 	add	r6, r0, #1
		if (mtd_id_len == 0) {
34806558:	e3560000 	cmp	r6, #0
			printf("mtdids: no <mtd-id> identifier\n");
3480655c:	059f0344 	ldreq	r0, [pc, #836]	; 348068a8 <mtdparts_init+0x5a8>
34806560:	0a000014 	beq	348065b8 <mtdparts_init+0x2b8>
		list_for_each(entry, &mtdids) {
34806564:	e5940220 	ldr	r0, [r4, #544]	; 0x220
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
34806568:	e5dd100e 	ldrb	r1, [sp, #14]
3480656c:	e5dd200f 	ldrb	r2, [sp, #15]
		list_for_each(entry, &mtdids) {
34806570:	e150000b 	cmp	r0, fp
34806574:	0a000007 	beq	34806598 <mtdparts_init+0x298>
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
34806578:	e5d0c008 	ldrb	ip, [r0, #8]
3480657c:	e15c0001 	cmp	ip, r1
34806580:	1a000002 	bne	34806590 <mtdparts_init+0x290>
34806584:	e5d0c009 	ldrb	ip, [r0, #9]
34806588:	e15c0002 	cmp	ip, r2
3480658c:	0a00000b 	beq	348065c0 <mtdparts_init+0x2c0>
		list_for_each(entry, &mtdids) {
34806590:	e5900000 	ldr	r0, [r0]
34806594:	eafffff5 	b	34806570 <mtdparts_init+0x270>
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
34806598:	e2862014 	add	r2, r6, #20
3480659c:	e1a00002 	mov	r0, r2
348065a0:	e58d2004 	str	r2, [sp, #4]
348065a4:	eb000e4b 	bl	34809ed8 <malloc>
348065a8:	e2505000 	subs	r5, r0, #0
348065ac:	e59d2004 	ldr	r2, [sp, #4]
348065b0:	1a000074 	bne	34806788 <mtdparts_init+0x488>
			printf("out of memory\n");
348065b4:	e59f02f0 	ldr	r0, [pc, #752]	; 348068ac <mtdparts_init+0x5ac>
348065b8:	eb000c77 	bl	3480979c <printf>
348065bc:	ea000009 	b	348065e8 <mtdparts_init+0x2e8>
			printf("device id %s%d redefined, please correct mtdids variable\n",
348065c0:	e3510002 	cmp	r1, #2
348065c4:	059f12e4 	ldreq	r1, [pc, #740]	; 348068b0 <mtdparts_init+0x5b0>
348065c8:	0a000004 	beq	348065e0 <mtdparts_init+0x2e0>
					MTD_DEV_TYPE(type), num);
348065cc:	e59f02e0 	ldr	r0, [pc, #736]	; 348068b4 <mtdparts_init+0x5b4>
348065d0:	e3510004 	cmp	r1, #4
348065d4:	e59f32dc 	ldr	r3, [pc, #732]	; 348068b8 <mtdparts_init+0x5b8>
348065d8:	11a01000 	movne	r1, r0
348065dc:	01a01003 	moveq	r1, r3
			printf("device id %s%d redefined, please correct mtdids variable\n",
348065e0:	e59f02d4 	ldr	r0, [pc, #724]	; 348068bc <mtdparts_init+0x5bc>
348065e4:	eb000c6c 	bl	3480979c <printf>
		list_for_each_safe(entry, n, &mtdids) {
348065e8:	e5944220 	ldr	r4, [r4, #544]	; 0x220
348065ec:	e5945000 	ldr	r5, [r4]
348065f0:	e154000b 	cmp	r4, fp
348065f4:	0affffc7 	beq	34806518 <mtdparts_init+0x218>
			list_del(entry);
348065f8:	e1a00004 	mov	r0, r4
348065fc:	ebfffa89 	bl	34805028 <list_del>
			free(id_tmp);
34806600:	e1a00004 	mov	r0, r4
		list_for_each_safe(entry, n, &mtdids) {
34806604:	e1a04005 	mov	r4, r5
			free(id_tmp);
34806608:	eb000da8 	bl	34809cb0 <free>
		list_for_each_safe(entry, n, &mtdids) {
3480660c:	e5955000 	ldr	r5, [r5]
34806610:	eafffff6 	b	348065f0 <mtdparts_init+0x2f0>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
34806614:	e3590000 	cmp	r9, #0
34806618:	e5d4301d 	ldrb	r3, [r4, #29]
3480661c:	0a000073 	beq	348067f0 <mtdparts_init+0x4f0>
34806620:	e3530000 	cmp	r3, #0
34806624:	1a000005 	bne	34806640 <mtdparts_init+0x340>
	const char *p = mtdparts;
34806628:	e58d9010 	str	r9, [sp, #16]
	if (mtd_devices_init() != 0) {
3480662c:	ebfffc68 	bl	348057d4 <mtd_devices_init>
34806630:	e3500000 	cmp	r0, #0
34806634:	0a000007 	beq	34806658 <mtdparts_init+0x358>
		printf("could not initialise device list\n");
34806638:	e59f0280 	ldr	r0, [pc, #640]	; 348068c0 <mtdparts_init+0x5c0>
3480663c:	ea00000e 	b	3480667c <mtdparts_init+0x37c>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
34806640:	e1a01009 	mov	r1, r9
34806644:	e59f0278 	ldr	r0, [pc, #632]	; 348068c4 <mtdparts_init+0x5c4>
34806648:	eb005474 	bl	3481b820 <strcmp>
3480664c:	e1903005 	orrs	r3, r0, r5
34806650:	1afffff4 	bne	34806628 <mtdparts_init+0x328>
34806654:	ea000069 	b	34806800 <mtdparts_init+0x500>
	p = getenv("mtdparts");
34806658:	e59f0224 	ldr	r0, [pc, #548]	; 34806884 <mtdparts_init+0x584>
3480665c:	eb000548 	bl	34807b84 <getenv>
	if (strncmp(p, "mtdparts=", 9) != 0) {
34806660:	e3a02009 	mov	r2, #9
34806664:	e59f125c 	ldr	r1, [pc, #604]	; 348068c8 <mtdparts_init+0x5c8>
	p = getenv("mtdparts");
34806668:	e58d0010 	str	r0, [sp, #16]
	if (strncmp(p, "mtdparts=", 9) != 0) {
3480666c:	eb005475 	bl	3481b848 <strncmp>
34806670:	e2506000 	subs	r6, r0, #0
34806674:	0a000002 	beq	34806684 <mtdparts_init+0x384>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
34806678:	e59f024c 	ldr	r0, [pc, #588]	; 348068cc <mtdparts_init+0x5cc>
3480667c:	eb000c46 	bl	3480979c <printf>
34806680:	eaffff5f 	b	34806404 <mtdparts_init+0x104>
	p += 9;
34806684:	e59d3010 	ldr	r3, [sp, #16]
	new->next = next;
34806688:	e59f7240 	ldr	r7, [pc, #576]	; 348068d0 <mtdparts_init+0x5d0>
3480668c:	e2833009 	add	r3, r3, #9
34806690:	e58d3010 	str	r3, [sp, #16]
	int err = 1;
34806694:	e3a03001 	mov	r3, #1
	while (p && (*p != '\0')) {
34806698:	e59d0010 	ldr	r0, [sp, #16]
3480669c:	e3500000 	cmp	r0, #0
348066a0:	1a000008 	bne	348066c8 <mtdparts_init+0x3c8>
	if (err == 1) {
348066a4:	e3530001 	cmp	r3, #1
348066a8:	0a00002b 	beq	3480675c <mtdparts_init+0x45c>
	return head->next == head;
348066ac:	e59f51c8 	ldr	r5, [pc, #456]	; 3480687c <mtdparts_init+0x57c>
		if (list_empty(&devices)) {
348066b0:	e5942004 	ldr	r2, [r4, #4]
348066b4:	e2853004 	add	r3, r5, #4
348066b8:	e1520003 	cmp	r2, r3
348066bc:	1a000028 	bne	34806764 <mtdparts_init+0x464>
			printf("mtdparts_init: no valid partitions\n");
348066c0:	e59f020c 	ldr	r0, [pc, #524]	; 348068d4 <mtdparts_init+0x5d4>
348066c4:	eaffffec 	b	3480667c <mtdparts_init+0x37c>
	while (p && (*p != '\0')) {
348066c8:	e5d02000 	ldrb	r2, [r0]
348066cc:	e3520000 	cmp	r2, #0
348066d0:	0afffff3 	beq	348066a4 <mtdparts_init+0x3a4>
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
348066d4:	e28d2014 	add	r2, sp, #20
348066d8:	e28d1010 	add	r1, sp, #16
348066dc:	ebfffd1a 	bl	34805b4c <device_parse>
348066e0:	e3500000 	cmp	r0, #0
348066e4:	1a00001c 	bne	3480675c <mtdparts_init+0x45c>
348066e8:	e59d5014 	ldr	r5, [sp, #20]
348066ec:	e3550000 	cmp	r5, #0
348066f0:	0a000019 	beq	3480675c <mtdparts_init+0x45c>
		if (device_find(dev->id->type, dev->id->num) != NULL) {
348066f4:	e5953008 	ldr	r3, [r5, #8]
348066f8:	e5d3b008 	ldrb	fp, [r3, #8]
348066fc:	e5d3a009 	ldrb	sl, [r3, #9]
34806700:	e1a0000b 	mov	r0, fp
34806704:	e1a0100a 	mov	r1, sl
34806708:	ebfffcfc 	bl	34805b00 <device_find>
3480670c:	e3500000 	cmp	r0, #0
34806710:	0a00000a 	beq	34806740 <mtdparts_init+0x440>
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806714:	e35b0002 	cmp	fp, #2
34806718:	059f1190 	ldreq	r1, [pc, #400]	; 348068b0 <mtdparts_init+0x5b0>
3480671c:	0a000003 	beq	34806730 <mtdparts_init+0x430>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
34806720:	e59f3190 	ldr	r3, [pc, #400]	; 348068b8 <mtdparts_init+0x5b8>
34806724:	e35b0004 	cmp	fp, #4
34806728:	e59f1184 	ldr	r1, [pc, #388]	; 348068b4 <mtdparts_init+0x5b4>
3480672c:	01a01003 	moveq	r1, r3
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806730:	e1a0200a 	mov	r2, sl
34806734:	e59f019c 	ldr	r0, [pc, #412]	; 348068d8 <mtdparts_init+0x5d8>
34806738:	eb000c17 	bl	3480979c <printf>
3480673c:	ea000006 	b	3480675c <mtdparts_init+0x45c>
	__list_add(new, head->prev, head);
34806740:	e5942008 	ldr	r2, [r4, #8]
		err = 0;
34806744:	e1a03000 	mov	r3, r0
	next->prev = new;
34806748:	e5845008 	str	r5, [r4, #8]
	new->next = next;
3480674c:	e5857000 	str	r7, [r5]
	new->prev = prev;
34806750:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
34806754:	e5825000 	str	r5, [r2]
34806758:	eaffffce 	b	34806698 <mtdparts_init+0x398>
		device_delall(&devices);
3480675c:	ebfffc07 	bl	34805780 <device_delall.constprop.10>
34806760:	eaffff27 	b	34806404 <mtdparts_init+0x104>
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
34806764:	e3a02c02 	mov	r2, #512	; 0x200
34806768:	e1a01009 	mov	r1, r9
3480676c:	e285001d 	add	r0, r5, #29
34806770:	eb005400 	bl	3481b778 <strncpy>
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34806774:	e5953004 	ldr	r3, [r5, #4]
		current_mtd_partnum = 0;
34806778:	e5c5600c 	strb	r6, [r5, #12]
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
3480677c:	e5853000 	str	r3, [r5]
		current_save();
34806780:	ebfffac0 	bl	34805288 <current_save>
34806784:	ea00001d 	b	34806800 <mtdparts_init+0x500>
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
34806788:	e3a01000 	mov	r1, #0
3480678c:	eb0054fa 	bl	3481bb7c <memset>
		id->num = num;
34806790:	e5dd200f 	ldrb	r2, [sp, #15]
		id->mtd_id = (char *)(id + 1);
34806794:	e2850014 	add	r0, r5, #20
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806798:	e1a0100a 	mov	r1, sl
		id->num = num;
3480679c:	e5c52009 	strb	r2, [r5, #9]
		id->type = type;
348067a0:	e5dd200e 	ldrb	r2, [sp, #14]
348067a4:	e5c52008 	strb	r2, [r5, #8]
		id->size = size;
348067a8:	e59d2014 	ldr	r2, [sp, #20]
		id->mtd_id = (char *)(id + 1);
348067ac:	e5850010 	str	r0, [r5, #16]
		id->size = size;
348067b0:	e585200c 	str	r2, [r5, #12]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
348067b4:	e2462001 	sub	r2, r6, #1
348067b8:	eb0053ee 	bl	3481b778 <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
348067bc:	e5952010 	ldr	r2, [r5, #16]
348067c0:	e3a03000 	mov	r3, #0
	next->prev = new;
348067c4:	e59d1000 	ldr	r1, [sp]
348067c8:	e0822006 	add	r2, r2, r6
348067cc:	e5423001 	strb	r3, [r2, #-1]
	__list_add(new, head->prev, head);
348067d0:	e59d2000 	ldr	r2, [sp]
	list->prev = list;
348067d4:	e5855004 	str	r5, [r5, #4]
	__list_add(new, head->prev, head);
348067d8:	e5922224 	ldr	r2, [r2, #548]	; 0x224
	next->prev = new;
348067dc:	e5815224 	str	r5, [r1, #548]	; 0x224
	new->next = next;
348067e0:	e585b000 	str	fp, [r5]
	new->prev = prev;
348067e4:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
348067e8:	e5825000 	str	r5, [r2]
348067ec:	eaffff28 	b	34806494 <mtdparts_init+0x194>
	if (!parts && (last_parts[0] != '\0'))
348067f0:	e3530000 	cmp	r3, #0
348067f4:	0a000016 	beq	34806854 <mtdparts_init+0x554>
		return mtd_devices_init();
348067f8:	ebfffbf5 	bl	348057d4 <mtd_devices_init>
348067fc:	ea00001c 	b	34806874 <mtdparts_init+0x574>
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806800:	e5dd3018 	ldrb	r3, [sp, #24]
34806804:	e3530000 	cmp	r3, #0
34806808:	0a000013 	beq	3480685c <mtdparts_init+0x55c>
3480680c:	e59f4068 	ldr	r4, [pc, #104]	; 3480687c <mtdparts_init+0x57c>
34806810:	e28d0018 	add	r0, sp, #24
34806814:	e284100d 	add	r1, r4, #13
34806818:	eb005400 	bl	3481b820 <strcmp>
3480681c:	e3500000 	cmp	r0, #0
34806820:	0a00000d 	beq	3480685c <mtdparts_init+0x55c>
		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
34806824:	e28d3010 	add	r3, sp, #16
34806828:	e28d200f 	add	r2, sp, #15
3480682c:	e28d1014 	add	r1, sp, #20
34806830:	e28d0018 	add	r0, sp, #24
34806834:	ebfffe44 	bl	3480614c <find_dev_and_part>
34806838:	e3500000 	cmp	r0, #0
3480683c:	1a000004 	bne	34806854 <mtdparts_init+0x554>
			current_mtd_dev = cdev;
34806840:	e59d3014 	ldr	r3, [sp, #20]
34806844:	e5843000 	str	r3, [r4]
			current_mtd_partnum = pnum;
34806848:	e5dd300f 	ldrb	r3, [sp, #15]
3480684c:	e5c4300c 	strb	r3, [r4, #12]
			current_save();
34806850:	ebfffa8c 	bl	34805288 <current_save>
	return 0;
34806854:	e3a00000 	mov	r0, #0
34806858:	ea000005 	b	34806874 <mtdparts_init+0x574>
	} else if (getenv("partition") == NULL) {
3480685c:	e59f0024 	ldr	r0, [pc, #36]	; 34806888 <mtdparts_init+0x588>
34806860:	eb0004c7 	bl	34807b84 <getenv>
34806864:	e2504000 	subs	r4, r0, #0
34806868:	1afffff9 	bne	34806854 <mtdparts_init+0x554>
		current_save();
3480686c:	ebfffa85 	bl	34805288 <current_save>
	return 0;
34806870:	e1a00004 	mov	r0, r4
}
34806874:	e28dd028 	add	sp, sp, #40	; 0x28
34806878:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480687c:	34828780 	.word	0x34828780
34806880:	3482353a 	.word	0x3482353a
34806884:	348231f9 	.word	0x348231f9
34806888:	34823deb 	.word	0x34823deb
3480688c:	34823521 	.word	0x34823521
34806890:	34823541 	.word	0x34823541
34806894:	34823559 	.word	0x34823559
34806898:	34823589 	.word	0x34823589
3480689c:	348289a0 	.word	0x348289a0
348068a0:	348289ac 	.word	0x348289ac
348068a4:	348235a3 	.word	0x348235a3
348068a8:	348235c0 	.word	0x348235c0
348068ac:	348233ec 	.word	0x348233ec
348068b0:	34823535 	.word	0x34823535
348068b4:	34823173 	.word	0x34823173
348068b8:	34823532 	.word	0x34823532
348068bc:	348235e0 	.word	0x348235e0
348068c0:	3482361a 	.word	0x3482361a
348068c4:	3482879d 	.word	0x3482879d
348068c8:	348231ef 	.word	0x348231ef
348068cc:	3482363c 	.word	0x3482363c
348068d0:	34828784 	.word	0x34828784
348068d4:	348236a7 	.word	0x348236a7
348068d8:	3482366e 	.word	0x3482366e

348068dc <do_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348068dc:	e92d4030 	push	{r4, r5, lr}
348068e0:	e24dd014 	sub	sp, sp, #20
348068e4:	e1a05002 	mov	r5, r2
348068e8:	e1a04003 	mov	r4, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
348068ec:	ebfffe83 	bl	34806300 <mtdparts_init>
348068f0:	e3500000 	cmp	r0, #0
348068f4:	1a000021 	bne	34806980 <do_chpart+0xa4>
		return 1;

	if (argc < 2) {
348068f8:	e3550001 	cmp	r5, #1
348068fc:	ca000002 	bgt	3480690c <do_chpart+0x30>
		printf("no partition id specified\n");
34806900:	e59f0088 	ldr	r0, [pc, #136]	; 34806990 <do_chpart+0xb4>
34806904:	eb000ba4 	bl	3480979c <printf>
34806908:	ea00001c 	b	34806980 <do_chpart+0xa4>
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
3480690c:	e5940004 	ldr	r0, [r4, #4]
34806910:	e28d300c 	add	r3, sp, #12
34806914:	e28d2007 	add	r2, sp, #7
34806918:	e28d1008 	add	r1, sp, #8
3480691c:	ebfffe0a 	bl	3480614c <find_dev_and_part>
34806920:	e2504000 	subs	r4, r0, #0
34806924:	1a000015 	bne	34806980 <do_chpart+0xa4>
		return 1;

	current_mtd_dev = dev;
34806928:	e59f3064 	ldr	r3, [pc, #100]	; 34806994 <do_chpart+0xb8>
3480692c:	e59d2008 	ldr	r2, [sp, #8]
34806930:	e5832000 	str	r2, [r3]
	current_mtd_partnum = pnum;
34806934:	e5dd2007 	ldrb	r2, [sp, #7]
34806938:	e5c3200c 	strb	r2, [r3, #12]
	current_save();
3480693c:	ebfffa51 	bl	34805288 <current_save>

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34806940:	e59d3008 	ldr	r3, [sp, #8]
34806944:	e5932008 	ldr	r2, [r3, #8]
34806948:	e5d21008 	ldrb	r1, [r2, #8]
	printf("partition changed to %s%d,%d\n",
3480694c:	e3510002 	cmp	r1, #2
34806950:	059f1040 	ldreq	r1, [pc, #64]	; 34806998 <do_chpart+0xbc>
34806954:	0a000004 	beq	3480696c <do_chpart+0x90>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34806958:	e59f003c 	ldr	r0, [pc, #60]	; 3480699c <do_chpart+0xc0>
3480695c:	e3510004 	cmp	r1, #4
34806960:	e59f3038 	ldr	r3, [pc, #56]	; 348069a0 <do_chpart+0xc4>
34806964:	11a01000 	movne	r1, r0
34806968:	01a01003 	moveq	r1, r3
	printf("partition changed to %s%d,%d\n",
3480696c:	e5dd3007 	ldrb	r3, [sp, #7]
34806970:	e5d22009 	ldrb	r2, [r2, #9]
34806974:	e59f0028 	ldr	r0, [pc, #40]	; 348069a4 <do_chpart+0xc8>
34806978:	eb000b87 	bl	3480979c <printf>
3480697c:	ea000000 	b	34806984 <do_chpart+0xa8>
		return 1;
34806980:	e3a04001 	mov	r4, #1

	return 0;
}
34806984:	e1a00004 	mov	r0, r4
34806988:	e28dd014 	add	sp, sp, #20
3480698c:	e8bd8030 	pop	{r4, r5, pc}
34806990:	348236cb 	.word	0x348236cb
34806994:	34828780 	.word	0x34828780
34806998:	34823535 	.word	0x34823535
3480699c:	34823173 	.word	0x34823173
348069a0:	34823532 	.word	0x34823532
348069a4:	348236e6 	.word	0x348236e6

348069a8 <do_mtdparts>:
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc == 2) {
348069a8:	e3520002 	cmp	r2, #2
{
348069ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348069b0:	e1a06002 	mov	r6, r2
348069b4:	e24dd058 	sub	sp, sp, #88	; 0x58
348069b8:	e1a05003 	mov	r5, r3
	if (argc == 2) {
348069bc:	1a00001b 	bne	34806a30 <do_mtdparts+0x88>
		if (strcmp(argv[1], "default") == 0) {
348069c0:	e59f1500 	ldr	r1, [pc, #1280]	; 34806ec8 <do_mtdparts+0x520>
348069c4:	e5930004 	ldr	r0, [r3, #4]
348069c8:	eb005394 	bl	3481b820 <strcmp>
348069cc:	e2504000 	subs	r4, r0, #0
348069d0:	1a00000a 	bne	34806a00 <do_mtdparts+0x58>
			setenv("mtdids", (char *)mtdids_default);
348069d4:	e59f14f0 	ldr	r1, [pc, #1264]	; 34806ecc <do_mtdparts+0x524>
348069d8:	e59f04f0 	ldr	r0, [pc, #1264]	; 34806ed0 <do_mtdparts+0x528>
348069dc:	eb000364 	bl	34807774 <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
348069e0:	e59f14ec 	ldr	r1, [pc, #1260]	; 34806ed4 <do_mtdparts+0x52c>
348069e4:	e59f04ec 	ldr	r0, [pc, #1260]	; 34806ed8 <do_mtdparts+0x530>
348069e8:	eb000361 	bl	34807774 <setenv>
			setenv("partition", NULL);
348069ec:	e1a01004 	mov	r1, r4
348069f0:	e59f04e4 	ldr	r0, [pc, #1252]	; 34806edc <do_mtdparts+0x534>
348069f4:	eb00035e 	bl	34807774 <setenv>

			mtdparts_init();
348069f8:	ebfffe40 	bl	34806300 <mtdparts_init>
			return 0;
348069fc:	ea00012e 	b	34806ebc <do_mtdparts+0x514>
		} else if (strcmp(argv[1], "delall") == 0) {
34806a00:	e59f14d8 	ldr	r1, [pc, #1240]	; 34806ee0 <do_mtdparts+0x538>
34806a04:	e5950004 	ldr	r0, [r5, #4]
34806a08:	eb005384 	bl	3481b820 <strcmp>
34806a0c:	e2504000 	subs	r4, r0, #0
34806a10:	1a000006 	bne	34806a30 <do_mtdparts+0x88>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
34806a14:	ebfffe39 	bl	34806300 <mtdparts_init>

			setenv("mtdparts", NULL);
34806a18:	e1a01004 	mov	r1, r4
34806a1c:	e59f04b4 	ldr	r0, [pc, #1204]	; 34806ed8 <do_mtdparts+0x530>
34806a20:	eb000353 	bl	34807774 <setenv>

			/* mtd_devices_init() calls current_save() */
			return mtd_devices_init();
34806a24:	ebfffb6a 	bl	348057d4 <mtd_devices_init>
34806a28:	e1a04000 	mov	r4, r0
34806a2c:	ea000122 	b	34806ebc <do_mtdparts+0x514>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
34806a30:	ebfffe32 	bl	34806300 <mtdparts_init>
34806a34:	e2504000 	subs	r4, r0, #0
34806a38:	1a000116 	bne	34806e98 <do_mtdparts+0x4f0>
		return 1;

	if (argc == 1) {
34806a3c:	e3560001 	cmp	r6, #1
34806a40:	1a00005a 	bne	34806bb0 <do_mtdparts+0x208>
	list_for_each(dentry, &devices) {
34806a44:	e59f7498 	ldr	r7, [pc, #1176]	; 34806ee4 <do_mtdparts+0x53c>
34806a48:	e5975004 	ldr	r5, [r7, #4]
34806a4c:	e2879004 	add	r9, r7, #4
34806a50:	e1550009 	cmp	r5, r9
34806a54:	0a000023 	beq	34806ae8 <do_mtdparts+0x140>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806a58:	e5950008 	ldr	r0, [r5, #8]
34806a5c:	e5d02008 	ldrb	r2, [r0, #8]
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806a60:	e3520002 	cmp	r2, #2
34806a64:	059f147c 	ldreq	r1, [pc, #1148]	; 34806ee8 <do_mtdparts+0x540>
34806a68:	0a000003 	beq	34806a7c <do_mtdparts+0xd4>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806a6c:	e59f3478 	ldr	r3, [pc, #1144]	; 34806eec <do_mtdparts+0x544>
34806a70:	e3520004 	cmp	r2, #4
34806a74:	e59f1474 	ldr	r1, [pc, #1140]	; 34806ef0 <do_mtdparts+0x548>
34806a78:	01a01003 	moveq	r1, r3
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806a7c:	e1d530bc 	ldrh	r3, [r5, #12]
		list_for_each(pentry, &dev->parts) {
34806a80:	e1a0a005 	mov	sl, r5
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806a84:	e5d02009 	ldrb	r2, [r0, #9]
		part_num = 0;
34806a88:	e3a0b000 	mov	fp, #0
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806a8c:	e58d3000 	str	r3, [sp]
34806a90:	e5903010 	ldr	r3, [r0, #16]
34806a94:	e59f0458 	ldr	r0, [pc, #1112]	; 34806ef4 <do_mtdparts+0x54c>
34806a98:	eb000b3f 	bl	3480979c <printf>
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");
34806a9c:	e59f0454 	ldr	r0, [pc, #1108]	; 34806ef8 <do_mtdparts+0x550>
34806aa0:	eb000b3d 	bl	3480979c <printf>
		list_for_each(pentry, &dev->parts) {
34806aa4:	e5ba6010 	ldr	r6, [sl, #16]!
34806aa8:	e156000a 	cmp	r6, sl
34806aac:	0a00000b 	beq	34806ae0 <do_mtdparts+0x138>
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806ab0:	e596301c 	ldr	r3, [r6, #28]
34806ab4:	e1a0100b 	mov	r1, fp
34806ab8:	e59f043c 	ldr	r0, [pc, #1084]	; 34806efc <do_mtdparts+0x554>
			part_num++;
34806abc:	e28bb001 	add	fp, fp, #1
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806ac0:	e58d3004 	str	r3, [sp, #4]
34806ac4:	e5963014 	ldr	r3, [r6, #20]
34806ac8:	e58d3000 	str	r3, [sp]
34806acc:	e5963010 	ldr	r3, [r6, #16]
34806ad0:	e5962008 	ldr	r2, [r6, #8]
34806ad4:	eb000b30 	bl	3480979c <printf>
		list_for_each(pentry, &dev->parts) {
34806ad8:	e5966000 	ldr	r6, [r6]
34806adc:	eafffff1 	b	34806aa8 <do_mtdparts+0x100>
	list_for_each(dentry, &devices) {
34806ae0:	e5955000 	ldr	r5, [r5]
34806ae4:	eaffffd9 	b	34806a50 <do_mtdparts+0xa8>
	if (list_empty(&devices))
34806ae8:	e59f33f4 	ldr	r3, [pc, #1012]	; 34806ee4 <do_mtdparts+0x53c>
34806aec:	e5933004 	ldr	r3, [r3, #4]
34806af0:	e1530005 	cmp	r3, r5
34806af4:	1a000001 	bne	34806b00 <do_mtdparts+0x158>
		printf("no partitions defined\n");
34806af8:	e59f0400 	ldr	r0, [pc, #1024]	; 34806f00 <do_mtdparts+0x558>
34806afc:	eb000b26 	bl	3480979c <printf>
	if (current_mtd_dev) {
34806b00:	e5970000 	ldr	r0, [r7]
34806b04:	e59f53d8 	ldr	r5, [pc, #984]	; 34806ee4 <do_mtdparts+0x53c>
34806b08:	e3500000 	cmp	r0, #0
34806b0c:	0a00001b 	beq	34806b80 <do_mtdparts+0x1d8>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806b10:	e5d5100c 	ldrb	r1, [r5, #12]
34806b14:	ebfff987 	bl	34805138 <mtd_part_info>
		if (part) {
34806b18:	e3500000 	cmp	r0, #0
34806b1c:	0a000015 	beq	34806b78 <do_mtdparts+0x1d0>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806b20:	e5953000 	ldr	r3, [r5]
34806b24:	e5932008 	ldr	r2, [r3, #8]
34806b28:	e5d21008 	ldrb	r1, [r2, #8]
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806b2c:	e3510002 	cmp	r1, #2
34806b30:	059f13b0 	ldreq	r1, [pc, #944]	; 34806ee8 <do_mtdparts+0x540>
34806b34:	0a000004 	beq	34806b4c <do_mtdparts+0x1a4>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806b38:	e59fc3b0 	ldr	ip, [pc, #944]	; 34806ef0 <do_mtdparts+0x548>
34806b3c:	e3510004 	cmp	r1, #4
34806b40:	e59f33a4 	ldr	r3, [pc, #932]	; 34806eec <do_mtdparts+0x544>
34806b44:	11a0100c 	movne	r1, ip
34806b48:	01a01003 	moveq	r1, r3
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806b4c:	e590c014 	ldr	ip, [r0, #20]
34806b50:	e5d7300c 	ldrb	r3, [r7, #12]
34806b54:	e5d22009 	ldrb	r2, [r2, #9]
34806b58:	e58dc008 	str	ip, [sp, #8]
34806b5c:	e590c010 	ldr	ip, [r0, #16]
34806b60:	e58dc004 	str	ip, [sp, #4]
34806b64:	e5900008 	ldr	r0, [r0, #8]
34806b68:	e58d0000 	str	r0, [sp]
34806b6c:	e59f0390 	ldr	r0, [pc, #912]	; 34806f04 <do_mtdparts+0x55c>
34806b70:	eb000b09 	bl	3480979c <printf>
34806b74:	ea000001 	b	34806b80 <do_mtdparts+0x1d8>
			printf("could not get current partition info\n\n");
34806b78:	e59f0388 	ldr	r0, [pc, #904]	; 34806f08 <do_mtdparts+0x560>
34806b7c:	eb000b06 	bl	3480979c <printf>
	printf("\ndefaults:\n");
34806b80:	e59f0384 	ldr	r0, [pc, #900]	; 34806f0c <do_mtdparts+0x564>
34806b84:	eb000b04 	bl	3480979c <printf>
	printf("mtdids  : %s\n",
34806b88:	e59f133c 	ldr	r1, [pc, #828]	; 34806ecc <do_mtdparts+0x524>
34806b8c:	e59f037c 	ldr	r0, [pc, #892]	; 34806f10 <do_mtdparts+0x568>
34806b90:	eb000b01 	bl	3480979c <printf>
	puts("mtdparts: ");
34806b94:	e59f0378 	ldr	r0, [pc, #888]	; 34806f14 <do_mtdparts+0x56c>
34806b98:	eb000af3 	bl	3480976c <puts>
	puts(mtdparts_default ? mtdparts_default : "none");
34806b9c:	e59f0330 	ldr	r0, [pc, #816]	; 34806ed4 <do_mtdparts+0x52c>
34806ba0:	eb000af1 	bl	3480976c <puts>
	puts("\n");
34806ba4:	e59f036c 	ldr	r0, [pc, #876]	; 34806f18 <do_mtdparts+0x570>
34806ba8:	eb000aef 	bl	3480976c <puts>
34806bac:	ea0000c2 	b	34806ebc <do_mtdparts+0x514>
		list_partitions();
		return 0;
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strncmp(argv[1], "add", 3) == 0)) {
34806bb0:	e2463005 	sub	r3, r6, #5
34806bb4:	e3530001 	cmp	r3, #1
34806bb8:	8a000069 	bhi	34806d64 <do_mtdparts+0x3bc>
34806bbc:	e59f1358 	ldr	r1, [pc, #856]	; 34806f1c <do_mtdparts+0x574>
34806bc0:	e3a02003 	mov	r2, #3
34806bc4:	e5950004 	ldr	r0, [r5, #4]
34806bc8:	eb00531e 	bl	3481b848 <strncmp>
34806bcc:	e2501000 	subs	r1, r0, #0
34806bd0:	0a000001 	beq	34806bdc <do_mtdparts+0x234>
#if defined(CONFIG_CMD_MTDPARTS_SPREAD)
	if ((argc == 2) && (strcmp(argv[1], "spread") == 0))
		return spread_partitions();
#endif /* CONFIG_CMD_MTDPARTS_SPREAD */

	return CMD_RET_USAGE;
34806bd4:	e3e04000 	mvn	r4, #0
34806bd8:	ea0000b7 	b	34806ebc <do_mtdparts+0x514>
		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
34806bdc:	e28d3013 	add	r3, sp, #19
34806be0:	e28d2012 	add	r2, sp, #18
34806be4:	e5950008 	ldr	r0, [r5, #8]
34806be8:	ebfffd12 	bl	34806038 <mtd_id_parse>
34806bec:	e3500000 	cmp	r0, #0
34806bf0:	1a0000a8 	bne	34806e98 <do_mtdparts+0x4f0>
	list_for_each(entry, &mtdids) {
34806bf4:	e59f62e8 	ldr	r6, [pc, #744]	; 34806ee4 <do_mtdparts+0x53c>
		if ((id = id_find(type, num)) == NULL) {
34806bf8:	e5dd2012 	ldrb	r2, [sp, #18]
34806bfc:	e5dd1013 	ldrb	r1, [sp, #19]
	list_for_each(entry, &mtdids) {
34806c00:	e5967220 	ldr	r7, [r6, #544]	; 0x220
34806c04:	e2863e22 	add	r3, r6, #544	; 0x220
34806c08:	e1570003 	cmp	r7, r3
34806c0c:	0a00009b 	beq	34806e80 <do_mtdparts+0x4d8>
		if ((id->type == type) && (id->num == num))
34806c10:	e5d70008 	ldrb	r0, [r7, #8]
34806c14:	e1500002 	cmp	r0, r2
34806c18:	1a000013 	bne	34806c6c <do_mtdparts+0x2c4>
34806c1c:	e5d70009 	ldrb	r0, [r7, #9]
34806c20:	e1500001 	cmp	r0, r1
34806c24:	1a000010 	bne	34806c6c <do_mtdparts+0x2c4>
		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
34806c28:	e5970010 	ldr	r0, [r7, #16]
34806c2c:	eb005329 	bl	3481b8d8 <strlen>
34806c30:	e1a04000 	mov	r4, r0
		len += strlen(argv[3]);		/* size@offset */
34806c34:	e595000c 	ldr	r0, [r5, #12]
34806c38:	eb005326 	bl	3481b8d8 <strlen>
34806c3c:	e0840000 	add	r0, r4, r0
34806c40:	e2804001 	add	r4, r0, #1
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806c44:	e5950010 	ldr	r0, [r5, #16]
		len += strlen(argv[3]);		/* size@offset */
34806c48:	e6ef4074 	uxtb	r4, r4
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806c4c:	eb005321 	bl	3481b8d8 <strlen>
34806c50:	e2800002 	add	r0, r0, #2
34806c54:	e0844000 	add	r4, r4, r0
		if (argv[5] && (strlen(argv[5]) == 2))
34806c58:	e5950014 	ldr	r0, [r5, #20]
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806c5c:	e6ef4074 	uxtb	r4, r4
		if (argv[5] && (strlen(argv[5]) == 2))
34806c60:	e3500000 	cmp	r0, #0
34806c64:	1a000002 	bne	34806c74 <do_mtdparts+0x2cc>
34806c68:	ea00008c 	b	34806ea0 <do_mtdparts+0x4f8>
	list_for_each(entry, &mtdids) {
34806c6c:	e5977000 	ldr	r7, [r7]
34806c70:	eaffffe4 	b	34806c08 <do_mtdparts+0x260>
		if (argv[5] && (strlen(argv[5]) == 2))
34806c74:	eb005317 	bl	3481b8d8 <strlen>
34806c78:	e3500002 	cmp	r0, #2
			len += 2;		/* 'ro' */
34806c7c:	02844002 	addeq	r4, r4, #2
34806c80:	06ef4074 	uxtbeq	r4, r4
		if (len >= PART_ADD_DESC_MAXLEN) {
34806c84:	e354003f 	cmp	r4, #63	; 0x3f
34806c88:	9a000001 	bls	34806c94 <do_mtdparts+0x2ec>
			printf("too long partition description\n");
34806c8c:	e59f028c 	ldr	r0, [pc, #652]	; 34806f20 <do_mtdparts+0x578>
34806c90:	ea000075 	b	34806e6c <do_mtdparts+0x4c4>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
34806c94:	e5951014 	ldr	r1, [r5, #20]
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806c98:	e59fc284 	ldr	ip, [pc, #644]	; 34806f24 <do_mtdparts+0x57c>
34806c9c:	e5972010 	ldr	r2, [r7, #16]
34806ca0:	e595300c 	ldr	r3, [r5, #12]
34806ca4:	e3510000 	cmp	r1, #0
34806ca8:	e5950010 	ldr	r0, [r5, #16]
34806cac:	01a0100c 	moveq	r1, ip
34806cb0:	e88d0003 	stm	sp, {r0, r1}
34806cb4:	e28d0018 	add	r0, sp, #24
34806cb8:	e59f1268 	ldr	r1, [pc, #616]	; 34806f28 <do_mtdparts+0x580>
34806cbc:	eb005751 	bl	3481ca08 <sprintf>
		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
34806cc0:	e28d2014 	add	r2, sp, #20
34806cc4:	e3a01000 	mov	r1, #0
34806cc8:	e28d0018 	add	r0, sp, #24
34806ccc:	ebfffb9e 	bl	34805b4c <device_parse>
34806cd0:	e3500000 	cmp	r0, #0
34806cd4:	1a00006f 	bne	34806e98 <do_mtdparts+0x4f0>
34806cd8:	e59d4014 	ldr	r4, [sp, #20]
34806cdc:	e3540000 	cmp	r4, #0
34806ce0:	0a00006c 	beq	34806e98 <do_mtdparts+0x4f0>
		dev_tmp = device_find(dev->id->type, dev->id->num);
34806ce4:	e5943008 	ldr	r3, [r4, #8]
		p = list_entry(dev->parts.next, struct part_info, link);
34806ce8:	e5947010 	ldr	r7, [r4, #16]
		dev_tmp = device_find(dev->id->type, dev->id->num);
34806cec:	e5d31009 	ldrb	r1, [r3, #9]
34806cf0:	e5d30008 	ldrb	r0, [r3, #8]
34806cf4:	ebfffb81 	bl	34805b00 <device_find>
		if (dev_tmp == NULL) {
34806cf8:	e2505000 	subs	r5, r0, #0
34806cfc:	1a00000d 	bne	34806d38 <do_mtdparts+0x390>
	return head->next == head;
34806d00:	e59f21dc 	ldr	r2, [pc, #476]	; 34806ee4 <do_mtdparts+0x53c>
	if (list_empty(&devices)) {
34806d04:	e5961004 	ldr	r1, [r6, #4]
34806d08:	e2823004 	add	r3, r2, #4
34806d0c:	e1510003 	cmp	r1, r3
		current_mtd_dev = dev;
34806d10:	05824000 	streq	r4, [r2]
		current_mtd_partnum = 0;
34806d14:	05c2500c 	strbeq	r5, [r2, #12]
		current_save_needed = 1;
34806d18:	03a05001 	moveq	r5, #1
	__list_add(new, head->prev, head);
34806d1c:	e5962008 	ldr	r2, [r6, #8]
	if (current_save_needed > 0)
34806d20:	e3550000 	cmp	r5, #0
	next->prev = new;
34806d24:	e5864008 	str	r4, [r6, #8]
	new->next = next;
34806d28:	e5843000 	str	r3, [r4]
	new->prev = prev;
34806d2c:	e5842004 	str	r2, [r4, #4]
	prev->next = new;
34806d30:	e5824000 	str	r4, [r2]
34806d34:	ea000044 	b	34806e4c <do_mtdparts+0x4a4>
	if (part_validate(dev->id, part) != 0)
34806d38:	e1a01007 	mov	r1, r7
34806d3c:	e5950008 	ldr	r0, [r5, #8]
34806d40:	ebfffaca 	bl	34805870 <part_validate>
34806d44:	e3500000 	cmp	r0, #0
34806d48:	1a000050 	bne	34806e90 <do_mtdparts+0x4e8>
	if (part_sort_add(dev, part) != 0)
34806d4c:	e1a01007 	mov	r1, r7
34806d50:	e1a00005 	mov	r0, r5
34806d54:	ebfff978 	bl	3480533c <part_sort_add>
34806d58:	e3500000 	cmp	r0, #0
34806d5c:	0a00003e 	beq	34806e5c <do_mtdparts+0x4b4>
34806d60:	ea00004a 	b	34806e90 <do_mtdparts+0x4e8>
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
34806d64:	e3560003 	cmp	r6, #3
34806d68:	1affff99 	bne	34806bd4 <do_mtdparts+0x22c>
34806d6c:	e59f11b8 	ldr	r1, [pc, #440]	; 34806f2c <do_mtdparts+0x584>
34806d70:	e5950004 	ldr	r0, [r5, #4]
34806d74:	eb0052a9 	bl	3481b820 <strcmp>
34806d78:	e3500000 	cmp	r0, #0
34806d7c:	1affff94 	bne	34806bd4 <do_mtdparts+0x22c>
		return delete_partition(argv[2]);
34806d80:	e5954008 	ldr	r4, [r5, #8]
	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
34806d84:	e28d3018 	add	r3, sp, #24
34806d88:	e28d2013 	add	r2, sp, #19
34806d8c:	e28d1014 	add	r1, sp, #20
34806d90:	e1a00004 	mov	r0, r4
34806d94:	ebfffcec 	bl	3480614c <find_dev_and_part>
34806d98:	e3500000 	cmp	r0, #0
34806d9c:	1a000034 	bne	34806e74 <do_mtdparts+0x4cc>
		if (part_del(dev, part) != 0)
34806da0:	e59d5014 	ldr	r5, [sp, #20]
34806da4:	e59d6018 	ldr	r6, [sp, #24]
	if (dev->num_parts == 1)
34806da8:	e1d540bc 	ldrh	r4, [r5, #12]
34806dac:	e3540001 	cmp	r4, #1
34806db0:	1a000004 	bne	34806dc8 <do_mtdparts+0x420>
		return device_del(dev);
34806db4:	e1a00005 	mov	r0, r5
34806db8:	ebfff9a1 	bl	34805444 <device_del>
		if (part_del(dev, part) != 0)
34806dbc:	e3500000 	cmp	r0, #0
34806dc0:	1a00003d 	bne	34806ebc <do_mtdparts+0x514>
34806dc4:	ea000024 	b	34806e5c <do_mtdparts+0x4b4>
	if (dev == current_mtd_dev) {
34806dc8:	e59f4114 	ldr	r4, [pc, #276]	; 34806ee4 <do_mtdparts+0x53c>
34806dcc:	e5943000 	ldr	r3, [r4]
34806dd0:	e1550003 	cmp	r5, r3
34806dd4:	0a000001 	beq	34806de0 <do_mtdparts+0x438>
	u8 current_save_needed = 0;
34806dd8:	e3a04000 	mov	r4, #0
34806ddc:	ea000012 	b	34806e2c <do_mtdparts+0x484>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806de0:	e5d4100c 	ldrb	r1, [r4, #12]
34806de4:	e1a00005 	mov	r0, r5
34806de8:	ebfff8d2 	bl	34805138 <mtd_part_info>
		if (curr_pi) {
34806dec:	e3500000 	cmp	r0, #0
34806df0:	0afffff8 	beq	34806dd8 <do_mtdparts+0x430>
			if (curr_pi == part) {
34806df4:	e1500006 	cmp	r0, r6
34806df8:	1a000003 	bne	34806e0c <do_mtdparts+0x464>
				printf("current partition deleted, resetting current to 0\n");
34806dfc:	e59f012c 	ldr	r0, [pc, #300]	; 34806f30 <do_mtdparts+0x588>
34806e00:	eb000a65 	bl	3480979c <printf>
				current_mtd_partnum = 0;
34806e04:	e3a03000 	mov	r3, #0
34806e08:	ea000005 	b	34806e24 <do_mtdparts+0x47c>
			} else if (part->offset <= curr_pi->offset) {
34806e0c:	e5962014 	ldr	r2, [r6, #20]
34806e10:	e5903014 	ldr	r3, [r0, #20]
34806e14:	e1520003 	cmp	r2, r3
34806e18:	8a000002 	bhi	34806e28 <do_mtdparts+0x480>
				current_mtd_partnum--;
34806e1c:	e5d4300c 	ldrb	r3, [r4, #12]
34806e20:	e2433001 	sub	r3, r3, #1
34806e24:	e5c4300c 	strb	r3, [r4, #12]
			current_save_needed = 1;
34806e28:	e3a04001 	mov	r4, #1
	list_del(&part->link);
34806e2c:	e1a00006 	mov	r0, r6
34806e30:	ebfff87c 	bl	34805028 <list_del>
	free(part);
34806e34:	e1a00006 	mov	r0, r6
34806e38:	eb000b9c 	bl	34809cb0 <free>
	dev->num_parts--;
34806e3c:	e1d530bc 	ldrh	r3, [r5, #12]
	if (current_save_needed > 0)
34806e40:	e3540000 	cmp	r4, #0
	dev->num_parts--;
34806e44:	e2433001 	sub	r3, r3, #1
34806e48:	e1c530bc 	strh	r3, [r5, #12]
	if (current_save_needed > 0)
34806e4c:	0a000001 	beq	34806e58 <do_mtdparts+0x4b0>
		current_save();
34806e50:	ebfff90c 	bl	34805288 <current_save>
34806e54:	ea000000 	b	34806e5c <do_mtdparts+0x4b4>
		index_partitions();
34806e58:	ebfff8dc 	bl	348051d0 <index_partitions>
		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
34806e5c:	ebfff991 	bl	348054a8 <generate_mtdparts_save.constprop.8>
34806e60:	e2504000 	subs	r4, r0, #0
34806e64:	0a000014 	beq	34806ebc <do_mtdparts+0x514>
			printf("generated mtdparts too long, reseting to null\n");
34806e68:	e59f00c4 	ldr	r0, [pc, #196]	; 34806f34 <do_mtdparts+0x58c>
34806e6c:	eb000a4a 	bl	3480979c <printf>
34806e70:	ea000008 	b	34806e98 <do_mtdparts+0x4f0>
	printf("partition %s not found\n", id);
34806e74:	e1a01004 	mov	r1, r4
34806e78:	e59f00b8 	ldr	r0, [pc, #184]	; 34806f38 <do_mtdparts+0x590>
34806e7c:	ea000001 	b	34806e88 <do_mtdparts+0x4e0>
			printf("no such device %s defined in mtdids variable\n", argv[2]);
34806e80:	e5951008 	ldr	r1, [r5, #8]
34806e84:	e59f00b0 	ldr	r0, [pc, #176]	; 34806f3c <do_mtdparts+0x594>
34806e88:	eb000a43 	bl	3480979c <printf>
34806e8c:	ea000001 	b	34806e98 <do_mtdparts+0x4f0>
			device_del(dev);
34806e90:	e59d0014 	ldr	r0, [sp, #20]
34806e94:	ebfff96a 	bl	34805444 <device_del>
			return 1;
34806e98:	e3a04001 	mov	r4, #1
34806e9c:	ea000006 	b	34806ebc <do_mtdparts+0x514>
		if (len >= PART_ADD_DESC_MAXLEN) {
34806ea0:	e354003f 	cmp	r4, #63	; 0x3f
34806ea4:	8affff78 	bhi	34806c8c <do_mtdparts+0x2e4>
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806ea8:	e5972010 	ldr	r2, [r7, #16]
34806eac:	e595300c 	ldr	r3, [r5, #12]
34806eb0:	e5950010 	ldr	r0, [r5, #16]
34806eb4:	e59f1068 	ldr	r1, [pc, #104]	; 34806f24 <do_mtdparts+0x57c>
34806eb8:	eaffff7c 	b	34806cb0 <do_mtdparts+0x308>
}
34806ebc:	e1a00004 	mov	r0, r4
34806ec0:	e28dd058 	add	sp, sp, #88	; 0x58
34806ec4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34806ec8:	34823704 	.word	0x34823704
34806ecc:	34823521 	.word	0x34823521
34806ed0:	3482353a 	.word	0x3482353a
34806ed4:	3481f6d4 	.word	0x3481f6d4
34806ed8:	348231f9 	.word	0x348231f9
34806edc:	34823deb 	.word	0x34823deb
34806ee0:	3482370c 	.word	0x3482370c
34806ee4:	34828780 	.word	0x34828780
34806ee8:	34823535 	.word	0x34823535
34806eec:	34823532 	.word	0x34823532
34806ef0:	34823173 	.word	0x34823173
34806ef4:	34823713 	.word	0x34823713
34806ef8:	34823734 	.word	0x34823734
34806efc:	34823758 	.word	0x34823758
34806f00:	34823774 	.word	0x34823774
34806f04:	3482378b 	.word	0x3482378b
34806f08:	348237be 	.word	0x348237be
34806f0c:	348237e5 	.word	0x348237e5
34806f10:	348237f1 	.word	0x348237f1
34806f14:	348237ff 	.word	0x348237ff
34806f18:	34824f42 	.word	0x34824f42
34806f1c:	3482380a 	.word	0x3482380a
34806f20:	3482380e 	.word	0x3482380e
34806f24:	34822afd 	.word	0x34822afd
34806f28:	3482382e 	.word	0x3482382e
34806f2c:	34823869 	.word	0x34823869
34806f30:	3482386d 	.word	0x3482386d
34806f34:	3482383a 	.word	0x3482383a
34806f38:	348238a0 	.word	0x348238a0
34806f3c:	348238b8 	.word	0x348238b8

34806f40 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34806f40:	e92d4010 	push	{r4, lr}
	printf("Not implemented yet\n");
34806f44:	e59f0008 	ldr	r0, [pc, #8]	; 34806f54 <do_env_delete+0x14>
34806f48:	eb000a13 	bl	3480979c <printf>
	return 0;
}
34806f4c:	e3a00000 	mov	r0, #0
34806f50:	e8bd8010 	pop	{r4, pc}
34806f54:	34823e34 	.word	0x34823e34

34806f58 <env_print>:
	if (name) {		/* print a single name */
34806f58:	e2503000 	subs	r3, r0, #0
{
34806f5c:	e92d4010 	push	{r4, lr}
	char *res = NULL;
34806f60:	e3a02000 	mov	r2, #0
{
34806f64:	e24dd018 	sub	sp, sp, #24
	char *res = NULL;
34806f68:	e58d2008 	str	r2, [sp, #8]
	if (name) {		/* print a single name */
34806f6c:	0a00000f 	beq	34806fb0 <env_print+0x58>
		e.key = name;
34806f70:	e58d3010 	str	r3, [sp, #16]
		hsearch_r(e, FIND, &ep, &env_htab);
34806f74:	e28d1018 	add	r1, sp, #24
34806f78:	e59f306c 	ldr	r3, [pc, #108]	; 34806fec <env_print+0x94>
		e.data = NULL;
34806f7c:	e58d2014 	str	r2, [sp, #20]
		hsearch_r(e, FIND, &ep, &env_htab);
34806f80:	e58d3000 	str	r3, [sp]
34806f84:	e28d300c 	add	r3, sp, #12
34806f88:	e9110003 	ldmdb	r1, {r0, r1}
34806f8c:	eb004de1 	bl	3481a718 <hsearch_r>
		if (ep == NULL)
34806f90:	e59d000c 	ldr	r0, [sp, #12]
34806f94:	e3500000 	cmp	r0, #0
34806f98:	0a000002 	beq	34806fa8 <env_print+0x50>
		len = printf("%s=%s\n", ep->key, ep->data);
34806f9c:	e8900006 	ldm	r0, {r1, r2}
34806fa0:	e59f0048 	ldr	r0, [pc, #72]	; 34806ff0 <env_print+0x98>
34806fa4:	eb0009fc 	bl	3480979c <printf>
			return 0;
34806fa8:	e1a04000 	mov	r4, r0
34806fac:	ea00000b 	b	34806fe0 <env_print+0x88>
	len = hexport_r(&env_htab, '\n', &res, 0, 0, NULL);
34806fb0:	e58d3004 	str	r3, [sp, #4]
34806fb4:	e28d2008 	add	r2, sp, #8
34806fb8:	e58d3000 	str	r3, [sp]
34806fbc:	e3a0100a 	mov	r1, #10
34806fc0:	e59f0024 	ldr	r0, [pc, #36]	; 34806fec <env_print+0x94>
34806fc4:	eb004eb3 	bl	3481aa98 <hexport_r>
	if (len > 0) {
34806fc8:	e2504000 	subs	r4, r0, #0
34806fcc:	0a000003 	beq	34806fe0 <env_print+0x88>
		puts(res);
34806fd0:	e59d0008 	ldr	r0, [sp, #8]
34806fd4:	eb0009e4 	bl	3480976c <puts>
		free(res);
34806fd8:	e59d0008 	ldr	r0, [sp, #8]
34806fdc:	eb000b33 	bl	34809cb0 <free>
}
34806fe0:	e1a00004 	mov	r0, r4
34806fe4:	e28dd018 	add	sp, sp, #24
34806fe8:	e8bd8010 	pop	{r4, pc}
34806fec:	348276a4 	.word	0x348276a4
34806ff0:	34823e49 	.word	0x34823e49

34806ff4 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
34806ff4:	e3520001 	cmp	r2, #1
34806ff8:	da000013 	ble	3480704c <do_env+0x58>
{
34806ffc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34807000:	e1a06001 	mov	r6, r1
34807004:	e1a05000 	mov	r5, r0
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
34807008:	e2424001 	sub	r4, r2, #1
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
3480700c:	e3a02008 	mov	r2, #8
	argv++;
34807010:	e2837004 	add	r7, r3, #4
	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
34807014:	e59f1038 	ldr	r1, [pc, #56]	; 34807054 <do_env+0x60>
34807018:	e5930004 	ldr	r0, [r3, #4]
3480701c:	eb000855 	bl	34809178 <find_cmd_tbl>

	if (cp)
34807020:	e3500000 	cmp	r0, #0
34807024:	0a000006 	beq	34807044 <do_env+0x50>
		return cp->cmd(cmdtp, flag, argc, argv);
34807028:	e590c00c 	ldr	ip, [r0, #12]
3480702c:	e1a03007 	mov	r3, r7
34807030:	e1a02004 	mov	r2, r4
34807034:	e1a01006 	mov	r1, r6
34807038:	e1a00005 	mov	r0, r5

	return CMD_RET_USAGE;
}
3480703c:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
		return cp->cmd(cmdtp, flag, argc, argv);
34807040:	e12fff1c 	bx	ip
}
34807044:	e3e00000 	mvn	r0, #0
34807048:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480704c:	e3e00000 	mvn	r0, #0
34807050:	e12fff1e 	bx	lr
34807054:	348270f0 	.word	0x348270f0

34807058 <do_env_import>:
	cmd = *argv;
34807058:	e5931000 	ldr	r1, [r3]
{
3480705c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int	del = 0;
34807060:	e3a07000 	mov	r7, #0
{
34807064:	e1a0a002 	mov	sl, r2
34807068:	e24dd01c 	sub	sp, sp, #28
3480706c:	e1a05003 	mov	r5, r3
	int	fmt = 0;
34807070:	e1a02007 	mov	r2, r7
	int	chk = 0;
34807074:	e1a04007 	mov	r4, r7
	char	sep = '\n';
34807078:	e3a0900a 	mov	r9, #10
	while (--argc > 0 && **++argv == '-') {
3480707c:	e24aa001 	sub	sl, sl, #1
34807080:	e35a0000 	cmp	sl, #0
34807084:	da000026 	ble	34807124 <do_env_import+0xcc>
34807088:	e5b50004 	ldr	r0, [r5, #4]!
3480708c:	e5d03000 	ldrb	r3, [r0]
34807090:	e353002d 	cmp	r3, #45	; 0x2d
34807094:	1a000024 	bne	3480712c <do_env_import+0xd4>
		while (*++arg) {
34807098:	e5f03001 	ldrb	r3, [r0, #1]!
3480709c:	e3530000 	cmp	r3, #0
348070a0:	0afffff5 	beq	3480707c <do_env_import+0x24>
			switch (*arg) {
348070a4:	e3530063 	cmp	r3, #99	; 0x63
348070a8:	0a00000c 	beq	348070e0 <do_env_import+0x88>
348070ac:	8a000002 	bhi	348070bc <do_env_import+0x64>
348070b0:	e3530062 	cmp	r3, #98	; 0x62
348070b4:	0a000005 	beq	348070d0 <do_env_import+0x78>
348070b8:	ea000019 	b	34807124 <do_env_import+0xcc>
348070bc:	e3530064 	cmp	r3, #100	; 0x64
348070c0:	0a000011 	beq	3480710c <do_env_import+0xb4>
348070c4:	e3530074 	cmp	r3, #116	; 0x74
348070c8:	0a00000a 	beq	348070f8 <do_env_import+0xa0>
348070cc:	ea000014 	b	34807124 <do_env_import+0xcc>
				if (fmt++)
348070d0:	e3520000 	cmp	r2, #0
348070d4:	1a00000e 	bne	34807114 <do_env_import+0xbc>
348070d8:	e3a02001 	mov	r2, #1
348070dc:	ea000003 	b	348070f0 <do_env_import+0x98>
				if (fmt++)
348070e0:	e3520000 	cmp	r2, #0
348070e4:	1a00000a 	bne	34807114 <do_env_import+0xbc>
348070e8:	e3a02001 	mov	r2, #1
				chk = 1;
348070ec:	e1a04002 	mov	r4, r2
				sep = '\0';
348070f0:	e3a09000 	mov	r9, #0
348070f4:	eaffffe7 	b	34807098 <do_env_import+0x40>
				if (fmt++)
348070f8:	e3520000 	cmp	r2, #0
348070fc:	1a000004 	bne	34807114 <do_env_import+0xbc>
34807100:	e3a02001 	mov	r2, #1
				sep = '\n';
34807104:	e3a0900a 	mov	r9, #10
34807108:	eaffffe2 	b	34807098 <do_env_import+0x40>
				del = 1;
3480710c:	e3a07001 	mov	r7, #1
34807110:	eaffffe0 	b	34807098 <do_env_import+0x40>
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
34807114:	e59f015c 	ldr	r0, [pc, #348]	; 34807278 <do_env_import+0x220>
34807118:	eb00099f 	bl	3480979c <printf>
	return 1;
3480711c:	e3a00001 	mov	r0, #1
34807120:	ea000052 	b	34807270 <do_env_import+0x218>
		return CMD_RET_USAGE;
34807124:	e3e00000 	mvn	r0, #0
34807128:	ea000050 	b	34807270 <do_env_import+0x218>
	if (!fmt)
3480712c:	e3520000 	cmp	r2, #0
34807130:	1a000001 	bne	3480713c <do_env_import+0xe4>
		printf("## Warning: defaulting to text format\n");
34807134:	e59f0140 	ldr	r0, [pc, #320]	; 3480727c <do_env_import+0x224>
34807138:	eb000997 	bl	3480979c <printf>
	addr = (char *)simple_strtoul(argv[0], NULL, 16);
3480713c:	e3a02010 	mov	r2, #16
34807140:	e3a01000 	mov	r1, #0
34807144:	e5950000 	ldr	r0, [r5]
34807148:	eb005585 	bl	3481c764 <simple_strtoul>
	if (argc == 2) {
3480714c:	e35a0002 	cmp	sl, #2
	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807150:	e1a06000 	mov	r6, r0
34807154:	12802601 	addne	r2, r0, #1048576	; 0x100000
	if (argc == 2) {
34807158:	11a03000 	movne	r3, r0
3480715c:	1a000005 	bne	34807178 <do_env_import+0x120>
		size = simple_strtoul(argv[1], NULL, 16);
34807160:	e5950004 	ldr	r0, [r5, #4]
34807164:	e3a02010 	mov	r2, #16
34807168:	e3a01000 	mov	r1, #0
3480716c:	eb00557c 	bl	3481c764 <simple_strtoul>
34807170:	e1a05000 	mov	r5, r0
34807174:	ea000011 	b	348071c0 <do_env_import+0x168>
34807178:	e0665003 	rsb	r5, r6, r3
			if ((*s == sep) && (*(s+1) == '\0'))
3480717c:	e4d31001 	ldrb	r1, [r3], #1
34807180:	e1510009 	cmp	r1, r9
34807184:	1a000002 	bne	34807194 <do_env_import+0x13c>
34807188:	e5d31000 	ldrb	r1, [r3]
3480718c:	e3510000 	cmp	r1, #0
34807190:	0a000005 	beq	348071ac <do_env_import+0x154>
		while (size < MAX_ENV_SIZE) {
34807194:	e1530002 	cmp	r3, r2
34807198:	1afffff6 	bne	34807178 <do_env_import+0x120>
			printf("## Warning: Input data exceeds %d bytes"
3480719c:	e3a05601 	mov	r5, #1048576	; 0x100000
348071a0:	e3a01601 	mov	r1, #1048576	; 0x100000
348071a4:	e59f00d4 	ldr	r0, [pc, #212]	; 34807280 <do_env_import+0x228>
348071a8:	eb00097b 	bl	3480979c <printf>
		size += 2;
348071ac:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
348071b0:	e59f00cc 	ldr	r0, [pc, #204]	; 34807284 <do_env_import+0x22c>
348071b4:	e1a02005 	mov	r2, r5
348071b8:	e1a01005 	mov	r1, r5
348071bc:	eb000976 	bl	3480979c <printf>
	if (chk) {
348071c0:	e3540000 	cmp	r4, #0
348071c4:	0a00000f 	beq	34807208 <do_env_import+0x1b0>
		memcpy(&crc, &ep->crc, sizeof(crc));
348071c8:	e1a01006 	mov	r1, r6
348071cc:	e3a02004 	mov	r2, #4
		size -= offsetof(env_t, data);
348071d0:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
348071d4:	e28d0014 	add	r0, sp, #20
		if (crc32(0, ep->data, size) != crc) {
348071d8:	e2866004 	add	r6, r6, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
348071dc:	eb005286 	bl	3481bbfc <memcpy>
		if (crc32(0, ep->data, size) != crc) {
348071e0:	e1a02005 	mov	r2, r5
348071e4:	e1a01006 	mov	r1, r6
348071e8:	e3a00000 	mov	r0, #0
348071ec:	eb004b1d 	bl	34819e68 <crc32>
348071f0:	e59d3014 	ldr	r3, [sp, #20]
348071f4:	e1500003 	cmp	r0, r3
348071f8:	0a000002 	beq	34807208 <do_env_import+0x1b0>
			puts("## Error: bad CRC, import failed\n");
348071fc:	e59f0084 	ldr	r0, [pc, #132]	; 34807288 <do_env_import+0x230>
34807200:	eb000959 	bl	3480976c <puts>
34807204:	eaffffc4 	b	3480711c <do_env_import+0xc4>
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
34807208:	e3a04000 	mov	r4, #0
3480720c:	e2277001 	eor	r7, r7, #1
34807210:	e58d400c 	str	r4, [sp, #12]
34807214:	e1a03009 	mov	r3, r9
34807218:	e58d4008 	str	r4, [sp, #8]
3480721c:	e1a02005 	mov	r2, r5
34807220:	e58d4004 	str	r4, [sp, #4]
34807224:	e1a01006 	mov	r1, r6
34807228:	e58d7000 	str	r7, [sp]
3480722c:	e59f0058 	ldr	r0, [pc, #88]	; 3480728c <do_env_import+0x234>
34807230:	eb004ebd 	bl	3481ad2c <himport_r>
34807234:	e1500004 	cmp	r0, r4
34807238:	1a000008 	bne	34807260 <do_env_import+0x208>
		error("Environment import failed: errno = %d\n", errno);
3480723c:	e59f304c 	ldr	r3, [pc, #76]	; 34807290 <do_env_import+0x238>
34807240:	e59f104c 	ldr	r1, [pc, #76]	; 34807294 <do_env_import+0x23c>
34807244:	e59f204c 	ldr	r2, [pc, #76]	; 34807298 <do_env_import+0x240>
34807248:	e58d3000 	str	r3, [sp]
3480724c:	e30033bd 	movw	r3, #957	; 0x3bd
34807250:	e5911000 	ldr	r1, [r1]
34807254:	e59f0040 	ldr	r0, [pc, #64]	; 3480729c <do_env_import+0x244>
34807258:	eb00094f 	bl	3480979c <printf>
3480725c:	eaffffae 	b	3480711c <do_env_import+0xc4>
	gd->flags |= GD_FLG_ENV_READY;
34807260:	e5983004 	ldr	r3, [r8, #4]
	return 0;
34807264:	e1a00004 	mov	r0, r4
	gd->flags |= GD_FLG_ENV_READY;
34807268:	e3833080 	orr	r3, r3, #128	; 0x80
3480726c:	e5883004 	str	r3, [r8, #4]
}
34807270:	e28dd01c 	add	sp, sp, #28
34807274:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807278:	34823f0b 	.word	0x34823f0b
3480727c:	34823e50 	.word	0x34823e50
34807280:	34823f3a 	.word	0x34823f3a
34807284:	34823e77 	.word	0x34823e77
34807288:	34823e9f 	.word	0x34823e9f
3480728c:	348276a4 	.word	0x348276a4
34807290:	3481f750 	.word	0x3481f750
34807294:	3482a918 	.word	0x3482a918
34807298:	34823ec1 	.word	0x34823ec1
3480729c:	34823ece 	.word	0x34823ece

348072a0 <do_env_default>:
	int all = 0, flag = 0;
348072a0:	e3a0c000 	mov	ip, #0
{
348072a4:	e92d4010 	push	{r4, lr}
	while (--argc > 0 && **++argv == '-') {
348072a8:	e2422001 	sub	r2, r2, #1
348072ac:	e3520000 	cmp	r2, #0
348072b0:	da00000d 	ble	348072ec <do_env_default+0x4c>
348072b4:	e5b31004 	ldr	r1, [r3, #4]!
348072b8:	e5d1e000 	ldrb	lr, [r1]
348072bc:	e35e002d 	cmp	lr, #45	; 0x2d
348072c0:	1a000009 	bne	348072ec <do_env_default+0x4c>
		while (*++arg) {
348072c4:	e5f1e001 	ldrb	lr, [r1, #1]!
348072c8:	e35e0000 	cmp	lr, #0
348072cc:	0afffff5 	beq	348072a8 <do_env_default+0x8>
			switch (*arg) {
348072d0:	e35e0061 	cmp	lr, #97	; 0x61
348072d4:	0a000002 	beq	348072e4 <do_env_default+0x44>
348072d8:	e35e0066 	cmp	lr, #102	; 0x66
348072dc:	0afffff8 	beq	348072c4 <do_env_default+0x24>
348072e0:	ea000013 	b	34807334 <do_env_default+0x94>
				all = 1;
348072e4:	e3a0c001 	mov	ip, #1
348072e8:	eafffff5 	b	348072c4 <do_env_default+0x24>
	if (all && (argc == 0)) {
348072ec:	e3520000 	cmp	r2, #0
348072f0:	13a01000 	movne	r1, #0
348072f4:	020c1001 	andeq	r1, ip, #1
348072f8:	e3510000 	cmp	r1, #0
348072fc:	0a000002 	beq	3480730c <do_env_default+0x6c>
		set_default_env("## Resetting to default environment\n");
34807300:	e59f003c 	ldr	r0, [pc, #60]	; 34807344 <do_env_default+0xa4>
34807304:	eb000e5e 	bl	3480ac84 <set_default_env>
		return 0;
34807308:	ea00000b 	b	3480733c <do_env_default+0x9c>
	if (!all && (argc > 0)) {
3480730c:	e22cc001 	eor	ip, ip, #1
34807310:	e3520000 	cmp	r2, #0
34807314:	d3a0c000 	movle	ip, #0
34807318:	c20cc001 	andgt	ip, ip, #1
3480731c:	e35c0000 	cmp	ip, #0
34807320:	0a000003 	beq	34807334 <do_env_default+0x94>
		set_default_vars(argc, argv);
34807324:	e1a01003 	mov	r1, r3
34807328:	e1a00002 	mov	r0, r2
3480732c:	eb000e84 	bl	3480ad44 <set_default_vars>
		return 0;
34807330:	ea000001 	b	3480733c <do_env_default+0x9c>
}
34807334:	e8bd4010 	pop	{r4, lr}
	return cmd_usage(cmdtp);
34807338:	ea0007c1 	b	34809244 <cmd_usage>
}
3480733c:	e3a00000 	mov	r0, #0
34807340:	e8bd8010 	pop	{r4, pc}
34807344:	34823f6f 	.word	0x34823f6f

34807348 <do_env_print>:
	if (argc == 1) {
34807348:	e3520001 	cmp	r2, #1
{
3480734c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34807350:	e1a04002 	mov	r4, r2
34807354:	11a05003 	movne	r5, r3
	if (argc == 1) {
34807358:	13a06000 	movne	r6, #0
3480735c:	13a07001 	movne	r7, #1
34807360:	1a000011 	bne	348073ac <do_env_print+0x64>
		rcode = env_print(NULL);
34807364:	e3a00000 	mov	r0, #0
34807368:	ebfffefa 	bl	34806f58 <env_print>
		if (!rcode)
3480736c:	e2501000 	subs	r1, r0, #0
34807370:	0a000011 	beq	348073bc <do_env_print+0x74>
		printf("\nEnvironment size: %d/%ld bytes\n",
34807374:	e59f2048 	ldr	r2, [pc, #72]	; 348073c4 <do_env_print+0x7c>
34807378:	e59f0048 	ldr	r0, [pc, #72]	; 348073c8 <do_env_print+0x80>
3480737c:	eb000906 	bl	3480979c <printf>
		return 0;
34807380:	e3a00000 	mov	r0, #0
34807384:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		int rc = env_print(argv[i]);
34807388:	e5b50004 	ldr	r0, [r5, #4]!
3480738c:	ebfffef1 	bl	34806f58 <env_print>
		if (!rc) {
34807390:	e3500000 	cmp	r0, #0
34807394:	1a000003 	bne	348073a8 <do_env_print+0x60>
			++rcode;
34807398:	e2866001 	add	r6, r6, #1
			printf("## Error: \"%s\" not defined\n", argv[i]);
3480739c:	e5951000 	ldr	r1, [r5]
348073a0:	e59f0024 	ldr	r0, [pc, #36]	; 348073cc <do_env_print+0x84>
348073a4:	eb0008fc 	bl	3480979c <printf>
	for (i = 1; i < argc; ++i) {
348073a8:	e2877001 	add	r7, r7, #1
348073ac:	e1570004 	cmp	r7, r4
348073b0:	bafffff4 	blt	34807388 <do_env_print+0x40>
	return rcode;
348073b4:	e1a00006 	mov	r0, r6
348073b8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			return 1;
348073bc:	e1a00004 	mov	r0, r4
}
348073c0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348073c4:	0003fffc 	.word	0x0003fffc
348073c8:	34823f94 	.word	0x34823f94
348073cc:	34823fb5 	.word	0x34823fb5

348073d0 <get_env_id>:
}
348073d0:	e59f3004 	ldr	r3, [pc, #4]	; 348073dc <get_env_id+0xc>
348073d4:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
348073d8:	e12fff1e 	bx	lr
348073dc:	348270f0 	.word	0x348270f0

348073e0 <env_check_apply>:
{
348073e0:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	newval = newval ? : "";
348073e4:	e3520000 	cmp	r2, #0
{
348073e8:	e1a04001 	mov	r4, r1
	if (strcmp(name, "stdin") == 0)
348073ec:	e59f118c 	ldr	r1, [pc, #396]	; 34807580 <env_check_apply+0x1a0>
{
348073f0:	e1a06000 	mov	r6, r0
348073f4:	e1a07003 	mov	r7, r3
	newval = newval ? : "";
348073f8:	e59f5184 	ldr	r5, [pc, #388]	; 34807584 <env_check_apply+0x1a4>
348073fc:	11a05002 	movne	r5, r2
	if (strcmp(name, "stdin") == 0)
34807400:	eb005106 	bl	3481b820 <strcmp>
34807404:	e3500000 	cmp	r0, #0
34807408:	0a000039 	beq	348074f4 <env_check_apply+0x114>
	else if (strcmp(name, "stdout") == 0)
3480740c:	e59f1174 	ldr	r1, [pc, #372]	; 34807588 <env_check_apply+0x1a8>
34807410:	e1a00006 	mov	r0, r6
34807414:	eb005101 	bl	3481b820 <strcmp>
34807418:	e3500000 	cmp	r0, #0
		console = stdout;
3480741c:	03a00001 	moveq	r0, #1
	else if (strcmp(name, "stdout") == 0)
34807420:	0a000033 	beq	348074f4 <env_check_apply+0x114>
	else if (strcmp(name, "stderr") == 0)
34807424:	e59f1160 	ldr	r1, [pc, #352]	; 3480758c <env_check_apply+0x1ac>
34807428:	e1a00006 	mov	r0, r6
3480742c:	eb0050fb 	bl	3481b820 <strcmp>
34807430:	e3500000 	cmp	r0, #0
34807434:	0a00002d 	beq	348074f0 <env_check_apply+0x110>
	if (oldval != NULL ||			/* variable exists */
34807438:	e3540000 	cmp	r4, #0
3480743c:	1a000007 	bne	34807460 <env_check_apply+0x80>
34807440:	e3170001 	tst	r7, #1
34807444:	0a000005 	beq	34807460 <env_check_apply+0x80>
	if (strcmp(name, "loadaddr") == 0) {
34807448:	e59f1140 	ldr	r1, [pc, #320]	; 34807590 <env_check_apply+0x1b0>
3480744c:	e1a00006 	mov	r0, r6
34807450:	eb0050f2 	bl	3481b820 <strcmp>
34807454:	e2504000 	subs	r4, r0, #0
34807458:	1a00001b 	bne	348074cc <env_check_apply+0xec>
3480745c:	ea00001c 	b	348074d4 <env_check_apply+0xf4>
		if (strcmp(name, "baudrate") == 0) {
34807460:	e59f112c 	ldr	r1, [pc, #300]	; 34807594 <env_check_apply+0x1b4>
34807464:	e1a00006 	mov	r0, r6
34807468:	eb0050ec 	bl	3481b820 <strcmp>
3480746c:	e2501000 	subs	r1, r0, #0
34807470:	1afffff4 	bne	34807448 <env_check_apply+0x68>
			int baudrate = simple_strtoul(newval, NULL, 10);
34807474:	e3a0200a 	mov	r2, #10
34807478:	e1a00005 	mov	r0, r5
3480747c:	eb0054b8 	bl	3481c764 <simple_strtoul>
				if (baudrate == baudrate_table[i])
34807480:	e3500d96 	cmp	r0, #9600	; 0x2580
			int baudrate = simple_strtoul(newval, NULL, 10);
34807484:	e1a04000 	mov	r4, r0
				if (baudrate == baudrate_table[i])
34807488:	0a00002a 	beq	34807538 <env_check_apply+0x158>
3480748c:	e3500c4b 	cmp	r0, #19200	; 0x4b00
34807490:	0a000028 	beq	34807538 <env_check_apply+0x158>
34807494:	e3500c96 	cmp	r0, #38400	; 0x9600
34807498:	0a000026 	beq	34807538 <env_check_apply+0x158>
3480749c:	e3500ce1 	cmp	r0, #57600	; 0xe100
348074a0:	0a000024 	beq	34807538 <env_check_apply+0x158>
348074a4:	e59f30ec 	ldr	r3, [pc, #236]	; 34807598 <env_check_apply+0x1b8>
348074a8:	e1500003 	cmp	r0, r3
348074ac:	0a000021 	beq	34807538 <env_check_apply+0x158>
				if ((flag & H_FORCE) == 0)
348074b0:	e3170002 	tst	r7, #2
348074b4:	1a000002 	bne	348074c4 <env_check_apply+0xe4>
					printf("## Baudrate %d bps not "
348074b8:	e1a01000 	mov	r1, r0
348074bc:	e59f00d8 	ldr	r0, [pc, #216]	; 3480759c <env_check_apply+0x1bc>
348074c0:	eb0008b5 	bl	3480979c <printf>
				return 1;
348074c4:	e3a04001 	mov	r4, #1
348074c8:	ea00002a 	b	34807578 <env_check_apply+0x198>
	return 0;
348074cc:	e3a04000 	mov	r4, #0
348074d0:	ea000028 	b	34807578 <env_check_apply+0x198>
		load_addr = simple_strtoul(newval, NULL, 16);
348074d4:	e3a02010 	mov	r2, #16
348074d8:	e1a01004 	mov	r1, r4
348074dc:	e1a00005 	mov	r0, r5
348074e0:	eb00549f 	bl	3481c764 <simple_strtoul>
348074e4:	e59f30b4 	ldr	r3, [pc, #180]	; 348075a0 <env_check_apply+0x1c0>
348074e8:	e58300c4 	str	r0, [r3, #196]	; 0xc4
		return 0;
348074ec:	ea000021 	b	34807578 <env_check_apply+0x198>
		console = stderr;
348074f0:	e3a00002 	mov	r0, #2
		if ((newval == NULL) || (*newval == '\0')) {
348074f4:	e5d53000 	ldrb	r3, [r5]
348074f8:	e3530000 	cmp	r3, #0
348074fc:	1a000004 	bne	34807514 <env_check_apply+0x134>
			if ((flag & H_FORCE) == 0)
34807500:	e3170002 	tst	r7, #2
34807504:	1affffee 	bne	348074c4 <env_check_apply+0xe4>
				printf("Can't delete \"%s\"\n", name);
34807508:	e1a01006 	mov	r1, r6
3480750c:	e59f0090 	ldr	r0, [pc, #144]	; 348075a4 <env_check_apply+0x1c4>
34807510:	eaffffea 	b	348074c0 <env_check_apply+0xe0>
		if (console_assign(console, newval) < 0)
34807514:	e1a01005 	mov	r1, r5
34807518:	eb0008f1 	bl	348098e4 <console_assign>
3480751c:	e3500000 	cmp	r0, #0
34807520:	baffffe7 	blt	348074c4 <env_check_apply+0xe4>
		if (serial_assign(newval) < 0)
34807524:	e1a00005 	mov	r0, r5
34807528:	eb001cfd 	bl	3480e924 <serial_assign>
3480752c:	e3500000 	cmp	r0, #0
34807530:	aaffffc0 	bge	34807438 <env_check_apply+0x58>
34807534:	eaffffe2 	b	348074c4 <env_check_apply+0xe4>
			if (gd->baudrate == baudrate) {
34807538:	e5983008 	ldr	r3, [r8, #8]
3480753c:	e1530004 	cmp	r3, r4
34807540:	0affffe1 	beq	348074cc <env_check_apply+0xec>
			printf("## Switch baudrate to %d bps and"
34807544:	e1a01004 	mov	r1, r4
34807548:	e59f0058 	ldr	r0, [pc, #88]	; 348075a8 <env_check_apply+0x1c8>
3480754c:	eb000892 	bl	3480979c <printf>
			udelay(50000);
34807550:	e30c0350 	movw	r0, #50000	; 0xc350
34807554:	eb00522c 	bl	3481be0c <udelay>
			gd->baudrate = baudrate;
34807558:	e5884008 	str	r4, [r8, #8]
			serial_setbrg();
3480755c:	eb001d23 	bl	3480e9f0 <serial_setbrg>
			udelay(50000);
34807560:	e30c0350 	movw	r0, #50000	; 0xc350
34807564:	eb005228 	bl	3481be0c <udelay>
			while (getc() != '\r')
34807568:	eb00085b 	bl	348096dc <getc>
3480756c:	e350000d 	cmp	r0, #13
34807570:	1afffffc 	bne	34807568 <env_check_apply+0x188>
34807574:	eaffffb3 	b	34807448 <env_check_apply+0x68>
}
34807578:	e1a00004 	mov	r0, r4
3480757c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34807580:	34823fd1 	.word	0x34823fd1
34807584:	34822afd 	.word	0x34822afd
34807588:	34823fd7 	.word	0x34823fd7
3480758c:	34823fde 	.word	0x34823fde
34807590:	34821665 	.word	0x34821665
34807594:	34821654 	.word	0x34821654
34807598:	0001c200 	.word	0x0001c200
3480759c:	34823ff8 	.word	0x34823ff8
348075a0:	348270f0 	.word	0x348270f0
348075a4:	34823fe5 	.word	0x34823fe5
348075a8:	3482401a 	.word	0x3482401a

348075ac <_do_env_set>:
{
348075ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348075b0:	e1a07001 	mov	r7, r1
	name = argv[1];
348075b4:	e5926004 	ldr	r6, [r2, #4]
	if (strchr(name, '=')) {
348075b8:	e3a0103d 	mov	r1, #61	; 0x3d
{
348075bc:	e24dd020 	sub	sp, sp, #32
348075c0:	e1a05002 	mov	r5, r2
	value = argv[2];
348075c4:	e5924008 	ldr	r4, [r2, #8]
	if (strchr(name, '=')) {
348075c8:	e1a00006 	mov	r0, r6
348075cc:	eb0050ac 	bl	3481b884 <strchr>
348075d0:	e2502000 	subs	r2, r0, #0
		printf("## Error: illegal character '='"
348075d4:	11a01006 	movne	r1, r6
348075d8:	159f015c 	ldrne	r0, [pc, #348]	; 3480773c <_do_env_set+0x190>
	if (strchr(name, '=')) {
348075dc:	1a000030 	bne	348076a4 <_do_env_set+0xf8>
	env_id++;
348075e0:	e59f1158 	ldr	r1, [pc, #344]	; 34807740 <_do_env_set+0x194>
	hsearch_r(e, FIND, &ep, &env_htab);
348075e4:	e28d9018 	add	r9, sp, #24
348075e8:	e59fa154 	ldr	sl, [pc, #340]	; 34807744 <_do_env_set+0x198>
	e.data = NULL;
348075ec:	e58d201c 	str	r2, [sp, #28]
	env_id++;
348075f0:	e59130c0 	ldr	r3, [r1, #192]	; 0xc0
	e.key = name;
348075f4:	e58d6018 	str	r6, [sp, #24]
	env_id++;
348075f8:	e2833001 	add	r3, r3, #1
348075fc:	e58130c0 	str	r3, [r1, #192]	; 0xc0
	hsearch_r(e, FIND, &ep, &env_htab);
34807600:	e28d3014 	add	r3, sp, #20
34807604:	e58da000 	str	sl, [sp]
34807608:	e8990003 	ldm	r9, {r0, r1}
3480760c:	eb004c41 	bl	3481a718 <hsearch_r>
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
34807610:	e59d1014 	ldr	r1, [sp, #20]
34807614:	e1a02004 	mov	r2, r4
34807618:	e3a03001 	mov	r3, #1
3480761c:	e1a00006 	mov	r0, r6
34807620:	e58da00c 	str	sl, [sp, #12]
34807624:	e3510000 	cmp	r1, #0
34807628:	15911004 	ldrne	r1, [r1, #4]
3480762c:	ebffff6b 	bl	348073e0 <env_check_apply>
34807630:	e2504000 	subs	r4, r0, #0
34807634:	1a00003c 	bne	3480772c <_do_env_set+0x180>
	if (argc < 3 || argv[2] == NULL) {
34807638:	e3570002 	cmp	r7, #2
3480763c:	da000004 	ble	34807654 <_do_env_set+0xa8>
34807640:	e5953008 	ldr	r3, [r5, #8]
34807644:	e3530000 	cmp	r3, #0
34807648:	11a0b004 	movne	fp, r4
3480764c:	13a0a002 	movne	sl, #2
34807650:	1a000006 	bne	34807670 <_do_env_set+0xc4>
		int rc = hdelete_r(name, &env_htab, 0);
34807654:	e3a02000 	mov	r2, #0
34807658:	e59f10e4 	ldr	r1, [pc, #228]	; 34807744 <_do_env_set+0x198>
3480765c:	e1a00006 	mov	r0, r6
34807660:	eb004cdf 	bl	3481a9e4 <hdelete_r>
		return !rc;
34807664:	e16f4f10 	clz	r4, r0
34807668:	e1a042a4 	lsr	r4, r4, #5
3480766c:	ea00002f 	b	34807730 <_do_env_set+0x184>
		len += strlen(argv[i]) + 1;
34807670:	e795010a 	ldr	r0, [r5, sl, lsl #2]
	for (i = 2, len = 0; i < argc; ++i)
34807674:	e28aa001 	add	sl, sl, #1
		len += strlen(argv[i]) + 1;
34807678:	eb005096 	bl	3481b8d8 <strlen>
	for (i = 2, len = 0; i < argc; ++i)
3480767c:	e15a0007 	cmp	sl, r7
34807680:	e28bb001 	add	fp, fp, #1
		len += strlen(argv[i]) + 1;
34807684:	e08bb000 	add	fp, fp, r0
	for (i = 2, len = 0; i < argc; ++i)
34807688:	1afffff8 	bne	34807670 <_do_env_set+0xc4>
	value = malloc(len);
3480768c:	e1a0000b 	mov	r0, fp
34807690:	eb000a10 	bl	34809ed8 <malloc>
	if (value == NULL) {
34807694:	e2507000 	subs	r7, r0, #0
34807698:	1a000003 	bne	348076ac <_do_env_set+0x100>
		printf("## Can't malloc %d bytes\n", len);
3480769c:	e59f00a4 	ldr	r0, [pc, #164]	; 34807748 <_do_env_set+0x19c>
348076a0:	e1a0100b 	mov	r1, fp
348076a4:	eb00083c 	bl	3480979c <printf>
348076a8:	ea00001f 	b	3480772c <_do_env_set+0x180>
348076ac:	e2851008 	add	r1, r5, #8
348076b0:	e085510a 	add	r5, r5, sl, lsl #2
	if (value == NULL) {
348076b4:	e1a03007 	mov	r3, r7
		*(s - 1) = ' ';
348076b8:	e3a0e020 	mov	lr, #32
		char *v = argv[i];
348076bc:	e491c004 	ldr	ip, [r1], #4
		while ((*s++ = *v++) != '\0')
348076c0:	e4dc2001 	ldrb	r2, [ip], #1
348076c4:	e1a00003 	mov	r0, r3
348076c8:	e3520000 	cmp	r2, #0
348076cc:	e4c32001 	strb	r2, [r3], #1
348076d0:	1afffffa 	bne	348076c0 <_do_env_set+0x114>
	for (i = 2, s = value; i < argc; ++i) {
348076d4:	e1510005 	cmp	r1, r5
		*(s - 1) = ' ';
348076d8:	e5c0e000 	strb	lr, [r0]
	for (i = 2, s = value; i < argc; ++i) {
348076dc:	1afffff6 	bne	348076bc <_do_env_set+0x110>
	if (s != value)
348076e0:	e1530007 	cmp	r3, r7
	e.data	= value;
348076e4:	e58d701c 	str	r7, [sp, #28]
		*--s = '\0';
348076e8:	15432001 	strbne	r2, [r3, #-1]
	hsearch_r(e, ENTER, &ep, &env_htab);
348076ec:	e3a02001 	mov	r2, #1
348076f0:	e59d300c 	ldr	r3, [sp, #12]
348076f4:	e58d3000 	str	r3, [sp]
348076f8:	e28d3014 	add	r3, sp, #20
348076fc:	e8990003 	ldm	r9, {r0, r1}
34807700:	eb004c04 	bl	3481a718 <hsearch_r>
	free(value);
34807704:	e1a00007 	mov	r0, r7
34807708:	eb000968 	bl	34809cb0 <free>
	if (!ep) {
3480770c:	e59d3014 	ldr	r3, [sp, #20]
34807710:	e3530000 	cmp	r3, #0
34807714:	1a000005 	bne	34807730 <_do_env_set+0x184>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
34807718:	e59f302c 	ldr	r3, [pc, #44]	; 3480774c <_do_env_set+0x1a0>
3480771c:	e1a01006 	mov	r1, r6
34807720:	e59f0028 	ldr	r0, [pc, #40]	; 34807750 <_do_env_set+0x1a4>
34807724:	e5932000 	ldr	r2, [r3]
34807728:	eb00081b 	bl	3480979c <printf>
		return 1;
3480772c:	e3a04001 	mov	r4, #1
}
34807730:	e1a00004 	mov	r0, r4
34807734:	e28dd020 	add	sp, sp, #32
34807738:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480773c:	3482404b 	.word	0x3482404b
34807740:	348270f0 	.word	0x348270f0
34807744:	348276a4 	.word	0x348276a4
34807748:	34824081 	.word	0x34824081
3480774c:	3482a918 	.word	0x3482a918
34807750:	3482409b 	.word	0x3482409b

34807754 <do_env_set>:
	if (argc < 2)
34807754:	e3520001 	cmp	r2, #1
{
34807758:	e1a00001 	mov	r0, r1
3480775c:	e1a01002 	mov	r1, r2
	if (argc < 2)
34807760:	da000001 	ble	3480776c <do_env_set+0x18>
	return _do_env_set(flag, argc, argv);
34807764:	e1a02003 	mov	r2, r3
34807768:	eaffff8f 	b	348075ac <_do_env_set>
}
3480776c:	e3e00000 	mvn	r0, #0
34807770:	e12fff1e 	bx	lr

34807774 <setenv>:
{
34807774:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
		return _do_env_set(0, 2, (char * const *)argv);
34807778:	e1a0200d 	mov	r2, sp
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
3480777c:	e59f3038 	ldr	r3, [pc, #56]	; 348077bc <setenv+0x48>
34807780:	e98d0003 	stmib	sp, {r0, r1}
34807784:	e3a00000 	mov	r0, #0
	if (varvalue == NULL || varvalue[0] == '\0')
34807788:	e1510000 	cmp	r1, r0
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
3480778c:	e58d3000 	str	r3, [sp]
34807790:	e58d000c 	str	r0, [sp, #12]
	if (varvalue == NULL || varvalue[0] == '\0')
34807794:	0a000003 	beq	348077a8 <setenv+0x34>
34807798:	e5d13000 	ldrb	r3, [r1]
3480779c:	e1530000 	cmp	r3, r0
		return _do_env_set(0, 3, (char * const *)argv);
348077a0:	13a01003 	movne	r1, #3
	if (varvalue == NULL || varvalue[0] == '\0')
348077a4:	1a000001 	bne	348077b0 <setenv+0x3c>
		return _do_env_set(0, 2, (char * const *)argv);
348077a8:	e3a01002 	mov	r1, #2
348077ac:	e3a00000 	mov	r0, #0
		return _do_env_set(0, 3, (char * const *)argv);
348077b0:	ebffff7d 	bl	348075ac <_do_env_set>
}
348077b4:	e28dd014 	add	sp, sp, #20
348077b8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
348077bc:	348240c7 	.word	0x348240c7

348077c0 <do_env_export>:
{
348077c0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348077c4:	e1a0c003 	mov	ip, r3
	int	fmt = 0;
348077c8:	e3a04000 	mov	r4, #0
	cmd = *argv;
348077cc:	e5933000 	ldr	r3, [r3]
{
348077d0:	e1a0b000 	mov	fp, r0
348077d4:	e1a05002 	mov	r5, r2
	int	chk = 0;
348077d8:	e1a0a004 	mov	sl, r4
	char	sep = '\n';
348077dc:	e3a0700a 	mov	r7, #10
	size_t	size = 0;
348077e0:	e1a09004 	mov	r9, r4
{
348077e4:	e24dd038 	sub	sp, sp, #56	; 0x38
	cmd = *argv;
348077e8:	e58d3008 	str	r3, [sp, #8]
	while (--argc > 0 && **++argv == '-') {
348077ec:	e2453001 	sub	r3, r5, #1
348077f0:	e3530000 	cmp	r3, #0
348077f4:	da000036 	ble	348078d4 <do_env_export+0x114>
348077f8:	e59c0004 	ldr	r0, [ip, #4]
348077fc:	e28c6004 	add	r6, ip, #4
34807800:	e5d02000 	ldrb	r2, [r0]
34807804:	e352002d 	cmp	r2, #45	; 0x2d
34807808:	1a000033 	bne	348078dc <do_env_export+0x11c>
		while (*++arg) {
3480780c:	e5f02001 	ldrb	r2, [r0, #1]!
34807810:	e3520000 	cmp	r2, #0
34807814:	0a000026 	beq	348078b4 <do_env_export+0xf4>
			switch (*arg) {
34807818:	e3520063 	cmp	r2, #99	; 0x63
3480781c:	0a00000b 	beq	34807850 <do_env_export+0x90>
34807820:	8a000002 	bhi	34807830 <do_env_export+0x70>
34807824:	e3520062 	cmp	r2, #98	; 0x62
34807828:	0a000005 	beq	34807844 <do_env_export+0x84>
3480782c:	ea000028 	b	348078d4 <do_env_export+0x114>
34807830:	e3520073 	cmp	r2, #115	; 0x73
34807834:	0a00000a 	beq	34807864 <do_env_export+0xa4>
34807838:	e3520074 	cmp	r2, #116	; 0x74
3480783c:	0a000017 	beq	348078a0 <do_env_export+0xe0>
34807840:	ea000023 	b	348078d4 <do_env_export+0x114>
				if (fmt++)
34807844:	e3540000 	cmp	r4, #0
34807848:	0a000003 	beq	3480785c <do_env_export+0x9c>
3480784c:	ea00001b 	b	348078c0 <do_env_export+0x100>
				if (fmt++)
34807850:	e3540000 	cmp	r4, #0
34807854:	1a000019 	bne	348078c0 <do_env_export+0x100>
				chk = 1;
34807858:	e3a0a001 	mov	sl, #1
				sep = '\0';
3480785c:	e1a07004 	mov	r7, r4
34807860:	ea000011 	b	348078ac <do_env_export+0xec>
				if (--argc <= 0)
34807864:	e2453002 	sub	r3, r5, #2
34807868:	e3530000 	cmp	r3, #0
3480786c:	ca000002 	bgt	3480787c <do_env_export+0xbc>
					return cmd_usage(cmdtp);
34807870:	e1a0000b 	mov	r0, fp
34807874:	eb000672 	bl	34809244 <cmd_usage>
34807878:	ea000055 	b	348079d4 <do_env_export+0x214>
				size = simple_strtoul(*++argv, NULL, 16);
3480787c:	e3a02010 	mov	r2, #16
34807880:	e3a01000 	mov	r1, #0
34807884:	e59c0008 	ldr	r0, [ip, #8]
34807888:	e28c6008 	add	r6, ip, #8
3480788c:	e58d300c 	str	r3, [sp, #12]
34807890:	eb0053b3 	bl	3481c764 <simple_strtoul>
				goto NXTARG;
34807894:	e59d300c 	ldr	r3, [sp, #12]
				size = simple_strtoul(*++argv, NULL, 16);
34807898:	e1a09000 	mov	r9, r0
				goto NXTARG;
3480789c:	ea000004 	b	348078b4 <do_env_export+0xf4>
				if (fmt++)
348078a0:	e3540000 	cmp	r4, #0
348078a4:	1a000005 	bne	348078c0 <do_env_export+0x100>
				sep = '\n';
348078a8:	e3a0700a 	mov	r7, #10
348078ac:	e3a04001 	mov	r4, #1
348078b0:	eaffffd5 	b	3480780c <do_env_export+0x4c>
348078b4:	e1a0c006 	mov	ip, r6
348078b8:	e1a05003 	mov	r5, r3
348078bc:	eaffffca 	b	348077ec <do_env_export+0x2c>
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
348078c0:	e59d1008 	ldr	r1, [sp, #8]
348078c4:	e59f0110 	ldr	r0, [pc, #272]	; 348079dc <do_env_export+0x21c>
348078c8:	eb0007b3 	bl	3480979c <printf>
	return 1;
348078cc:	e3a00001 	mov	r0, #1
348078d0:	ea00003f 	b	348079d4 <do_env_export+0x214>
		return CMD_RET_USAGE;
348078d4:	e3e00000 	mvn	r0, #0
348078d8:	ea00003d 	b	348079d4 <do_env_export+0x214>
	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348078dc:	e3a02010 	mov	r2, #16
348078e0:	e3a01000 	mov	r1, #0
348078e4:	eb00539e 	bl	3481c764 <simple_strtoul>
	if (size)
348078e8:	e3590000 	cmp	r9, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348078ec:	e58d0010 	str	r0, [sp, #16]
	if (size)
348078f0:	0a000002 	beq	34807900 <do_env_export+0x140>
		memset(addr, '\0', size);
348078f4:	e1a02009 	mov	r2, r9
348078f8:	e3a01000 	mov	r1, #0
348078fc:	eb00509e 	bl	3481bb7c <memset>
	if (sep) {		/* export as text file */
34807900:	e3570000 	cmp	r7, #0
	argc--;
34807904:	e2455002 	sub	r5, r5, #2
	argv++;
34807908:	e2866004 	add	r6, r6, #4
	if (sep) {		/* export as text file */
3480790c:	0a00000b 	beq	34807940 <do_env_export+0x180>
		len = hexport_r(&env_htab, sep, &addr, size, argc, argv);
34807910:	e28d2010 	add	r2, sp, #16
34807914:	e88d0060 	stm	sp, {r5, r6}
34807918:	e1a03009 	mov	r3, r9
3480791c:	e1a01007 	mov	r1, r7
34807920:	e59f00b8 	ldr	r0, [pc, #184]	; 348079e0 <do_env_export+0x220>
34807924:	eb004c5b 	bl	3481aa98 <hexport_r>
		if (len < 0) {
34807928:	e2502000 	subs	r2, r0, #0
3480792c:	aa000021 	bge	348079b8 <do_env_export+0x1f8>
			error("Cannot export environment: errno = %d\n", errno);
34807930:	e59f30ac 	ldr	r3, [pc, #172]	; 348079e4 <do_env_export+0x224>
34807934:	e58d3000 	str	r3, [sp]
34807938:	e3003333 	movw	r3, #819	; 0x333
3480793c:	ea00000f 	b	34807980 <do_env_export+0x1c0>
	envp = (env_t *)addr;
34807940:	e59d4010 	ldr	r4, [sp, #16]
	if (chk)		/* export as checksum protected block */
34807944:	e35a0000 	cmp	sl, #0
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807948:	e88d0060 	stm	sp, {r5, r6}
3480794c:	e28d2014 	add	r2, sp, #20
34807950:	e3a01000 	mov	r1, #0
34807954:	e59f0084 	ldr	r0, [pc, #132]	; 348079e0 <do_env_export+0x220>
		res = (char *)envp->data;
34807958:	12843004 	addne	r3, r4, #4
		res = addr;
3480795c:	058d4014 	streq	r4, [sp, #20]
		res = (char *)envp->data;
34807960:	158d3014 	strne	r3, [sp, #20]
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807964:	e59f307c 	ldr	r3, [pc, #124]	; 348079e8 <do_env_export+0x228>
34807968:	eb004c4a 	bl	3481aa98 <hexport_r>
	if (len < 0) {
3480796c:	e2505000 	subs	r5, r0, #0
34807970:	aa000008 	bge	34807998 <do_env_export+0x1d8>
		error("Cannot export environment: errno = %d\n", errno);
34807974:	e59f3068 	ldr	r3, [pc, #104]	; 348079e4 <do_env_export+0x224>
34807978:	e58d3000 	str	r3, [sp]
3480797c:	e3003345 	movw	r3, #837	; 0x345
34807980:	e59f1064 	ldr	r1, [pc, #100]	; 348079ec <do_env_export+0x22c>
34807984:	e59f2064 	ldr	r2, [pc, #100]	; 348079f0 <do_env_export+0x230>
34807988:	e59f0064 	ldr	r0, [pc, #100]	; 348079f4 <do_env_export+0x234>
3480798c:	e5911000 	ldr	r1, [r1]
34807990:	eb000781 	bl	3480979c <printf>
34807994:	eaffffcc 	b	348078cc <do_env_export+0x10c>
	if (chk) {
34807998:	e35a0000 	cmp	sl, #0
3480799c:	0a000004 	beq	348079b4 <do_env_export+0x1f4>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
348079a0:	e59f2040 	ldr	r2, [pc, #64]	; 348079e8 <do_env_export+0x228>
348079a4:	e2841004 	add	r1, r4, #4
348079a8:	e3a00000 	mov	r0, #0
348079ac:	eb00492d 	bl	34819e68 <crc32>
348079b0:	e5840000 	str	r0, [r4]
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
348079b4:	e2852004 	add	r2, r5, #4
348079b8:	e59f1038 	ldr	r1, [pc, #56]	; 348079f8 <do_env_export+0x238>
348079bc:	e28d0018 	add	r0, sp, #24
348079c0:	eb005410 	bl	3481ca08 <sprintf>
	setenv("filesize", buf);
348079c4:	e28d1018 	add	r1, sp, #24
348079c8:	e59f002c 	ldr	r0, [pc, #44]	; 348079fc <do_env_export+0x23c>
348079cc:	ebffff68 	bl	34807774 <setenv>
	return 0;
348079d0:	e3a00000 	mov	r0, #0
}
348079d4:	e28dd038 	add	sp, sp, #56	; 0x38
348079d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348079dc:	34823f0b 	.word	0x34823f0b
348079e0:	348276a4 	.word	0x348276a4
348079e4:	3481f75e 	.word	0x3481f75e
348079e8:	0003fffc 	.word	0x0003fffc
348079ec:	3482a918 	.word	0x3482a918
348079f0:	34823ec1 	.word	0x34823ec1
348079f4:	348240ce 	.word	0x348240ce
348079f8:	3482410b 	.word	0x3482410b
348079fc:	34821f6d 	.word	0x34821f6d

34807a00 <setenv_ulong>:
{
34807a00:	e92d4010 	push	{r4, lr}
34807a04:	e1a04000 	mov	r4, r0
	char *str = simple_itoa(value);
34807a08:	e1a00001 	mov	r0, r1
34807a0c:	eb00541d 	bl	3481ca88 <simple_itoa>
	return setenv(varname, str);
34807a10:	e1a01000 	mov	r1, r0
34807a14:	e1a00004 	mov	r0, r4
}
34807a18:	e8bd4010 	pop	{r4, lr}
	return setenv(varname, str);
34807a1c:	eaffff54 	b	34807774 <setenv>

34807a20 <setenv_addr>:
{
34807a20:	e92d4010 	push	{r4, lr}
34807a24:	e24dd018 	sub	sp, sp, #24
	sprintf(str, "%lx", (uintptr_t)addr);
34807a28:	e1a02001 	mov	r2, r1
{
34807a2c:	e1a04000 	mov	r4, r0
	sprintf(str, "%lx", (uintptr_t)addr);
34807a30:	e28d0004 	add	r0, sp, #4
34807a34:	e59f1014 	ldr	r1, [pc, #20]	; 34807a50 <setenv_addr+0x30>
34807a38:	eb0053f2 	bl	3481ca08 <sprintf>
	return setenv(varname, str);
34807a3c:	e28d1004 	add	r1, sp, #4
34807a40:	e1a00004 	mov	r0, r4
34807a44:	ebffff4a 	bl	34807774 <setenv>
}
34807a48:	e28dd018 	add	sp, sp, #24
34807a4c:	e8bd8010 	pop	{r4, pc}
34807a50:	34821e60 	.word	0x34821e60

34807a54 <envmatch>:
{
34807a54:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34807a58:	e1a05000 	mov	r5, r0
34807a5c:	e1a04001 	mov	r4, r1
	while (*s1 == env_get_char(i2++))
34807a60:	e1a00004 	mov	r0, r4
34807a64:	e2846001 	add	r6, r4, #1
34807a68:	e5d57000 	ldrb	r7, [r5]
34807a6c:	eb000c78 	bl	3480ac54 <env_get_char>
34807a70:	e1570000 	cmp	r7, r0
34807a74:	1a000005 	bne	34807a90 <envmatch+0x3c>
		if (*s1++ == '=')
34807a78:	e4d53001 	ldrb	r3, [r5], #1
	while (*s1 == env_get_char(i2++))
34807a7c:	e1a04006 	mov	r4, r6
		if (*s1++ == '=')
34807a80:	e353003d 	cmp	r3, #61	; 0x3d
34807a84:	1afffff5 	bne	34807a60 <envmatch+0xc>
	while (*s1 == env_get_char(i2++))
34807a88:	e1a00006 	mov	r0, r6
}
34807a8c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807a90:	e5d53000 	ldrb	r3, [r5]
34807a94:	e3530000 	cmp	r3, #0
34807a98:	0a000001 	beq	34807aa4 <envmatch+0x50>
	return -1;
34807a9c:	e3e00000 	mvn	r0, #0
34807aa0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807aa4:	e1a00004 	mov	r0, r4
34807aa8:	eb000c69 	bl	3480ac54 <env_get_char>
34807aac:	e350003d 	cmp	r0, #61	; 0x3d
34807ab0:	1afffff9 	bne	34807a9c <envmatch+0x48>
	while (*s1 == env_get_char(i2++))
34807ab4:	e1a00006 	mov	r0, r6
34807ab8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

34807abc <getenv_f>:
{
34807abc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34807ac0:	e1a07000 	mov	r7, r0
			if (nxt >= CONFIG_ENV_SIZE)
34807ac4:	e59fa0b0 	ldr	sl, [pc, #176]	; 34807b7c <getenv_f+0xc0>
{
34807ac8:	e1a06001 	mov	r6, r1
34807acc:	e1a09002 	mov	r9, r2
	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807ad0:	e3a05000 	mov	r5, #0
34807ad4:	e1a00005 	mov	r0, r5
34807ad8:	eb000c5d 	bl	3480ac54 <env_get_char>
34807adc:	e3500000 	cmp	r0, #0
34807ae0:	1a000001 	bne	34807aec <getenv_f+0x30>
				return -1;
34807ae4:	e3e00000 	mvn	r0, #0
34807ae8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807aec:	e1a04005 	mov	r4, r5
		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
34807af0:	e1a00004 	mov	r0, r4
34807af4:	eb000c56 	bl	3480ac54 <env_get_char>
34807af8:	e3500000 	cmp	r0, #0
34807afc:	0a000003 	beq	34807b10 <getenv_f+0x54>
			if (nxt >= CONFIG_ENV_SIZE)
34807b00:	e154000a 	cmp	r4, sl
34807b04:	cafffff6 	bgt	34807ae4 <getenv_f+0x28>
		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
34807b08:	e2844001 	add	r4, r4, #1
34807b0c:	eafffff7 	b	34807af0 <getenv_f+0x34>
		val = envmatch((uchar *)name, i);
34807b10:	e1a01005 	mov	r1, r5
34807b14:	e1a00007 	mov	r0, r7
34807b18:	ebffffcd 	bl	34807a54 <envmatch>
		if (val < 0)
34807b1c:	e3500000 	cmp	r0, #0
34807b20:	a086b009 	addge	fp, r6, r9
34807b24:	a1a05006 	movge	r5, r6
34807b28:	a066a000 	rsbge	sl, r6, r0
34807b2c:	aa000005 	bge	34807b48 <getenv_f+0x8c>
	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807b30:	e2845001 	add	r5, r4, #1
34807b34:	eaffffe6 	b	34807ad4 <getenv_f+0x18>
			*buf = env_get_char(val++);
34807b38:	eb000c45 	bl	3480ac54 <env_get_char>
			if (*buf == '\0')
34807b3c:	e3500000 	cmp	r0, #0
			*buf = env_get_char(val++);
34807b40:	e4c50001 	strb	r0, [r5], #1
			if (*buf == '\0')
34807b44:	0a00000a 	beq	34807b74 <getenv_f+0xb8>
		for (n = 0; n < len; ++n, ++buf) {
34807b48:	e155000b 	cmp	r5, fp
34807b4c:	e08a0005 	add	r0, sl, r5
34807b50:	e0664005 	rsb	r4, r6, r5
34807b54:	1afffff7 	bne	34807b38 <getenv_f+0x7c>
		if (n)
34807b58:	e3540000 	cmp	r4, #0
		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807b5c:	e1a02007 	mov	r2, r7
			*--buf = '\0';
34807b60:	13a03000 	movne	r3, #0
		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807b64:	e1a01009 	mov	r1, r9
			*--buf = '\0';
34807b68:	15453001 	strbne	r3, [r5, #-1]
		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807b6c:	e59f000c 	ldr	r0, [pc, #12]	; 34807b80 <getenv_f+0xc4>
34807b70:	eb000709 	bl	3480979c <printf>
34807b74:	e1a00004 	mov	r0, r4
}
34807b78:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807b7c:	0003ffff 	.word	0x0003ffff
34807b80:	3482410f 	.word	0x3482410f

34807b84 <getenv>:
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34807b84:	e5983004 	ldr	r3, [r8, #4]
{
34807b88:	e92d4010 	push	{r4, lr}
34807b8c:	e24dd018 	sub	sp, sp, #24
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34807b90:	e2134080 	ands	r4, r3, #128	; 0x80
34807b94:	0a00000c 	beq	34807bcc <getenv+0x48>
		hsearch_r(e, FIND, &ep, &env_htab);
34807b98:	e59f304c 	ldr	r3, [pc, #76]	; 34807bec <getenv+0x68>
		e.data	= NULL;
34807b9c:	e3a02000 	mov	r2, #0
		hsearch_r(e, FIND, &ep, &env_htab);
34807ba0:	e28d1018 	add	r1, sp, #24
		e.key	= name;
34807ba4:	e58d0010 	str	r0, [sp, #16]
		e.data	= NULL;
34807ba8:	e58d2014 	str	r2, [sp, #20]
		hsearch_r(e, FIND, &ep, &env_htab);
34807bac:	e58d3000 	str	r3, [sp]
34807bb0:	e28d300c 	add	r3, sp, #12
34807bb4:	e9110003 	ldmdb	r1, {r0, r1}
34807bb8:	eb004ad6 	bl	3481a718 <hsearch_r>
		return ep ? ep->data : NULL;
34807bbc:	e59d000c 	ldr	r0, [sp, #12]
34807bc0:	e3500000 	cmp	r0, #0
34807bc4:	15900004 	ldrne	r0, [r0, #4]
34807bc8:	ea000005 	b	34807be4 <getenv+0x60>
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
34807bcc:	e3a02020 	mov	r2, #32
34807bd0:	e2881058 	add	r1, r8, #88	; 0x58
34807bd4:	ebffffb8 	bl	34807abc <getenv_f>
34807bd8:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
34807bdc:	c2880058 	addgt	r0, r8, #88	; 0x58
	return NULL;
34807be0:	d1a00004 	movle	r0, r4
}
34807be4:	e28dd018 	add	sp, sp, #24
34807be8:	e8bd8010 	pop	{r4, pc}
34807bec:	348276a4 	.word	0x348276a4

34807bf0 <do_env_edit>:
	if (argc < 2)
34807bf0:	e3520001 	cmp	r2, #1
34807bf4:	da000013 	ble	34807c48 <do_env_edit+0x58>
{
34807bf8:	e92d4010 	push	{r4, lr}
34807bfc:	e24ddc01 	sub	sp, sp, #256	; 0x100
	init_val = getenv(argv[1]);
34807c00:	e5930004 	ldr	r0, [r3, #4]
34807c04:	e1a04003 	mov	r4, r3
34807c08:	ebffffdd 	bl	34807b84 <getenv>
	if (init_val)
34807c0c:	e2502000 	subs	r2, r0, #0
		buffer[0] = '\0';
34807c10:	05cd2000 	strbeq	r2, [sp]
	if (init_val)
34807c14:	0a000002 	beq	34807c24 <do_env_edit+0x34>
		sprintf(buffer, "%s", init_val);
34807c18:	e59f1030 	ldr	r1, [pc, #48]	; 34807c50 <do_env_edit+0x60>
34807c1c:	e1a0000d 	mov	r0, sp
34807c20:	eb005378 	bl	3481ca08 <sprintf>
	readline_into_buffer("edit: ", buffer, 0);
34807c24:	e3a02000 	mov	r2, #0
34807c28:	e1a0100d 	mov	r1, sp
34807c2c:	e59f0020 	ldr	r0, [pc, #32]	; 34807c54 <do_env_edit+0x64>
34807c30:	eb00173e 	bl	3480d930 <readline_into_buffer>
	return setenv(argv[1], buffer);
34807c34:	e1a0100d 	mov	r1, sp
34807c38:	e5940004 	ldr	r0, [r4, #4]
34807c3c:	ebfffecc 	bl	34807774 <setenv>
}
34807c40:	e28ddc01 	add	sp, sp, #256	; 0x100
34807c44:	e8bd8010 	pop	{r4, pc}
		return CMD_RET_USAGE;
34807c48:	e3e00000 	mvn	r0, #0
34807c4c:	e12fff1e 	bx	lr
34807c50:	34823837 	.word	0x34823837
34807c54:	3482413f 	.word	0x3482413f

34807c58 <getenv_ulong>:
{
34807c58:	e92d4070 	push	{r4, r5, r6, lr}
34807c5c:	e1a05001 	mov	r5, r1
34807c60:	e1a04002 	mov	r4, r2
	const char *str = getenv(name);
34807c64:	ebffffc6 	bl	34807b84 <getenv>
	return str ? simple_strtoul(str, NULL, base) : default_val;
34807c68:	e3500000 	cmp	r0, #0
34807c6c:	0a000003 	beq	34807c80 <getenv_ulong+0x28>
34807c70:	e1a02005 	mov	r2, r5
34807c74:	e3a01000 	mov	r1, #0
}
34807c78:	e8bd4070 	pop	{r4, r5, r6, lr}
	return str ? simple_strtoul(str, NULL, base) : default_val;
34807c7c:	ea0052b8 	b	3481c764 <simple_strtoul>
}
34807c80:	e1a00004 	mov	r0, r4
34807c84:	e8bd8070 	pop	{r4, r5, r6, pc}

34807c88 <do_onenand>:

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
34807c88:	e3520001 	cmp	r2, #1
34807c8c:	da000017 	ble	34807cf0 <do_onenand+0x68>
{
34807c90:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34807c94:	e1a0c003 	mov	ip, r3
34807c98:	e1a06001 	mov	r6, r1
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
34807c9c:	e59f3054 	ldr	r3, [pc, #84]	; 34807cf8 <do_onenand+0x70>
34807ca0:	e1a05000 	mov	r5, r0

	/* Strip off leading 'onenand' command argument */
	argc--;
34807ca4:	e2424001 	sub	r4, r2, #1
	mtd = &onenand_mtd;
34807ca8:	e59f104c 	ldr	r1, [pc, #76]	; 34807cfc <do_onenand+0x74>
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34807cac:	e3a02009 	mov	r2, #9
34807cb0:	e59c0004 	ldr	r0, [ip, #4]
	argv++;
34807cb4:	e28c7004 	add	r7, ip, #4
	mtd = &onenand_mtd;
34807cb8:	e5831000 	str	r1, [r3]
	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34807cbc:	e59f103c 	ldr	r1, [pc, #60]	; 34807d00 <do_onenand+0x78>
34807cc0:	eb00052c 	bl	34809178 <find_cmd_tbl>

	if (c)
34807cc4:	e3500000 	cmp	r0, #0
34807cc8:	0a000006 	beq	34807ce8 <do_onenand+0x60>
		return c->cmd(cmdtp, flag, argc, argv);
34807ccc:	e590c00c 	ldr	ip, [r0, #12]
34807cd0:	e1a03007 	mov	r3, r7
34807cd4:	e1a02004 	mov	r2, r4
34807cd8:	e1a01006 	mov	r1, r6
34807cdc:	e1a00005 	mov	r0, r5
	else
		return CMD_RET_USAGE;
}
34807ce0:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
		return c->cmd(cmdtp, flag, argc, argv);
34807ce4:	e12fff1c 	bx	ip
}
34807ce8:	e3e00000 	mvn	r0, #0
34807cec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34807cf0:	e3e00000 	mvn	r0, #0
34807cf4:	e12fff1e 	bx	lr
34807cf8:	34828a38 	.word	0x34828a38
34807cfc:	3482a798 	.word	0x3482a798
34807d00:	348271b8 	.word	0x348271b8

34807d04 <do_onenand_markbad>:
{
34807d04:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	argc -= 2;
34807d08:	e2426002 	sub	r6, r2, #2
	if (argc <= 0)
34807d0c:	e3560000 	cmp	r6, #0
34807d10:	da00001b 	ble	34807d84 <do_onenand_markbad+0x80>
		if (mtd->block_markbad(mtd, addr)) {
34807d14:	e59f9070 	ldr	r9, [pc, #112]	; 34807d8c <do_onenand_markbad+0x88>
34807d18:	e2835004 	add	r5, r3, #4
	if (argc <= 0)
34807d1c:	e3a04000 	mov	r4, #0
		addr = simple_strtoul(*argv, NULL, 16);
34807d20:	e3a02010 	mov	r2, #16
34807d24:	e3a01000 	mov	r1, #0
34807d28:	e5b50004 	ldr	r0, [r5, #4]!
34807d2c:	eb00528c 	bl	3481c764 <simple_strtoul>
34807d30:	e1a07000 	mov	r7, r0
		if (mtd->block_markbad(mtd, addr)) {
34807d34:	e5990000 	ldr	r0, [r9]
34807d38:	e1a02007 	mov	r2, r7
34807d3c:	e3a03000 	mov	r3, #0
34807d40:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34807d44:	e12fff31 	blx	r1
34807d48:	e3500000 	cmp	r0, #0
34807d4c:	0a000005 	beq	34807d68 <do_onenand_markbad+0x64>
			printf("block 0x%08lx NOT marked "
34807d50:	e1a02004 	mov	r2, r4
34807d54:	e1a01007 	mov	r1, r7
34807d58:	e59f0030 	ldr	r0, [pc, #48]	; 34807d90 <do_onenand_markbad+0x8c>
			ret = 1;
34807d5c:	e3a04001 	mov	r4, #1
			printf("block 0x%08lx NOT marked "
34807d60:	eb00068d 	bl	3480979c <printf>
34807d64:	ea000002 	b	34807d74 <do_onenand_markbad+0x70>
			printf("block 0x%08lx successfully "
34807d68:	e1a01007 	mov	r1, r7
34807d6c:	e59f0020 	ldr	r0, [pc, #32]	; 34807d94 <do_onenand_markbad+0x90>
34807d70:	eb000689 	bl	3480979c <printf>
	while (argc > 0) {
34807d74:	e2566001 	subs	r6, r6, #1
34807d78:	1affffe8 	bne	34807d20 <do_onenand_markbad+0x1c>
	return ret;
34807d7c:	e1a00004 	mov	r0, r4
34807d80:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return CMD_RET_USAGE;
34807d84:	e3e00000 	mvn	r0, #0
}
34807d88:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34807d8c:	34828a38 	.word	0x34828a38
34807d90:	3482452d 	.word	0x3482452d
34807d94:	34824558 	.word	0x34824558

34807d98 <do_onenand_bad>:
{
34807d98:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34807d9c:	e3a04000 	mov	r4, #0
	mtd = &onenand_mtd;
34807da0:	e59f3068 	ldr	r3, [pc, #104]	; 34807e10 <do_onenand_bad+0x78>
	printf("\nDevice %d bad blocks:\n", 0);
34807da4:	e3a01000 	mov	r1, #0
	mtd = &onenand_mtd;
34807da8:	e59f5064 	ldr	r5, [pc, #100]	; 34807e14 <do_onenand_bad+0x7c>
	printf("\nDevice %d bad blocks:\n", 0);
34807dac:	e59f0064 	ldr	r0, [pc, #100]	; 34807e18 <do_onenand_bad+0x80>
	mtd = &onenand_mtd;
34807db0:	e5853000 	str	r3, [r5]
	printf("\nDevice %d bad blocks:\n", 0);
34807db4:	eb000678 	bl	3480979c <printf>
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34807db8:	e5950000 	ldr	r0, [r5]
34807dbc:	e3a07000 	mov	r7, #0
34807dc0:	e1a06004 	mov	r6, r4
34807dc4:	e1c020d8 	ldrd	r2, [r0, #8]
34807dc8:	e1570003 	cmp	r7, r3
34807dcc:	01540002 	cmpeq	r4, r2
34807dd0:	2a00000c 	bcs	34807e08 <do_onenand_bad+0x70>
		if (mtd->block_isbad(mtd, ofs))
34807dd4:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34807dd8:	e1a02004 	mov	r2, r4
34807ddc:	e3a03000 	mov	r3, #0
34807de0:	e12fff31 	blx	r1
34807de4:	e3500000 	cmp	r0, #0
34807de8:	0a000002 	beq	34807df8 <do_onenand_bad+0x60>
			printf("  %08x\n", (u32)ofs);
34807dec:	e1a01004 	mov	r1, r4
34807df0:	e59f0024 	ldr	r0, [pc, #36]	; 34807e1c <do_onenand_bad+0x84>
34807df4:	eb000668 	bl	3480979c <printf>
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34807df8:	e5953000 	ldr	r3, [r5]
34807dfc:	e5933010 	ldr	r3, [r3, #16]
34807e00:	e0844003 	add	r4, r4, r3
34807e04:	eaffffeb 	b	34807db8 <do_onenand_bad+0x20>
}
34807e08:	e3a00000 	mov	r0, #0
34807e0c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34807e10:	3482a798 	.word	0x3482a798
34807e14:	34828a38 	.word	0x34828a38
34807e18:	34824582 	.word	0x34824582
34807e1c:	3482517d 	.word	0x3482517d

34807e20 <do_onenand_info>:
	printf("%s\n", mtd->name);
34807e20:	e59f3018 	ldr	r3, [pc, #24]	; 34807e40 <do_onenand_info+0x20>
{
34807e24:	e92d4010 	push	{r4, lr}
	printf("%s\n", mtd->name);
34807e28:	e59f0014 	ldr	r0, [pc, #20]	; 34807e44 <do_onenand_info+0x24>
34807e2c:	e5933000 	ldr	r3, [r3]
34807e30:	e5931020 	ldr	r1, [r3, #32]
34807e34:	eb000658 	bl	3480979c <printf>
}
34807e38:	e3a00000 	mov	r0, #0
34807e3c:	e8bd8010 	pop	{r4, pc}
34807e40:	34828a38 	.word	0x34828a38
34807e44:	34824c10 	.word	0x34824c10

34807e48 <onenand_dump>:
{
34807e48:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34807e4c:	e1a05000 	mov	r5, r0
	datbuf = malloc(mtd->writesize + mtd->oobsize);
34807e50:	e5953014 	ldr	r3, [r5, #20]
{
34807e54:	e24dd058 	sub	sp, sp, #88	; 0x58
34807e58:	e1a04001 	mov	r4, r1
34807e5c:	e1a0a002 	mov	sl, r2
	datbuf = malloc(mtd->writesize + mtd->oobsize);
34807e60:	e5900018 	ldr	r0, [r0, #24]
34807e64:	e0800003 	add	r0, r0, r3
34807e68:	eb00081a 	bl	34809ed8 <malloc>
34807e6c:	e1a09000 	mov	r9, r0
	oobbuf = malloc(mtd->oobsize);
34807e70:	e5950018 	ldr	r0, [r5, #24]
34807e74:	eb000817 	bl	34809ed8 <malloc>
	if (!datbuf || !oobbuf) {
34807e78:	e3590000 	cmp	r9, #0
34807e7c:	13500000 	cmpne	r0, #0
34807e80:	e1a07000 	mov	r7, r0
34807e84:	03a06001 	moveq	r6, #1
34807e88:	13a06000 	movne	r6, #0
34807e8c:	1a000002 	bne	34807e9c <onenand_dump+0x54>
		puts("No memory for page buffer\n");
34807e90:	e59f01b8 	ldr	r0, [pc, #440]	; 34808050 <onenand_dump+0x208>
34807e94:	eb000634 	bl	3480976c <puts>
34807e98:	ea00001d 	b	34807f14 <onenand_dump+0xcc>
	off &= ~(mtd->writesize - 1);
34807e9c:	e5953014 	ldr	r3, [r5, #20]
	memset(&ops, 0, sizeof(ops));
34807ea0:	e28db038 	add	fp, sp, #56	; 0x38
34807ea4:	e3a02020 	mov	r2, #32
34807ea8:	e1a01006 	mov	r1, r6
34807eac:	e1a0000b 	mov	r0, fp
	off &= ~(mtd->writesize - 1);
34807eb0:	e2633000 	rsb	r3, r3, #0
34807eb4:	e0044003 	and	r4, r4, r3
	memset(&ops, 0, sizeof(ops));
34807eb8:	eb004f2f 	bl	3481bb7c <memset>
	ops.len = mtd->writesize;
34807ebc:	e5953014 	ldr	r3, [r5, #20]
	i = mtd->read_oob(mtd, addr, &ops);
34807ec0:	e1a02004 	mov	r2, r4
	ops.datbuf = datbuf;
34807ec4:	e58d9050 	str	r9, [sp, #80]	; 0x50
	i = mtd->read_oob(mtd, addr, &ops);
34807ec8:	e1a00005 	mov	r0, r5
	ops.oobbuf = oobbuf;
34807ecc:	e58d7054 	str	r7, [sp, #84]	; 0x54
	ops.len = mtd->writesize;
34807ed0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	ops.ooblen = mtd->oobsize;
34807ed4:	e5953018 	ldr	r3, [r5, #24]
	ops.retlen = 0;
34807ed8:	e58d6040 	str	r6, [sp, #64]	; 0x40
	i = mtd->read_oob(mtd, addr, &ops);
34807edc:	e58db000 	str	fp, [sp]
	ops.ooblen = mtd->oobsize;
34807ee0:	e58d3044 	str	r3, [sp, #68]	; 0x44
	i = mtd->read_oob(mtd, addr, &ops);
34807ee4:	e1a03006 	mov	r3, r6
34807ee8:	e595104c 	ldr	r1, [r5, #76]	; 0x4c
34807eec:	e12fff31 	blx	r1
	if (i < 0) {
34807ef0:	e2501000 	subs	r1, r0, #0
34807ef4:	aa000008 	bge	34807f1c <onenand_dump+0xd4>
		printf("Error (%d) reading page %08lx\n", i, off);
34807ef8:	e1a02004 	mov	r2, r4
34807efc:	e59f0150 	ldr	r0, [pc, #336]	; 34808054 <onenand_dump+0x20c>
34807f00:	eb000625 	bl	3480979c <printf>
		free(datbuf);
34807f04:	e1a00009 	mov	r0, r9
34807f08:	eb000768 	bl	34809cb0 <free>
		free(oobbuf);
34807f0c:	e1a00007 	mov	r0, r7
34807f10:	eb000766 	bl	34809cb0 <free>
		return 1;
34807f14:	e3a00001 	mov	r0, #1
34807f18:	ea00004a 	b	34808048 <onenand_dump+0x200>
	printf("Page %08lx dump:\n", off);
34807f1c:	e1a01004 	mov	r1, r4
34807f20:	e59f0130 	ldr	r0, [pc, #304]	; 34808058 <onenand_dump+0x210>
34807f24:	eb00061c 	bl	3480979c <printf>
	i = mtd->writesize >> 4;
34807f28:	e595b014 	ldr	fp, [r5, #20]
34807f2c:	e2894010 	add	r4, r9, #16
34807f30:	e1a0b22b 	lsr	fp, fp, #4
	while (i--) {
34807f34:	e156000b 	cmp	r6, fp
34807f38:	0a000023 	beq	34807fcc <onenand_dump+0x184>
		if (!only_oob)
34807f3c:	e35a0000 	cmp	sl, #0
34807f40:	1a00001e 	bne	34807fc0 <onenand_dump+0x178>
			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
34807f44:	e5540001 	ldrb	r0, [r4, #-1]
34807f48:	e554300e 	ldrb	r3, [r4, #-14]
34807f4c:	e554200f 	ldrb	r2, [r4, #-15]
34807f50:	e5541010 	ldrb	r1, [r4, #-16]
34807f54:	e58d0030 	str	r0, [sp, #48]	; 0x30
34807f58:	e5540002 	ldrb	r0, [r4, #-2]
34807f5c:	e58d002c 	str	r0, [sp, #44]	; 0x2c
34807f60:	e5540003 	ldrb	r0, [r4, #-3]
34807f64:	e58d0028 	str	r0, [sp, #40]	; 0x28
34807f68:	e5540004 	ldrb	r0, [r4, #-4]
34807f6c:	e58d0024 	str	r0, [sp, #36]	; 0x24
34807f70:	e5540005 	ldrb	r0, [r4, #-5]
34807f74:	e58d0020 	str	r0, [sp, #32]
34807f78:	e5540006 	ldrb	r0, [r4, #-6]
34807f7c:	e58d001c 	str	r0, [sp, #28]
34807f80:	e5540007 	ldrb	r0, [r4, #-7]
34807f84:	e58d0018 	str	r0, [sp, #24]
34807f88:	e5540008 	ldrb	r0, [r4, #-8]
34807f8c:	e58d0014 	str	r0, [sp, #20]
34807f90:	e5540009 	ldrb	r0, [r4, #-9]
34807f94:	e58d0010 	str	r0, [sp, #16]
34807f98:	e554000a 	ldrb	r0, [r4, #-10]
34807f9c:	e58d000c 	str	r0, [sp, #12]
34807fa0:	e554000b 	ldrb	r0, [r4, #-11]
34807fa4:	e58d0008 	str	r0, [sp, #8]
34807fa8:	e554000c 	ldrb	r0, [r4, #-12]
34807fac:	e58d0004 	str	r0, [sp, #4]
34807fb0:	e554000d 	ldrb	r0, [r4, #-13]
34807fb4:	e58d0000 	str	r0, [sp]
34807fb8:	e59f009c 	ldr	r0, [pc, #156]	; 3480805c <onenand_dump+0x214>
34807fbc:	eb0005f6 	bl	3480979c <printf>
34807fc0:	e2866001 	add	r6, r6, #1
34807fc4:	e2844010 	add	r4, r4, #16
34807fc8:	eaffffd9 	b	34807f34 <onenand_dump+0xec>
	puts("OOB:\n");
34807fcc:	e59f008c 	ldr	r0, [pc, #140]	; 34808060 <onenand_dump+0x218>
34807fd0:	e1a04007 	mov	r4, r7
34807fd4:	eb0005e4 	bl	3480976c <puts>
	i = mtd->oobsize >> 3;
34807fd8:	e5955018 	ldr	r5, [r5, #24]
	while (i--) {
34807fdc:	e3a06000 	mov	r6, #0
	i = mtd->oobsize >> 3;
34807fe0:	e1a051a5 	lsr	r5, r5, #3
	while (i--) {
34807fe4:	e1560005 	cmp	r6, r5
34807fe8:	e2844008 	add	r4, r4, #8
34807fec:	0a000010 	beq	34808034 <onenand_dump+0x1ec>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
34807ff0:	e5540001 	ldrb	r0, [r4, #-1]
34807ff4:	e2866001 	add	r6, r6, #1
34807ff8:	e5543006 	ldrb	r3, [r4, #-6]
34807ffc:	e5542007 	ldrb	r2, [r4, #-7]
34808000:	e5541008 	ldrb	r1, [r4, #-8]
34808004:	e58d0010 	str	r0, [sp, #16]
34808008:	e5540002 	ldrb	r0, [r4, #-2]
3480800c:	e58d000c 	str	r0, [sp, #12]
34808010:	e5540003 	ldrb	r0, [r4, #-3]
34808014:	e58d0008 	str	r0, [sp, #8]
34808018:	e5540004 	ldrb	r0, [r4, #-4]
3480801c:	e58d0004 	str	r0, [sp, #4]
34808020:	e5540005 	ldrb	r0, [r4, #-5]
34808024:	e58d0000 	str	r0, [sp]
34808028:	e59f0034 	ldr	r0, [pc, #52]	; 34808064 <onenand_dump+0x21c>
3480802c:	eb0005da 	bl	3480979c <printf>
34808030:	eaffffeb 	b	34807fe4 <onenand_dump+0x19c>
	free(datbuf);
34808034:	e1a00009 	mov	r0, r9
34808038:	eb00071c 	bl	34809cb0 <free>
	free(oobbuf);
3480803c:	e1a00007 	mov	r0, r7
34808040:	eb00071a 	bl	34809cb0 <free>
	return 0;
34808044:	e3a00000 	mov	r0, #0
}
34808048:	e28dd058 	add	sp, sp, #88	; 0x58
3480804c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808050:	3482459a 	.word	0x3482459a
34808054:	348245b5 	.word	0x348245b5
34808058:	348245d4 	.word	0x348245d4
3480805c:	348245e6 	.word	0x348245e6
34808060:	34824639 	.word	0x34824639
34808064:	3482463f 	.word	0x3482463f

34808068 <do_onenand_dump>:
	if (argc < 2)
34808068:	e3520001 	cmp	r2, #1
3480806c:	da00001a 	ble	348080dc <do_onenand_dump+0x74>
{
34808070:	e92d4070 	push	{r4, r5, r6, lr}
	s = strchr(argv[0], '.');
34808074:	e3a0102e 	mov	r1, #46	; 0x2e
34808078:	e1a04003 	mov	r4, r3
3480807c:	e5930000 	ldr	r0, [r3]
34808080:	eb004dff 	bl	3481b884 <strchr>
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808084:	e3a02010 	mov	r2, #16
	s = strchr(argv[0], '.');
34808088:	e1a06000 	mov	r6, r0
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
3480808c:	e3a01000 	mov	r1, #0
34808090:	e5940004 	ldr	r0, [r4, #4]
34808094:	eb0051b2 	bl	3481c764 <simple_strtoul>
	if (s != NULL && strcmp(s, ".oob") == 0)
34808098:	e3560000 	cmp	r6, #0
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
3480809c:	e1a05000 	mov	r5, r0
348080a0:	e59f403c 	ldr	r4, [pc, #60]	; 348080e4 <do_onenand_dump+0x7c>
	if (s != NULL && strcmp(s, ".oob") == 0)
348080a4:	0a000005 	beq	348080c0 <do_onenand_dump+0x58>
348080a8:	e59f1038 	ldr	r1, [pc, #56]	; 348080e8 <do_onenand_dump+0x80>
348080ac:	e1a00006 	mov	r0, r6
348080b0:	eb004dda 	bl	3481b820 <strcmp>
348080b4:	e3500000 	cmp	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
348080b8:	03a02001 	moveq	r2, #1
	if (s != NULL && strcmp(s, ".oob") == 0)
348080bc:	0a000000 	beq	348080c4 <do_onenand_dump+0x5c>
		ret = onenand_dump(mtd, ofs, 0);
348080c0:	e3a02000 	mov	r2, #0
348080c4:	e1a01005 	mov	r1, r5
348080c8:	e5940000 	ldr	r0, [r4]
348080cc:	ebffff5d 	bl	34807e48 <onenand_dump>
	return ret == 0 ? 1 : 0;
348080d0:	e16f0f10 	clz	r0, r0
348080d4:	e1a002a0 	lsr	r0, r0, #5
348080d8:	e8bd8070 	pop	{r4, r5, r6, pc}
		return CMD_RET_USAGE;
348080dc:	e3e00000 	mvn	r0, #0
348080e0:	e12fff1e 	bx	lr
348080e4:	34828a38 	.word	0x34828a38
348080e8:	34824669 	.word	0x34824669

348080ec <arg_off_size>:
{
348080ec:	e92d42f3 	push	{r0, r1, r4, r5, r6, r7, r9, lr}
	if (argc >= 1) {
348080f0:	e2509000 	subs	r9, r0, #0
{
348080f4:	e1a04002 	mov	r4, r2
348080f8:	e1a06003 	mov	r6, r3
	if (argc >= 1) {
348080fc:	da00000f 	ble	34808140 <arg_off_size+0x54>
		if (!(str2long(argv[0], off))) {
34808100:	e5917000 	ldr	r7, [r1]
34808104:	e1a05001 	mov	r5, r1
	*num = simple_strtoul(p, &endptr, 16);
34808108:	e3a02010 	mov	r2, #16
3480810c:	e28d1004 	add	r1, sp, #4
34808110:	e1a00007 	mov	r0, r7
34808114:	eb005192 	bl	3481c764 <simple_strtoul>
34808118:	e5840000 	str	r0, [r4]
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
3480811c:	e5d73000 	ldrb	r3, [r7]
34808120:	e3530000 	cmp	r3, #0
34808124:	0a000003 	beq	34808138 <arg_off_size+0x4c>
34808128:	e59d3004 	ldr	r3, [sp, #4]
3480812c:	e5d33000 	ldrb	r3, [r3]
		if (!(str2long(argv[0], off))) {
34808130:	e3530000 	cmp	r3, #0
34808134:	0a000004 	beq	3480814c <arg_off_size+0x60>
			printf("'%s' is not a number\n", argv[0]);
34808138:	e5951000 	ldr	r1, [r5]
3480813c:	ea000012 	b	3480818c <arg_off_size+0xa0>
		*off = 0;
34808140:	e3a03000 	mov	r3, #0
34808144:	e5823000 	str	r3, [r2]
34808148:	ea000012 	b	34808198 <arg_off_size+0xac>
	if (argc >= 2) {
3480814c:	e3590001 	cmp	r9, #1
34808150:	0a000010 	beq	34808198 <arg_off_size+0xac>
		if (!(str2long(argv[1], (ulong *)size))) {
34808154:	e5957004 	ldr	r7, [r5, #4]
	*num = simple_strtoul(p, &endptr, 16);
34808158:	e3a02010 	mov	r2, #16
3480815c:	e28d1004 	add	r1, sp, #4
34808160:	e1a00007 	mov	r0, r7
34808164:	eb00517e 	bl	3481c764 <simple_strtoul>
34808168:	e5860000 	str	r0, [r6]
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
3480816c:	e5d73000 	ldrb	r3, [r7]
34808170:	e3530000 	cmp	r3, #0
34808174:	0a000003 	beq	34808188 <arg_off_size+0x9c>
34808178:	e59d3004 	ldr	r3, [sp, #4]
3480817c:	e5d33000 	ldrb	r3, [r3]
		if (!(str2long(argv[1], (ulong *)size))) {
34808180:	e3530000 	cmp	r3, #0
34808184:	0a000009 	beq	348081b0 <arg_off_size+0xc4>
			printf("'%s' is not a number\n", argv[1]);
34808188:	e5951004 	ldr	r1, [r5, #4]
3480818c:	e59f0094 	ldr	r0, [pc, #148]	; 34808228 <arg_off_size+0x13c>
34808190:	eb000581 	bl	3480979c <printf>
34808194:	ea000013 	b	348081e8 <arg_off_size+0xfc>
		*size = mtd->size - *off;
34808198:	e59f308c 	ldr	r3, [pc, #140]	; 3480822c <arg_off_size+0x140>
3480819c:	e5942000 	ldr	r2, [r4]
348081a0:	e5933000 	ldr	r3, [r3]
348081a4:	e5933008 	ldr	r3, [r3, #8]
348081a8:	e0623003 	rsb	r3, r2, r3
348081ac:	e5863000 	str	r3, [r6]
	if ((*off + *size) > mtd->size) {
348081b0:	e59f2074 	ldr	r2, [pc, #116]	; 3480822c <arg_off_size+0x140>
348081b4:	e3a05000 	mov	r5, #0
348081b8:	e594c000 	ldr	ip, [r4]
348081bc:	e5963000 	ldr	r3, [r6]
348081c0:	e5922000 	ldr	r2, [r2]
348081c4:	e08c4003 	add	r4, ip, r3
348081c8:	e1c200d8 	ldrd	r0, [r2, #8]
348081cc:	e1550001 	cmp	r5, r1
348081d0:	01540000 	cmpeq	r4, r0
348081d4:	9a000005 	bls	348081f0 <arg_off_size+0x104>
		printf("total chip size (0x%llx) exceeded!\n", mtd->size);
348081d8:	e1a02000 	mov	r2, r0
348081dc:	e1a03001 	mov	r3, r1
348081e0:	e59f0048 	ldr	r0, [pc, #72]	; 34808230 <arg_off_size+0x144>
348081e4:	eb00056c 	bl	3480979c <printf>
		return -1;
348081e8:	e3e00000 	mvn	r0, #0
348081ec:	ea00000b 	b	34808220 <arg_off_size+0x134>
	if (*size == mtd->size)
348081f0:	e3a05000 	mov	r5, #0
348081f4:	e1550001 	cmp	r5, r1
348081f8:	01530000 	cmpeq	r3, r0
348081fc:	1a000002 	bne	3480820c <arg_off_size+0x120>
		puts("whole chip\n");
34808200:	e59f002c 	ldr	r0, [pc, #44]	; 34808234 <arg_off_size+0x148>
34808204:	eb000558 	bl	3480976c <puts>
34808208:	ea000003 	b	3480821c <arg_off_size+0x130>
		printf("offset 0x%lx, size 0x%x\n", *off, *size);
3480820c:	e1a02003 	mov	r2, r3
34808210:	e1a0100c 	mov	r1, ip
34808214:	e59f001c 	ldr	r0, [pc, #28]	; 34808238 <arg_off_size+0x14c>
34808218:	eb00055f 	bl	3480979c <printf>
	return 0;
3480821c:	e3a00000 	mov	r0, #0
}
34808220:	e28dd008 	add	sp, sp, #8
34808224:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34808228:	3482466e 	.word	0x3482466e
3480822c:	34828a38 	.word	0x34828a38
34808230:	34824684 	.word	0x34824684
34808234:	348246a8 	.word	0x348246a8
34808238:	348246b4 	.word	0x348246b4

3480823c <do_onenand_erase>:
{
3480823c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc)
34808240:	e2526001 	subs	r6, r2, #1
{
34808244:	e24dd068 	sub	sp, sp, #104	; 0x68
34808248:	e1a05002 	mov	r5, r2
3480824c:	e1a04003 	mov	r4, r3
	argv++;
34808250:	e2837004 	add	r7, r3, #4
	if (argc)
34808254:	0a000005 	beq	34808270 <do_onenand_erase+0x34>
		if (!strcmp("force", argv[0]))
34808258:	e5931004 	ldr	r1, [r3, #4]
3480825c:	e59f0148 	ldr	r0, [pc, #328]	; 348083ac <do_onenand_erase+0x170>
34808260:	eb004d6e 	bl	3481b820 <strcmp>
34808264:	e3500000 	cmp	r0, #0
			argc--;
34808268:	02456002 	subeq	r6, r5, #2
			argv++;
3480826c:	02847008 	addeq	r7, r4, #8
	printf("\nOneNAND erase: ");
34808270:	e59f0138 	ldr	r0, [pc, #312]	; 348083b0 <do_onenand_erase+0x174>
34808274:	eb000548 	bl	3480979c <printf>
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808278:	e1a01007 	mov	r1, r7
3480827c:	e28d301c 	add	r3, sp, #28
34808280:	e28d2018 	add	r2, sp, #24
34808284:	e1a00006 	mov	r0, r6
34808288:	ebffff97 	bl	348080ec <arg_off_size>
3480828c:	e2507000 	subs	r7, r0, #0
		return 1;
34808290:	13a07001 	movne	r7, #1
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808294:	1a000041 	bne	348083a0 <do_onenand_erase+0x164>
	struct onenand_chip *this = mtd->priv;
34808298:	e59f6114 	ldr	r6, [pc, #276]	; 348083b4 <do_onenand_erase+0x178>
	struct erase_info instr = {
3480829c:	e3a02048 	mov	r2, #72	; 0x48
348082a0:	e1a01007 	mov	r1, r7
348082a4:	e28d0020 	add	r0, sp, #32
	ret = onenand_block_erase(ofs, len, force);
348082a8:	e59db018 	ldr	fp, [sp, #24]
	for (ofs = start; ofs < (start + size); ofs += blocksize) {
348082ac:	e3a05000 	mov	r5, #0
	struct onenand_chip *this = mtd->priv;
348082b0:	e5963000 	ldr	r3, [r6]
	ret = onenand_block_erase(ofs, len, force);
348082b4:	e59d901c 	ldr	r9, [sp, #28]
	for (ofs = start; ofs < (start + size); ofs += blocksize) {
348082b8:	e1a0400b 	mov	r4, fp
	struct onenand_chip *this = mtd->priv;
348082bc:	e593a094 	ldr	sl, [r3, #148]	; 0x94
	struct erase_info instr = {
348082c0:	eb004e2d 	bl	3481bb7c <memset>
	int blocksize = 1 << this->erase_shift;
348082c4:	e3a03001 	mov	r3, #1
	for (ofs = start; ofs < (start + size); ofs += blocksize) {
348082c8:	e089900b 	add	r9, r9, fp
	int blocksize = 1 << this->erase_shift;
348082cc:	e59a2030 	ldr	r2, [sl, #48]	; 0x30
348082d0:	e1cd40f0 	strd	r4, [sp]
348082d4:	e1a03213 	lsl	r3, r3, r2
	for (ofs = start; ofs < (start + size); ofs += blocksize) {
348082d8:	e1a02009 	mov	r2, r9
348082dc:	e1a01fc3 	asr	r1, r3, #31
348082e0:	e1a00003 	mov	r0, r3
348082e4:	e3a03000 	mov	r3, #0
348082e8:	e1cd00f8 	strd	r0, [sp, #8]
348082ec:	e1cd21f0 	strd	r2, [sp, #16]
348082f0:	e1cd21d0 	ldrd	r2, [sp, #16]
348082f4:	e1540002 	cmp	r4, r2
348082f8:	e0d53003 	sbcs	r3, r5, r3
348082fc:	aa000024 	bge	34808394 <do_onenand_erase+0x158>
		ret = mtd->block_isbad(mtd, ofs);
34808300:	e5960000 	ldr	r0, [r6]
34808304:	e1a02004 	mov	r2, r4
34808308:	e1a03005 	mov	r3, r5
3480830c:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808310:	e12fff31 	blx	r1
		instr.addr = ofs;
34808314:	e1cd20d0 	ldrd	r2, [sp]
		instr.mtd = mtd;
34808318:	e28d1068 	add	r1, sp, #104	; 0x68
3480831c:	e5960000 	ldr	r0, [r6]
		instr.addr = ofs;
34808320:	e1cd22f8 	strd	r2, [sp, #40]	; 0x28
		instr.len = blocksize;
34808324:	e1cd20d8 	ldrd	r2, [sp, #8]
		instr.mtd = mtd;
34808328:	e5210048 	str	r0, [r1, #-72]!	; 0xffffffb8
		instr.len = blocksize;
3480832c:	e1cd23f0 	strd	r2, [sp, #48]	; 0x30
		instr.priv = force;
34808330:	e3a03001 	mov	r3, #1
34808334:	e58d3054 	str	r3, [sp, #84]	; 0x54
		ret = mtd->erase(mtd, &instr);
34808338:	e5903034 	ldr	r3, [r0, #52]	; 0x34
3480833c:	e12fff33 	blx	r3
		if (ret) {
34808340:	e3500000 	cmp	r0, #0
34808344:	0a000007 	beq	34808368 <do_onenand_erase+0x12c>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808348:	e59a2030 	ldr	r2, [sl, #48]	; 0x30
3480834c:	e1a00004 	mov	r0, r4
34808350:	e1a01005 	mov	r1, r5
34808354:	fa005c81 	blx	3481f560 <__ashrdi3>
			printf("erase failed block %d at 0x%x\n",
34808358:	e1a02004 	mov	r2, r4
3480835c:	e1a01000 	mov	r1, r0
34808360:	e59f0050 	ldr	r0, [pc, #80]	; 348083b8 <do_onenand_erase+0x17c>
34808364:	eb00050c 	bl	3480979c <printf>
34808368:	e1cd20d8 	ldrd	r2, [sp, #8]
3480836c:	e1cd00d0 	ldrd	r0, [sp]
34808370:	e0922004 	adds	r2, r2, r4
34808374:	e0a33005 	adc	r3, r3, r5
34808378:	e1a04002 	mov	r4, r2
3480837c:	e1a05003 	mov	r5, r3
34808380:	e1cd20d8 	ldrd	r2, [sp, #8]
34808384:	e0922000 	adds	r2, r2, r0
34808388:	e0a33001 	adc	r3, r3, r1
3480838c:	e1cd20f0 	strd	r2, [sp]
34808390:	eaffffd6 	b	348082f0 <do_onenand_erase+0xb4>
	printf("%s\n", ret ? "ERROR" : "OK");
34808394:	e59f1020 	ldr	r1, [pc, #32]	; 348083bc <do_onenand_erase+0x180>
34808398:	e59f0020 	ldr	r0, [pc, #32]	; 348083c0 <do_onenand_erase+0x184>
3480839c:	eb0004fe 	bl	3480979c <printf>
}
348083a0:	e1a00007 	mov	r0, r7
348083a4:	e28dd068 	add	sp, sp, #104	; 0x68
348083a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348083ac:	348246cd 	.word	0x348246cd
348083b0:	348246d3 	.word	0x348246d3
348083b4:	34828a38 	.word	0x34828a38
348083b8:	348246e4 	.word	0x348246e4
348083bc:	34822e2f 	.word	0x34822e2f
348083c0:	34824c10 	.word	0x34824c10

348083c4 <do_onenand_read>:
	if (argc < 3)
348083c4:	e3520002 	cmp	r2, #2
{
348083c8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		return CMD_RET_USAGE;
348083cc:	d3e07000 	mvnle	r7, #0
{
348083d0:	e24dd040 	sub	sp, sp, #64	; 0x40
	if (argc < 3)
348083d4:	da00006d 	ble	34808590 <do_onenand_read+0x1cc>
	s = strchr(argv[0], '.');
348083d8:	e3a0102e 	mov	r1, #46	; 0x2e
348083dc:	e5930000 	ldr	r0, [r3]
348083e0:	e1a06003 	mov	r6, r3
348083e4:	e1a07002 	mov	r7, r2
348083e8:	eb004d25 	bl	3481b884 <strchr>
	if ((s != NULL) && (!strcmp(s, ".oob")))
348083ec:	e2504000 	subs	r4, r0, #0
348083f0:	0a000003 	beq	34808404 <do_onenand_read+0x40>
348083f4:	e59f11a0 	ldr	r1, [pc, #416]	; 3480859c <do_onenand_read+0x1d8>
348083f8:	eb004d08 	bl	3481b820 <strcmp>
348083fc:	e16f4f10 	clz	r4, r0
34808400:	e1a042a4 	lsr	r4, r4, #5
	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808404:	e3a02010 	mov	r2, #16
34808408:	e5960004 	ldr	r0, [r6, #4]
3480840c:	e3a01000 	mov	r1, #0
34808410:	eb0050d3 	bl	3481c764 <simple_strtoul>
34808414:	e1a05000 	mov	r5, r0
	printf("\nOneNAND read: ");
34808418:	e59f0180 	ldr	r0, [pc, #384]	; 348085a0 <do_onenand_read+0x1dc>
3480841c:	eb0004de 	bl	3480979c <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808420:	e2470002 	sub	r0, r7, #2
34808424:	e28d301c 	add	r3, sp, #28
34808428:	e28d2018 	add	r2, sp, #24
3480842c:	e2861008 	add	r1, r6, #8
34808430:	ebffff2d 	bl	348080ec <arg_off_size>
34808434:	e2507000 	subs	r7, r0, #0
		return 1;
34808438:	13a07001 	movne	r7, #1
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
3480843c:	1a000053 	bne	34808590 <do_onenand_read+0x1cc>
	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
34808440:	e59d3018 	ldr	r3, [sp, #24]
	int blocksize = (1 << this->erase_shift);
34808444:	e3a06001 	mov	r6, #1
	int blocks = (int) len >> this->erase_shift;
34808448:	e59d201c 	ldr	r2, [sp, #28]
	struct mtd_oob_ops ops = {
3480844c:	e1a01007 	mov	r1, r7
	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
34808450:	e3a0b000 	mov	fp, #0
	int oob = 0;
34808454:	e3a09000 	mov	r9, #0
	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
34808458:	e1a0a003 	mov	sl, r3
	struct onenand_chip *this = mtd->priv;
3480845c:	e59f3140 	ldr	r3, [pc, #320]	; 348085a4 <do_onenand_read+0x1e0>
34808460:	e5933000 	ldr	r3, [r3]
34808464:	e5933094 	ldr	r3, [r3, #148]	; 0x94
34808468:	e58d3014 	str	r3, [sp, #20]
	int blocks = (int) len >> this->erase_shift;
3480846c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
34808470:	e1a02352 	asr	r2, r2, r3
	int blocksize = (1 << this->erase_shift);
34808474:	e1a06316 	lsl	r6, r6, r3
	int blocks = (int) len >> this->erase_shift;
34808478:	e58d2010 	str	r2, [sp, #16]
	struct mtd_oob_ops ops = {
3480847c:	e3a02020 	mov	r2, #32
34808480:	e08d0002 	add	r0, sp, r2
34808484:	eb004dbc 	bl	3481bb7c <memset>
	if (oob)
34808488:	e3540000 	cmp	r4, #0
		ops.len = blocksize;
3480848c:	058d6024 	streq	r6, [sp, #36]	; 0x24
		ops.ooblen = blocksize;
34808490:	158d602c 	strne	r6, [sp, #44]	; 0x2c
	while (blocks) {
34808494:	e59d3010 	ldr	r3, [sp, #16]
34808498:	e3530000 	cmp	r3, #0
3480849c:	0a000037 	beq	34808580 <do_onenand_read+0x1bc>
		ret = mtd->block_isbad(mtd, ofs);
348084a0:	e59f30fc 	ldr	r3, [pc, #252]	; 348085a4 <do_onenand_read+0x1e0>
348084a4:	e1a0200a 	mov	r2, sl
348084a8:	e5930000 	ldr	r0, [r3]
348084ac:	e1a0300b 	mov	r3, fp
348084b0:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348084b4:	e12fff31 	blx	r1
348084b8:	e1a03fc6 	asr	r3, r6, #31
		if (ret) {
348084bc:	e3500000 	cmp	r0, #0
348084c0:	e1a02006 	mov	r2, r6
348084c4:	e1cd20f8 	strd	r2, [sp, #8]
348084c8:	0a000008 	beq	348084f0 <do_onenand_read+0x12c>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348084cc:	e59d3014 	ldr	r3, [sp, #20]
348084d0:	e1a0000a 	mov	r0, sl
348084d4:	e1a0100b 	mov	r1, fp
348084d8:	e5932030 	ldr	r2, [r3, #48]	; 0x30
348084dc:	fa005c1f 	blx	3481f560 <__ashrdi3>
			printk("Bad blocks %d at 0x%x\n",
348084e0:	e1a0200a 	mov	r2, sl
348084e4:	e1a01000 	mov	r1, r0
348084e8:	e59f00b8 	ldr	r0, [pc, #184]	; 348085a8 <do_onenand_read+0x1e4>
348084ec:	ea000010 	b	34808534 <do_onenand_read+0x170>
		ops.retlen = 0;
348084f0:	e3a03000 	mov	r3, #0
		if (oob)
348084f4:	e3540000 	cmp	r4, #0
		ops.retlen = 0;
348084f8:	e58d3028 	str	r3, [sp, #40]	; 0x28
		ret = mtd->read_oob(mtd, ofs, &ops);
348084fc:	e1a0200a 	mov	r2, sl
34808500:	e59f309c 	ldr	r3, [pc, #156]	; 348085a4 <do_onenand_read+0x1e0>
			ops.oobbuf = buf;
34808504:	158d503c 	strne	r5, [sp, #60]	; 0x3c
			ops.datbuf = buf;
34808508:	058d5038 	streq	r5, [sp, #56]	; 0x38
		ret = mtd->read_oob(mtd, ofs, &ops);
3480850c:	e5930000 	ldr	r0, [r3]
34808510:	e28d3020 	add	r3, sp, #32
34808514:	e58d3000 	str	r3, [sp]
34808518:	e1a0300b 	mov	r3, fp
3480851c:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34808520:	e12fff31 	blx	r1
		if (ret) {
34808524:	e2502000 	subs	r2, r0, #0
34808528:	0a000008 	beq	34808550 <do_onenand_read+0x18c>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
3480852c:	e59f0078 	ldr	r0, [pc, #120]	; 348085ac <do_onenand_read+0x1e8>
34808530:	e1a0100a 	mov	r1, sl
34808534:	eb000498 	bl	3480979c <printf>
			ofs += blocksize;
34808538:	e1cd20d8 	ldrd	r2, [sp, #8]
3480853c:	e092200a 	adds	r2, r2, sl
34808540:	e0a3300b 	adc	r3, r3, fp
34808544:	e1a0a002 	mov	sl, r2
34808548:	e1a0b003 	mov	fp, r3
3480854c:	eaffffd0 	b	34808494 <do_onenand_read+0xd0>
		ofs += blocksize;
34808550:	e1cd20d8 	ldrd	r2, [sp, #8]
		buf += blocksize;
34808554:	e0855006 	add	r5, r5, r6
		ofs += blocksize;
34808558:	e092200a 	adds	r2, r2, sl
3480855c:	e0a3300b 	adc	r3, r3, fp
34808560:	e1a0a002 	mov	sl, r2
34808564:	e1a0b003 	mov	fp, r3
		blocks--;
34808568:	e59d3010 	ldr	r3, [sp, #16]
3480856c:	e2433001 	sub	r3, r3, #1
34808570:	e58d3010 	str	r3, [sp, #16]
		*retlen += ops.retlen;
34808574:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34808578:	e0899003 	add	r9, r9, r3
3480857c:	eaffffc4 	b	34808494 <do_onenand_read+0xd0>
	printf(" %d bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
34808580:	e59f2028 	ldr	r2, [pc, #40]	; 348085b0 <do_onenand_read+0x1ec>
34808584:	e1a01009 	mov	r1, r9
34808588:	e59f0024 	ldr	r0, [pc, #36]	; 348085b4 <do_onenand_read+0x1f0>
3480858c:	eb000482 	bl	3480979c <printf>
}
34808590:	e1a00007 	mov	r0, r7
34808594:	e28dd040 	add	sp, sp, #64	; 0x40
34808598:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480859c:	34824669 	.word	0x34824669
348085a0:	34824703 	.word	0x34824703
348085a4:	34828a38 	.word	0x34828a38
348085a8:	34824713 	.word	0x34824713
348085ac:	3482472a 	.word	0x3482472a
348085b0:	34822e2f 	.word	0x34822e2f
348085b4:	34824740 	.word	0x34824740

348085b8 <do_onenand_test>:
{
348085b8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348085bc:	e1a04002 	mov	r4, r2
348085c0:	e24dd088 	sub	sp, sp, #136	; 0x88
348085c4:	e1a05003 	mov	r5, r3
	printf("\nOneNAND test: ");
348085c8:	e59f0280 	ldr	r0, [pc, #640]	; 34808850 <do_onenand_test+0x298>
348085cc:	eb000472 	bl	3480979c <printf>
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348085d0:	e28d3038 	add	r3, sp, #56	; 0x38
348085d4:	e28d2034 	add	r2, sp, #52	; 0x34
348085d8:	e2851004 	add	r1, r5, #4
348085dc:	e2440001 	sub	r0, r4, #1
348085e0:	ebfffec1 	bl	348080ec <arg_off_size>
348085e4:	e2503000 	subs	r3, r0, #0
348085e8:	e58d3014 	str	r3, [sp, #20]
		return 1;
348085ec:	13a00001 	movne	r0, #1
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348085f0:	1a000094 	bne	34808848 <do_onenand_test+0x290>
	struct onenand_chip *this = mtd->priv;
348085f4:	e59f7258 	ldr	r7, [pc, #600]	; 34808854 <do_onenand_test+0x29c>
	struct erase_info instr = {
348085f8:	e1a01000 	mov	r1, r0
348085fc:	e3a02048 	mov	r2, #72	; 0x48
34808600:	e28d0040 	add	r0, sp, #64	; 0x40
	ret = onenand_block_test(ofs, len);
34808604:	e59d6034 	ldr	r6, [sp, #52]	; 0x34
	int blocksize = 1 << this->erase_shift;
34808608:	e3a04001 	mov	r4, #1
	struct onenand_chip *this = mtd->priv;
3480860c:	e5973000 	ldr	r3, [r7]
	ret = onenand_block_test(ofs, len);
34808610:	e59da038 	ldr	sl, [sp, #56]	; 0x38
	struct onenand_chip *this = mtd->priv;
34808614:	e5935094 	ldr	r5, [r3, #148]	; 0x94
	struct erase_info instr = {
34808618:	eb004d57 	bl	3481bb7c <memset>
	int blocksize = 1 << this->erase_shift;
3480861c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
34808620:	e1a04314 	lsl	r4, r4, r3
	buf = malloc(blocksize);
34808624:	e1a00004 	mov	r0, r4
34808628:	eb00062a 	bl	34809ed8 <malloc>
	if (!buf) {
3480862c:	e2503000 	subs	r3, r0, #0
34808630:	e58d3018 	str	r3, [sp, #24]
34808634:	1a000005 	bne	34808650 <do_onenand_test+0x98>
		printf("Not enough malloc space available!\n");
34808638:	e59f0218 	ldr	r0, [pc, #536]	; 34808858 <do_onenand_test+0x2a0>
3480863c:	eb000456 	bl	3480979c <printf>
		return -1;
34808640:	e3e03000 	mvn	r3, #0
	printf("%s\n", ret ? "ERROR" : "OK");
34808644:	e59f1210 	ldr	r1, [pc, #528]	; 3480885c <do_onenand_test+0x2a4>
		return -1;
34808648:	e58d3014 	str	r3, [sp, #20]
3480864c:	ea000078 	b	34808834 <do_onenand_test+0x27c>
	verify_buf = malloc(blocksize);
34808650:	e1a00004 	mov	r0, r4
34808654:	eb00061f 	bl	34809ed8 <malloc>
	if (!verify_buf) {
34808658:	e2503000 	subs	r3, r0, #0
3480865c:	e58d301c 	str	r3, [sp, #28]
34808660:	0afffff4 	beq	34808638 <do_onenand_test+0x80>
	start_block = start >> this->erase_shift;
34808664:	e5952030 	ldr	r2, [r5, #48]	; 0x30
	end_block = (start + size) >> this->erase_shift;
34808668:	e08aa006 	add	sl, sl, r6
	ofs = start;
3480866c:	e3a0b000 	mov	fp, #0
	end_block = (start + size) >> this->erase_shift;
34808670:	e1a0323a 	lsr	r3, sl, r2
	start_block = start >> this->erase_shift;
34808674:	e1a09236 	lsr	r9, r6, r2
	end_block = (start + size) >> this->erase_shift;
34808678:	e58d3010 	str	r3, [sp, #16]
		start_block = 2;
3480867c:	e3590002 	cmp	r9, #2
	if (end_block > (mtd->size >> this->erase_shift))
34808680:	e5973000 	ldr	r3, [r7]
		start_block = 2;
34808684:	b3a09002 	movlt	r9, #2
	ofs = start;
34808688:	e1a0a006 	mov	sl, r6
	if (end_block > (mtd->size >> this->erase_shift))
3480868c:	e1c300d8 	ldrd	r0, [r3, #8]
34808690:	fa005bac 	blx	3481f548 <__lshrdi3>
34808694:	e59d2010 	ldr	r2, [sp, #16]
34808698:	e1cda2f8 	strd	sl, [sp, #40]	; 0x28
3480869c:	e1a03fc2 	asr	r3, r2, #31
		end_block = mtd->size >> this->erase_shift;
348086a0:	e1530001 	cmp	r3, r1
348086a4:	e59d3010 	ldr	r3, [sp, #16]
348086a8:	01520000 	cmpeq	r2, r0
348086ac:	e1a02004 	mov	r2, r4
348086b0:	81a03000 	movhi	r3, r0
348086b4:	e58d3010 	str	r3, [sp, #16]
348086b8:	e1a03fc4 	asr	r3, r4, #31
348086bc:	e1cd22f0 	strd	r2, [sp, #32]
	while (blocks < end_block) {
348086c0:	e59d3010 	ldr	r3, [sp, #16]
348086c4:	e1590003 	cmp	r9, r3
348086c8:	aa000052 	bge	34808818 <do_onenand_test+0x260>
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);
348086cc:	e5952030 	ldr	r2, [r5, #48]	; 0x30
348086d0:	e1a0000a 	mov	r0, sl
348086d4:	e1a0100b 	mov	r1, fp
348086d8:	fa005ba0 	blx	3481f560 <__ashrdi3>
348086dc:	e1a0200a 	mov	r2, sl
348086e0:	e1a01000 	mov	r1, r0
348086e4:	e59f0174 	ldr	r0, [pc, #372]	; 34808860 <do_onenand_test+0x2a8>
348086e8:	eb00042b 	bl	3480979c <printf>
		ret = mtd->block_isbad(mtd, ofs);
348086ec:	e5970000 	ldr	r0, [r7]
348086f0:	e1a0200a 	mov	r2, sl
348086f4:	e1a0300b 	mov	r3, fp
348086f8:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348086fc:	e12fff31 	blx	r1
		if (ret) {
34808700:	e3500000 	cmp	r0, #0
34808704:	0a000007 	beq	34808728 <do_onenand_test+0x170>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808708:	e5952030 	ldr	r2, [r5, #48]	; 0x30
3480870c:	e1a0000a 	mov	r0, sl
34808710:	e1a0100b 	mov	r1, fp
34808714:	fa005b91 	blx	3481f560 <__ashrdi3>
			printf("Skip erase bad block %d at 0x%x\n",
34808718:	e1a0200a 	mov	r2, sl
3480871c:	e1a01000 	mov	r1, r0
34808720:	e59f013c 	ldr	r0, [pc, #316]	; 34808864 <do_onenand_test+0x2ac>
34808724:	ea00000b 	b	34808758 <do_onenand_test+0x1a0>
		instr.addr = ofs;
34808728:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
		ret = mtd->erase(mtd, &instr);
3480872c:	e28d1040 	add	r1, sp, #64	; 0x40
34808730:	e5970000 	ldr	r0, [r7]
		instr.addr = ofs;
34808734:	e1cd24f8 	strd	r2, [sp, #72]	; 0x48
		instr.len = blocksize;
34808738:	e1cd22d0 	ldrd	r2, [sp, #32]
3480873c:	e1cd25f0 	strd	r2, [sp, #80]	; 0x50
		ret = mtd->erase(mtd, &instr);
34808740:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34808744:	e12fff33 	blx	r3
		if (ret) {
34808748:	e2502000 	subs	r2, r0, #0
3480874c:	0a000003 	beq	34808760 <do_onenand_test+0x1a8>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
34808750:	e59f0110 	ldr	r0, [pc, #272]	; 34808868 <do_onenand_test+0x2b0>
34808754:	e1a0100a 	mov	r1, sl
34808758:	eb00040f 	bl	3480979c <printf>
3480875c:	ea000021 	b	348087e8 <do_onenand_test+0x230>
		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
34808760:	e59d3018 	ldr	r3, [sp, #24]
34808764:	e28d603c 	add	r6, sp, #60	; 0x3c
34808768:	e5970000 	ldr	r0, [r7]
3480876c:	e1a0200a 	mov	r2, sl
34808770:	e88d0050 	stm	sp, {r4, r6}
34808774:	e58d3008 	str	r3, [sp, #8]
34808778:	e1a0300b 	mov	r3, fp
3480877c:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808780:	e12fff31 	blx	r1
		if (ret) {
34808784:	e2502000 	subs	r2, r0, #0
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
34808788:	11a0100a 	movne	r1, sl
3480878c:	159f00d8 	ldrne	r0, [pc, #216]	; 3480886c <do_onenand_test+0x2b4>
		if (ret) {
34808790:	1afffff0 	bne	34808758 <do_onenand_test+0x1a0>
		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
34808794:	e59d301c 	ldr	r3, [sp, #28]
34808798:	e1a0200a 	mov	r2, sl
3480879c:	e5970000 	ldr	r0, [r7]
348087a0:	e88d0050 	stm	sp, {r4, r6}
348087a4:	e58d3008 	str	r3, [sp, #8]
348087a8:	e1a0300b 	mov	r3, fp
348087ac:	e5901040 	ldr	r1, [r0, #64]	; 0x40
348087b0:	e12fff31 	blx	r1
		if (ret) {
348087b4:	e2502000 	subs	r2, r0, #0
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
348087b8:	11a0100a 	movne	r1, sl
348087bc:	159f00ac 	ldrne	r0, [pc, #172]	; 34808870 <do_onenand_test+0x2b8>
		if (ret) {
348087c0:	1affffe4 	bne	34808758 <do_onenand_test+0x1a0>
		if (memcmp(buf, verify_buf, blocksize))
348087c4:	e1a02004 	mov	r2, r4
348087c8:	e59d101c 	ldr	r1, [sp, #28]
348087cc:	e59d0018 	ldr	r0, [sp, #24]
348087d0:	eb004d36 	bl	3481bcb0 <memcmp>
348087d4:	e3500000 	cmp	r0, #0
348087d8:	0a000002 	beq	348087e8 <do_onenand_test+0x230>
			printk("\nRead/Write test failed at 0x%x\n", (u32)ofs);
348087dc:	e1a0100a 	mov	r1, sl
348087e0:	e59f008c 	ldr	r0, [pc, #140]	; 34808874 <do_onenand_test+0x2bc>
348087e4:	eb0003ec 	bl	3480979c <printf>
348087e8:	e1cd22d0 	ldrd	r2, [sp, #32]
		blocks++;
348087ec:	e2899001 	add	r9, r9, #1
348087f0:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
348087f4:	e092200a 	adds	r2, r2, sl
348087f8:	e0a3300b 	adc	r3, r3, fp
348087fc:	e1a0a002 	mov	sl, r2
34808800:	e1a0b003 	mov	fp, r3
34808804:	e1cd22d0 	ldrd	r2, [sp, #32]
34808808:	e0922000 	adds	r2, r2, r0
3480880c:	e0a33001 	adc	r3, r3, r1
34808810:	e1cd22f8 	strd	r2, [sp, #40]	; 0x28
34808814:	eaffffa9 	b	348086c0 <do_onenand_test+0x108>
	printf("...Done\n");
34808818:	e59f0058 	ldr	r0, [pc, #88]	; 34808878 <do_onenand_test+0x2c0>
3480881c:	eb0003de 	bl	3480979c <printf>
	free(buf);
34808820:	e59d0018 	ldr	r0, [sp, #24]
34808824:	eb000521 	bl	34809cb0 <free>
	free(verify_buf);
34808828:	e59d001c 	ldr	r0, [sp, #28]
3480882c:	eb00051f 	bl	34809cb0 <free>
	printf("%s\n", ret ? "ERROR" : "OK");
34808830:	e59f1044 	ldr	r1, [pc, #68]	; 3480887c <do_onenand_test+0x2c4>
34808834:	e59f0044 	ldr	r0, [pc, #68]	; 34808880 <do_onenand_test+0x2c8>
34808838:	eb0003d7 	bl	3480979c <printf>
	return ret == 0 ? 0 : 1;
3480883c:	e59d3014 	ldr	r3, [sp, #20]
34808840:	e2930000 	adds	r0, r3, #0
34808844:	13a00001 	movne	r0, #1
}
34808848:	e28dd088 	add	sp, sp, #136	; 0x88
3480884c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808850:	34824754 	.word	0x34824754
34808854:	34828a38 	.word	0x34828a38
34808858:	34824764 	.word	0x34824764
3480885c:	34822e29 	.word	0x34822e29
34808860:	34824788 	.word	0x34824788
34808864:	348247a2 	.word	0x348247a2
34808868:	348247c3 	.word	0x348247c3
3480886c:	348247da 	.word	0x348247da
34808870:	3482472a 	.word	0x3482472a
34808874:	348247f1 	.word	0x348247f1
34808878:	34824812 	.word	0x34824812
3480887c:	34822e2f 	.word	0x34822e2f
34808880:	34824c10 	.word	0x34824c10

34808884 <do_onenand_write>:
	if (argc < 3)
34808884:	e3520002 	cmp	r2, #2
{
34808888:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		return CMD_RET_USAGE;
3480888c:	d3e09000 	mvnle	r9, #0
{
34808890:	e24dd078 	sub	sp, sp, #120	; 0x78
	if (argc < 3)
34808894:	da0000ba 	ble	34808b84 <do_onenand_write+0x300>
	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808898:	e5930000 	ldr	r0, [r3]
3480889c:	e1a04003 	mov	r4, r3
348088a0:	e1a06002 	mov	r6, r2
348088a4:	e59f12e4 	ldr	r1, [pc, #740]	; 34808b90 <do_onenand_write+0x30c>
348088a8:	e3a02005 	mov	r2, #5
348088ac:	e2800006 	add	r0, r0, #6
348088b0:	eb004be4 	bl	3481b848 <strncmp>
	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
348088b4:	e3a02010 	mov	r2, #16
348088b8:	e3a01000 	mov	r1, #0
	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
348088bc:	e58d0014 	str	r0, [sp, #20]
	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
348088c0:	e5940004 	ldr	r0, [r4, #4]
348088c4:	eb004fa6 	bl	3481c764 <simple_strtoul>
348088c8:	e1a05000 	mov	r5, r0
	printf("\nOneNAND write: ");
348088cc:	e59f02c0 	ldr	r0, [pc, #704]	; 34808b94 <do_onenand_write+0x310>
348088d0:	eb0003b1 	bl	3480979c <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
348088d4:	e28d3050 	add	r3, sp, #80	; 0x50
348088d8:	e28d204c 	add	r2, sp, #76	; 0x4c
348088dc:	e2841008 	add	r1, r4, #8
348088e0:	e2460002 	sub	r0, r6, #2
348088e4:	ebfffe00 	bl	348080ec <arg_off_size>
348088e8:	e2509000 	subs	r9, r0, #0
		return 1;
348088ec:	13a09001 	movne	r9, #1
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
348088f0:	1a0000a3 	bne	34808b84 <do_onenand_write+0x300>
	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
348088f4:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
348088f8:	e3a0b000 	mov	fp, #0
	struct onenand_chip *this = mtd->priv;
348088fc:	e59fc294 	ldr	ip, [pc, #660]	; 34808b98 <do_onenand_write+0x314>
	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808900:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
34808904:	e1a0a003 	mov	sl, r3
	size_t _retlen = 0;
34808908:	e58d9054 	str	r9, [sp, #84]	; 0x54
	struct onenand_chip *this = mtd->priv;
3480890c:	e59c3000 	ldr	r3, [ip]
34808910:	e5933094 	ldr	r3, [r3, #148]	; 0x94
34808914:	e58d3038 	str	r3, [sp, #56]	; 0x38
	int blocks = len >> this->erase_shift;
34808918:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3480891c:	e1a01332 	lsr	r1, r2, r3
34808920:	e58d1028 	str	r1, [sp, #40]	; 0x28
	int blocksize = (1 << this->erase_shift);
34808924:	e3a01001 	mov	r1, #1
34808928:	e1a03311 	lsl	r3, r1, r3
	if (to == next_ofs) {
3480892c:	e1cc00d8 	ldrd	r0, [ip, #8]
	int blocksize = (1 << this->erase_shift);
34808930:	e58d301c 	str	r3, [sp, #28]
34808934:	e3a03000 	mov	r3, #0
	if (to == next_ofs) {
34808938:	e15b0001 	cmp	fp, r1
3480893c:	015a0000 	cmpeq	sl, r0
34808940:	1a00000c 	bne	34808978 <do_onenand_write+0xf4>
		next_ofs = to + len;
34808944:	e092200a 	adds	r2, r2, sl
34808948:	e0a3300b 	adc	r3, r3, fp
3480894c:	e1cc20f8 	strd	r2, [ip, #8]
		to += skip_ofs;
34808950:	e1cc21d0 	ldrd	r2, [ip, #16]
34808954:	e09aa002 	adds	sl, sl, r2
34808958:	e0abb003 	adc	fp, fp, r3
			skip_ofs += blocksize;
3480895c:	e59d201c 	ldr	r2, [sp, #28]
	*retlen = (ret) ? 0 : mtd->erasesize;
34808960:	e3a03000 	mov	r3, #0
34808964:	e58d3018 	str	r3, [sp, #24]
		ret = mtd->block_isbad(mtd, ofs);
34808968:	e59f4228 	ldr	r4, [pc, #552]	; 34808b98 <do_onenand_write+0x314>
			skip_ofs += blocksize;
3480896c:	e1a03fc2 	asr	r3, r2, #31
34808970:	e1cd23f0 	strd	r2, [sp, #48]	; 0x30
34808974:	ea000023 	b	34808a08 <do_onenand_write+0x184>
		next_ofs = to + len;
34808978:	e092200a 	adds	r2, r2, sl
3480897c:	e0a3300b 	adc	r3, r3, fp
34808980:	e1cc20f8 	strd	r2, [ip, #8]
		skip_ofs = 0;
34808984:	e3a02000 	mov	r2, #0
34808988:	e3a03000 	mov	r3, #0
3480898c:	e1cc21f0 	strd	r2, [ip, #16]
34808990:	eafffff1 	b	3480895c <do_onenand_write+0xd8>
		ret = mtd->block_isbad(mtd, ofs);
34808994:	e5940000 	ldr	r0, [r4]
34808998:	e1a0300b 	mov	r3, fp
3480899c:	e1a0200a 	mov	r2, sl
348089a0:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348089a4:	e12fff31 	blx	r1
		if (ret) {
348089a8:	e2503000 	subs	r3, r0, #0
348089ac:	e58d3010 	str	r3, [sp, #16]
348089b0:	0a000018 	beq	34808a18 <do_onenand_write+0x194>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348089b4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
348089b8:	e1a0000a 	mov	r0, sl
348089bc:	e1a0100b 	mov	r1, fp
348089c0:	e5932030 	ldr	r2, [r3, #48]	; 0x30
348089c4:	fa005ae5 	blx	3481f560 <__ashrdi3>
			printk("Bad blocks %d at 0x%x\n",
348089c8:	e1a01000 	mov	r1, r0
348089cc:	e59f01c8 	ldr	r0, [pc, #456]	; 34808b9c <do_onenand_write+0x318>
348089d0:	e1a0200a 	mov	r2, sl
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
348089d4:	eb000370 	bl	3480979c <printf>
			skip_ofs += blocksize;
348089d8:	e1c421d0 	ldrd	r2, [r4, #16]
348089dc:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
348089e0:	e0900002 	adds	r0, r0, r2
348089e4:	e0a11003 	adc	r1, r1, r3
348089e8:	e1a02000 	mov	r2, r0
348089ec:	e1a03001 	mov	r3, r1
348089f0:	e1c421f0 	strd	r2, [r4, #16]
348089f4:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
348089f8:	e092200a 	adds	r2, r2, sl
348089fc:	e0a3300b 	adc	r3, r3, fp
34808a00:	e1a0a002 	mov	sl, r2
34808a04:	e1a0b003 	mov	fp, r3
	while (blocks) {
34808a08:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34808a0c:	e3530000 	cmp	r3, #0
34808a10:	1affffdf 	bne	34808994 <do_onenand_write+0x110>
34808a14:	ea000056 	b	34808b74 <do_onenand_write+0x2f0>
		if (!withoob)
34808a18:	e59d3014 	ldr	r3, [sp, #20]
34808a1c:	e3530000 	cmp	r3, #0
34808a20:	0a00000b 	beq	34808a54 <do_onenand_write+0x1d0>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
34808a24:	e28d3054 	add	r3, sp, #84	; 0x54
34808a28:	e5940000 	ldr	r0, [r4]
34808a2c:	e58d3004 	str	r3, [sp, #4]
34808a30:	e1a0200a 	mov	r2, sl
34808a34:	e59d301c 	ldr	r3, [sp, #28]
34808a38:	e58d5008 	str	r5, [sp, #8]
34808a3c:	e58d3000 	str	r3, [sp]
34808a40:	e1a0300b 	mov	r3, fp
34808a44:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808a48:	e12fff31 	blx	r1
34808a4c:	e58d0010 	str	r0, [sp, #16]
34808a50:	ea000037 	b	34808b34 <do_onenand_write+0x2b0>
	struct mtd_oob_ops ops = {
34808a54:	e28d6058 	add	r6, sp, #88	; 0x58
34808a58:	e3a02020 	mov	r2, #32
34808a5c:	e59d1014 	ldr	r1, [sp, #20]
34808a60:	e1a00006 	mov	r0, r6
34808a64:	eb004c44 	bl	3481bb7c <memset>
34808a68:	e3a03001 	mov	r3, #1
34808a6c:	e1a07005 	mov	r7, r5
34808a70:	e58d3058 	str	r3, [sp, #88]	; 0x58
		.len = mtd->writesize,
34808a74:	e5943000 	ldr	r3, [r4]
	struct mtd_oob_ops ops = {
34808a78:	e1cda2f0 	strd	sl, [sp, #32]
		ret = mtd->write_oob(mtd, to, &ops);
34808a7c:	e58d603c 	str	r6, [sp, #60]	; 0x3c
	struct mtd_oob_ops ops = {
34808a80:	e5932014 	ldr	r2, [r3, #20]
34808a84:	e5933018 	ldr	r3, [r3, #24]
34808a88:	e58d205c 	str	r2, [sp, #92]	; 0x5c
34808a8c:	e58d3064 	str	r3, [sp, #100]	; 0x64
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808a90:	e59d3014 	ldr	r3, [sp, #20]
34808a94:	e58d302c 	str	r3, [sp, #44]	; 0x2c
34808a98:	e5946000 	ldr	r6, [r4]
34808a9c:	e5962010 	ldr	r2, [r6, #16]
34808aa0:	e5963014 	ldr	r3, [r6, #20]
34808aa4:	e1a00002 	mov	r0, r2
34808aa8:	e58d2040 	str	r2, [sp, #64]	; 0x40
34808aac:	e1a01003 	mov	r1, r3
34808ab0:	e58d3044 	str	r3, [sp, #68]	; 0x44
34808ab4:	fa005959 	blx	3481f020 <__udivsi3>
34808ab8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
34808abc:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
34808ac0:	e1530000 	cmp	r3, r0
34808ac4:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34808ac8:	2a000018 	bcs	34808b30 <do_onenand_write+0x2ac>
		ops.datbuf = (u_char *)buf;
34808acc:	e58d7070 	str	r7, [sp, #112]	; 0x70
		buf += mtd->writesize;
34808ad0:	e0877003 	add	r7, r7, r3
		buf += mtd->oobsize;
34808ad4:	e5963018 	ldr	r3, [r6, #24]
		ret = mtd->write_oob(mtd, to, &ops);
34808ad8:	e1a00006 	mov	r0, r6
		ops.oobbuf = (u_char *)buf;
34808adc:	e58d7074 	str	r7, [sp, #116]	; 0x74
		buf += mtd->oobsize;
34808ae0:	e0877003 	add	r7, r7, r3
		ret = mtd->write_oob(mtd, to, &ops);
34808ae4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
34808ae8:	e58d3000 	str	r3, [sp]
34808aec:	e1cd22d0 	ldrd	r2, [sp, #32]
34808af0:	e5961050 	ldr	r1, [r6, #80]	; 0x50
34808af4:	e12fff31 	blx	r1
		if (ret)
34808af8:	e3500000 	cmp	r0, #0
34808afc:	1a000009 	bne	34808b28 <do_onenand_write+0x2a4>
		to += mtd->writesize;
34808b00:	e5943000 	ldr	r3, [r4]
34808b04:	e1cd02d0 	ldrd	r0, [sp, #32]
34808b08:	e5933014 	ldr	r3, [r3, #20]
34808b0c:	e0900003 	adds	r0, r0, r3
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808b10:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
		to += mtd->writesize;
34808b14:	e2a11000 	adc	r1, r1, #0
34808b18:	e1cd02f0 	strd	r0, [sp, #32]
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808b1c:	e2833001 	add	r3, r3, #1
34808b20:	e58d302c 	str	r3, [sp, #44]	; 0x2c
34808b24:	eaffffdb 	b	34808a98 <do_onenand_write+0x214>
	*retlen = (ret) ? 0 : mtd->erasesize;
34808b28:	e3a02000 	mov	r2, #0
		if (ret)
34808b2c:	e58d0010 	str	r0, [sp, #16]
	*retlen = (ret) ? 0 : mtd->erasesize;
34808b30:	e58d2054 	str	r2, [sp, #84]	; 0x54
		if (ret) {
34808b34:	e59d3010 	ldr	r3, [sp, #16]
34808b38:	e3530000 	cmp	r3, #0
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
34808b3c:	11a02003 	movne	r2, r3
34808b40:	11a0100a 	movne	r1, sl
34808b44:	159f0054 	ldrne	r0, [pc, #84]	; 34808ba0 <do_onenand_write+0x31c>
34808b48:	1affffa1 	bne	348089d4 <do_onenand_write+0x150>
		buf += blocksize;
34808b4c:	e59d301c 	ldr	r3, [sp, #28]
		*retlen += _retlen;
34808b50:	e59d2018 	ldr	r2, [sp, #24]
		buf += blocksize;
34808b54:	e0855003 	add	r5, r5, r3
		blocks--;
34808b58:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34808b5c:	e2433001 	sub	r3, r3, #1
34808b60:	e58d3028 	str	r3, [sp, #40]	; 0x28
		*retlen += _retlen;
34808b64:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
34808b68:	e0823003 	add	r3, r2, r3
34808b6c:	e58d3018 	str	r3, [sp, #24]
34808b70:	eaffff9f 	b	348089f4 <do_onenand_write+0x170>
	printf(" %d bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
34808b74:	e59f2028 	ldr	r2, [pc, #40]	; 34808ba4 <do_onenand_write+0x320>
34808b78:	e59d1018 	ldr	r1, [sp, #24]
34808b7c:	e59f0024 	ldr	r0, [pc, #36]	; 34808ba8 <do_onenand_write+0x324>
34808b80:	eb000305 	bl	3480979c <printf>
}
34808b84:	e1a00009 	mov	r0, r9
34808b88:	e28dd078 	add	sp, sp, #120	; 0x78
34808b8c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808b90:	34824a6a 	.word	0x34824a6a
34808b94:	3482481b 	.word	0x3482481b
34808b98:	34828a38 	.word	0x34828a38
34808b9c:	34824713 	.word	0x34824713
34808ba0:	3482482c 	.word	0x3482482c
34808ba4:	34822e2f 	.word	0x34822e2f
34808ba8:	34824842 	.word	0x34824842

34808bac <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
34808bac:	e3a00000 	mov	r0, #0
34808bb0:	e12fff1e 	bx	lr

34808bb4 <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
34808bb4:	e92d4070 	push	{r4, r5, r6, lr}
34808bb8:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
34808bbc:	e59f00a8 	ldr	r0, [pc, #168]	; 34808c6c <source+0xb8>
34808bc0:	eb001117 	bl	3480d024 <getenv_yesno>
34808bc4:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
34808bc8:	e1a00004 	mov	r0, r4
34808bcc:	eb001209 	bl	3480d3f8 <genimg_get_format>
34808bd0:	e3500001 	cmp	r0, #1
34808bd4:	1a00001e 	bne	34808c54 <source+0xa0>
34808bd8:	e5942000 	ldr	r2, [r4]
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808bdc:	e59f308c 	ldr	r3, [pc, #140]	; 34808c70 <source+0xbc>
34808be0:	e1520003 	cmp	r2, r3
			puts ("Bad magic number\n");
34808be4:	159f0088 	ldrne	r0, [pc, #136]	; 34808c74 <source+0xc0>
		if (!image_check_magic (hdr)) {
34808be8:	1a00001a 	bne	34808c58 <source+0xa4>
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
34808bec:	e1a00004 	mov	r0, r4
34808bf0:	eb0010bf 	bl	3480cef4 <image_check_hcrc>
34808bf4:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
34808bf8:	059f0078 	ldreq	r0, [pc, #120]	; 34808c78 <source+0xc4>
		if (!image_check_hcrc (hdr)) {
34808bfc:	0a000015 	beq	34808c58 <source+0xa4>
			return 1;
		}

		if (verify) {
34808c00:	e3550000 	cmp	r5, #0
34808c04:	0a000004 	beq	34808c1c <source+0x68>
			if (!image_check_dcrc (hdr)) {
34808c08:	e1a00004 	mov	r0, r4
34808c0c:	eb0010cc 	bl	3480cf44 <image_check_dcrc>
34808c10:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
34808c14:	059f0060 	ldreq	r0, [pc, #96]	; 34808c7c <source+0xc8>
			if (!image_check_dcrc (hdr)) {
34808c18:	0a00000e 	beq	34808c58 <source+0xa4>
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
34808c1c:	e5d4301e 	ldrb	r3, [r4, #30]
34808c20:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
34808c24:	159f0054 	ldrne	r0, [pc, #84]	; 34808c80 <source+0xcc>
		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
34808c28:	1a00000a 	bne	34808c58 <source+0xa4>
34808c2c:	e5941040 	ldr	r1, [r4, #64]	; 0x40
	return ((ulong)hdr + image_get_header_size());
34808c30:	e2840040 	add	r0, r4, #64	; 0x40
34808c34:	e6bf1f31 	rev	r1, r1
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
34808c38:	e3510000 	cmp	r1, #0
			puts ("Empty Script\n");
34808c3c:	059f0040 	ldreq	r0, [pc, #64]	; 34808c84 <source+0xd0>
		if ((len = uimage_to_cpu (*data)) == 0) {
34808c40:	0a000004 	beq	34808c58 <source+0xa4>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
34808c44:	e4902004 	ldr	r2, [r0], #4
34808c48:	e3520000 	cmp	r2, #0
34808c4c:	1afffffc 	bne	34808c44 <source+0x90>
34808c50:	ea000003 	b	34808c64 <source+0xb0>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808c54:	e59f002c 	ldr	r0, [pc, #44]	; 34808c88 <source+0xd4>
34808c58:	eb0002c3 	bl	3480976c <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
34808c5c:	e3a00001 	mov	r0, #1
34808c60:	e8bd8070 	pop	{r4, r5, r6, pc}
34808c64:	e8bd4070 	pop	{r4, r5, r6, lr}
	return run_command_list((char *)data, len, 0);
34808c68:	ea001590 	b	3480e2b0 <run_command_list>
34808c6c:	34821d0e 	.word	0x34821d0e
34808c70:	56190527 	.word	0x56190527
34808c74:	34824aa0 	.word	0x34824aa0
34808c78:	34824ab2 	.word	0x34824ab2
34808c7c:	34824ac2 	.word	0x34824ac2
34808c80:	34824ad0 	.word	0x34824ad0
34808c84:	34824ae0 	.word	0x34824ae0
34808c88:	34824aee 	.word	0x34824aee

34808c8c <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808c8c:	e3520001 	cmp	r2, #1
{
34808c90:	e92d4010 	push	{r4, lr}
		addr = CONFIG_SYS_LOAD_ADDR;
34808c94:	d3a04309 	movle	r4, #603979776	; 0x24000000
	if (argc < 2) {
34808c98:	da000004 	ble	34808cb0 <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
34808c9c:	e3a02010 	mov	r2, #16
34808ca0:	e3a01000 	mov	r1, #0
34808ca4:	e5930004 	ldr	r0, [r3, #4]
34808ca8:	eb004ead 	bl	3481c764 <simple_strtoul>
34808cac:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
34808cb0:	e1a01004 	mov	r1, r4
34808cb4:	e59f0010 	ldr	r0, [pc, #16]	; 34808ccc <do_source+0x40>
34808cb8:	eb0002b7 	bl	3480979c <printf>
	rcode = source (addr, fit_uname);
34808cbc:	e1a00004 	mov	r0, r4
34808cc0:	e3a01000 	mov	r1, #0
	return rcode;
}
34808cc4:	e8bd4010 	pop	{r4, lr}
	rcode = source (addr, fit_uname);
34808cc8:	eaffffb9 	b	34808bb4 <source>
34808ccc:	34824b17 	.word	0x34824b17

34808cd0 <do_false>:
);

int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
34808cd0:	e3a00001 	mov	r0, #1
34808cd4:	e12fff1e 	bx	lr

34808cd8 <do_true>:
);

int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
34808cd8:	e3a00000 	mov	r0, #0
34808cdc:	e12fff1e 	bx	lr

34808ce0 <do_test>:
	if (argc < 3)
34808ce0:	e3520002 	cmp	r2, #2
34808ce4:	da000024 	ble	34808d7c <do_test+0x9c>
{
34808ce8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34808cec:	e1a04003 	mov	r4, r3
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34808cf0:	e59f140c 	ldr	r1, [pc, #1036]	; 34809104 <do_test+0x424>
34808cf4:	e1a07002 	mov	r7, r2
	last_cmp = -1;
34808cf8:	e3e06000 	mvn	r6, #0
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34808cfc:	e5930004 	ldr	r0, [r3, #4]
	expr = -1;
34808d00:	e1a05006 	mov	r5, r6
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34808d04:	eb004ac5 	bl	3481b820 <strcmp>
34808d08:	e3500000 	cmp	r0, #0
	last_expr = -1;
34808d0c:	e1a09006 	mov	r9, r6
	left = argc - 1; ap = argv + 1;
34808d10:	12477001 	subne	r7, r7, #1
34808d14:	12844004 	addne	r4, r4, #4
		neg = 0;
34808d18:	13a0a000 	movne	sl, #0
		ap++;
34808d1c:	02844008 	addeq	r4, r4, #8
		left--;
34808d20:	02477002 	subeq	r7, r7, #2
		neg = 1;
34808d24:	03a0a001 	moveq	sl, #1
		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
34808d28:	e59f13d8 	ldr	r1, [pc, #984]	; 34809108 <do_test+0x428>
34808d2c:	e5940000 	ldr	r0, [r4]
34808d30:	eb004aba 	bl	3481b820 <strcmp>
34808d34:	e3500000 	cmp	r0, #0
34808d38:	0a000011 	beq	34808d84 <do_test+0xa4>
34808d3c:	e59f13c8 	ldr	r1, [pc, #968]	; 3480910c <do_test+0x42c>
34808d40:	e5940000 	ldr	r0, [r4]
34808d44:	eb004ab5 	bl	3481b820 <strcmp>
34808d48:	e3500000 	cmp	r0, #0
34808d4c:	0a00000c 	beq	34808d84 <do_test+0xa4>
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34808d50:	e59f13b8 	ldr	r1, [pc, #952]	; 34809110 <do_test+0x430>
34808d54:	e5940000 	ldr	r0, [r4]
34808d58:	eb004ab0 	bl	3481b820 <strcmp>
34808d5c:	e3500000 	cmp	r0, #0
34808d60:	0a000035 	beq	34808e3c <do_test+0x15c>
34808d64:	e59f13a8 	ldr	r1, [pc, #936]	; 34809114 <do_test+0x434>
34808d68:	e5940000 	ldr	r0, [r4]
34808d6c:	eb004aab 	bl	3481b820 <strcmp>
34808d70:	e3500000 	cmp	r0, #0
34808d74:	0a000030 	beq	34808e3c <do_test+0x15c>
34808d78:	ea00000e 	b	34808db8 <do_test+0xd8>
		return 1;
34808d7c:	e3a00001 	mov	r0, #1
}
34808d80:	e12fff1e 	bx	lr
			if (strcmp(ap[0], "-o") == 0) {
34808d84:	e59f137c 	ldr	r1, [pc, #892]	; 34809108 <do_test+0x428>
34808d88:	e5940000 	ldr	r0, [r4]
34808d8c:	eb004aa3 	bl	3481b820 <strcmp>
34808d90:	e3500000 	cmp	r0, #0
				last_cmp = 0;
34808d94:	01a06000 	moveq	r6, r0
			if (strcmp(ap[0], "-o") == 0) {
34808d98:	0a000024 	beq	34808e30 <do_test+0x150>
			} else if (strcmp(ap[0], "-a") == 0) {
34808d9c:	e59f1368 	ldr	r1, [pc, #872]	; 3480910c <do_test+0x42c>
34808da0:	e5940000 	ldr	r0, [r4]
34808da4:	eb004a9d 	bl	3481b820 <strcmp>
34808da8:	e3500000 	cmp	r0, #0
34808dac:	0a00001e 	beq	34808e2c <do_test+0x14c>
				expr = 1;
34808db0:	e3a05001 	mov	r5, #1
34808db4:	ea000016 	b	34808e14 <do_test+0x134>
		if (left < adv) {
34808db8:	e3570002 	cmp	r7, #2
34808dbc:	dafffffb 	ble	34808db0 <do_test+0xd0>
			if (strcmp(ap[1], "=") == 0)
34808dc0:	e59f1350 	ldr	r1, [pc, #848]	; 34809118 <do_test+0x438>
34808dc4:	e5940004 	ldr	r0, [r4, #4]
34808dc8:	eb004a94 	bl	3481b820 <strcmp>
34808dcc:	e3500000 	cmp	r0, #0
34808dd0:	1a00003b 	bne	34808ec4 <do_test+0x1e4>
				expr = strcmp(ap[0], ap[2]) == 0;
34808dd4:	e5941008 	ldr	r1, [r4, #8]
34808dd8:	e5940000 	ldr	r0, [r4]
34808ddc:	eb004a8f 	bl	3481b820 <strcmp>
34808de0:	e16f5f10 	clz	r5, r0
34808de4:	e1a052a5 	lsr	r5, r5, #5
			if (last_cmp == 0)
34808de8:	e3560000 	cmp	r6, #0
34808dec:	1a0000be 	bne	348090ec <do_test+0x40c>
				expr = last_expr || expr;
34808df0:	e1953009 	orrs	r3, r5, r9
34808df4:	13a05001 	movne	r5, #1
34808df8:	03a05000 	moveq	r5, #0
			else if (last_cmp == 1)
34808dfc:	e3a03003 	mov	r3, #3
			last_cmp = -1;
34808e00:	e3e06000 	mvn	r6, #0
		ap += adv; left -= adv;
34808e04:	e0637007 	rsb	r7, r3, r7
34808e08:	e0844103 	add	r4, r4, r3, lsl #2
	while (left > 0) {
34808e0c:	e3570000 	cmp	r7, #0
34808e10:	caffffc4 	bgt	34808d28 <do_test+0x48>
	if (neg)
34808e14:	e35a0000 	cmp	sl, #0
		expr = !expr;
34808e18:	116f5f15 	clzne	r5, r5
34808e1c:	11a052a5 	lsrne	r5, r5, #5
	expr = !expr;
34808e20:	e16f0f15 	clz	r0, r5
34808e24:	e1a002a0 	lsr	r0, r0, #5
34808e28:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
				last_cmp = 1;
34808e2c:	e3a06001 	mov	r6, #1
			last_cmp = -1;
34808e30:	e1a09005 	mov	r9, r5
34808e34:	e3a03001 	mov	r3, #1
34808e38:	eafffff1 	b	34808e04 <do_test+0x124>
		if (left < adv) {
34808e3c:	e3570001 	cmp	r7, #1
34808e40:	0affffda 	beq	34808db0 <do_test+0xd0>
			if (strcmp(ap[0], "-z") == 0)
34808e44:	e59f12c4 	ldr	r1, [pc, #708]	; 34809110 <do_test+0x430>
34808e48:	e5940000 	ldr	r0, [r4]
34808e4c:	eb004a73 	bl	3481b820 <strcmp>
34808e50:	e3500000 	cmp	r0, #0
34808e54:	1a000004 	bne	34808e6c <do_test+0x18c>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
34808e58:	e5940004 	ldr	r0, [r4, #4]
34808e5c:	eb004a9d 	bl	3481b8d8 <strlen>
34808e60:	e16f5f10 	clz	r5, r0
34808e64:	e1a052a5 	lsr	r5, r5, #5
34808e68:	ea000008 	b	34808e90 <do_test+0x1b0>
			else if (strcmp(ap[0], "-n") == 0)
34808e6c:	e59f12a0 	ldr	r1, [pc, #672]	; 34809114 <do_test+0x434>
34808e70:	e5940000 	ldr	r0, [r4]
34808e74:	eb004a69 	bl	3481b820 <strcmp>
34808e78:	e3500000 	cmp	r0, #0
34808e7c:	1affffcb 	bne	34808db0 <do_test+0xd0>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
34808e80:	e5940004 	ldr	r0, [r4, #4]
34808e84:	eb004a93 	bl	3481b8d8 <strlen>
34808e88:	e2905000 	adds	r5, r0, #0
34808e8c:	13a05001 	movne	r5, #1
			if (last_cmp == 0)
34808e90:	e3560000 	cmp	r6, #0
34808e94:	1a000003 	bne	34808ea8 <do_test+0x1c8>
				expr = last_expr || expr;
34808e98:	e1953009 	orrs	r3, r5, r9
34808e9c:	13a05001 	movne	r5, #1
34808ea0:	03a05000 	moveq	r5, #0
34808ea4:	ea000004 	b	34808ebc <do_test+0x1dc>
			else if (last_cmp == 1)
34808ea8:	e3560001 	cmp	r6, #1
34808eac:	1a000002 	bne	34808ebc <do_test+0x1dc>
				expr = last_expr && expr;
34808eb0:	e3590000 	cmp	r9, #0
34808eb4:	03a05000 	moveq	r5, #0
34808eb8:	12055001 	andne	r5, r5, #1
	last_expr = -1;
34808ebc:	e3a03002 	mov	r3, #2
34808ec0:	eaffffce 	b	34808e00 <do_test+0x120>
			else if (strcmp(ap[1], "!=") == 0)
34808ec4:	e59f1250 	ldr	r1, [pc, #592]	; 3480911c <do_test+0x43c>
34808ec8:	e5940004 	ldr	r0, [r4, #4]
34808ecc:	eb004a53 	bl	3481b820 <strcmp>
34808ed0:	e3500000 	cmp	r0, #0
34808ed4:	1a000005 	bne	34808ef0 <do_test+0x210>
				expr = strcmp(ap[0], ap[2]) != 0;
34808ed8:	e5941008 	ldr	r1, [r4, #8]
34808edc:	e5940000 	ldr	r0, [r4]
34808ee0:	eb004a4e 	bl	3481b820 <strcmp>
34808ee4:	e2905000 	adds	r5, r0, #0
34808ee8:	13a05001 	movne	r5, #1
34808eec:	eaffffbd 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], ">") == 0)
34808ef0:	e59f1228 	ldr	r1, [pc, #552]	; 34809120 <do_test+0x440>
34808ef4:	e5940004 	ldr	r0, [r4, #4]
34808ef8:	eb004a48 	bl	3481b820 <strcmp>
34808efc:	e3500000 	cmp	r0, #0
34808f00:	1a000004 	bne	34808f18 <do_test+0x238>
				expr = strcmp(ap[0], ap[2]) > 0;
34808f04:	e5941008 	ldr	r1, [r4, #8]
34808f08:	e5940000 	ldr	r0, [r4]
34808f0c:	eb004a43 	bl	3481b820 <strcmp>
34808f10:	e3500000 	cmp	r0, #0
34808f14:	ea00005f 	b	34809098 <do_test+0x3b8>
			else if (strcmp(ap[1], "<") == 0)
34808f18:	e59f1204 	ldr	r1, [pc, #516]	; 34809124 <do_test+0x444>
34808f1c:	e5940004 	ldr	r0, [r4, #4]
34808f20:	eb004a3e 	bl	3481b820 <strcmp>
34808f24:	e3500000 	cmp	r0, #0
34808f28:	1a000004 	bne	34808f40 <do_test+0x260>
				expr = strcmp(ap[0], ap[2]) < 0;
34808f2c:	e5941008 	ldr	r1, [r4, #8]
34808f30:	e5940000 	ldr	r0, [r4]
34808f34:	eb004a39 	bl	3481b820 <strcmp>
34808f38:	e1a05fa0 	lsr	r5, r0, #31
34808f3c:	eaffffa9 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-eq") == 0)
34808f40:	e59f11e0 	ldr	r1, [pc, #480]	; 34809128 <do_test+0x448>
34808f44:	e5940004 	ldr	r0, [r4, #4]
34808f48:	eb004a34 	bl	3481b820 <strcmp>
34808f4c:	e3500000 	cmp	r0, #0
34808f50:	1a00000c 	bne	34808f88 <do_test+0x2a8>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
34808f54:	e3a0200a 	mov	r2, #10
34808f58:	e3a01000 	mov	r1, #0
34808f5c:	e5940000 	ldr	r0, [r4]
34808f60:	eb004e4b 	bl	3481c894 <simple_strtol>
34808f64:	e3a0200a 	mov	r2, #10
34808f68:	e1a05000 	mov	r5, r0
34808f6c:	e3a01000 	mov	r1, #0
34808f70:	e5940008 	ldr	r0, [r4, #8]
34808f74:	eb004e46 	bl	3481c894 <simple_strtol>
34808f78:	e0605005 	rsb	r5, r0, r5
34808f7c:	e16f5f15 	clz	r5, r5
34808f80:	e1a052a5 	lsr	r5, r5, #5
34808f84:	eaffff97 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-ne") == 0)
34808f88:	e59f119c 	ldr	r1, [pc, #412]	; 3480912c <do_test+0x44c>
34808f8c:	e5940004 	ldr	r0, [r4, #4]
34808f90:	eb004a22 	bl	3481b820 <strcmp>
34808f94:	e250b000 	subs	fp, r0, #0
34808f98:	1a00000b 	bne	34808fcc <do_test+0x2ec>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
34808f9c:	e3a0200a 	mov	r2, #10
34808fa0:	e1a0100b 	mov	r1, fp
34808fa4:	e5940000 	ldr	r0, [r4]
34808fa8:	eb004e39 	bl	3481c894 <simple_strtol>
34808fac:	e3a0200a 	mov	r2, #10
34808fb0:	e1a05000 	mov	r5, r0
34808fb4:	e1a0100b 	mov	r1, fp
34808fb8:	e5940008 	ldr	r0, [r4, #8]
34808fbc:	eb004e34 	bl	3481c894 <simple_strtol>
34808fc0:	e0555000 	subs	r5, r5, r0
34808fc4:	13a05001 	movne	r5, #1
34808fc8:	eaffff86 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-lt") == 0)
34808fcc:	e59f115c 	ldr	r1, [pc, #348]	; 34809130 <do_test+0x450>
34808fd0:	e5940004 	ldr	r0, [r4, #4]
34808fd4:	eb004a11 	bl	3481b820 <strcmp>
34808fd8:	e250b000 	subs	fp, r0, #0
34808fdc:	1a00000c 	bne	34809014 <do_test+0x334>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
34808fe0:	e3a0200a 	mov	r2, #10
34808fe4:	e1a0100b 	mov	r1, fp
34808fe8:	e5940000 	ldr	r0, [r4]
34808fec:	eb004e28 	bl	3481c894 <simple_strtol>
34808ff0:	e3a0200a 	mov	r2, #10
34808ff4:	e1a05000 	mov	r5, r0
34808ff8:	e1a0100b 	mov	r1, fp
34808ffc:	e5940008 	ldr	r0, [r4, #8]
34809000:	eb004e23 	bl	3481c894 <simple_strtol>
34809004:	e1550000 	cmp	r5, r0
34809008:	a3a05000 	movge	r5, #0
3480900c:	b3a05001 	movlt	r5, #1
34809010:	eaffff74 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-le") == 0)
34809014:	e59f1118 	ldr	r1, [pc, #280]	; 34809134 <do_test+0x454>
34809018:	e5940004 	ldr	r0, [r4, #4]
3480901c:	eb0049ff 	bl	3481b820 <strcmp>
34809020:	e250b000 	subs	fp, r0, #0
34809024:	1a00000c 	bne	3480905c <do_test+0x37c>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
34809028:	e3a0200a 	mov	r2, #10
3480902c:	e1a0100b 	mov	r1, fp
34809030:	e5940000 	ldr	r0, [r4]
34809034:	eb004e16 	bl	3481c894 <simple_strtol>
34809038:	e3a0200a 	mov	r2, #10
3480903c:	e1a05000 	mov	r5, r0
34809040:	e1a0100b 	mov	r1, fp
34809044:	e5940008 	ldr	r0, [r4, #8]
34809048:	eb004e11 	bl	3481c894 <simple_strtol>
3480904c:	e1550000 	cmp	r5, r0
34809050:	c3a05000 	movgt	r5, #0
34809054:	d3a05001 	movle	r5, #1
34809058:	eaffff62 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-gt") == 0)
3480905c:	e59f10d4 	ldr	r1, [pc, #212]	; 34809138 <do_test+0x458>
34809060:	e5940004 	ldr	r0, [r4, #4]
34809064:	eb0049ed 	bl	3481b820 <strcmp>
34809068:	e250b000 	subs	fp, r0, #0
3480906c:	1a00000c 	bne	348090a4 <do_test+0x3c4>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
34809070:	e3a0200a 	mov	r2, #10
34809074:	e1a0100b 	mov	r1, fp
34809078:	e5940000 	ldr	r0, [r4]
3480907c:	eb004e04 	bl	3481c894 <simple_strtol>
34809080:	e3a0200a 	mov	r2, #10
34809084:	e1a05000 	mov	r5, r0
34809088:	e1a0100b 	mov	r1, fp
3480908c:	e5940008 	ldr	r0, [r4, #8]
34809090:	eb004dff 	bl	3481c894 <simple_strtol>
34809094:	e1550000 	cmp	r5, r0
34809098:	d3a05000 	movle	r5, #0
3480909c:	c3a05001 	movgt	r5, #1
348090a0:	eaffff50 	b	34808de8 <do_test+0x108>
			else if (strcmp(ap[1], "-ge") == 0)
348090a4:	e59f1090 	ldr	r1, [pc, #144]	; 3480913c <do_test+0x45c>
348090a8:	e5940004 	ldr	r0, [r4, #4]
348090ac:	eb0049db 	bl	3481b820 <strcmp>
348090b0:	e250b000 	subs	fp, r0, #0
348090b4:	1affff3d 	bne	34808db0 <do_test+0xd0>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
348090b8:	e3a0200a 	mov	r2, #10
348090bc:	e1a0100b 	mov	r1, fp
348090c0:	e5940000 	ldr	r0, [r4]
348090c4:	eb004df2 	bl	3481c894 <simple_strtol>
348090c8:	e3a0200a 	mov	r2, #10
348090cc:	e1a05000 	mov	r5, r0
348090d0:	e1a0100b 	mov	r1, fp
348090d4:	e5940008 	ldr	r0, [r4, #8]
348090d8:	eb004ded 	bl	3481c894 <simple_strtol>
348090dc:	e1550000 	cmp	r5, r0
348090e0:	b3a05000 	movlt	r5, #0
348090e4:	a3a05001 	movge	r5, #1
348090e8:	eaffff3e 	b	34808de8 <do_test+0x108>
			else if (last_cmp == 1)
348090ec:	e3560001 	cmp	r6, #1
348090f0:	1affff41 	bne	34808dfc <do_test+0x11c>
				expr = last_expr && expr;
348090f4:	e3590000 	cmp	r9, #0
348090f8:	03a05000 	moveq	r5, #0
348090fc:	12055001 	andne	r5, r5, #1
34809100:	eaffff3d 	b	34808dfc <do_test+0x11c>
34809104:	34825e7d 	.word	0x34825e7d
34809108:	34824ba1 	.word	0x34824ba1
3480910c:	34824ba4 	.word	0x34824ba4
34809110:	34824ba7 	.word	0x34824ba7
34809114:	34824baa 	.word	0x34824baa
34809118:	348226d6 	.word	0x348226d6
3480911c:	348226d5 	.word	0x348226d5
34809120:	348226d9 	.word	0x348226d9
34809124:	348226c4 	.word	0x348226c4
34809128:	348226ca 	.word	0x348226ca
3480912c:	348226d1 	.word	0x348226d1
34809130:	348226c0 	.word	0x348226c0
34809134:	348226e2 	.word	0x348226e2
34809138:	348226c6 	.word	0x348226c6
3480913c:	348226db 	.word	0x348226db

34809140 <do_version>:
#include <linux/compiler.h>

const char __weak version_string[] = U_BOOT_VERSION_STRING;

int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34809140:	e92d4010 	push	{r4, lr}
	printf("\n%s\n", version_string);
34809144:	e59f101c 	ldr	r1, [pc, #28]	; 34809168 <do_version+0x28>
34809148:	e59f001c 	ldr	r0, [pc, #28]	; 3480916c <do_version+0x2c>
3480914c:	eb000192 	bl	3480979c <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
34809150:	e59f0018 	ldr	r0, [pc, #24]	; 34809170 <do_version+0x30>
34809154:	eb000184 	bl	3480976c <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
34809158:	e59f0014 	ldr	r0, [pc, #20]	; 34809174 <do_version+0x34>
3480915c:	eb000182 	bl	3480976c <puts>
#endif

	return 0;
}
34809160:	e3a00000 	mov	r0, #0
34809164:	e8bd8010 	pop	{r4, pc}
34809168:	3481f76c 	.word	0x3481f76c
3480916c:	34824c0f 	.word	0x34824c0f
34809170:	34824c14 	.word	0x34824c14
34809174:	34824c4c 	.word	0x34824c4c

34809178 <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
34809178:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
3480917c:	e2509000 	subs	r9, r0, #0
34809180:	1a000001 	bne	3480918c <find_cmd_tbl+0x14>
		return NULL;
34809184:	e3a00000 	mov	r0, #0
34809188:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480918c:	e1a04001 	mov	r4, r1
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
34809190:	e3a0102e 	mov	r1, #46	; 0x2e
34809194:	e1a06002 	mov	r6, r2
34809198:	eb0049b9 	bl	3481b884 <strchr>
3480919c:	e3500000 	cmp	r0, #0
348091a0:	10695000 	rsbne	r5, r9, r0
348091a4:	1a000002 	bne	348091b4 <find_cmd_tbl+0x3c>
348091a8:	e1a00009 	mov	r0, r9
348091ac:	eb0049c9 	bl	3481b8d8 <strlen>
348091b0:	e1a05000 	mov	r5, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
348091b4:	e3a07018 	mov	r7, #24
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
348091b8:	e1a0a004 	mov	sl, r4
	     cmdtp != table + table_len;
348091bc:	e0274697 	mla	r7, r7, r6, r4
	int n_found = 0;
348091c0:	e3a06000 	mov	r6, #0
	for (cmdtp = table;
348091c4:	e1540007 	cmp	r4, r7
348091c8:	0a00000d 	beq	34809204 <find_cmd_tbl+0x8c>
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
348091cc:	e1a02005 	mov	r2, r5
348091d0:	e5941000 	ldr	r1, [r4]
348091d4:	e1a00009 	mov	r0, r9
348091d8:	eb00499a 	bl	3481b848 <strncmp>
348091dc:	e3500000 	cmp	r0, #0
348091e0:	1a000005 	bne	348091fc <find_cmd_tbl+0x84>
			if (len == strlen (cmdtp->name))
348091e4:	e5940000 	ldr	r0, [r4]
348091e8:	eb0049ba 	bl	3481b8d8 <strlen>
348091ec:	e1550000 	cmp	r5, r0
348091f0:	0a000007 	beq	34809214 <find_cmd_tbl+0x9c>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
348091f4:	e2866001 	add	r6, r6, #1
348091f8:	e1a0a004 	mov	sl, r4
	     cmdtp++) {
348091fc:	e2844018 	add	r4, r4, #24
34809200:	eaffffef 	b	348091c4 <find_cmd_tbl+0x4c>
		}
	}
	if (n_found == 1) {			/* exactly one match */
34809204:	e3560001 	cmp	r6, #1
34809208:	1affffdd 	bne	34809184 <find_cmd_tbl+0xc>
3480920c:	e1a0000a 	mov	r0, sl
34809210:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809214:	e1a00004 	mov	r0, r4
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
}
34809218:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480921c <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
3480921c:	e59f1014 	ldr	r1, [pc, #20]	; 34809238 <find_cmd+0x1c>
34809220:	e59f3014 	ldr	r3, [pc, #20]	; 3480923c <find_cmd+0x20>
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809224:	e59f2014 	ldr	r2, [pc, #20]	; 34809240 <find_cmd+0x24>
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34809228:	e0613003 	rsb	r3, r1, r3
3480922c:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809230:	e0020392 	mul	r2, r2, r3
34809234:	eaffffcf 	b	34809178 <find_cmd_tbl>
34809238:	34828180 	.word	0x34828180
3480923c:	348285d0 	.word	0x348285d0
34809240:	aaaaaaab 	.word	0xaaaaaaab

34809244 <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
34809244:	e92d4010 	push	{r4, lr}
34809248:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
3480924c:	e5902010 	ldr	r2, [r0, #16]
34809250:	e5901000 	ldr	r1, [r0]
34809254:	e59f0038 	ldr	r0, [pc, #56]	; 34809294 <cmd_usage+0x50>
34809258:	eb00014f 	bl	3480979c <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
3480925c:	e5941000 	ldr	r1, [r4]
34809260:	e59f0030 	ldr	r0, [pc, #48]	; 34809298 <cmd_usage+0x54>
34809264:	eb00014c 	bl	3480979c <printf>

	if (!cmdtp->help) {
34809268:	e5940014 	ldr	r0, [r4, #20]
3480926c:	e3500000 	cmp	r0, #0
34809270:	1a000002 	bne	34809280 <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
34809274:	e59f0020 	ldr	r0, [pc, #32]	; 3480929c <cmd_usage+0x58>
34809278:	eb00013b 	bl	3480976c <puts>
		return 1;
3480927c:	ea000002 	b	3480928c <cmd_usage+0x48>
	}

	puts (cmdtp->help);
34809280:	eb000139 	bl	3480976c <puts>
	putc ('\n');
34809284:	e3a0000a 	mov	r0, #10
34809288:	eb00012b 	bl	3480973c <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
3480928c:	e3a00001 	mov	r0, #1
34809290:	e8bd8010 	pop	{r4, pc}
34809294:	34824c9e 	.word	0x34824c9e
34809298:	34824ca8 	.word	0x34824ca8
3480929c:	34824cb3 	.word	0x34824cb3

348092a0 <_do_help>:
{
348092a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348092a4:	e28db01c 	add	fp, sp, #28
348092a8:	e24dd010 	sub	sp, sp, #16
348092ac:	e1a06000 	mov	r6, r0
348092b0:	e1a04001 	mov	r4, r1
348092b4:	e59ba004 	ldr	sl, [fp, #4]
	if (argc == 1) {	/*show list of commands */
348092b8:	e35a0001 	cmp	sl, #1
348092bc:	159b9008 	ldrne	r9, [fp, #8]
348092c0:	13a05000 	movne	r5, #0
348092c4:	13a07001 	movne	r7, #1
348092c8:	1a000045 	bne	348093e4 <_do_help+0x144>
		cmd_tbl_t *cmd_array[cmd_items];
348092cc:	e1a03101 	lsl	r3, r1, #2
348092d0:	e50bd020 	str	sp, [fp, #-32]	; 0xffffffe0
348092d4:	e3a01018 	mov	r1, #24
348092d8:	e283300a 	add	r3, r3, #10
348092dc:	e3c33007 	bic	r3, r3, #7
348092e0:	e04dd003 	sub	sp, sp, r3
		for (i = 0; i < cmd_items; i++) {
348092e4:	e3a03000 	mov	r3, #0
		cmd_tbl_t *cmd_array[cmd_items];
348092e8:	e1a0900d 	mov	r9, sp
		for (i = 0; i < cmd_items; i++) {
348092ec:	e1530004 	cmp	r3, r4
348092f0:	e0226391 	mla	r2, r1, r3, r6
			cmd_array[i] = cmdtp++;
348092f4:	b7892103 	strlt	r2, [r9, r3, lsl #2]
		for (i = 0; i < cmd_items; i++) {
348092f8:	b2833001 	addlt	r3, r3, #1
348092fc:	bafffffa 	blt	348092ec <_do_help+0x4c>
		for (i = cmd_items - 1; i > 0; --i) {
34809300:	e2447001 	sub	r7, r4, #1
34809304:	e3570000 	cmp	r7, #0
34809308:	ca000001 	bgt	34809314 <_do_help+0x74>
3480930c:	e3a05000 	mov	r5, #0
34809310:	ea000023 	b	348093a4 <_do_help+0x104>
34809314:	e3a06000 	mov	r6, #0
34809318:	e1a05009 	mov	r5, r9
3480931c:	e1a0a006 	mov	sl, r6
				if (strcmp (cmd_array[j]->name,
34809320:	e5953000 	ldr	r3, [r5]
					    cmd_array[j + 1]->name) > 0) {
34809324:	e28aa001 	add	sl, sl, #1
34809328:	e5b52004 	ldr	r2, [r5, #4]!
				if (strcmp (cmd_array[j]->name,
3480932c:	e5930000 	ldr	r0, [r3]
34809330:	e5921000 	ldr	r1, [r2]
34809334:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
34809338:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
3480933c:	eb004937 	bl	3481b820 <strcmp>
34809340:	e3500000 	cmp	r0, #0
					cmd_array[j] = cmd_array[j + 1];
34809344:	c51b2028 	ldrgt	r2, [fp, #-40]	; 0xffffffd8
					++swaps;
34809348:	c2866001 	addgt	r6, r6, #1
					cmd_array[j + 1] = tmp;
3480934c:	c51b3024 	ldrgt	r3, [fp, #-36]	; 0xffffffdc
					cmd_array[j] = cmd_array[j + 1];
34809350:	c5052004 	strgt	r2, [r5, #-4]
					cmd_array[j + 1] = tmp;
34809354:	c5853000 	strgt	r3, [r5]
			for (j = 0; j < i; ++j) {
34809358:	e15a0007 	cmp	sl, r7
3480935c:	1affffef 	bne	34809320 <_do_help+0x80>
			if (!swaps)
34809360:	e3560000 	cmp	r6, #0
34809364:	0affffe8 	beq	3480930c <_do_help+0x6c>
		for (i = cmd_items - 1; i > 0; --i) {
34809368:	e2477001 	sub	r7, r7, #1
3480936c:	eaffffe4 	b	34809304 <_do_help+0x64>
			const char *usage = cmd_array[i]->usage;
34809370:	e7996105 	ldr	r6, [r9, r5, lsl #2]
34809374:	e5967010 	ldr	r7, [r6, #16]
			if (ctrlc ())
34809378:	eb000129 	bl	34809824 <ctrlc>
3480937c:	e3500000 	cmp	r0, #0
34809380:	1a00000b 	bne	348093b4 <_do_help+0x114>
			if (usage == NULL)
34809384:	e3570000 	cmp	r7, #0
34809388:	0a000004 	beq	348093a0 <_do_help+0x100>
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
3480938c:	e1a03007 	mov	r3, r7
34809390:	e5962000 	ldr	r2, [r6]
34809394:	e3a01008 	mov	r1, #8
34809398:	e59f0070 	ldr	r0, [pc, #112]	; 34809410 <_do_help+0x170>
3480939c:	eb0000fe 	bl	3480979c <printf>
		for (i = 0; i < cmd_items; i++) {
348093a0:	e2855001 	add	r5, r5, #1
348093a4:	e1550004 	cmp	r5, r4
348093a8:	bafffff0 	blt	34809370 <_do_help+0xd0>
		return 0;
348093ac:	e3a00000 	mov	r0, #0
348093b0:	ea000000 	b	348093b8 <_do_help+0x118>
				return 1;
348093b4:	e3a00001 	mov	r0, #1
348093b8:	e51bd020 	ldr	sp, [fp, #-32]	; 0xffffffe0
348093bc:	ea000011 	b	34809408 <_do_help+0x168>
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
348093c0:	e1a02004 	mov	r2, r4
348093c4:	e1a01006 	mov	r1, r6
348093c8:	e5b90004 	ldr	r0, [r9, #4]!
348093cc:	ebffff69 	bl	34809178 <find_cmd_tbl>
348093d0:	e3500000 	cmp	r0, #0
348093d4:	0a000005 	beq	348093f0 <_do_help+0x150>
			rcode |= cmd_usage(cmdtp);
348093d8:	ebffff99 	bl	34809244 <cmd_usage>
348093dc:	e1855000 	orr	r5, r5, r0
	for (i = 1; i < argc; ++i) {
348093e0:	e2877001 	add	r7, r7, #1
348093e4:	e157000a 	cmp	r7, sl
348093e8:	bafffff4 	blt	348093c0 <_do_help+0x120>
348093ec:	ea000004 	b	34809404 <_do_help+0x164>
			printf ("Unknown command '%s' - try 'help'"
348093f0:	e5991000 	ldr	r1, [r9]
			rcode = 1;
348093f4:	e3a05001 	mov	r5, #1
			printf ("Unknown command '%s' - try 'help'"
348093f8:	e59f0014 	ldr	r0, [pc, #20]	; 34809414 <_do_help+0x174>
348093fc:	eb0000e6 	bl	3480979c <printf>
34809400:	eafffff6 	b	348093e0 <_do_help+0x140>
	return rcode;
34809404:	e1a00005 	mov	r0, r5
}
34809408:	e24bd01c 	sub	sp, fp, #28
3480940c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809410:	34824cd4 	.word	0x34824cd4
34809414:	34824cde 	.word	0x34824cde

34809418 <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
34809418:	e92d4070 	push	{r4, r5, r6, lr}
3480941c:	e1a05000 	mov	r5, r0
34809420:	e1a04001 	mov	r4, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
34809424:	eb00492b 	bl	3481b8d8 <strlen>
	if (len > 2 && arg[len-2] == '.') {
34809428:	e3500002 	cmp	r0, #2
3480942c:	da00000b 	ble	34809460 <cmd_get_data_size+0x48>
34809430:	e0850000 	add	r0, r5, r0
34809434:	e5503002 	ldrb	r3, [r0, #-2]
34809438:	e353002e 	cmp	r3, #46	; 0x2e
3480943c:	1a000007 	bne	34809460 <cmd_get_data_size+0x48>
34809440:	e5503001 	ldrb	r3, [r0, #-1]
34809444:	e2433062 	sub	r3, r3, #98	; 0x62
34809448:	e6ef3073 	uxtb	r3, r3
3480944c:	e3530015 	cmp	r3, #21
34809450:	8a000004 	bhi	34809468 <cmd_get_data_size+0x50>
34809454:	e59f2014 	ldr	r2, [pc, #20]	; 34809470 <cmd_get_data_size+0x58>
34809458:	e19200d3 	ldrsb	r0, [r2, r3]
3480945c:	e8bd8070 	pop	{r4, r5, r6, pc}
			return -2;
		default:
			return -1;
		}
	}
	return default_size;
34809460:	e1a00004 	mov	r0, r4
34809464:	e8bd8070 	pop	{r4, r5, r6, pc}
		switch(arg[len-1]) {
34809468:	e3e00000 	mvn	r0, #0
}
3480946c:	e8bd8070 	pop	{r4, r5, r6, pc}
34809470:	3481f794 	.word	0x3481f794

34809474 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34809474:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34809478:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
3480947c:	e5920000 	ldr	r0, [r2]
{
34809480:	e1a0a001 	mov	sl, r1
34809484:	e1a06002 	mov	r6, r2
34809488:	e1a07003 	mov	r7, r3
	cmdtp = find_cmd(argv[0]);
3480948c:	ebffff62 	bl	3480921c <find_cmd>
	if (cmdtp == NULL) {
34809490:	e2504000 	subs	r4, r0, #0
34809494:	1a000003 	bne	348094a8 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
34809498:	e5961000 	ldr	r1, [r6]
3480949c:	e59f0078 	ldr	r0, [pc, #120]	; 3480951c <cmd_process+0xa8>
348094a0:	eb0000bd 	bl	3480979c <printf>
348094a4:	ea00000b 	b	348094d8 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
348094a8:	e5943004 	ldr	r3, [r4, #4]
348094ac:	e15a0003 	cmp	sl, r3
348094b0:	ca00000a 	bgt	348094e0 <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
348094b4:	e594900c 	ldr	r9, [r4, #12]
348094b8:	e59f3060 	ldr	r3, [pc, #96]	; 34809520 <cmd_process+0xac>
348094bc:	e1590003 	cmp	r9, r3
348094c0:	1a000009 	bne	348094ec <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
348094c4:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
348094c8:	03855002 	orreq	r5, r5, #2
		if (flag & CMD_FLAG_BOOTD) {
348094cc:	0a000006 	beq	348094ec <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
348094d0:	e59f004c 	ldr	r0, [pc, #76]	; 34809524 <cmd_process+0xb0>
348094d4:	eb0000a4 	bl	3480976c <puts>
			rc = CMD_RET_FAILURE;
348094d8:	e3a00001 	mov	r0, #1
348094dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
348094e0:	e1a00004 	mov	r0, r4
	return rc;
}
348094e4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
		rc = cmd_usage(cmdtp);
348094e8:	eaffff55 	b	34809244 <cmd_usage>
	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
348094ec:	e1a03006 	mov	r3, r6
348094f0:	e1a0200a 	mov	r2, sl
348094f4:	e1a01005 	mov	r1, r5
348094f8:	e1a00004 	mov	r0, r4
348094fc:	e12fff39 	blx	r9
		*repeatable &= cmdtp->repeatable;
34809500:	e5972000 	ldr	r2, [r7]
	if (rc == CMD_RET_USAGE)
34809504:	e3700001 	cmn	r0, #1
		*repeatable &= cmdtp->repeatable;
34809508:	e5943008 	ldr	r3, [r4, #8]
3480950c:	e0033002 	and	r3, r3, r2
34809510:	e5873000 	str	r3, [r7]
	if (rc == CMD_RET_USAGE)
34809514:	0afffff1 	beq	348094e0 <cmd_process+0x6c>
}
34809518:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480951c:	34824d33 	.word	0x34824d33
34809520:	34802214 	.word	0x34802214
34809524:	34824d56 	.word	0x34824d56

34809528 <console_setfile>:

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
34809528:	e3510000 	cmp	r1, #0
3480952c:	0a000022 	beq	348095bc <console_setfile+0x94>
		return -1;

	switch (file) {
34809530:	e3500002 	cmp	r0, #2
34809534:	8a000020 	bhi	348095bc <console_setfile+0x94>
{
34809538:	e92d4070 	push	{r4, r5, r6, lr}
3480953c:	e1a04000 	mov	r4, r0
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
34809540:	e5910018 	ldr	r0, [r1, #24]
34809544:	e1a05001 	mov	r5, r1
34809548:	e3500000 	cmp	r0, #0
3480954c:	0a000002 	beq	3480955c <console_setfile+0x34>
			error = dev->start();
34809550:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
34809554:	e3500000 	cmp	r0, #0
34809558:	b8bd8070 	poplt	{r4, r5, r6, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
3480955c:	e59f3060 	ldr	r3, [pc, #96]	; 348095c4 <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34809560:	e3540000 	cmp	r4, #0
		stdio_devices[file] = dev;
34809564:	e7835104 	str	r5, [r3, r4, lsl #2]
		switch (file) {
34809568:	0a000002 	beq	34809578 <console_setfile+0x50>
3480956c:	e3540001 	cmp	r4, #1
34809570:	0a000007 	beq	34809594 <console_setfile+0x6c>
34809574:	e8bd8070 	pop	{r4, r5, r6, pc}
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34809578:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480957c:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
34809580:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
34809584:	e5983054 	ldr	r3, [r8, #84]	; 0x54
34809588:	e5952028 	ldr	r2, [r5, #40]	; 0x28
3480958c:	e5832008 	str	r2, [r3, #8]
			break;
34809590:	e8bd8070 	pop	{r4, r5, r6, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
34809594:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809598:	e5951020 	ldr	r1, [r5, #32]
3480959c:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
348095a0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348095a4:	e5951024 	ldr	r1, [r5, #36]	; 0x24
348095a8:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
348095ac:	e59f2014 	ldr	r2, [pc, #20]	; 348095c8 <console_setfile+0xa0>
348095b0:	e5983054 	ldr	r3, [r8, #84]	; 0x54
348095b4:	e5832014 	str	r2, [r3, #20]
			break;
348095b8:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
348095bc:	e3e00000 	mvn	r0, #0
348095c0:	e12fff1e 	bx	lr
348095c4:	3482a29c 	.word	0x3482a29c
348095c8:	3480979c 	.word	0x3480979c

348095cc <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
348095cc:	e92d000f 	push	{r0, r1, r2, r3}
348095d0:	e92d4010 	push	{r4, lr}
348095d4:	e24ddf62 	sub	sp, sp, #392	; 0x188
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
348095d8:	e28d2f65 	add	r2, sp, #404	; 0x194

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348095dc:	e28d0008 	add	r0, sp, #8
348095e0:	e59d1190 	ldr	r1, [sp, #400]	; 0x190
	va_start(args, fmt);
348095e4:	e58d2004 	str	r2, [sp, #4]
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348095e8:	eb004d05 	bl	3481ca04 <vsprintf>
348095ec:	e1a04000 	mov	r4, r0
	va_end(args);

	serial_puts(printbuffer);
348095f0:	e28d0008 	add	r0, sp, #8
348095f4:	eb001513 	bl	3480ea48 <serial_puts>
	return i;
}
348095f8:	e1a00004 	mov	r0, r4
348095fc:	e28ddf62 	add	sp, sp, #392	; 0x188
34809600:	e8bd4010 	pop	{r4, lr}
34809604:	e28dd010 	add	sp, sp, #16
34809608:	e12fff1e 	bx	lr

3480960c <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
3480960c:	e3500002 	cmp	r0, #2
34809610:	ca000003 	bgt	34809624 <fgetc+0x18>
	return stdio_devices[file]->getc();
34809614:	e59f3010 	ldr	r3, [pc, #16]	; 3480962c <fgetc+0x20>
34809618:	e7933100 	ldr	r3, [r3, r0, lsl #2]
3480961c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34809620:	e12fff13 	bx	r3
		return console_getc(file);
#endif
	}

	return -1;
}
34809624:	e3e00000 	mvn	r0, #0
34809628:	e12fff1e 	bx	lr
3480962c:	3482a29c 	.word	0x3482a29c

34809630 <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
34809630:	e3500002 	cmp	r0, #2
34809634:	ca000003 	bgt	34809648 <ftstc+0x18>
	return stdio_devices[file]->tstc();
34809638:	e59f3010 	ldr	r3, [pc, #16]	; 34809650 <ftstc+0x20>
3480963c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34809640:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34809644:	e12fff13 	bx	r3
		return console_tstc(file);

	return -1;
}
34809648:	e3e00000 	mvn	r0, #0
3480964c:	e12fff1e 	bx	lr
34809650:	3482a29c 	.word	0x3482a29c

34809654 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
34809654:	e3500002 	cmp	r0, #2
34809658:	c12fff1e 	bxgt	lr
	stdio_devices[file]->putc(c);
3480965c:	e59f200c 	ldr	r2, [pc, #12]	; 34809670 <fputc+0x1c>
34809660:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34809664:	e1a00001 	mov	r0, r1
34809668:	e5933020 	ldr	r3, [r3, #32]
3480966c:	e12fff13 	bx	r3
34809670:	3482a29c 	.word	0x3482a29c

34809674 <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
34809674:	e3500002 	cmp	r0, #2
34809678:	c12fff1e 	bxgt	lr
	stdio_devices[file]->puts(s);
3480967c:	e59f200c 	ldr	r2, [pc, #12]	; 34809690 <fputs+0x1c>
34809680:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34809684:	e1a00001 	mov	r0, r1
34809688:	e5933024 	ldr	r3, [r3, #36]	; 0x24
3480968c:	e12fff13 	bx	r3
34809690:	3482a29c 	.word	0x3482a29c

34809694 <fprintf>:
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34809694:	e92d000e 	push	{r1, r2, r3}
34809698:	e92d4030 	push	{r4, r5, lr}
3480969c:	e24ddf62 	sub	sp, sp, #392	; 0x188
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
348096a0:	e28d2f66 	add	r2, sp, #408	; 0x198
{
348096a4:	e1a05000 	mov	r5, r0

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348096a8:	e28d0008 	add	r0, sp, #8
348096ac:	e59d1194 	ldr	r1, [sp, #404]	; 0x194
	va_start(args, fmt);
348096b0:	e58d2004 	str	r2, [sp, #4]
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348096b4:	eb004cd2 	bl	3481ca04 <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
348096b8:	e28d1008 	add	r1, sp, #8
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348096bc:	e1a04000 	mov	r4, r0
	fputs(file, printbuffer);
348096c0:	e1a00005 	mov	r0, r5
348096c4:	ebffffea 	bl	34809674 <fputs>
	return i;
}
348096c8:	e1a00004 	mov	r0, r4
348096cc:	e28ddf62 	add	sp, sp, #392	; 0x188
348096d0:	e8bd4030 	pop	{r4, r5, lr}
348096d4:	e28dd00c 	add	sp, sp, #12
348096d8:	e12fff1e 	bx	lr

348096dc <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
348096dc:	e598000c 	ldr	r0, [r8, #12]
348096e0:	e3500000 	cmp	r0, #0
348096e4:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
348096e8:	e5983004 	ldr	r3, [r8, #4]
348096ec:	e3130002 	tst	r3, #2
348096f0:	0a000003 	beq	34809704 <getc+0x28>
	return stdio_devices[file]->getc();
348096f4:	e59f300c 	ldr	r3, [pc, #12]	; 34809708 <getc+0x2c>
348096f8:	e5933000 	ldr	r3, [r3]
348096fc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34809700:	e12fff13 	bx	r3
		/* Get from the standard input */
		return fgetc(stdin);
	}

	/* Send directly to the handler */
	return serial_getc();
34809704:	ea0014be 	b	3480ea04 <serial_getc>
34809708:	3482a29c 	.word	0x3482a29c

3480970c <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
3480970c:	e598000c 	ldr	r0, [r8, #12]
34809710:	e3500000 	cmp	r0, #0
34809714:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34809718:	e5983004 	ldr	r3, [r8, #4]
3480971c:	e3130002 	tst	r3, #2
34809720:	0a000003 	beq	34809734 <tstc+0x28>
	return stdio_devices[file]->tstc();
34809724:	e59f300c 	ldr	r3, [pc, #12]	; 34809738 <tstc+0x2c>
34809728:	e5933000 	ldr	r3, [r3]
3480972c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34809730:	e12fff13 	bx	r3
		/* Test the standard input */
		return ftstc(stdin);
	}

	/* Send directly to the handler */
	return serial_tstc();
34809734:	ea0014b7 	b	3480ea18 <serial_tstc>
34809738:	3482a29c 	.word	0x3482a29c

3480973c <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
3480973c:	e598200c 	ldr	r2, [r8, #12]
34809740:	e3520000 	cmp	r2, #0
34809744:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
34809748:	e5983004 	ldr	r3, [r8, #4]
3480974c:	e3130002 	tst	r3, #2
34809750:	0a000003 	beq	34809764 <putc+0x28>
	stdio_devices[file]->putc(c);
34809754:	e59f300c 	ldr	r3, [pc, #12]	; 34809768 <putc+0x2c>
34809758:	e5933004 	ldr	r3, [r3, #4]
3480975c:	e5933020 	ldr	r3, [r3, #32]
34809760:	e12fff13 	bx	r3
		/* Send to the standard output */
		fputc(stdout, c);
	} else {
		/* Send directly to the handler */
		serial_putc(c);
34809764:	ea0014b0 	b	3480ea2c <serial_putc>
34809768:	3482a29c 	.word	0x3482a29c

3480976c <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
3480976c:	e598200c 	ldr	r2, [r8, #12]
34809770:	e3520000 	cmp	r2, #0
34809774:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
34809778:	e5983004 	ldr	r3, [r8, #4]
3480977c:	e3130002 	tst	r3, #2
34809780:	0a000003 	beq	34809794 <puts+0x28>
	stdio_devices[file]->puts(s);
34809784:	e59f300c 	ldr	r3, [pc, #12]	; 34809798 <puts+0x2c>
34809788:	e5933004 	ldr	r3, [r3, #4]
3480978c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
34809790:	e12fff13 	bx	r3
		/* Send to the standard output */
		fputs(stdout, s);
	} else {
		/* Send directly to the handler */
		serial_puts(s);
34809794:	ea0014ab 	b	3480ea48 <serial_puts>
34809798:	3482a29c 	.word	0x3482a29c

3480979c <printf>:
	}
}

int printf(const char *fmt, ...)
{
3480979c:	e92d000f 	push	{r0, r1, r2, r3}
348097a0:	e92d4010 	push	{r4, lr}
348097a4:	e24ddf62 	sub	sp, sp, #392	; 0x188
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
348097a8:	e598400c 	ldr	r4, [r8, #12]
348097ac:	e3540000 	cmp	r4, #0
348097b0:	0a000007 	beq	348097d4 <printf+0x38>
		return 0;
#endif

	va_start(args, fmt);
348097b4:	e28d2f65 	add	r2, sp, #404	; 0x194

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348097b8:	e59d1190 	ldr	r1, [sp, #400]	; 0x190
348097bc:	e28d0008 	add	r0, sp, #8
	va_start(args, fmt);
348097c0:	e58d2004 	str	r2, [sp, #4]
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348097c4:	eb004c8e 	bl	3481ca04 <vsprintf>
348097c8:	e1a04000 	mov	r4, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
348097cc:	e28d0008 	add	r0, sp, #8
348097d0:	ebffffe5 	bl	3480976c <puts>
	return i;
}
348097d4:	e1a00004 	mov	r0, r4
348097d8:	e28ddf62 	add	sp, sp, #392	; 0x188
348097dc:	e8bd4010 	pop	{r4, lr}
348097e0:	e28dd010 	add	sp, sp, #16
348097e4:	e12fff1e 	bx	lr

348097e8 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
348097e8:	e92d4010 	push	{r4, lr}
348097ec:	e24ddd06 	sub	sp, sp, #384	; 0x180
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
348097f0:	e598400c 	ldr	r4, [r8, #12]
348097f4:	e3540000 	cmp	r4, #0
348097f8:	0a000006 	beq	34809818 <vprintf+0x30>
348097fc:	e1a02001 	mov	r2, r1
34809800:	e1a01000 	mov	r1, r0
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809804:	e1a0000d 	mov	r0, sp
34809808:	eb004c7d 	bl	3481ca04 <vsprintf>
3480980c:	e1a04000 	mov	r4, r0

	/* Print the string */
	puts(printbuffer);
34809810:	e1a0000d 	mov	r0, sp
34809814:	ebffffd4 	bl	3480976c <puts>
	return i;
}
34809818:	e1a00004 	mov	r0, r4
3480981c:	e28ddd06 	add	sp, sp, #384	; 0x180
34809820:	e8bd8010 	pop	{r4, pc}

34809824 <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
34809824:	e92d4070 	push	{r4, r5, r6, lr}
	if (!ctrlc_disabled && gd->have_console) {
34809828:	e59f5040 	ldr	r5, [pc, #64]	; 34809870 <ctrlc+0x4c>
3480982c:	e5954000 	ldr	r4, [r5]
34809830:	e3540000 	cmp	r4, #0
34809834:	0a000001 	beq	34809840 <ctrlc+0x1c>
			default:
				break;
			}
		}
	}
	return 0;
34809838:	e3a04000 	mov	r4, #0
3480983c:	ea000009 	b	34809868 <ctrlc+0x44>
	if (!ctrlc_disabled && gd->have_console) {
34809840:	e598300c 	ldr	r3, [r8, #12]
34809844:	e3530000 	cmp	r3, #0
34809848:	0afffffa 	beq	34809838 <ctrlc+0x14>
		if (tstc()) {
3480984c:	ebffffae 	bl	3480970c <tstc>
34809850:	e3500000 	cmp	r0, #0
34809854:	0afffff7 	beq	34809838 <ctrlc+0x14>
			switch (getc()) {
34809858:	ebffff9f 	bl	348096dc <getc>
3480985c:	e3500003 	cmp	r0, #3
				ctrlc_was_pressed = 1;
34809860:	03a04001 	moveq	r4, #1
34809864:	05854004 	streq	r4, [r5, #4]
}
34809868:	e1a00004 	mov	r0, r4
3480986c:	e8bd8070 	pop	{r4, r5, r6, pc}
34809870:	34828a50 	.word	0x34828a50

34809874 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
34809874:	e59f300c 	ldr	r3, [pc, #12]	; 34809888 <disable_ctrlc+0x14>
34809878:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
3480987c:	e5830000 	str	r0, [r3]
	return prev;
}
34809880:	e1a00002 	mov	r0, r2
34809884:	e12fff1e 	bx	lr
34809888:	34828a50 	.word	0x34828a50

3480988c <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
3480988c:	e59f3004 	ldr	r3, [pc, #4]	; 34809898 <had_ctrlc+0xc>
34809890:	e5930004 	ldr	r0, [r3, #4]
34809894:	e12fff1e 	bx	lr
34809898:	34828a50 	.word	0x34828a50

3480989c <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
3480989c:	e59f3008 	ldr	r3, [pc, #8]	; 348098ac <clear_ctrlc+0x10>
348098a0:	e3a02000 	mov	r2, #0
348098a4:	e5832004 	str	r2, [r3, #4]
348098a8:	e12fff1e 	bx	lr
348098ac:	34828a50 	.word	0x34828a50

348098b0 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
348098b0:	e92d000f 	push	{r0, r1, r2, r3}
}
348098b4:	e28dd010 	add	sp, sp, #16
348098b8:	e12fff1e 	bx	lr

348098bc <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
348098bc:	e92d4010 	push	{r4, lr}
348098c0:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
348098c4:	e1a00001 	mov	r0, r1
348098c8:	eb001468 	bl	3480ea70 <stdio_get_by_name>

	if (dev && (dev->flags & flags))
348098cc:	e3500000 	cmp	r0, #0
348098d0:	08bd8010 	popeq	{r4, pc}
348098d4:	e5903000 	ldr	r3, [r0]
348098d8:	e1140003 	tst	r4, r3
348098dc:	03a00000 	moveq	r0, #0
		return dev;

	return NULL;
}
348098e0:	e8bd8010 	pop	{r4, pc}

348098e4 <console_assign>:
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
348098e4:	e2503000 	subs	r3, r0, #0
{
348098e8:	e92d4010 	push	{r4, lr}
	switch (file) {
348098ec:	0a000004 	beq	34809904 <console_assign+0x20>
348098f0:	ba00000b 	blt	34809924 <console_assign+0x40>
348098f4:	e3530002 	cmp	r3, #2
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
348098f8:	d3a00002 	movle	r0, #2
	switch (file) {
348098fc:	da000001 	ble	34809908 <console_assign+0x24>
34809900:	ea000007 	b	34809924 <console_assign+0x40>
		flag = DEV_FLAGS_INPUT;
34809904:	e3a00001 	mov	r0, #1
34809908:	e1a04003 	mov	r4, r3
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
3480990c:	ebffffea 	bl	348098bc <search_device>

	if (dev)
34809910:	e2501000 	subs	r1, r0, #0
34809914:	0a000002 	beq	34809924 <console_assign+0x40>
		return console_setfile(file, dev);
34809918:	e1a00004 	mov	r0, r4

	return -1;
}
3480991c:	e8bd4010 	pop	{r4, lr}
		return console_setfile(file, dev);
34809920:	eaffff00 	b	34809528 <console_setfile>
}
34809924:	e3e00000 	mvn	r0, #0
34809928:	e8bd8010 	pop	{r4, pc}

3480992c <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
3480992c:	e3a02001 	mov	r2, #1
#endif

	print_pre_console_buffer();

	return 0;
}
34809930:	e3a00000 	mov	r0, #0
	gd->have_console = 1;
34809934:	e588200c 	str	r2, [r8, #12]
}
34809938:	e12fff1e 	bx	lr

3480993c <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
3480993c:	e92d4010 	push	{r4, lr}
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	/* Print information */
	puts("In:    ");
	if (stdio_devices[stdin] == NULL) {
34809940:	e59f4084 	ldr	r4, [pc, #132]	; 348099cc <stdio_print_current_devices+0x90>
	puts("In:    ");
34809944:	e59f0084 	ldr	r0, [pc, #132]	; 348099d0 <stdio_print_current_devices+0x94>
34809948:	ebffff87 	bl	3480976c <puts>
	if (stdio_devices[stdin] == NULL) {
3480994c:	e5941000 	ldr	r1, [r4]
34809950:	e3510000 	cmp	r1, #0
34809954:	1a000002 	bne	34809964 <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
34809958:	e59f0074 	ldr	r0, [pc, #116]	; 348099d4 <stdio_print_current_devices+0x98>
3480995c:	ebffff82 	bl	3480976c <puts>
34809960:	ea000002 	b	34809970 <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
34809964:	e2811008 	add	r1, r1, #8
34809968:	e59f0068 	ldr	r0, [pc, #104]	; 348099d8 <stdio_print_current_devices+0x9c>
3480996c:	ebffff8a 	bl	3480979c <printf>
	}

	puts("Out:   ");
34809970:	e59f0064 	ldr	r0, [pc, #100]	; 348099dc <stdio_print_current_devices+0xa0>
34809974:	ebffff7c 	bl	3480976c <puts>
	if (stdio_devices[stdout] == NULL) {
34809978:	e5941004 	ldr	r1, [r4, #4]
3480997c:	e3510000 	cmp	r1, #0
34809980:	1a000002 	bne	34809990 <stdio_print_current_devices+0x54>
		puts("No output devices available!\n");
34809984:	e59f0054 	ldr	r0, [pc, #84]	; 348099e0 <stdio_print_current_devices+0xa4>
34809988:	ebffff77 	bl	3480976c <puts>
3480998c:	ea000002 	b	3480999c <stdio_print_current_devices+0x60>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
34809990:	e2811008 	add	r1, r1, #8
34809994:	e59f003c 	ldr	r0, [pc, #60]	; 348099d8 <stdio_print_current_devices+0x9c>
34809998:	ebffff7f 	bl	3480979c <printf>
	}

	puts("Err:   ");
3480999c:	e59f0040 	ldr	r0, [pc, #64]	; 348099e4 <stdio_print_current_devices+0xa8>
348099a0:	ebffff71 	bl	3480976c <puts>
	if (stdio_devices[stderr] == NULL) {
348099a4:	e5941008 	ldr	r1, [r4, #8]
348099a8:	e3510000 	cmp	r1, #0
348099ac:	1a000002 	bne	348099bc <stdio_print_current_devices+0x80>
		puts("No error devices available!\n");
348099b0:	e59f0030 	ldr	r0, [pc, #48]	; 348099e8 <stdio_print_current_devices+0xac>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
348099b4:	e8bd4010 	pop	{r4, lr}
		puts("No error devices available!\n");
348099b8:	eaffff6b 	b	3480976c <puts>
		printf ("%s\n", stdio_devices[stderr]->name);
348099bc:	e2811008 	add	r1, r1, #8
348099c0:	e59f0010 	ldr	r0, [pc, #16]	; 348099d8 <stdio_print_current_devices+0x9c>
}
348099c4:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stderr]->name);
348099c8:	eaffff73 	b	3480979c <printf>
348099cc:	3482a29c 	.word	0x3482a29c
348099d0:	34824d72 	.word	0x34824d72
348099d4:	34824d7a 	.word	0x34824d7a
348099d8:	34824c10 	.word	0x34824c10
348099dc:	34824d97 	.word	0x34824d97
348099e0:	34824d9f 	.word	0x34824d9f
348099e4:	34824dbd 	.word	0x34824dbd
348099e8:	34824dc5 	.word	0x34824dc5

348099ec <console_init_r>:
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
348099ec:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348099f0:	e59f1150 	ldr	r1, [pc, #336]	; 34809b48 <console_init_r+0x15c>
{
348099f4:	e92d4070 	push	{r4, r5, r6, lr}
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
348099f8:	e59f014c 	ldr	r0, [pc, #332]	; 34809b4c <console_init_r+0x160>
	gd->jt[XF_getc] = serial_getc;
348099fc:	e5821004 	str	r1, [r2, #4]
	gd->jt[XF_tstc] = serial_tstc;
34809a00:	e59f1148 	ldr	r1, [pc, #328]	; 34809b50 <console_init_r+0x164>
34809a04:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809a08:	e5821008 	str	r1, [r2, #8]
	gd->jt[XF_putc] = serial_putc;
34809a0c:	e59f1140 	ldr	r1, [pc, #320]	; 34809b54 <console_init_r+0x168>
34809a10:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809a14:	e582100c 	str	r1, [r2, #12]
	gd->jt[XF_puts] = serial_puts;
34809a18:	e59f1138 	ldr	r1, [pc, #312]	; 34809b58 <console_init_r+0x16c>
34809a1c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809a20:	e5821010 	str	r1, [r2, #16]
	gd->jt[XF_printf] = serial_printf;
34809a24:	e59f2130 	ldr	r2, [pc, #304]	; 34809b5c <console_init_r+0x170>
34809a28:	e5983054 	ldr	r3, [r8, #84]	; 0x54
34809a2c:	e5832014 	str	r2, [r3, #20]
	stdinname  = getenv("stdin");
34809a30:	ebfff853 	bl	34807b84 <getenv>
34809a34:	e1a06000 	mov	r6, r0
	stdoutname = getenv("stdout");
34809a38:	e59f0120 	ldr	r0, [pc, #288]	; 34809b60 <console_init_r+0x174>
34809a3c:	ebfff850 	bl	34807b84 <getenv>
34809a40:	e1a05000 	mov	r5, r0
	stderrname = getenv("stderr");
34809a44:	e59f0118 	ldr	r0, [pc, #280]	; 34809b64 <console_init_r+0x178>
34809a48:	ebfff84d 	bl	34807b84 <getenv>

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809a4c:	e1a01006 	mov	r1, r6
	stderrname = getenv("stderr");
34809a50:	e1a04000 	mov	r4, r0
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809a54:	e3a00001 	mov	r0, #1
34809a58:	ebffff97 	bl	348098bc <search_device>
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809a5c:	e1a01005 	mov	r1, r5
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809a60:	e1a06000 	mov	r6, r0
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809a64:	e3a00002 	mov	r0, #2
34809a68:	ebffff93 	bl	348098bc <search_device>
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809a6c:	e1a01004 	mov	r1, r4
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809a70:	e1a05000 	mov	r5, r0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809a74:	e3a00002 	mov	r0, #2
34809a78:	ebffff8f 	bl	348098bc <search_device>
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809a7c:	e3560000 	cmp	r6, #0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809a80:	e1a04000 	mov	r4, r0
	if (inputdev == NULL) {
34809a84:	1a000003 	bne	34809a98 <console_init_r+0xac>
		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
34809a88:	e59f10d8 	ldr	r1, [pc, #216]	; 34809b68 <console_init_r+0x17c>
34809a8c:	e3a00001 	mov	r0, #1
34809a90:	ebffff89 	bl	348098bc <search_device>
34809a94:	e1a06000 	mov	r6, r0
	}
	if (outputdev == NULL) {
34809a98:	e3550000 	cmp	r5, #0
34809a9c:	1a00001c 	bne	34809b14 <console_init_r+0x128>
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809aa0:	e59f10c0 	ldr	r1, [pc, #192]	; 34809b68 <console_init_r+0x17c>
34809aa4:	e3a00002 	mov	r0, #2
34809aa8:	ebffff83 	bl	348098bc <search_device>
	}
	if (errdev == NULL) {
34809aac:	e3540000 	cmp	r4, #0
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809ab0:	e1a05000 	mov	r5, r0
	if (errdev == NULL) {
34809ab4:	1a000013 	bne	34809b08 <console_init_r+0x11c>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809ab8:	e59f10a8 	ldr	r1, [pc, #168]	; 34809b68 <console_init_r+0x17c>
34809abc:	e3a00002 	mov	r0, #2
34809ac0:	ebffff7d 	bl	348098bc <search_device>
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
34809ac4:	e3550000 	cmp	r5, #0
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809ac8:	e1a04000 	mov	r4, r0
	if (outputdev != NULL) {
34809acc:	0a000002 	beq	34809adc <console_init_r+0xf0>
	console_setfile(file, dev);
34809ad0:	e1a01005 	mov	r1, r5
34809ad4:	e3a00001 	mov	r0, #1
34809ad8:	ebfffe92 	bl	34809528 <console_setfile>
		/* need to set a console if not done above. */
		console_doenv(stdout, outputdev);
	}
	if (errdev != NULL) {
34809adc:	e3540000 	cmp	r4, #0
34809ae0:	0a000002 	beq	34809af0 <console_init_r+0x104>
	console_setfile(file, dev);
34809ae4:	e1a01004 	mov	r1, r4
34809ae8:	e3a00002 	mov	r0, #2
34809aec:	ebfffe8d 	bl	34809528 <console_setfile>
		/* need to set a console if not done above. */
		console_doenv(stderr, errdev);
	}
	if (inputdev != NULL) {
34809af0:	e3560000 	cmp	r6, #0
34809af4:	0a00000d 	beq	34809b30 <console_init_r+0x144>
	console_setfile(file, dev);
34809af8:	e1a01006 	mov	r1, r6
34809afc:	e3a00000 	mov	r0, #0
34809b00:	ebfffe88 	bl	34809528 <console_setfile>
34809b04:	ea000009 	b	34809b30 <console_init_r+0x144>
	if (outputdev != NULL) {
34809b08:	e3500000 	cmp	r0, #0
34809b0c:	0afffff4 	beq	34809ae4 <console_init_r+0xf8>
34809b10:	eaffffee 	b	34809ad0 <console_init_r+0xe4>
	if (errdev == NULL) {
34809b14:	e3540000 	cmp	r4, #0
34809b18:	1affffec 	bne	34809ad0 <console_init_r+0xe4>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809b1c:	e59f1044 	ldr	r1, [pc, #68]	; 34809b68 <console_init_r+0x17c>
34809b20:	e3a00002 	mov	r0, #2
34809b24:	ebffff64 	bl	348098bc <search_device>
34809b28:	e1a04000 	mov	r4, r0
34809b2c:	eaffffe7 	b	34809ad0 <console_init_r+0xe4>

#ifdef CONFIG_CONSOLE_MUX
done:
#endif

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
34809b30:	e5983004 	ldr	r3, [r8, #4]
34809b34:	e3833002 	orr	r3, r3, #2
34809b38:	e5883004 	str	r3, [r8, #4]

	stdio_print_current_devices();
34809b3c:	ebffff7e 	bl	3480993c <stdio_print_current_devices>
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif
	return 0;
}
34809b40:	e3a00000 	mov	r0, #0
34809b44:	e8bd8070 	pop	{r4, r5, r6, pc}
34809b48:	3480ea04 	.word	0x3480ea04
34809b4c:	34823fd1 	.word	0x34823fd1
34809b50:	3480ea18 	.word	0x3480ea18
34809b54:	3480ea2c 	.word	0x3480ea2c
34809b58:	3480ea48 	.word	0x3480ea48
34809b5c:	348095cc 	.word	0x348095cc
34809b60:	34823fd7 	.word	0x34823fd7
34809b64:	34823fde 	.word	0x34823fde
34809b68:	34824de2 	.word	0x34824de2

34809b6c <sbrk>:
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
34809b6c:	e59f3054 	ldr	r3, [pc, #84]	; 34809bc8 <sbrk+0x5c>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809b70:	e3500000 	cmp	r0, #0
{
34809b74:	e92d4070 	push	{r4, r5, r6, lr}
34809b78:	e1a06003 	mov	r6, r3
	ulong old = mem_malloc_brk;
34809b7c:	e5934000 	ldr	r4, [r3]
	ulong new = old + increment;
34809b80:	e0805004 	add	r5, r0, r4
	if (increment < 0)
34809b84:	aa000003 	bge	34809b98 <sbrk+0x2c>
		memset((void *)new, 0, -increment);
34809b88:	e2602000 	rsb	r2, r0, #0
34809b8c:	e3a01000 	mov	r1, #0
34809b90:	e1a00005 	mov	r0, r5
34809b94:	eb0047f8 	bl	3481bb7c <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809b98:	e5962004 	ldr	r2, [r6, #4]
34809b9c:	e59f3024 	ldr	r3, [pc, #36]	; 34809bc8 <sbrk+0x5c>
34809ba0:	e1550002 	cmp	r5, r2
34809ba4:	3a000005 	bcc	34809bc0 <sbrk+0x54>
34809ba8:	e5932008 	ldr	r2, [r3, #8]
34809bac:	e1550002 	cmp	r5, r2
34809bb0:	8a000002 	bhi	34809bc0 <sbrk+0x54>
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
34809bb4:	e5835000 	str	r5, [r3]

	return (void *)old;
34809bb8:	e1a00004 	mov	r0, r4
34809bbc:	e8bd8070 	pop	{r4, r5, r6, pc}
		return (void *)MORECORE_FAILURE;
34809bc0:	e3e00000 	mvn	r0, #0
}
34809bc4:	e8bd8070 	pop	{r4, r5, r6, pc}
34809bc8:	34828a58 	.word	0x34828a58

34809bcc <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
34809bcc:	e59f3018 	ldr	r3, [pc, #24]	; 34809bec <mem_malloc_init+0x20>
{
34809bd0:	e1a02001 	mov	r2, r1
	mem_malloc_end = start + size;
34809bd4:	e0801001 	add	r1, r0, r1
34809bd8:	e5831008 	str	r1, [r3, #8]
	mem_malloc_brk = start;

	memset((void *)mem_malloc_start, 0, size);
34809bdc:	e3a01000 	mov	r1, #0
	mem_malloc_start = start;
34809be0:	e5830004 	str	r0, [r3, #4]
	mem_malloc_brk = start;
34809be4:	e5830000 	str	r0, [r3]
	memset((void *)mem_malloc_start, 0, size);
34809be8:	ea0047e3 	b	3481bb7c <memset>
34809bec:	34828a58 	.word	0x34828a58

34809bf0 <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
34809bf0:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
34809bf4:	e59f60ac 	ldr	r6, [pc, #172]	; 34809ca8 <malloc_trim+0xb8>
34809bf8:	e5963008 	ldr	r3, [r6, #8]
34809bfc:	e5935004 	ldr	r5, [r3, #4]
34809c00:	e3c55003 	bic	r5, r5, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
34809c04:	e0600005 	rsb	r0, r0, r5
34809c08:	e2804efe 	add	r4, r0, #4064	; 0xfe0
34809c0c:	e284400f 	add	r4, r4, #15
34809c10:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34809c14:	e3c4400f 	bic	r4, r4, #15
34809c18:	e2444a01 	sub	r4, r4, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
34809c1c:	e3540a01 	cmp	r4, #4096	; 0x1000
34809c20:	ba000014 	blt	34809c78 <malloc_trim+0x88>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
34809c24:	e3a00000 	mov	r0, #0
34809c28:	ebffffcf 	bl	34809b6c <sbrk>
    if (current_brk != (char*)(top) + top_size)
34809c2c:	e5963008 	ldr	r3, [r6, #8]
34809c30:	e0833005 	add	r3, r3, r5
34809c34:	e1500003 	cmp	r0, r3
34809c38:	1a00000e 	bne	34809c78 <malloc_trim+0x88>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
34809c3c:	e2640000 	rsb	r0, r4, #0
34809c40:	ebffffc9 	bl	34809b6c <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
34809c44:	e3700001 	cmn	r0, #1
34809c48:	1a00000c 	bne	34809c80 <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
34809c4c:	e3a00000 	mov	r0, #0
34809c50:	ebffffc5 	bl	34809b6c <sbrk>
	top_size = current_brk - (char*)top;
34809c54:	e5962008 	ldr	r2, [r6, #8]
34809c58:	e0623000 	rsb	r3, r2, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
34809c5c:	e353000f 	cmp	r3, #15
	{
	  sbrked_mem = current_brk - sbrk_base;
34809c60:	c5961408 	ldrgt	r1, [r6, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
34809c64:	c3833001 	orrgt	r3, r3, #1
34809c68:	c5823004 	strgt	r3, [r2, #4]
	  sbrked_mem = current_brk - sbrk_base;
34809c6c:	c0610000 	rsbgt	r0, r1, r0
34809c70:	c59f1034 	ldrgt	r1, [pc, #52]	; 34809cac <malloc_trim+0xbc>
34809c74:	c581000c 	strgt	r0, [r1, #12]
	  set_head(top, top_size | PREV_INUSE);
34809c78:	e3a00000 	mov	r0, #0
34809c7c:	e8bd8070 	pop	{r4, r5, r6, pc}
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
34809c80:	e5963008 	ldr	r3, [r6, #8]
34809c84:	e0645005 	rsb	r5, r4, r5
	sbrked_mem -= extra;
34809c88:	e59f201c 	ldr	r2, [pc, #28]	; 34809cac <malloc_trim+0xbc>
	set_head(top, (top_size - extra) | PREV_INUSE);
34809c8c:	e3855001 	orr	r5, r5, #1
	check_chunk(top);
	return 1;
34809c90:	e3a00001 	mov	r0, #1
	set_head(top, (top_size - extra) | PREV_INUSE);
34809c94:	e5835004 	str	r5, [r3, #4]
	sbrked_mem -= extra;
34809c98:	e592300c 	ldr	r3, [r2, #12]
34809c9c:	e0644003 	rsb	r4, r4, r3
34809ca0:	e582400c 	str	r4, [r2, #12]
      }
    }
  }
}
34809ca4:	e8bd8070 	pop	{r4, r5, r6, pc}
34809ca8:	34827290 	.word	0x34827290
34809cac:	34828a58 	.word	0x34828a58

34809cb0 <free>:
  if (mem == 0)                              /* free(0) has no effect */
34809cb0:	e3500000 	cmp	r0, #0
34809cb4:	012fff1e 	bxeq	lr
{
34809cb8:	e92d4030 	push	{r4, r5, lr}
  p = mem2chunk(mem);
34809cbc:	e2403008 	sub	r3, r0, #8
  hd = p->size;
34809cc0:	e5101004 	ldr	r1, [r0, #-4]
  if (next == top)                            /* merge with top */
34809cc4:	e59fc204 	ldr	ip, [pc, #516]	; 34809ed0 <free+0x220>
  sz = hd & ~PREV_INUSE;
34809cc8:	e3c12001 	bic	r2, r1, #1
34809ccc:	e2011001 	and	r1, r1, #1
  next = chunk_at_offset(p, sz);
34809cd0:	e0834002 	add	r4, r3, r2
  if (next == top)                            /* merge with top */
34809cd4:	e59c5008 	ldr	r5, [ip, #8]
  nextsz = chunksize(next);
34809cd8:	e594e004 	ldr	lr, [r4, #4]
  if (next == top)                            /* merge with top */
34809cdc:	e1540005 	cmp	r4, r5
  nextsz = chunksize(next);
34809ce0:	e3cee003 	bic	lr, lr, #3
  if (next == top)                            /* merge with top */
34809ce4:	1a000013 	bne	34809d38 <free+0x88>
    if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809ce8:	e3510000 	cmp	r1, #0
    sz += nextsz;
34809cec:	e08e2002 	add	r2, lr, r2
    if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809cf0:	1a000006 	bne	34809d10 <free+0x60>
      prevsz = p->prev_size;
34809cf4:	e5101008 	ldr	r1, [r0, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
34809cf8:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
34809cfc:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
34809d00:	e5930008 	ldr	r0, [r3, #8]
34809d04:	e593100c 	ldr	r1, [r3, #12]
34809d08:	e580100c 	str	r1, [r0, #12]
34809d0c:	e5810008 	str	r0, [r1, #8]
    set_head(p, sz | PREV_INUSE);
34809d10:	e3821001 	orr	r1, r2, #1
34809d14:	e5831004 	str	r1, [r3, #4]
    top = p;
34809d18:	e58c3008 	str	r3, [ip, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
34809d1c:	e59c340c 	ldr	r3, [ip, #1036]	; 0x40c
34809d20:	e1520003 	cmp	r2, r3
34809d24:	38bd8030 	popcc	{r4, r5, pc}
      malloc_trim(top_pad);
34809d28:	e59f31a4 	ldr	r3, [pc, #420]	; 34809ed4 <free+0x224>
}
34809d2c:	e8bd4030 	pop	{r4, r5, lr}
      malloc_trim(top_pad);
34809d30:	e5930034 	ldr	r0, [r3, #52]	; 0x34
34809d34:	eaffffad 	b	34809bf0 <malloc_trim>
  if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809d38:	e3510000 	cmp	r1, #0
  set_head(next, nextsz);                    /* clear inuse bit */
34809d3c:	e584e004 	str	lr, [r4, #4]
  islr = 0;
34809d40:	13a01000 	movne	r1, #0
  if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809d44:	1a000009 	bne	34809d70 <free+0xc0>
    prevsz = p->prev_size;
34809d48:	e5100008 	ldr	r0, [r0, #-8]
    if (p->fd == last_remainder)             /* keep as last_remainder */
34809d4c:	e28c5008 	add	r5, ip, #8
    p = chunk_at_offset(p, -((long) prevsz));
34809d50:	e0603003 	rsb	r3, r0, r3
    sz += prevsz;
34809d54:	e0822000 	add	r2, r2, r0
    if (p->fd == last_remainder)             /* keep as last_remainder */
34809d58:	e5930008 	ldr	r0, [r3, #8]
34809d5c:	e1500005 	cmp	r0, r5
      unlink(p, bck, fwd);
34809d60:	1593500c 	ldrne	r5, [r3, #12]
      islr = 1;
34809d64:	03a01001 	moveq	r1, #1
      unlink(p, bck, fwd);
34809d68:	1580500c 	strne	r5, [r0, #12]
34809d6c:	15850008 	strne	r0, [r5, #8]
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
34809d70:	e084000e 	add	r0, r4, lr
34809d74:	e5900004 	ldr	r0, [r0, #4]
34809d78:	e3100001 	tst	r0, #1
34809d7c:	1a000010 	bne	34809dc4 <free+0x114>
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809d80:	e3510000 	cmp	r1, #0
    sz += nextsz;
34809d84:	e082200e 	add	r2, r2, lr
34809d88:	e5940008 	ldr	r0, [r4, #8]
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809d8c:	1a000009 	bne	34809db8 <free+0x108>
34809d90:	e59fe138 	ldr	lr, [pc, #312]	; 34809ed0 <free+0x220>
34809d94:	e28e5008 	add	r5, lr, #8
34809d98:	e1500005 	cmp	r0, r5
34809d9c:	1a000005 	bne	34809db8 <free+0x108>
      link_last_remainder(p);
34809da0:	e58e3014 	str	r3, [lr, #20]
      islr = 1;
34809da4:	e3a01001 	mov	r1, #1
      link_last_remainder(p);
34809da8:	e58e3010 	str	r3, [lr, #16]
34809dac:	e583000c 	str	r0, [r3, #12]
34809db0:	e5830008 	str	r0, [r3, #8]
34809db4:	ea000002 	b	34809dc4 <free+0x114>
      unlink(next, bck, fwd);
34809db8:	e594e00c 	ldr	lr, [r4, #12]
34809dbc:	e580e00c 	str	lr, [r0, #12]
34809dc0:	e58e0008 	str	r0, [lr, #8]
  set_head(p, sz | PREV_INUSE);
34809dc4:	e3820001 	orr	r0, r2, #1
  if (!islr)
34809dc8:	e3510000 	cmp	r1, #0
  set_head(p, sz | PREV_INUSE);
34809dcc:	e5830004 	str	r0, [r3, #4]
  set_foot(p, sz);
34809dd0:	e7832002 	str	r2, [r3, r2]
  if (!islr)
34809dd4:	18bd8030 	popne	{r4, r5, pc}
    frontlink(p, sz, idx, bck, fwd);
34809dd8:	e3520c02 	cmp	r2, #512	; 0x200
34809ddc:	2a00000c 	bcs	34809e14 <free+0x164>
34809de0:	e59c0004 	ldr	r0, [ip, #4]
34809de4:	e1a021a2 	lsr	r2, r2, #3
34809de8:	e3a0e001 	mov	lr, #1
34809dec:	e1a01142 	asr	r1, r2, #2
34809df0:	e180111e 	orr	r1, r0, lr, lsl r1
34809df4:	e58c1004 	str	r1, [ip, #4]
34809df8:	e08cc182 	add	ip, ip, r2, lsl #3
34809dfc:	e59c2008 	ldr	r2, [ip, #8]
34809e00:	e583c00c 	str	ip, [r3, #12]
34809e04:	e5832008 	str	r2, [r3, #8]
34809e08:	e58c3008 	str	r3, [ip, #8]
34809e0c:	e582300c 	str	r3, [r2, #12]
34809e10:	e8bd8030 	pop	{r4, r5, pc}
34809e14:	e1a014a2 	lsr	r1, r2, #9
34809e18:	e3510004 	cmp	r1, #4
34809e1c:	91a01322 	lsrls	r1, r2, #6
34809e20:	92811038 	addls	r1, r1, #56	; 0x38
34809e24:	9a00000f 	bls	34809e68 <free+0x1b8>
34809e28:	e3510014 	cmp	r1, #20
34809e2c:	9281105b 	addls	r1, r1, #91	; 0x5b
34809e30:	9a00000c 	bls	34809e68 <free+0x1b8>
34809e34:	e3510054 	cmp	r1, #84	; 0x54
34809e38:	91a01622 	lsrls	r1, r2, #12
34809e3c:	9281106e 	addls	r1, r1, #110	; 0x6e
34809e40:	9a000008 	bls	34809e68 <free+0x1b8>
34809e44:	e3510f55 	cmp	r1, #340	; 0x154
34809e48:	91a017a2 	lsrls	r1, r2, #15
34809e4c:	92811077 	addls	r1, r1, #119	; 0x77
34809e50:	9a000004 	bls	34809e68 <free+0x1b8>
34809e54:	e3000554 	movw	r0, #1364	; 0x554
34809e58:	e1510000 	cmp	r1, r0
34809e5c:	91a01922 	lsrls	r1, r2, #18
34809e60:	83a0107e 	movhi	r1, #126	; 0x7e
34809e64:	9281107c 	addls	r1, r1, #124	; 0x7c
34809e68:	e08cc181 	add	ip, ip, r1, lsl #3
34809e6c:	e59fe05c 	ldr	lr, [pc, #92]	; 34809ed0 <free+0x220>
34809e70:	e59c0008 	ldr	r0, [ip, #8]
34809e74:	e150000c 	cmp	r0, ip
34809e78:	11a01000 	movne	r1, r0
34809e7c:	1a000009 	bne	34809ea8 <free+0x1f8>
34809e80:	e59e2004 	ldr	r2, [lr, #4]
34809e84:	e1a01141 	asr	r1, r1, #2
34809e88:	e3a0c001 	mov	ip, #1
34809e8c:	e182111c 	orr	r1, r2, ip, lsl r1
34809e90:	e58e1004 	str	r1, [lr, #4]
34809e94:	e1a01000 	mov	r1, r0
34809e98:	ea000007 	b	34809ebc <free+0x20c>
34809e9c:	e5911008 	ldr	r1, [r1, #8]
34809ea0:	e151000c 	cmp	r1, ip
34809ea4:	0a000003 	beq	34809eb8 <free+0x208>
34809ea8:	e5910004 	ldr	r0, [r1, #4]
34809eac:	e3c00003 	bic	r0, r0, #3
34809eb0:	e1520000 	cmp	r2, r0
34809eb4:	3afffff8 	bcc	34809e9c <free+0x1ec>
34809eb8:	e591000c 	ldr	r0, [r1, #12]
34809ebc:	e583000c 	str	r0, [r3, #12]
34809ec0:	e5831008 	str	r1, [r3, #8]
34809ec4:	e5803008 	str	r3, [r0, #8]
34809ec8:	e581300c 	str	r3, [r1, #12]
34809ecc:	e8bd8030 	pop	{r4, r5, pc}
34809ed0:	34827290 	.word	0x34827290
34809ed4:	34828a58 	.word	0x34828a58

34809ed8 <malloc>:
{
34809ed8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809edc:	e59f75c4 	ldr	r7, [pc, #1476]	; 3480a4a8 <malloc+0x5d0>
34809ee0:	e5973004 	ldr	r3, [r7, #4]
34809ee4:	e3530000 	cmp	r3, #0
34809ee8:	1a000004 	bne	34809f00 <malloc+0x28>
34809eec:	e5973008 	ldr	r3, [r7, #8]
34809ef0:	e3530000 	cmp	r3, #0
34809ef4:	1a000001 	bne	34809f00 <malloc+0x28>
    return 0;
34809ef8:	e3a00000 	mov	r0, #0
34809efc:	ea000167 	b	3480a4a0 <malloc+0x5c8>
  if ((long)bytes < 0) return 0;
34809f00:	e3500000 	cmp	r0, #0
34809f04:	bafffffb 	blt	34809ef8 <malloc+0x20>
  nb = request2size(bytes);  /* padded request size; */
34809f08:	e280600b 	add	r6, r0, #11
34809f0c:	e59f5598 	ldr	r5, [pc, #1432]	; 3480a4ac <malloc+0x5d4>
34809f10:	e3560016 	cmp	r6, #22
34809f14:	da000003 	ble	34809f28 <malloc+0x50>
34809f18:	e3c66007 	bic	r6, r6, #7
  if (is_small_request(nb))  /* Faster version for small requests */
34809f1c:	e3560f7e 	cmp	r6, #504	; 0x1f8
34809f20:	2a000013 	bcs	34809f74 <malloc+0x9c>
34809f24:	ea000000 	b	34809f2c <malloc+0x54>
  nb = request2size(bytes);  /* padded request size; */
34809f28:	e3a06010 	mov	r6, #16
    idx = smallbin_index(nb);
34809f2c:	e1a031a6 	lsr	r3, r6, #3
    q = bin_at(idx);
34809f30:	e0852183 	add	r2, r5, r3, lsl #3
    victim = last(q);
34809f34:	e592000c 	ldr	r0, [r2, #12]
    if (victim == q)
34809f38:	e1500002 	cmp	r0, r2
34809f3c:	1a000004 	bne	34809f54 <malloc+0x7c>
      q = next_bin(q);
34809f40:	e2802008 	add	r2, r0, #8
      victim = last(q);
34809f44:	e5900014 	ldr	r0, [r0, #20]
    if (victim != q)
34809f48:	e1500002 	cmp	r0, r2
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
34809f4c:	02833002 	addeq	r3, r3, #2
    if (victim != q)
34809f50:	0a000036 	beq	3480a030 <malloc+0x158>
      victim_size = chunksize(victim);
34809f54:	e5903004 	ldr	r3, [r0, #4]
      unlink(victim, bck, fwd);
34809f58:	e590200c 	ldr	r2, [r0, #12]
34809f5c:	e5901008 	ldr	r1, [r0, #8]
      victim_size = chunksize(victim);
34809f60:	e3c33003 	bic	r3, r3, #3
      set_inuse_bit_at_offset(victim, victim_size);
34809f64:	e0803003 	add	r3, r0, r3
      unlink(victim, bck, fwd);
34809f68:	e581200c 	str	r2, [r1, #12]
34809f6c:	e5821008 	str	r1, [r2, #8]
34809f70:	ea000020 	b	34809ff8 <malloc+0x120>
    idx = bin_index(nb);
34809f74:	e1b034a6 	lsrs	r3, r6, #9
34809f78:	03a0303f 	moveq	r3, #63	; 0x3f
34809f7c:	0a000013 	beq	34809fd0 <malloc+0xf8>
34809f80:	e3530004 	cmp	r3, #4
34809f84:	91a03326 	lsrls	r3, r6, #6
34809f88:	92833038 	addls	r3, r3, #56	; 0x38
34809f8c:	9a00000f 	bls	34809fd0 <malloc+0xf8>
34809f90:	e3530014 	cmp	r3, #20
34809f94:	9283305b 	addls	r3, r3, #91	; 0x5b
34809f98:	9a00000c 	bls	34809fd0 <malloc+0xf8>
34809f9c:	e3530054 	cmp	r3, #84	; 0x54
34809fa0:	91a03626 	lsrls	r3, r6, #12
34809fa4:	9283306e 	addls	r3, r3, #110	; 0x6e
34809fa8:	9a000008 	bls	34809fd0 <malloc+0xf8>
34809fac:	e3530f55 	cmp	r3, #340	; 0x154
34809fb0:	91a037a6 	lsrls	r3, r6, #15
34809fb4:	92833077 	addls	r3, r3, #119	; 0x77
34809fb8:	9a000004 	bls	34809fd0 <malloc+0xf8>
34809fbc:	e3002554 	movw	r2, #1364	; 0x554
34809fc0:	e1530002 	cmp	r3, r2
34809fc4:	91a03926 	lsrls	r3, r6, #18
34809fc8:	83a0307e 	movhi	r3, #126	; 0x7e
34809fcc:	9283307c 	addls	r3, r3, #124	; 0x7c
    bin = bin_at(idx);
34809fd0:	e0851183 	add	r1, r5, r3, lsl #3
    for (victim = last(bin); victim != bin; victim = victim->bk)
34809fd4:	e591000c 	ldr	r0, [r1, #12]
34809fd8:	ea00000b 	b	3480a00c <malloc+0x134>
      else if (remainder_size >= 0) /* exact fit */
34809fdc:	e35c0000 	cmp	ip, #0
34809fe0:	ba000008 	blt	3480a008 <malloc+0x130>
	unlink(victim, bck, fwd);
34809fe4:	e590300c 	ldr	r3, [r0, #12]
34809fe8:	e5901008 	ldr	r1, [r0, #8]
34809fec:	e581300c 	str	r3, [r1, #12]
34809ff0:	e5831008 	str	r1, [r3, #8]
	set_inuse_bit_at_offset(victim, victim_size);
34809ff4:	e0803002 	add	r3, r0, r2
34809ff8:	e5932004 	ldr	r2, [r3, #4]
34809ffc:	e3822001 	orr	r2, r2, #1
3480a000:	e5832004 	str	r2, [r3, #4]
3480a004:	ea000124 	b	3480a49c <malloc+0x5c4>
    for (victim = last(bin); victim != bin; victim = victim->bk)
3480a008:	e590000c 	ldr	r0, [r0, #12]
3480a00c:	e1500001 	cmp	r0, r1
3480a010:	0a000005 	beq	3480a02c <malloc+0x154>
      victim_size = chunksize(victim);
3480a014:	e5902004 	ldr	r2, [r0, #4]
3480a018:	e3c22003 	bic	r2, r2, #3
      remainder_size = victim_size - nb;
3480a01c:	e066c002 	rsb	ip, r6, r2
      if (remainder_size >= (long)MINSIZE) /* too big */
3480a020:	e35c000f 	cmp	ip, #15
3480a024:	daffffec 	ble	34809fdc <malloc+0x104>
	--idx; /* adjust to rescan below after checking last remainder */
3480a028:	e2433001 	sub	r3, r3, #1
    ++idx;
3480a02c:	e2833001 	add	r3, r3, #1
  if ( (victim = last_remainder->fd) != last_remainder)
3480a030:	e59f2474 	ldr	r2, [pc, #1140]	; 3480a4ac <malloc+0x5d4>
3480a034:	e5950010 	ldr	r0, [r5, #16]
3480a038:	e282e008 	add	lr, r2, #8
3480a03c:	e150000e 	cmp	r0, lr
3480a040:	e1a0100e 	mov	r1, lr
3480a044:	0a000053 	beq	3480a198 <malloc+0x2c0>
    victim_size = chunksize(victim);
3480a048:	e590c004 	ldr	ip, [r0, #4]
3480a04c:	e3ccc003 	bic	ip, ip, #3
    remainder_size = victim_size - nb;
3480a050:	e066400c 	rsb	r4, r6, ip
    if (remainder_size >= (long)MINSIZE) /* re-split */
3480a054:	e354000f 	cmp	r4, #15
3480a058:	da00000a 	ble	3480a088 <malloc+0x1b0>
      remainder = chunk_at_offset(victim, nb);
3480a05c:	e0803006 	add	r3, r0, r6
      set_head(victim, nb | PREV_INUSE);
3480a060:	e3866001 	orr	r6, r6, #1
3480a064:	e5806004 	str	r6, [r0, #4]
      link_last_remainder(remainder);
3480a068:	e5823014 	str	r3, [r2, #20]
3480a06c:	e5823010 	str	r3, [r2, #16]
      set_head(remainder, remainder_size | PREV_INUSE);
3480a070:	e3842001 	orr	r2, r4, #1
      link_last_remainder(remainder);
3480a074:	e583e00c 	str	lr, [r3, #12]
3480a078:	e583e008 	str	lr, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
3480a07c:	e5832004 	str	r2, [r3, #4]
      set_foot(remainder, remainder_size);
3480a080:	e7834004 	str	r4, [r3, r4]
3480a084:	ea000104 	b	3480a49c <malloc+0x5c4>
    if (remainder_size >= 0)  /* exhaust */
3480a088:	e3540000 	cmp	r4, #0
    clear_last_remainder;
3480a08c:	e582e014 	str	lr, [r2, #20]
3480a090:	e582e010 	str	lr, [r2, #16]
      set_inuse_bit_at_offset(victim, victim_size);
3480a094:	a080c00c 	addge	ip, r0, ip
3480a098:	a59c3004 	ldrge	r3, [ip, #4]
3480a09c:	a3833001 	orrge	r3, r3, #1
3480a0a0:	a58c3004 	strge	r3, [ip, #4]
3480a0a4:	aa0000fc 	bge	3480a49c <malloc+0x5c4>
    frontlink(victim, victim_size, remainder_index, bck, fwd);
3480a0a8:	e35c0c02 	cmp	ip, #512	; 0x200
3480a0ac:	2a00000c 	bcs	3480a0e4 <malloc+0x20c>
3480a0b0:	e5924004 	ldr	r4, [r2, #4]
3480a0b4:	e1a0c1ac 	lsr	ip, ip, #3
3480a0b8:	e3a09001 	mov	r9, #1
3480a0bc:	e1a0e14c 	asr	lr, ip, #2
3480a0c0:	e184ee19 	orr	lr, r4, r9, lsl lr
3480a0c4:	e582e004 	str	lr, [r2, #4]
3480a0c8:	e082218c 	add	r2, r2, ip, lsl #3
3480a0cc:	e592c008 	ldr	ip, [r2, #8]
3480a0d0:	e580200c 	str	r2, [r0, #12]
3480a0d4:	e580c008 	str	ip, [r0, #8]
3480a0d8:	e5820008 	str	r0, [r2, #8]
3480a0dc:	e58c000c 	str	r0, [ip, #12]
3480a0e0:	ea00002c 	b	3480a198 <malloc+0x2c0>
3480a0e4:	e1a024ac 	lsr	r2, ip, #9
3480a0e8:	e3520004 	cmp	r2, #4
3480a0ec:	91a0232c 	lsrls	r2, ip, #6
3480a0f0:	92822038 	addls	r2, r2, #56	; 0x38
3480a0f4:	9a00000f 	bls	3480a138 <malloc+0x260>
3480a0f8:	e3520014 	cmp	r2, #20
3480a0fc:	9282205b 	addls	r2, r2, #91	; 0x5b
3480a100:	9a00000c 	bls	3480a138 <malloc+0x260>
3480a104:	e3520054 	cmp	r2, #84	; 0x54
3480a108:	91a0262c 	lsrls	r2, ip, #12
3480a10c:	9282206e 	addls	r2, r2, #110	; 0x6e
3480a110:	9a000008 	bls	3480a138 <malloc+0x260>
3480a114:	e3520f55 	cmp	r2, #340	; 0x154
3480a118:	91a027ac 	lsrls	r2, ip, #15
3480a11c:	92822077 	addls	r2, r2, #119	; 0x77
3480a120:	9a000004 	bls	3480a138 <malloc+0x260>
3480a124:	e300e554 	movw	lr, #1364	; 0x554
3480a128:	e152000e 	cmp	r2, lr
3480a12c:	91a0292c 	lsrls	r2, ip, #18
3480a130:	83a0207e 	movhi	r2, #126	; 0x7e
3480a134:	9282207c 	addls	r2, r2, #124	; 0x7c
3480a138:	e0854182 	add	r4, r5, r2, lsl #3
3480a13c:	e59f9368 	ldr	r9, [pc, #872]	; 3480a4ac <malloc+0x5d4>
3480a140:	e594e008 	ldr	lr, [r4, #8]
3480a144:	e15e0004 	cmp	lr, r4
3480a148:	1a000009 	bne	3480a174 <malloc+0x29c>
3480a14c:	e599c004 	ldr	ip, [r9, #4]
3480a150:	e1a02142 	asr	r2, r2, #2
3480a154:	e3a04001 	mov	r4, #1
3480a158:	e18c2214 	orr	r2, ip, r4, lsl r2
3480a15c:	e5892004 	str	r2, [r9, #4]
3480a160:	e1a0200e 	mov	r2, lr
3480a164:	ea000007 	b	3480a188 <malloc+0x2b0>
3480a168:	e59ee008 	ldr	lr, [lr, #8]
3480a16c:	e15e0004 	cmp	lr, r4
3480a170:	0a000003 	beq	3480a184 <malloc+0x2ac>
3480a174:	e59e2004 	ldr	r2, [lr, #4]
3480a178:	e3c22003 	bic	r2, r2, #3
3480a17c:	e15c0002 	cmp	ip, r2
3480a180:	3afffff8 	bcc	3480a168 <malloc+0x290>
3480a184:	e59e200c 	ldr	r2, [lr, #12]
3480a188:	e580200c 	str	r2, [r0, #12]
3480a18c:	e580e008 	str	lr, [r0, #8]
3480a190:	e5820008 	str	r0, [r2, #8]
3480a194:	e58e000c 	str	r0, [lr, #12]
  if ( (block = idx2binblock(idx)) <= binblocks_r)
3480a198:	e1a02143 	asr	r2, r3, #2
3480a19c:	e3a00001 	mov	r0, #1
3480a1a0:	e1a02210 	lsl	r2, r0, r2
3480a1a4:	e5950004 	ldr	r0, [r5, #4]
3480a1a8:	e1520000 	cmp	r2, r0
3480a1ac:	8a00004a 	bhi	3480a2dc <malloc+0x404>
    if ( (block & binblocks_r) == 0)
3480a1b0:	e1120000 	tst	r2, r0
3480a1b4:	1a000004 	bne	3480a1cc <malloc+0x2f4>
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
3480a1b8:	e3c33003 	bic	r3, r3, #3
	block <<= 1;
3480a1bc:	e1a02082 	lsl	r2, r2, #1
	idx += BINBLOCKWIDTH;
3480a1c0:	e2833004 	add	r3, r3, #4
      while ((block & binblocks_r) == 0)
3480a1c4:	e1120000 	tst	r2, r0
3480a1c8:	0afffffb 	beq	3480a1bc <malloc+0x2e4>
      q = bin = bin_at(idx);
3480a1cc:	e0854183 	add	r4, r5, r3, lsl #3
3480a1d0:	e1a0e003 	mov	lr, r3
3480a1d4:	e1a0a004 	mov	sl, r4
	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a1d8:	e59a000c 	ldr	r0, [sl, #12]
3480a1dc:	e150000a 	cmp	r0, sl
3480a1e0:	0a000020 	beq	3480a268 <malloc+0x390>
	  victim_size = chunksize(victim);
3480a1e4:	e590c004 	ldr	ip, [r0, #4]
3480a1e8:	e3ccc003 	bic	ip, ip, #3
	  remainder_size = victim_size - nb;
3480a1ec:	e066900c 	rsb	r9, r6, ip
	  if (remainder_size >= (long)MINSIZE) /* split */
3480a1f0:	e359000f 	cmp	r9, #15
3480a1f4:	da00000e 	ble	3480a234 <malloc+0x35c>
	    remainder = chunk_at_offset(victim, nb);
3480a1f8:	e0803006 	add	r3, r0, r6
	    set_head(victim, nb | PREV_INUSE);
3480a1fc:	e3866001 	orr	r6, r6, #1
	    unlink(victim, bck, fwd);
3480a200:	e590200c 	ldr	r2, [r0, #12]
	    set_head(victim, nb | PREV_INUSE);
3480a204:	e5806004 	str	r6, [r0, #4]
	    unlink(victim, bck, fwd);
3480a208:	e5b0c008 	ldr	ip, [r0, #8]!
3480a20c:	e58c200c 	str	r2, [ip, #12]
3480a210:	e582c008 	str	ip, [r2, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
3480a214:	e3892001 	orr	r2, r9, #1
	    link_last_remainder(remainder);
3480a218:	e5853014 	str	r3, [r5, #20]
3480a21c:	e5853010 	str	r3, [r5, #16]
3480a220:	e583100c 	str	r1, [r3, #12]
3480a224:	e5831008 	str	r1, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
3480a228:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
3480a22c:	e7839009 	str	r9, [r3, r9]
	    return chunk2mem(victim);
3480a230:	ea00009a 	b	3480a4a0 <malloc+0x5c8>
	  else if (remainder_size >= 0)  /* take */
3480a234:	e3590000 	cmp	r9, #0
3480a238:	ba000008 	blt	3480a260 <malloc+0x388>
	    set_inuse_bit_at_offset(victim, victim_size);
3480a23c:	e080300c 	add	r3, r0, ip
3480a240:	e5932004 	ldr	r2, [r3, #4]
3480a244:	e3822001 	orr	r2, r2, #1
3480a248:	e5832004 	str	r2, [r3, #4]
	    unlink(victim, bck, fwd);
3480a24c:	e590300c 	ldr	r3, [r0, #12]
3480a250:	e5b02008 	ldr	r2, [r0, #8]!
3480a254:	e582300c 	str	r3, [r2, #12]
3480a258:	e5832008 	str	r2, [r3, #8]
	    return chunk2mem(victim);
3480a25c:	ea00008f 	b	3480a4a0 <malloc+0x5c8>
	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a260:	e590000c 	ldr	r0, [r0, #12]
3480a264:	eaffffdc 	b	3480a1dc <malloc+0x304>
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
3480a268:	e28ee001 	add	lr, lr, #1
       bin = next_bin(bin);
3480a26c:	e28aa008 	add	sl, sl, #8
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
3480a270:	e31e0003 	tst	lr, #3
3480a274:	1affffd7 	bne	3480a1d8 <malloc+0x300>
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
3480a278:	e3130003 	tst	r3, #3
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480a27c:	05953004 	ldreq	r3, [r5, #4]
3480a280:	01c33002 	biceq	r3, r3, r2
3480a284:	05853004 	streq	r3, [r5, #4]
	  break;
3480a288:	0a000004 	beq	3480a2a0 <malloc+0x3c8>
       q = prev_bin(q);
3480a28c:	e2440008 	sub	r0, r4, #8
      } while (first(q) == q);
3480a290:	e5944000 	ldr	r4, [r4]
	--startidx;
3480a294:	e2433001 	sub	r3, r3, #1
      } while (first(q) == q);
3480a298:	e1540000 	cmp	r4, r0
3480a29c:	0afffff5 	beq	3480a278 <malloc+0x3a0>
      if ( (block <<= 1) <= binblocks_r && (block != 0) )
3480a2a0:	e5953004 	ldr	r3, [r5, #4]
3480a2a4:	e1a02082 	lsl	r2, r2, #1
3480a2a8:	e1520003 	cmp	r2, r3
3480a2ac:	83a00000 	movhi	r0, #0
3480a2b0:	93a00001 	movls	r0, #1
3480a2b4:	e3520000 	cmp	r2, #0
3480a2b8:	03a00000 	moveq	r0, #0
3480a2bc:	e3500000 	cmp	r0, #0
3480a2c0:	0a000005 	beq	3480a2dc <malloc+0x404>
	while ((block & binblocks_r) == 0)
3480a2c4:	e1120003 	tst	r2, r3
	  idx += BINBLOCKWIDTH;
3480a2c8:	028ee004 	addeq	lr, lr, #4
	  block <<= 1;
3480a2cc:	01a02082 	lsleq	r2, r2, #1
3480a2d0:	0afffffb 	beq	3480a2c4 <malloc+0x3ec>
	while ((block & binblocks_r) == 0)
3480a2d4:	e1a0300e 	mov	r3, lr
3480a2d8:	eaffffbb 	b	3480a1cc <malloc+0x2f4>
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a2dc:	e595b008 	ldr	fp, [r5, #8]
3480a2e0:	e59b9004 	ldr	r9, [fp, #4]
3480a2e4:	e3c99003 	bic	r9, r9, #3
3480a2e8:	e0663009 	rsb	r3, r6, r9
3480a2ec:	e353000f 	cmp	r3, #15
3480a2f0:	ca000062 	bgt	3480a480 <malloc+0x5a8>
  if (sbrk_base != (char*)(-1))
3480a2f4:	e59f31b0 	ldr	r3, [pc, #432]	; 3480a4ac <malloc+0x5d4>
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a2f8:	e5974034 	ldr	r4, [r7, #52]	; 0x34
  if (sbrk_base != (char*)(-1))
3480a2fc:	e5933408 	ldr	r3, [r3, #1032]	; 0x408
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a300:	e0864004 	add	r4, r6, r4
  if (sbrk_base != (char*)(-1))
3480a304:	e3730001 	cmn	r3, #1
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
3480a308:	12844a01 	addne	r4, r4, #4096	; 0x1000
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a30c:	02844010 	addeq	r4, r4, #16
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
3480a310:	1284400f 	addne	r4, r4, #15
3480a314:	13c44eff 	bicne	r4, r4, #4080	; 0xff0
3480a318:	13c4400f 	bicne	r4, r4, #15
  brk = (char*)(MORECORE (sbrk_size));
3480a31c:	e1a00004 	mov	r0, r4
3480a320:	ebfffe11 	bl	34809b6c <sbrk>
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a324:	e3700001 	cmn	r0, #1
  brk = (char*)(MORECORE (sbrk_size));
3480a328:	e1a0a000 	mov	sl, r0
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a32c:	0a00004d 	beq	3480a468 <malloc+0x590>
      (brk < old_end && old_top != initial_top))
3480a330:	e05b2005 	subs	r2, fp, r5
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
3480a334:	e08b1009 	add	r1, fp, r9
      (brk < old_end && old_top != initial_top))
3480a338:	13a02001 	movne	r2, #1
3480a33c:	e15b0005 	cmp	fp, r5
3480a340:	115a0001 	cmpne	sl, r1
3480a344:	e59f0160 	ldr	r0, [pc, #352]	; 3480a4ac <malloc+0x5d4>
3480a348:	3a000046 	bcc	3480a468 <malloc+0x590>
  sbrked_mem += sbrk_size;
3480a34c:	e597300c 	ldr	r3, [r7, #12]
  if (brk == old_end) /* can just add bytes to current top */
3480a350:	e15a0001 	cmp	sl, r1
  sbrked_mem += sbrk_size;
3480a354:	e0843003 	add	r3, r4, r3
3480a358:	e587300c 	str	r3, [r7, #12]
    set_head(top, top_size | PREV_INUSE);
3480a35c:	05903008 	ldreq	r3, [r0, #8]
    top_size = sbrk_size + old_top_size;
3480a360:	00844009 	addeq	r4, r4, r9
    set_head(top, top_size | PREV_INUSE);
3480a364:	03844001 	orreq	r4, r4, #1
3480a368:	05834004 	streq	r4, [r3, #4]
3480a36c:	0a000034 	beq	3480a444 <malloc+0x56c>
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
3480a370:	e590c408 	ldr	ip, [r0, #1032]	; 0x408
3480a374:	e58d2004 	str	r2, [sp, #4]
3480a378:	e37c0001 	cmn	ip, #1
      sbrked_mem += brk - (char*)old_end;
3480a37c:	1061100a 	rsbne	r1, r1, sl
      sbrk_base = brk;
3480a380:	0580a408 	streq	sl, [r0, #1032]	; 0x408
      sbrked_mem += brk - (char*)old_end;
3480a384:	10833001 	addne	r3, r3, r1
3480a388:	159f1118 	ldrne	r1, [pc, #280]	; 3480a4a8 <malloc+0x5d0>
3480a38c:	1581300c 	strne	r3, [r1, #12]
    if (front_misalign > 0)
3480a390:	e21a1007 	ands	r1, sl, #7
      correction = (MALLOC_ALIGNMENT) - front_misalign;
3480a394:	12611008 	rsbne	r1, r1, #8
      brk += correction;
3480a398:	108aa001 	addne	sl, sl, r1
    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
3480a39c:	e08a3004 	add	r3, sl, r4
3480a3a0:	e0634001 	rsb	r4, r3, r1
3480a3a4:	e2833eff 	add	r3, r3, #4080	; 0xff0
3480a3a8:	e283300f 	add	r3, r3, #15
3480a3ac:	e3c33eff 	bic	r3, r3, #4080	; 0xff0
3480a3b0:	e3c3300f 	bic	r3, r3, #15
3480a3b4:	e0844003 	add	r4, r4, r3
    new_brk = (char*)(MORECORE (correction));
3480a3b8:	e1a00004 	mov	r0, r4
3480a3bc:	ebfffdea 	bl	34809b6c <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
3480a3c0:	e3700001 	cmn	r0, #1
3480a3c4:	0a000027 	beq	3480a468 <malloc+0x590>
    sbrked_mem += correction;
3480a3c8:	e597300c 	ldr	r3, [r7, #12]
    if (old_top != initial_top)
3480a3cc:	e59d2004 	ldr	r2, [sp, #4]
    top = (mchunkptr)brk;
3480a3d0:	e585a008 	str	sl, [r5, #8]
    sbrked_mem += correction;
3480a3d4:	e0843003 	add	r3, r4, r3
3480a3d8:	e587300c 	str	r3, [r7, #12]
    top_size = new_brk - brk + correction;
3480a3dc:	e06a3000 	rsb	r3, sl, r0
3480a3e0:	e0843003 	add	r3, r4, r3
    if (old_top != initial_top)
3480a3e4:	e3520000 	cmp	r2, #0
    set_head(top, top_size | PREV_INUSE);
3480a3e8:	e3833001 	orr	r3, r3, #1
3480a3ec:	e58a3004 	str	r3, [sl, #4]
    if (old_top != initial_top)
3480a3f0:	0a000013 	beq	3480a444 <malloc+0x56c>
      if (old_top_size < MINSIZE)
3480a3f4:	e359000f 	cmp	r9, #15
	set_head(top, PREV_INUSE); /* will force null return from malloc */
3480a3f8:	959f30ac 	ldrls	r3, [pc, #172]	; 3480a4ac <malloc+0x5d4>
3480a3fc:	93a02001 	movls	r2, #1
3480a400:	95933008 	ldrls	r3, [r3, #8]
3480a404:	95832004 	strls	r2, [r3, #4]
3480a408:	9a000016 	bls	3480a468 <malloc+0x590>
      set_head_size(old_top, old_top_size);
3480a40c:	e59b3004 	ldr	r3, [fp, #4]
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
3480a410:	e249900c 	sub	r9, r9, #12
3480a414:	e3c99007 	bic	r9, r9, #7
      chunk_at_offset(old_top, old_top_size          )->size =
3480a418:	e3a02005 	mov	r2, #5
      if (old_top_size >= MINSIZE)
3480a41c:	e359000f 	cmp	r9, #15
      set_head_size(old_top, old_top_size);
3480a420:	e2033001 	and	r3, r3, #1
3480a424:	e1893003 	orr	r3, r9, r3
3480a428:	e58b3004 	str	r3, [fp, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
3480a42c:	e08b3009 	add	r3, fp, r9
3480a430:	e5832004 	str	r2, [r3, #4]
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
3480a434:	e5832008 	str	r2, [r3, #8]
      if (old_top_size >= MINSIZE)
3480a438:	9a000001 	bls	3480a444 <malloc+0x56c>
	fREe(chunk2mem(old_top));
3480a43c:	e28b0008 	add	r0, fp, #8
3480a440:	ebfffe1a 	bl	34809cb0 <free>
  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
3480a444:	e597300c 	ldr	r3, [r7, #12]
3480a448:	e5972038 	ldr	r2, [r7, #56]	; 0x38
3480a44c:	e1530002 	cmp	r3, r2
    max_sbrked_mem = sbrked_mem;
3480a450:	859f2050 	ldrhi	r2, [pc, #80]	; 3480a4a8 <malloc+0x5d0>
3480a454:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
3480a458:	e597203c 	ldr	r2, [r7, #60]	; 0x3c
3480a45c:	e1530002 	cmp	r3, r2
    max_total_mem = mmapped_mem + sbrked_mem;
3480a460:	859f2040 	ldrhi	r2, [pc, #64]	; 3480a4a8 <malloc+0x5d0>
3480a464:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a468:	e5953008 	ldr	r3, [r5, #8]
3480a46c:	e5933004 	ldr	r3, [r3, #4]
3480a470:	e3c33003 	bic	r3, r3, #3
3480a474:	e0663003 	rsb	r3, r6, r3
3480a478:	e353000f 	cmp	r3, #15
3480a47c:	dafffe9d 	ble	34809ef8 <malloc+0x20>
  victim = top;
3480a480:	e5950008 	ldr	r0, [r5, #8]
  set_head(victim, nb | PREV_INUSE);
3480a484:	e3862001 	orr	r2, r6, #1
  set_head(top, remainder_size | PREV_INUSE);
3480a488:	e3833001 	orr	r3, r3, #1
  top = chunk_at_offset(victim, nb);
3480a48c:	e0806006 	add	r6, r0, r6
  set_head(victim, nb | PREV_INUSE);
3480a490:	e5802004 	str	r2, [r0, #4]
  top = chunk_at_offset(victim, nb);
3480a494:	e5856008 	str	r6, [r5, #8]
  set_head(top, remainder_size | PREV_INUSE);
3480a498:	e5863004 	str	r3, [r6, #4]
  return chunk2mem(victim);
3480a49c:	e2800008 	add	r0, r0, #8
}
3480a4a0:	e28dd008 	add	sp, sp, #8
3480a4a4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480a4a8:	34828a58 	.word	0x34828a58
3480a4ac:	34827290 	.word	0x34827290

3480a4b0 <calloc>:
  mchunkptr oldtop = top;
3480a4b0:	e59f30c8 	ldr	r3, [pc, #200]	; 3480a580 <calloc+0xd0>
{
3480a4b4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480a4b8:	e1a05000 	mov	r5, r0
  Void_t* mem = mALLOc (sz);
3480a4bc:	e0000091 	mul	r0, r1, r0
  mchunkptr oldtop = top;
3480a4c0:	e5937008 	ldr	r7, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
3480a4c4:	e5972004 	ldr	r2, [r7, #4]
3480a4c8:	e3c26003 	bic	r6, r2, #3
  Void_t* mem = mALLOc (sz);
3480a4cc:	ebfffe81 	bl	34809ed8 <malloc>
  if ((long)n < 0) return 0;
3480a4d0:	e1a01fa5 	lsr	r1, r5, #31
  if (mem == 0)
3480a4d4:	e3500000 	cmp	r0, #0
3480a4d8:	03811001 	orreq	r1, r1, #1
3480a4dc:	e3510000 	cmp	r1, #0
3480a4e0:	1a000024 	bne	3480a578 <calloc+0xc8>
    csz = chunksize(p);
3480a4e4:	e5103004 	ldr	r3, [r0, #-4]
    p = mem2chunk(mem);
3480a4e8:	e2402008 	sub	r2, r0, #8
    if (p == oldtop && csz > oldtopsize)
3480a4ec:	e0627007 	rsb	r7, r2, r7
3480a4f0:	e1a04000 	mov	r4, r0
3480a4f4:	e16f7f17 	clz	r7, r7
    csz = chunksize(p);
3480a4f8:	e3c33003 	bic	r3, r3, #3
    if (p == oldtop && csz > oldtopsize)
3480a4fc:	e1a072a7 	lsr	r7, r7, #5
3480a500:	e1530006 	cmp	r3, r6
3480a504:	93a07000 	movls	r7, #0
    csz = chunksize(p);
3480a508:	e3570000 	cmp	r7, #0
3480a50c:	01a06003 	moveq	r6, r3
    MALLOC_ZERO(mem, csz - SIZE_SZ);
3480a510:	e2462004 	sub	r2, r6, #4
3480a514:	e3520024 	cmp	r2, #36	; 0x24
3480a518:	8a000013 	bhi	3480a56c <calloc+0xbc>
3480a51c:	e3520013 	cmp	r2, #19
3480a520:	91a03000 	movls	r3, r0
3480a524:	9a00000b 	bls	3480a558 <calloc+0xa8>
3480a528:	e352001b 	cmp	r2, #27
3480a52c:	e5801000 	str	r1, [r0]
3480a530:	e5801004 	str	r1, [r0, #4]
3480a534:	92803008 	addls	r3, r0, #8
3480a538:	9a000006 	bls	3480a558 <calloc+0xa8>
3480a53c:	e3520024 	cmp	r2, #36	; 0x24
3480a540:	e5801008 	str	r1, [r0, #8]
3480a544:	12803010 	addne	r3, r0, #16
3480a548:	02803018 	addeq	r3, r0, #24
3480a54c:	e580100c 	str	r1, [r0, #12]
3480a550:	05801010 	streq	r1, [r0, #16]
3480a554:	05801014 	streq	r1, [r0, #20]
3480a558:	e3a02000 	mov	r2, #0
3480a55c:	e5832000 	str	r2, [r3]
3480a560:	e5832004 	str	r2, [r3, #4]
3480a564:	e5832008 	str	r2, [r3, #8]
3480a568:	ea000000 	b	3480a570 <calloc+0xc0>
3480a56c:	eb004582 	bl	3481bb7c <memset>
3480a570:	e1a00004 	mov	r0, r4
3480a574:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
    return 0;
3480a578:	e3a00000 	mov	r0, #0
}
3480a57c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480a580:	34827290 	.word	0x34827290

3480a584 <realloc>:
{
3480a584:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480a588:	e1a04000 	mov	r4, r0
  if ((long)bytes < 0) return 0;
3480a58c:	e2510000 	subs	r0, r1, #0
3480a590:	aa000001 	bge	3480a59c <realloc+0x18>
3480a594:	e3a00000 	mov	r0, #0
3480a598:	ea000124 	b	3480aa30 <realloc+0x4ac>
  if (oldmem == 0) return mALLOc(bytes);
3480a59c:	e3540000 	cmp	r4, #0
3480a5a0:	1a000002 	bne	3480a5b0 <realloc+0x2c>
}
3480a5a4:	e28dd008 	add	sp, sp, #8
3480a5a8:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
  if (oldmem == 0) return mALLOc(bytes);
3480a5ac:	eafffe49 	b	34809ed8 <malloc>
  newsize = oldsize = chunksize(oldp);
3480a5b0:	e514e004 	ldr	lr, [r4, #-4]
  nb = request2size(bytes);
3480a5b4:	e280900b 	add	r9, r0, #11
3480a5b8:	e3590016 	cmp	r9, #22
  newp    = oldp    = mem2chunk(oldmem);
3480a5bc:	e244b008 	sub	fp, r4, #8
  nb = request2size(bytes);
3480a5c0:	c3c99007 	bicgt	r9, r9, #7
3480a5c4:	d3a09010 	movle	r9, #16
  newsize = oldsize = chunksize(oldp);
3480a5c8:	e3ce5003 	bic	r5, lr, #3
  if ((long)(oldsize) < (long)(nb))
3480a5cc:	e1550009 	cmp	r5, r9
3480a5d0:	aa0000fd 	bge	3480a9cc <realloc+0x448>
    if (next == top || !inuse(next))
3480a5d4:	e59f345c 	ldr	r3, [pc, #1116]	; 3480aa38 <realloc+0x4b4>
    next = chunk_at_offset(oldp, oldsize);
3480a5d8:	e08b2005 	add	r2, fp, r5
3480a5dc:	e592a004 	ldr	sl, [r2, #4]
    if (next == top || !inuse(next))
3480a5e0:	e5931008 	ldr	r1, [r3, #8]
3480a5e4:	e1520001 	cmp	r2, r1
3480a5e8:	0a000004 	beq	3480a600 <realloc+0x7c>
3480a5ec:	e3cac001 	bic	ip, sl, #1
3480a5f0:	e082c00c 	add	ip, r2, ip
3480a5f4:	e59cc004 	ldr	ip, [ip, #4]
3480a5f8:	e31c0001 	tst	ip, #1
3480a5fc:	1a000019 	bne	3480a668 <realloc+0xe4>
      if (next == top)
3480a600:	e1520001 	cmp	r2, r1
      nextsize = chunksize(next);
3480a604:	e3caa003 	bic	sl, sl, #3
3480a608:	e08ac005 	add	ip, sl, r5
      if (next == top)
3480a60c:	1a00000d 	bne	3480a648 <realloc+0xc4>
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
3480a610:	e2896010 	add	r6, r9, #16
3480a614:	e15c0006 	cmp	ip, r6
3480a618:	ba000014 	blt	3480a670 <realloc+0xec>
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a61c:	e069c00c 	rsb	ip, r9, ip
	  top = chunk_at_offset(oldp, nb);
3480a620:	e08b0009 	add	r0, fp, r9
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a624:	e38cc001 	orr	ip, ip, #1
	  top = chunk_at_offset(oldp, nb);
3480a628:	e5830008 	str	r0, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a62c:	e580c004 	str	ip, [r0, #4]
	  return chunk2mem(oldp);
3480a630:	e1a00004 	mov	r0, r4
	  set_head_size(oldp, nb);
3480a634:	e5143004 	ldr	r3, [r4, #-4]
3480a638:	e2033001 	and	r3, r3, #1
3480a63c:	e1899003 	orr	r9, r9, r3
3480a640:	e5049004 	str	r9, [r4, #-4]
	  return chunk2mem(oldp);
3480a644:	ea0000f9 	b	3480aa30 <realloc+0x4ac>
      else if (((long)(nextsize + newsize) >= (long)(nb)))
3480a648:	e15c0009 	cmp	ip, r9
3480a64c:	ba000007 	blt	3480a670 <realloc+0xec>
	unlink(next, bck, fwd);
3480a650:	e592300c 	ldr	r3, [r2, #12]
	newsize  += nextsize;
3480a654:	e1a0500c 	mov	r5, ip
	unlink(next, bck, fwd);
3480a658:	e5922008 	ldr	r2, [r2, #8]
3480a65c:	e582300c 	str	r3, [r2, #12]
3480a660:	e5832008 	str	r2, [r3, #8]
	goto split;
3480a664:	ea0000d8 	b	3480a9cc <realloc+0x448>
      nextsize = 0;
3480a668:	e3a0a000 	mov	sl, #0
      next = 0;
3480a66c:	e1a0200a 	mov	r2, sl
    if (!prev_inuse(oldp))
3480a670:	e31e0001 	tst	lr, #1
3480a674:	1a00009f 	bne	3480a8f8 <realloc+0x374>
      prev = prev_chunk(oldp);
3480a678:	e5147008 	ldr	r7, [r4, #-8]
      if (next != 0)
3480a67c:	e3520000 	cmp	r2, #0
      prev = prev_chunk(oldp);
3480a680:	e067700b 	rsb	r7, r7, fp
      prevsize = chunksize(prev);
3480a684:	e5976004 	ldr	r6, [r7, #4]
3480a688:	e3c66003 	bic	r6, r6, #3
3480a68c:	e0866005 	add	r6, r6, r5
      if (next != 0)
3480a690:	0a00006b 	beq	3480a844 <realloc+0x2c0>
	if (next == top)
3480a694:	e1520001 	cmp	r2, r1
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
3480a698:	e086a00a 	add	sl, r6, sl
	if (next == top)
3480a69c:	1a000038 	bne	3480a784 <realloc+0x200>
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
3480a6a0:	e2892010 	add	r2, r9, #16
3480a6a4:	e15a0002 	cmp	sl, r2
3480a6a8:	ba000065 	blt	3480a844 <realloc+0x2c0>
	    unlink(prev, bck, fwd);
3480a6ac:	e1a06007 	mov	r6, r7
3480a6b0:	e597200c 	ldr	r2, [r7, #12]
3480a6b4:	e5b61008 	ldr	r1, [r6, #8]!
3480a6b8:	e581200c 	str	r2, [r1, #12]
3480a6bc:	e5821008 	str	r1, [r2, #8]
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a6c0:	e2452004 	sub	r2, r5, #4
3480a6c4:	e3520024 	cmp	r2, #36	; 0x24
3480a6c8:	8a00001e 	bhi	3480a748 <realloc+0x1c4>
3480a6cc:	e3520013 	cmp	r2, #19
3480a6d0:	91a02006 	movls	r2, r6
3480a6d4:	9a000014 	bls	3480a72c <realloc+0x1a8>
3480a6d8:	e5941000 	ldr	r1, [r4]
3480a6dc:	e352001b 	cmp	r2, #27
3480a6e0:	92872010 	addls	r2, r7, #16
3480a6e4:	e5871008 	str	r1, [r7, #8]
3480a6e8:	e5941004 	ldr	r1, [r4, #4]
3480a6ec:	92844008 	addls	r4, r4, #8
3480a6f0:	e587100c 	str	r1, [r7, #12]
3480a6f4:	9a00000c 	bls	3480a72c <realloc+0x1a8>
3480a6f8:	e5941008 	ldr	r1, [r4, #8]
3480a6fc:	e3520024 	cmp	r2, #36	; 0x24
3480a700:	12872018 	addne	r2, r7, #24
3480a704:	e5871010 	str	r1, [r7, #16]
3480a708:	e594100c 	ldr	r1, [r4, #12]
3480a70c:	12844010 	addne	r4, r4, #16
3480a710:	e5871014 	str	r1, [r7, #20]
3480a714:	05942010 	ldreq	r2, [r4, #16]
3480a718:	05872018 	streq	r2, [r7, #24]
3480a71c:	02872020 	addeq	r2, r7, #32
3480a720:	05941014 	ldreq	r1, [r4, #20]
3480a724:	02844018 	addeq	r4, r4, #24
3480a728:	0587101c 	streq	r1, [r7, #28]
3480a72c:	e5941000 	ldr	r1, [r4]
3480a730:	e5821000 	str	r1, [r2]
3480a734:	e5941004 	ldr	r1, [r4, #4]
3480a738:	e5821004 	str	r1, [r2, #4]
3480a73c:	e5941008 	ldr	r1, [r4, #8]
3480a740:	e5821008 	str	r1, [r2, #8]
3480a744:	ea000004 	b	3480a75c <realloc+0x1d8>
3480a748:	e1a01004 	mov	r1, r4
3480a74c:	e1a00006 	mov	r0, r6
3480a750:	e58d3004 	str	r3, [sp, #4]
3480a754:	eb004528 	bl	3481bbfc <memcpy>
3480a758:	e59d3004 	ldr	r3, [sp, #4]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a75c:	e069a00a 	rsb	sl, r9, sl
	    top = chunk_at_offset(newp, nb);
3480a760:	e0872009 	add	r2, r7, r9
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a764:	e38aa001 	orr	sl, sl, #1
	    top = chunk_at_offset(newp, nb);
3480a768:	e5832008 	str	r2, [r3, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a76c:	e582a004 	str	sl, [r2, #4]
	    set_head_size(newp, nb);
3480a770:	e5973004 	ldr	r3, [r7, #4]
3480a774:	e2033001 	and	r3, r3, #1
3480a778:	e1899003 	orr	r9, r9, r3
3480a77c:	e5879004 	str	r9, [r7, #4]
3480a780:	ea00008f 	b	3480a9c4 <realloc+0x440>
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
3480a784:	e15a0009 	cmp	sl, r9
3480a788:	ba00002d 	blt	3480a844 <realloc+0x2c0>
	  unlink(next, bck, fwd);
3480a78c:	e592300c 	ldr	r3, [r2, #12]
	  unlink(prev, bck, fwd);
3480a790:	e1a00007 	mov	r0, r7
	  unlink(next, bck, fwd);
3480a794:	e5922008 	ldr	r2, [r2, #8]
3480a798:	e582300c 	str	r3, [r2, #12]
3480a79c:	e5832008 	str	r2, [r3, #8]
	  unlink(prev, bck, fwd);
3480a7a0:	e597300c 	ldr	r3, [r7, #12]
3480a7a4:	e5b02008 	ldr	r2, [r0, #8]!
3480a7a8:	e582300c 	str	r3, [r2, #12]
3480a7ac:	e5832008 	str	r2, [r3, #8]
	  MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a7b0:	e2452004 	sub	r2, r5, #4
3480a7b4:	e3520024 	cmp	r2, #36	; 0x24
3480a7b8:	8a00001d 	bhi	3480a834 <realloc+0x2b0>
3480a7bc:	e3520013 	cmp	r2, #19
3480a7c0:	9a000014 	bls	3480a818 <realloc+0x294>
3480a7c4:	e5943000 	ldr	r3, [r4]
3480a7c8:	e352001b 	cmp	r2, #27
3480a7cc:	92870010 	addls	r0, r7, #16
3480a7d0:	e5873008 	str	r3, [r7, #8]
3480a7d4:	e5943004 	ldr	r3, [r4, #4]
3480a7d8:	92844008 	addls	r4, r4, #8
3480a7dc:	e587300c 	str	r3, [r7, #12]
3480a7e0:	9a00000c 	bls	3480a818 <realloc+0x294>
3480a7e4:	e5943008 	ldr	r3, [r4, #8]
3480a7e8:	e3520024 	cmp	r2, #36	; 0x24
3480a7ec:	12870018 	addne	r0, r7, #24
3480a7f0:	02870020 	addeq	r0, r7, #32
3480a7f4:	e5873010 	str	r3, [r7, #16]
3480a7f8:	e594300c 	ldr	r3, [r4, #12]
3480a7fc:	12844010 	addne	r4, r4, #16
3480a800:	e5873014 	str	r3, [r7, #20]
3480a804:	05943010 	ldreq	r3, [r4, #16]
3480a808:	05873018 	streq	r3, [r7, #24]
3480a80c:	05943014 	ldreq	r3, [r4, #20]
3480a810:	02844018 	addeq	r4, r4, #24
3480a814:	0587301c 	streq	r3, [r7, #28]
3480a818:	e5943000 	ldr	r3, [r4]
3480a81c:	e5803000 	str	r3, [r0]
3480a820:	e5943004 	ldr	r3, [r4, #4]
3480a824:	e5803004 	str	r3, [r0, #4]
3480a828:	e5943008 	ldr	r3, [r4, #8]
3480a82c:	e5803008 	str	r3, [r0, #8]
3480a830:	ea000001 	b	3480a83c <realloc+0x2b8>
3480a834:	e1a01004 	mov	r1, r4
3480a838:	eb0044ef 	bl	3481bbfc <memcpy>
	  newsize += nextsize + prevsize;
3480a83c:	e1a0500a 	mov	r5, sl
3480a840:	ea000027 	b	3480a8e4 <realloc+0x360>
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
3480a844:	e1560009 	cmp	r6, r9
3480a848:	ba00002a 	blt	3480a8f8 <realloc+0x374>
	unlink(prev, bck, fwd);
3480a84c:	e1a00007 	mov	r0, r7
3480a850:	e597300c 	ldr	r3, [r7, #12]
3480a854:	e5b02008 	ldr	r2, [r0, #8]!
3480a858:	e582300c 	str	r3, [r2, #12]
3480a85c:	e5832008 	str	r2, [r3, #8]
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a860:	e2452004 	sub	r2, r5, #4
3480a864:	e3520024 	cmp	r2, #36	; 0x24
3480a868:	8a00001f 	bhi	3480a8ec <realloc+0x368>
3480a86c:	e3520013 	cmp	r2, #19
3480a870:	9a000014 	bls	3480a8c8 <realloc+0x344>
3480a874:	e5943000 	ldr	r3, [r4]
3480a878:	e352001b 	cmp	r2, #27
3480a87c:	92870010 	addls	r0, r7, #16
3480a880:	e5873008 	str	r3, [r7, #8]
3480a884:	e5943004 	ldr	r3, [r4, #4]
3480a888:	92844008 	addls	r4, r4, #8
3480a88c:	e587300c 	str	r3, [r7, #12]
3480a890:	9a00000c 	bls	3480a8c8 <realloc+0x344>
3480a894:	e5943008 	ldr	r3, [r4, #8]
3480a898:	e3520024 	cmp	r2, #36	; 0x24
3480a89c:	12870018 	addne	r0, r7, #24
3480a8a0:	02870020 	addeq	r0, r7, #32
3480a8a4:	e5873010 	str	r3, [r7, #16]
3480a8a8:	e594300c 	ldr	r3, [r4, #12]
3480a8ac:	12844010 	addne	r4, r4, #16
3480a8b0:	e5873014 	str	r3, [r7, #20]
3480a8b4:	05943010 	ldreq	r3, [r4, #16]
3480a8b8:	05873018 	streq	r3, [r7, #24]
3480a8bc:	05943014 	ldreq	r3, [r4, #20]
3480a8c0:	02844018 	addeq	r4, r4, #24
3480a8c4:	0587301c 	streq	r3, [r7, #28]
3480a8c8:	e5943000 	ldr	r3, [r4]
3480a8cc:	e5803000 	str	r3, [r0]
3480a8d0:	e5943004 	ldr	r3, [r4, #4]
3480a8d4:	e5803004 	str	r3, [r0, #4]
3480a8d8:	e5943008 	ldr	r3, [r4, #8]
3480a8dc:	e5803008 	str	r3, [r0, #8]
	newsize += prevsize;
3480a8e0:	e1a05006 	mov	r5, r6
3480a8e4:	e1a0b007 	mov	fp, r7
3480a8e8:	ea000037 	b	3480a9cc <realloc+0x448>
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a8ec:	e1a01004 	mov	r1, r4
3480a8f0:	eb0044c1 	bl	3481bbfc <memcpy>
3480a8f4:	eafffff9 	b	3480a8e0 <realloc+0x35c>
    newmem = mALLOc (bytes);
3480a8f8:	ebfffd76 	bl	34809ed8 <malloc>
    if (newmem == 0)  /* propagate failure */
3480a8fc:	e2506000 	subs	r6, r0, #0
3480a900:	0affff23 	beq	3480a594 <realloc+0x10>
    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a904:	e5143004 	ldr	r3, [r4, #-4]
3480a908:	e2462008 	sub	r2, r6, #8
3480a90c:	e3c33001 	bic	r3, r3, #1
3480a910:	e08b3003 	add	r3, fp, r3
3480a914:	e1520003 	cmp	r2, r3
      newsize += chunksize(newp);
3480a918:	05163004 	ldreq	r3, [r6, #-4]
3480a91c:	03c33003 	biceq	r3, r3, #3
3480a920:	00855003 	addeq	r5, r5, r3
    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a924:	0a000028 	beq	3480a9cc <realloc+0x448>
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a928:	e2452004 	sub	r2, r5, #4
3480a92c:	e3520024 	cmp	r2, #36	; 0x24
3480a930:	8a00001f 	bhi	3480a9b4 <realloc+0x430>
3480a934:	e3520013 	cmp	r2, #19
3480a938:	91a03006 	movls	r3, r6
3480a93c:	91a02004 	movls	r2, r4
3480a940:	9a000014 	bls	3480a998 <realloc+0x414>
3480a944:	e5943000 	ldr	r3, [r4]
3480a948:	e352001b 	cmp	r2, #27
3480a94c:	92842008 	addls	r2, r4, #8
3480a950:	e5863000 	str	r3, [r6]
3480a954:	e5943004 	ldr	r3, [r4, #4]
3480a958:	e5863004 	str	r3, [r6, #4]
3480a95c:	92863008 	addls	r3, r6, #8
3480a960:	9a00000c 	bls	3480a998 <realloc+0x414>
3480a964:	e5943008 	ldr	r3, [r4, #8]
3480a968:	e3520024 	cmp	r2, #36	; 0x24
3480a96c:	12842010 	addne	r2, r4, #16
3480a970:	02842018 	addeq	r2, r4, #24
3480a974:	e5863008 	str	r3, [r6, #8]
3480a978:	e594300c 	ldr	r3, [r4, #12]
3480a97c:	e586300c 	str	r3, [r6, #12]
3480a980:	12863010 	addne	r3, r6, #16
3480a984:	05943010 	ldreq	r3, [r4, #16]
3480a988:	05863010 	streq	r3, [r6, #16]
3480a98c:	02863018 	addeq	r3, r6, #24
3480a990:	05941014 	ldreq	r1, [r4, #20]
3480a994:	05861014 	streq	r1, [r6, #20]
3480a998:	e5921000 	ldr	r1, [r2]
3480a99c:	e5831000 	str	r1, [r3]
3480a9a0:	e5921004 	ldr	r1, [r2, #4]
3480a9a4:	e5831004 	str	r1, [r3, #4]
3480a9a8:	e5922008 	ldr	r2, [r2, #8]
3480a9ac:	e5832008 	str	r2, [r3, #8]
3480a9b0:	ea000001 	b	3480a9bc <realloc+0x438>
3480a9b4:	e1a01004 	mov	r1, r4
3480a9b8:	eb00448f 	bl	3481bbfc <memcpy>
    fREe(oldmem);
3480a9bc:	e1a00004 	mov	r0, r4
3480a9c0:	ebfffcba 	bl	34809cb0 <free>
    return newmem;
3480a9c4:	e1a00006 	mov	r0, r6
3480a9c8:	ea000018 	b	3480aa30 <realloc+0x4ac>
  if (newsize - nb >= MINSIZE) /* split off remainder */
3480a9cc:	e0692005 	rsb	r2, r9, r5
3480a9d0:	e59b3004 	ldr	r3, [fp, #4]
3480a9d4:	e352000f 	cmp	r2, #15
3480a9d8:	9a00000c 	bls	3480aa10 <realloc+0x48c>
    remainder = chunk_at_offset(newp, nb);
3480a9dc:	e08b0009 	add	r0, fp, r9
    set_head_size(newp, nb);
3480a9e0:	e2033001 	and	r3, r3, #1
3480a9e4:	e1899003 	orr	r9, r9, r3
    set_head(remainder, remainder_size | PREV_INUSE);
3480a9e8:	e3823001 	orr	r3, r2, #1
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a9ec:	e0802002 	add	r2, r0, r2
    set_head_size(newp, nb);
3480a9f0:	e58b9004 	str	r9, [fp, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
3480a9f4:	e5803004 	str	r3, [r0, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480a9f8:	e2800008 	add	r0, r0, #8
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a9fc:	e5923004 	ldr	r3, [r2, #4]
3480aa00:	e3833001 	orr	r3, r3, #1
3480aa04:	e5823004 	str	r3, [r2, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480aa08:	ebfffca8 	bl	34809cb0 <free>
3480aa0c:	ea000006 	b	3480aa2c <realloc+0x4a8>
    set_head_size(newp, newsize);
3480aa10:	e2033001 	and	r3, r3, #1
    set_inuse_bit_at_offset(newp, newsize);
3480aa14:	e08b2005 	add	r2, fp, r5
    set_head_size(newp, newsize);
3480aa18:	e1853003 	orr	r3, r5, r3
3480aa1c:	e58b3004 	str	r3, [fp, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480aa20:	e5923004 	ldr	r3, [r2, #4]
3480aa24:	e3833001 	orr	r3, r3, #1
3480aa28:	e5823004 	str	r3, [r2, #4]
  return chunk2mem(newp);
3480aa2c:	e28b0008 	add	r0, fp, #8
}
3480aa30:	e28dd008 	add	sp, sp, #8
3480aa34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480aa38:	34827290 	.word	0x34827290

3480aa3c <memalign>:
{
3480aa3c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480aa40:	e1a07000 	mov	r7, r0
  if ((long)bytes < 0) return 0;
3480aa44:	e2510000 	subs	r0, r1, #0
3480aa48:	aa000001 	bge	3480aa54 <memalign+0x18>
3480aa4c:	e3a00000 	mov	r0, #0
3480aa50:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480aa54:	e3570008 	cmp	r7, #8
3480aa58:	8a000001 	bhi	3480aa64 <memalign+0x28>
}
3480aa5c:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480aa60:	eafffd1c 	b	34809ed8 <malloc>
  nb = request2size(bytes);
3480aa64:	e280500b 	add	r5, r0, #11
  if (alignment <  MINSIZE) alignment = MINSIZE;
3480aa68:	e357000f 	cmp	r7, #15
3480aa6c:	93a07010 	movls	r7, #16
  nb = request2size(bytes);
3480aa70:	e3550016 	cmp	r5, #22
3480aa74:	c3c55007 	bicgt	r5, r5, #7
3480aa78:	d3a05010 	movle	r5, #16
3480aa7c:	e2870010 	add	r0, r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
3480aa80:	e0800005 	add	r0, r0, r5
3480aa84:	ebfffd13 	bl	34809ed8 <malloc>
  if (m == 0) return 0; /* propagate failure */
3480aa88:	e2509000 	subs	r9, r0, #0
3480aa8c:	0affffee 	beq	3480aa4c <memalign+0x10>
  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480aa90:	e1a01007 	mov	r1, r7
  p = mem2chunk(m);
3480aa94:	e2494008 	sub	r4, r9, #8
  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480aa98:	fa0051f7 	blx	3481f27c <__aeabi_uidivmod>
3480aa9c:	e3510000 	cmp	r1, #0
3480aaa0:	0a000018 	beq	3480ab08 <memalign+0xcc>
    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
3480aaa4:	e2476001 	sub	r6, r7, #1
3480aaa8:	e2673000 	rsb	r3, r7, #0
3480aaac:	e0896006 	add	r6, r9, r6
    fREe(chunk2mem(p));
3480aab0:	e1a00009 	mov	r0, r9
    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
3480aab4:	e0066003 	and	r6, r6, r3
3480aab8:	e2466008 	sub	r6, r6, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480aabc:	e0643006 	rsb	r3, r4, r6
3480aac0:	e353000f 	cmp	r3, #15
    newsize = chunksize(p) - leadsize;
3480aac4:	e5193004 	ldr	r3, [r9, #-4]
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480aac8:	90866007 	addls	r6, r6, r7
    leadsize = brk - (char*)(p);
3480aacc:	e0644006 	rsb	r4, r4, r6
    newsize = chunksize(p) - leadsize;
3480aad0:	e3c33003 	bic	r3, r3, #3
3480aad4:	e0643003 	rsb	r3, r4, r3
    set_head(newp, newsize | PREV_INUSE);
3480aad8:	e3832001 	orr	r2, r3, #1
    set_inuse_bit_at_offset(newp, newsize);
3480aadc:	e0863003 	add	r3, r6, r3
    set_head(newp, newsize | PREV_INUSE);
3480aae0:	e5862004 	str	r2, [r6, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480aae4:	e5932004 	ldr	r2, [r3, #4]
3480aae8:	e3822001 	orr	r2, r2, #1
3480aaec:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
3480aaf0:	e5193004 	ldr	r3, [r9, #-4]
3480aaf4:	e2033001 	and	r3, r3, #1
3480aaf8:	e1844003 	orr	r4, r4, r3
3480aafc:	e5094004 	str	r4, [r9, #-4]
3480ab00:	e1a04006 	mov	r4, r6
    fREe(chunk2mem(p));
3480ab04:	ebfffc69 	bl	34809cb0 <free>
  remainder_size = chunksize(p) - nb;
3480ab08:	e5943004 	ldr	r3, [r4, #4]
3480ab0c:	e3c33003 	bic	r3, r3, #3
3480ab10:	e0653003 	rsb	r3, r5, r3
  if (remainder_size >= (long)MINSIZE)
3480ab14:	e353000f 	cmp	r3, #15
3480ab18:	da000008 	ble	3480ab40 <memalign+0x104>
    remainder = chunk_at_offset(p, nb);
3480ab1c:	e0840005 	add	r0, r4, r5
    set_head(remainder, remainder_size | PREV_INUSE);
3480ab20:	e3833001 	orr	r3, r3, #1
3480ab24:	e5803004 	str	r3, [r0, #4]
    fREe(chunk2mem(remainder));
3480ab28:	e2800008 	add	r0, r0, #8
    set_head_size(p, nb);
3480ab2c:	e5941004 	ldr	r1, [r4, #4]
3480ab30:	e2011001 	and	r1, r1, #1
3480ab34:	e1855001 	orr	r5, r5, r1
3480ab38:	e5845004 	str	r5, [r4, #4]
    fREe(chunk2mem(remainder));
3480ab3c:	ebfffc5b 	bl	34809cb0 <free>
  return chunk2mem(p);
3480ab40:	e2840008 	add	r0, r4, #8
}
3480ab44:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

3480ab48 <valloc>:
  return mEMALIGn (malloc_getpagesize, bytes);
3480ab48:	e1a01000 	mov	r1, r0
3480ab4c:	e3a00a01 	mov	r0, #4096	; 0x1000
3480ab50:	eaffffb9 	b	3480aa3c <memalign>

3480ab54 <pvalloc>:
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
3480ab54:	e2801eff 	add	r1, r0, #4080	; 0xff0
3480ab58:	e3a00a01 	mov	r0, #4096	; 0x1000
3480ab5c:	e281100f 	add	r1, r1, #15
3480ab60:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
3480ab64:	e3c1100f 	bic	r1, r1, #15
3480ab68:	eaffffb3 	b	3480aa3c <memalign>

3480ab6c <cfree>:
  fREe(mem);
3480ab6c:	eafffc4f 	b	34809cb0 <free>

3480ab70 <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
3480ab70:	e3500000 	cmp	r0, #0
3480ab74:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
3480ab78:	e5103004 	ldr	r3, [r0, #-4]
3480ab7c:	e3130002 	tst	r3, #2
3480ab80:	1a000006 	bne	3480aba0 <malloc_usable_size+0x30>
    {
      if (!inuse(p)) return 0;
3480ab84:	e3c32001 	bic	r2, r3, #1
3480ab88:	e0800002 	add	r0, r0, r2
3480ab8c:	e5100004 	ldr	r0, [r0, #-4]
3480ab90:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
3480ab94:	13c30003 	bicne	r0, r3, #3
3480ab98:	12400004 	subne	r0, r0, #4
3480ab9c:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
3480aba0:	e3c30003 	bic	r0, r3, #3
3480aba4:	e2400008 	sub	r0, r0, #8
  }
}
3480aba8:	e12fff1e 	bx	lr

3480abac <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
3480abac:	e2800004 	add	r0, r0, #4
3480abb0:	e3500003 	cmp	r0, #3
3480abb4:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480abb8:	ea000012 	b	3480ac08 <mallopt+0x5c>
3480abbc:	3480abf0 	.word	0x3480abf0
3480abc0:	3480abe4 	.word	0x3480abe4
3480abc4:	3480abd8 	.word	0x3480abd8
3480abc8:	3480abcc 	.word	0x3480abcc
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
3480abcc:	e59f303c 	ldr	r3, [pc, #60]	; 3480ac10 <mallopt+0x64>
3480abd0:	e583140c 	str	r1, [r3, #1036]	; 0x40c
3480abd4:	ea000009 	b	3480ac00 <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
3480abd8:	e59f3034 	ldr	r3, [pc, #52]	; 3480ac14 <mallopt+0x68>
3480abdc:	e5831034 	str	r1, [r3, #52]	; 0x34
3480abe0:	ea000006 	b	3480ac00 <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
3480abe4:	e59f3024 	ldr	r3, [pc, #36]	; 3480ac10 <mallopt+0x64>
3480abe8:	e5831410 	str	r1, [r3, #1040]	; 0x410
3480abec:	ea000003 	b	3480ac00 <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480abf0:	e3510000 	cmp	r1, #0
3480abf4:	1a000003 	bne	3480ac08 <mallopt+0x5c>
3480abf8:	e59f3014 	ldr	r3, [pc, #20]	; 3480ac14 <mallopt+0x68>
3480abfc:	e5831040 	str	r1, [r3, #64]	; 0x40
3480ac00:	e3a00001 	mov	r0, #1
3480ac04:	e12fff1e 	bx	lr
3480ac08:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
3480ac0c:	e12fff1e 	bx	lr
3480ac10:	34827290 	.word	0x34827290
3480ac14:	34828a58 	.word	0x34828a58

3480ac18 <env_get_char_spec>:
	.apply = env_check_apply,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
3480ac18:	e5983010 	ldr	r3, [r8, #16]
}
3480ac1c:	e7d00003 	ldrb	r0, [r0, r3]
3480ac20:	e12fff1e 	bx	lr

3480ac24 <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
3480ac24:	e5982014 	ldr	r2, [r8, #20]
3480ac28:	e1a03008 	mov	r3, r8
3480ac2c:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
3480ac30:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
3480ac34:	059f3004 	ldreq	r3, [pc, #4]	; 3480ac40 <env_get_addr+0x1c>
3480ac38:	e0830000 	add	r0, r3, r0
}
3480ac3c:	e12fff1e 	bx	lr
3480ac40:	3481f7aa 	.word	0x3481f7aa

3480ac44 <env_get_char_memory>:
{
3480ac44:	e92d4010 	push	{r4, lr}
	return *env_get_addr(index);
3480ac48:	ebfffff5 	bl	3480ac24 <env_get_addr>
}
3480ac4c:	e5d00000 	ldrb	r0, [r0]
3480ac50:	e8bd8010 	pop	{r4, pc}

3480ac54 <env_get_char>:
	if (gd->flags & GD_FLG_RELOC)
3480ac54:	e5981004 	ldr	r1, [r8, #4]
3480ac58:	e3110001 	tst	r1, #1
3480ac5c:	0a000000 	beq	3480ac64 <env_get_char+0x10>
		return env_get_char_memory(index);
3480ac60:	eafffff7 	b	3480ac44 <env_get_char_memory>
	if (gd->env_valid)
3480ac64:	e5983014 	ldr	r3, [r8, #20]
3480ac68:	e3530000 	cmp	r3, #0
3480ac6c:	0a000000 	beq	3480ac74 <env_get_char+0x20>
		return env_get_char_spec(index);
3480ac70:	eaffffe8 	b	3480ac18 <env_get_char_spec>
}
3480ac74:	e59f3004 	ldr	r3, [pc, #4]	; 3480ac80 <env_get_char+0x2c>
3480ac78:	e7d30000 	ldrb	r0, [r3, r0]
3480ac7c:	e12fff1e 	bx	lr
3480ac80:	3481f7aa 	.word	0x3481f7aa

3480ac84 <set_default_env>:

void set_default_env(const char *s)
{
3480ac84:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
3480ac88:	e2504000 	subs	r4, r0, #0
3480ac8c:	0a00000a 	beq	3480acbc <set_default_env+0x38>
		if (*s == '!') {
3480ac90:	e5d43000 	ldrb	r3, [r4]
3480ac94:	e3530021 	cmp	r3, #33	; 0x21
3480ac98:	1a000004 	bne	3480acb0 <set_default_env+0x2c>
			printf("*** Warning - %s, "
3480ac9c:	e2841001 	add	r1, r4, #1
3480aca0:	e59f007c 	ldr	r0, [pc, #124]	; 3480ad24 <set_default_env+0xa0>
3480aca4:	ebfffabc 	bl	3480979c <printf>
	int do_apply = 0;
3480aca8:	e3a04000 	mov	r4, #0
3480acac:	ea000004 	b	3480acc4 <set_default_env+0x40>
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
			puts(s);
3480acb0:	ebfffaad 	bl	3480976c <puts>
			do_apply = 1;
3480acb4:	e3a04001 	mov	r4, #1
3480acb8:	ea000001 	b	3480acc4 <set_default_env+0x40>
		}
	} else {
		puts("Using default environment\n\n");
3480acbc:	e59f0064 	ldr	r0, [pc, #100]	; 3480ad28 <set_default_env+0xa4>
3480acc0:	ebfffaa9 	bl	3480976c <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
3480acc4:	e3a03000 	mov	r3, #0
3480acc8:	e58d400c 	str	r4, [sp, #12]
3480accc:	e58d3008 	str	r3, [sp, #8]
3480acd0:	e30026f9 	movw	r2, #1785	; 0x6f9
3480acd4:	e58d3004 	str	r3, [sp, #4]
3480acd8:	e58d3000 	str	r3, [sp]
3480acdc:	e59f1048 	ldr	r1, [pc, #72]	; 3480ad2c <set_default_env+0xa8>
3480ace0:	e59f0048 	ldr	r0, [pc, #72]	; 3480ad30 <set_default_env+0xac>
3480ace4:	eb004010 	bl	3481ad2c <himport_r>
3480ace8:	e3500000 	cmp	r0, #0
3480acec:	1a000007 	bne	3480ad10 <set_default_env+0x8c>
			sizeof(default_environment), '\0', 0,
			0, NULL, do_apply) == 0)
		error("Environment import failed: errno = %d\n", errno);
3480acf0:	e59f303c 	ldr	r3, [pc, #60]	; 3480ad34 <set_default_env+0xb0>
3480acf4:	e59f103c 	ldr	r1, [pc, #60]	; 3480ad38 <set_default_env+0xb4>
3480acf8:	e59f203c 	ldr	r2, [pc, #60]	; 3480ad3c <set_default_env+0xb8>
3480acfc:	e58d3000 	str	r3, [sp]
3480ad00:	e3a030d8 	mov	r3, #216	; 0xd8
3480ad04:	e5911000 	ldr	r1, [r1]
3480ad08:	e59f0030 	ldr	r0, [pc, #48]	; 3480ad40 <set_default_env+0xbc>
3480ad0c:	ebfffaa2 	bl	3480979c <printf>

	gd->flags |= GD_FLG_ENV_READY;
3480ad10:	e5983004 	ldr	r3, [r8, #4]
3480ad14:	e3833080 	orr	r3, r3, #128	; 0x80
3480ad18:	e5883004 	str	r3, [r8, #4]
}
3480ad1c:	e28dd010 	add	sp, sp, #16
3480ad20:	e8bd8010 	pop	{r4, pc}
3480ad24:	34824de9 	.word	0x34824de9
3480ad28:	34824e17 	.word	0x34824e17
3480ad2c:	3481f7aa 	.word	0x3481f7aa
3480ad30:	348276a4 	.word	0x348276a4
3480ad34:	3481fea3 	.word	0x3481fea3
3480ad38:	3482a918 	.word	0x3482a918
3480ad3c:	34824e33 	.word	0x34824e33
3480ad40:	34823ece 	.word	0x34823ece

3480ad44 <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
3480ad44:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
3480ad48:	e3a03001 	mov	r3, #1
3480ad4c:	e98d000b 	stmib	sp, {r0, r1, r3}
3480ad50:	e30026f9 	movw	r2, #1785	; 0x6f9
3480ad54:	e58d3000 	str	r3, [sp]
3480ad58:	e3a03000 	mov	r3, #0
3480ad5c:	e59f100c 	ldr	r1, [pc, #12]	; 3480ad70 <set_default_vars+0x2c>
3480ad60:	e59f000c 	ldr	r0, [pc, #12]	; 3480ad74 <set_default_vars+0x30>
3480ad64:	eb003ff0 	bl	3481ad2c <himport_r>
				sizeof(default_environment), '\0', H_NOCLEAR,
				nvars, vars, 1 /* do_apply */);
}
3480ad68:	e28dd014 	add	sp, sp, #20
3480ad6c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
3480ad70:	3481f7aa 	.word	0x3481f7aa
3480ad74:	348276a4 	.word	0x348276a4

3480ad78 <env_import>:
 */
int env_import(const char *buf, int check)
{
	env_t *ep = (env_t *)buf;

	if (check) {
3480ad78:	e3510000 	cmp	r1, #0
{
3480ad7c:	e92d4010 	push	{r4, lr}
3480ad80:	e2804004 	add	r4, r0, #4
3480ad84:	e24dd018 	sub	sp, sp, #24
	if (check) {
3480ad88:	0a00000e 	beq	3480adc8 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
3480ad8c:	e1a01000 	mov	r1, r0
3480ad90:	e3a02004 	mov	r2, #4
3480ad94:	e28d0014 	add	r0, sp, #20
3480ad98:	eb004397 	bl	3481bbfc <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
3480ad9c:	e59f2094 	ldr	r2, [pc, #148]	; 3480ae38 <env_import+0xc0>
3480ada0:	e1a01004 	mov	r1, r4
3480ada4:	e3a00000 	mov	r0, #0
3480ada8:	eb003c2e 	bl	34819e68 <crc32>
3480adac:	e59d3014 	ldr	r3, [sp, #20]
3480adb0:	e1500003 	cmp	r0, r3
3480adb4:	0a000003 	beq	3480adc8 <env_import+0x50>
			set_default_env("!bad CRC");
3480adb8:	e59f007c 	ldr	r0, [pc, #124]	; 3480ae3c <env_import+0xc4>
			return 0;
3480adbc:	e3a04000 	mov	r4, #0
			set_default_env("!bad CRC");
3480adc0:	ebffffaf 	bl	3480ac84 <set_default_env>
3480adc4:	ea000018 	b	3480ae2c <env_import+0xb4>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
3480adc8:	e3a03000 	mov	r3, #0
3480adcc:	e1a01004 	mov	r1, r4
3480add0:	e58d300c 	str	r3, [sp, #12]
3480add4:	e58d3008 	str	r3, [sp, #8]
3480add8:	e58d3004 	str	r3, [sp, #4]
3480addc:	e58d3000 	str	r3, [sp]
3480ade0:	e59f2050 	ldr	r2, [pc, #80]	; 3480ae38 <env_import+0xc0>
3480ade4:	e59f0054 	ldr	r0, [pc, #84]	; 3480ae40 <env_import+0xc8>
3480ade8:	eb003fcf 	bl	3481ad2c <himport_r>
3480adec:	e2504000 	subs	r4, r0, #0
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480adf0:	15983004 	ldrne	r3, [r8, #4]
		return 1;
3480adf4:	13a04001 	movne	r4, #1
		gd->flags |= GD_FLG_ENV_READY;
3480adf8:	13833080 	orrne	r3, r3, #128	; 0x80
3480adfc:	15883004 	strne	r3, [r8, #4]
		return 1;
3480ae00:	1a000009 	bne	3480ae2c <env_import+0xb4>
	}

	error("Cannot import environment: errno = %d\n", errno);
3480ae04:	e59f3038 	ldr	r3, [pc, #56]	; 3480ae44 <env_import+0xcc>
3480ae08:	e59f1038 	ldr	r1, [pc, #56]	; 3480ae48 <env_import+0xd0>
3480ae0c:	e59f2038 	ldr	r2, [pc, #56]	; 3480ae4c <env_import+0xd4>
3480ae10:	e58d3000 	str	r3, [sp]
3480ae14:	e3a03f41 	mov	r3, #260	; 0x104
3480ae18:	e5911000 	ldr	r1, [r1]
3480ae1c:	e59f002c 	ldr	r0, [pc, #44]	; 3480ae50 <env_import+0xd8>
3480ae20:	ebfffa5d 	bl	3480979c <printf>

	set_default_env("!import failed");
3480ae24:	e59f0028 	ldr	r0, [pc, #40]	; 3480ae54 <env_import+0xdc>
3480ae28:	ebffff95 	bl	3480ac84 <set_default_env>

	return 0;
}
3480ae2c:	e1a00004 	mov	r0, r4
3480ae30:	e28dd018 	add	sp, sp, #24
3480ae34:	e8bd8010 	pop	{r4, pc}
3480ae38:	0003fffc 	.word	0x0003fffc
3480ae3c:	34824e40 	.word	0x34824e40
3480ae40:	348276a4 	.word	0x348276a4
3480ae44:	3481feb3 	.word	0x3481feb3
3480ae48:	3482a918 	.word	0x3482a918
3480ae4c:	34824e33 	.word	0x34824e33
3480ae50:	34824e49 	.word	0x34824e49
3480ae54:	34824e86 	.word	0x34824e86

3480ae58 <env_relocate>:
void env_relocate(void)
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480ae58:	e5980014 	ldr	r0, [r8, #20]
3480ae5c:	e3500000 	cmp	r0, #0
3480ae60:	1a000000 	bne	3480ae68 <env_relocate+0x10>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
3480ae64:	eaffff86 	b	3480ac84 <set_default_env>
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
3480ae68:	eaffffff 	b	3480ae6c <env_relocate_spec>

3480ae6c <env_relocate_spec>:
DECLARE_GLOBAL_DATA_PTR;

env_t *env_ptr;

void env_relocate_spec(void)
{
3480ae6c:	e12fff1e 	bx	lr

3480ae70 <env_init>:
 *
 * We are still running from ROM, so data use is limited
 */
int env_init(void)
{
	gd->env_addr	= (ulong)&default_environment[0];
3480ae70:	e59f200c 	ldr	r2, [pc, #12]	; 3480ae84 <env_init+0x14>
	gd->env_valid	= 0;
3480ae74:	e3a00000 	mov	r0, #0
	gd->env_addr	= (ulong)&default_environment[0];
3480ae78:	e5882010 	str	r2, [r8, #16]
	gd->env_valid	= 0;
3480ae7c:	e5880014 	str	r0, [r8, #20]

	return 0;
}
3480ae80:	e12fff1e 	bx	lr
3480ae84:	3481f7aa 	.word	0x3481f7aa

3480ae88 <dummy>:
#include <spi.h>

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
3480ae88:	e12fff1e 	bx	lr

3480ae8c <get_version>:
}

unsigned long get_version(void)
{
	return XF_VERSION;
}
3480ae8c:	e3a00006 	mov	r0, #6
3480ae90:	e12fff1e 	bx	lr

3480ae94 <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
3480ae94:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
3480ae98:	e3a00070 	mov	r0, #112	; 0x70
3480ae9c:	e1a04008 	mov	r4, r8
3480aea0:	ebfffc0c 	bl	34809ed8 <malloc>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480aea4:	e59f212c 	ldr	r2, [pc, #300]	; 3480afd8 <jumptable_init+0x144>
3480aea8:	e5840054 	str	r0, [r4, #84]	; 0x54
3480aeac:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
3480aeb0:	e59f1124 	ldr	r1, [pc, #292]	; 3480afdc <jumptable_init+0x148>
EXPORT_FUNC(get_version)
3480aeb4:	e5832000 	str	r2, [r3]
EXPORT_FUNC(getc)
3480aeb8:	e59f2120 	ldr	r2, [pc, #288]	; 3480afe0 <jumptable_init+0x14c>
3480aebc:	e5983054 	ldr	r3, [r8, #84]	; 0x54
3480aec0:	e5832004 	str	r2, [r3, #4]
EXPORT_FUNC(tstc)
3480aec4:	e59f2118 	ldr	r2, [pc, #280]	; 3480afe4 <jumptable_init+0x150>
3480aec8:	e5983054 	ldr	r3, [r8, #84]	; 0x54
3480aecc:	e5832008 	str	r2, [r3, #8]
EXPORT_FUNC(putc)
3480aed0:	e59f2110 	ldr	r2, [pc, #272]	; 3480afe8 <jumptable_init+0x154>
3480aed4:	e5983054 	ldr	r3, [r8, #84]	; 0x54
3480aed8:	e583200c 	str	r2, [r3, #12]
EXPORT_FUNC(puts)
3480aedc:	e59f2108 	ldr	r2, [pc, #264]	; 3480afec <jumptable_init+0x158>
3480aee0:	e5983054 	ldr	r3, [r8, #84]	; 0x54
3480aee4:	e5832010 	str	r2, [r3, #16]
EXPORT_FUNC(printf)
3480aee8:	e59f2100 	ldr	r2, [pc, #256]	; 3480aff0 <jumptable_init+0x15c>
3480aeec:	e5983054 	ldr	r3, [r8, #84]	; 0x54
3480aef0:	e5832014 	str	r2, [r3, #20]
EXPORT_FUNC(install_hdlr)
3480aef4:	e59f30f8 	ldr	r3, [pc, #248]	; 3480aff4 <jumptable_init+0x160>
3480aef8:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aefc:	e5823018 	str	r3, [r2, #24]
EXPORT_FUNC(free_hdlr)
3480af00:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af04:	e582301c 	str	r3, [r2, #28]
EXPORT_FUNC(malloc)
3480af08:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af0c:	e5821020 	str	r1, [r2, #32]
EXPORT_FUNC(free)
3480af10:	e59f10e0 	ldr	r1, [pc, #224]	; 3480aff8 <jumptable_init+0x164>
3480af14:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af18:	e5821024 	str	r1, [r2, #36]	; 0x24
EXPORT_FUNC(udelay)
3480af1c:	e59f10d8 	ldr	r1, [pc, #216]	; 3480affc <jumptable_init+0x168>
3480af20:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af24:	e5821028 	str	r1, [r2, #40]	; 0x28
EXPORT_FUNC(get_timer)
3480af28:	e59f10d0 	ldr	r1, [pc, #208]	; 3480b000 <jumptable_init+0x16c>
3480af2c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af30:	e582102c 	str	r1, [r2, #44]	; 0x2c
EXPORT_FUNC(vprintf)
3480af34:	e59f10c8 	ldr	r1, [pc, #200]	; 3480b004 <jumptable_init+0x170>
3480af38:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af3c:	e5821030 	str	r1, [r2, #48]	; 0x30
EXPORT_FUNC(do_reset)
3480af40:	e59f10c0 	ldr	r1, [pc, #192]	; 3480b008 <jumptable_init+0x174>
3480af44:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af48:	e5821034 	str	r1, [r2, #52]	; 0x34
EXPORT_FUNC(getenv)
3480af4c:	e59f10b8 	ldr	r1, [pc, #184]	; 3480b00c <jumptable_init+0x178>
3480af50:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af54:	e5821038 	str	r1, [r2, #56]	; 0x38
EXPORT_FUNC(setenv)
3480af58:	e59f10b0 	ldr	r1, [pc, #176]	; 3480b010 <jumptable_init+0x17c>
3480af5c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af60:	e582103c 	str	r1, [r2, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
3480af64:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af68:	e59f10a4 	ldr	r1, [pc, #164]	; 3480b014 <jumptable_init+0x180>
3480af6c:	e5821040 	str	r1, [r2, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
3480af70:	e59f10a0 	ldr	r1, [pc, #160]	; 3480b018 <jumptable_init+0x184>
3480af74:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af78:	e5821044 	str	r1, [r2, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
3480af7c:	e59f1098 	ldr	r1, [pc, #152]	; 3480b01c <jumptable_init+0x188>
3480af80:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af84:	e5821048 	str	r1, [r2, #72]	; 0x48
EXPORT_FUNC(strcmp)
3480af88:	e59f1090 	ldr	r1, [pc, #144]	; 3480b020 <jumptable_init+0x18c>
3480af8c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af90:	e582104c 	str	r1, [r2, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
3480af94:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480af98:	e5823050 	str	r3, [r2, #80]	; 0x50
EXPORT_FUNC(i2c_read)
3480af9c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afa0:	e5823054 	str	r3, [r2, #84]	; 0x54
EXPORT_FUNC(spi_init)
3480afa4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afa8:	e5823058 	str	r3, [r2, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
3480afac:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afb0:	e582305c 	str	r3, [r2, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
3480afb4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afb8:	e5823060 	str	r3, [r2, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
3480afbc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afc0:	e5823064 	str	r3, [r2, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
3480afc4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afc8:	e5823068 	str	r3, [r2, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
3480afcc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480afd0:	e582306c 	str	r3, [r2, #108]	; 0x6c
3480afd4:	e8bd8010 	pop	{r4, pc}
3480afd8:	3480ae8c 	.word	0x3480ae8c
3480afdc:	34809ed8 	.word	0x34809ed8
3480afe0:	348096dc 	.word	0x348096dc
3480afe4:	3480970c 	.word	0x3480970c
3480afe8:	3480973c 	.word	0x3480973c
3480afec:	3480976c 	.word	0x3480976c
3480aff0:	3480979c 	.word	0x3480979c
3480aff4:	3480ae88 	.word	0x3480ae88
3480aff8:	34809cb0 	.word	0x34809cb0
3480affc:	3481be0c 	.word	0x3481be0c
3480b000:	34801104 	.word	0x34801104
3480b004:	348097e8 	.word	0x348097e8
3480b008:	34801ef0 	.word	0x34801ef0
3480b00c:	34807b84 	.word	0x34807b84
3480b010:	34807774 	.word	0x34807774
3480b014:	3481c764 	.word	0x3481c764
3480b018:	3481c81c 	.word	0x3481c81c
3480b01c:	3481c894 	.word	0x3481c894
3480b020:	3481b820 	.word	0x3481b820

3480b024 <b_reset>:

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b024:	e5902000 	ldr	r2, [r0]
	o->length = 0;
3480b028:	e3a03000 	mov	r3, #0
3480b02c:	e5803004 	str	r3, [r0, #4]
	o->nonnull = 0;
3480b030:	e5803010 	str	r3, [r0, #16]
	if (o->data != NULL) *o->data = '\0';
3480b034:	e1520003 	cmp	r2, r3
3480b038:	15c23000 	strbne	r3, [r2]
3480b03c:	e12fff1e 	bx	lr

3480b040 <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480b040:	e5903000 	ldr	r3, [r0]
3480b044:	e2832001 	add	r2, r3, #1
3480b048:	e5802000 	str	r2, [r0]
3480b04c:	e5d30000 	ldrb	r0, [r3]
	if (ch=='\0') return EOF;
3480b050:	e3500000 	cmp	r0, #0
	return ch;
}
3480b054:	03e00000 	mvneq	r0, #0
3480b058:	e12fff1e 	bx	lr

3480b05c <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
3480b05c:	e5903000 	ldr	r3, [r0]
}
3480b060:	e5d30000 	ldrb	r0, [r3]
3480b064:	e12fff1e 	bx	lr

3480b068 <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
3480b068:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
3480b06c:	e5d30000 	ldrb	r0, [r3]
3480b070:	e12fff1e 	bx	lr

3480b074 <syntax_err>:
	 printf("syntax error\n");
3480b074:	e59f0000 	ldr	r0, [pc]	; 3480b07c <syntax_err+0x8>
3480b078:	eafff9c7 	b	3480979c <printf>
3480b07c:	34824e95 	.word	0x34824e95

3480b080 <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
3480b080:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
3480b084:	e3a05000 	mov	r5, #0
{
3480b088:	e1a04000 	mov	r4, r0
3480b08c:	e1a06005 	mov	r6, r5
3480b090:	e58d1004 	str	r1, [sp, #4]
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b094:	e3540000 	cmp	r4, #0
3480b098:	0a00002f 	beq	3480b15c <free_pipe_list+0xdc>
			ret_code = free_pipe_list(child->group,indent+3);
3480b09c:	e59d3004 	ldr	r3, [sp, #4]
3480b0a0:	e3a05000 	mov	r5, #0
3480b0a4:	e1a07005 	mov	r7, r5
3480b0a8:	e2833003 	add	r3, r3, #3
3480b0ac:	e58d3008 	str	r3, [sp, #8]
	for (i=0; i<pi->num_progs; i++) {
3480b0b0:	e5943000 	ldr	r3, [r4]
3480b0b4:	e1570003 	cmp	r7, r3
3480b0b8:	aa00001e 	bge	3480b138 <free_pipe_list+0xb8>
3480b0bc:	e3a03014 	mov	r3, #20
		child = &pi->progs[i];
3480b0c0:	e594b004 	ldr	fp, [r4, #4]
3480b0c4:	e00a0793 	mul	sl, r3, r7
		if (child->argv) {
3480b0c8:	e79b100a 	ldr	r1, [fp, sl]
		child = &pi->progs[i];
3480b0cc:	e08b900a 	add	r9, fp, sl
		if (child->argv) {
3480b0d0:	e3510000 	cmp	r1, #0
3480b0d4:	13a01000 	movne	r1, #0
3480b0d8:	0a00000e 	beq	3480b118 <free_pipe_list+0x98>
			for (a = 0; a < child->argc; a++) {
3480b0dc:	e5990004 	ldr	r0, [r9, #4]
3480b0e0:	e1510000 	cmp	r1, r0
3480b0e4:	aa000006 	bge	3480b104 <free_pipe_list+0x84>
				free(child->argv[a]);
3480b0e8:	e5990000 	ldr	r0, [r9]
3480b0ec:	e58d100c 	str	r1, [sp, #12]
3480b0f0:	e7900101 	ldr	r0, [r0, r1, lsl #2]
3480b0f4:	ebfffaed 	bl	34809cb0 <free>
			for (a = 0; a < child->argc; a++) {
3480b0f8:	e59d100c 	ldr	r1, [sp, #12]
3480b0fc:	e2811001 	add	r1, r1, #1
3480b100:	eafffff5 	b	3480b0dc <free_pipe_list+0x5c>
					free(child->argv);
3480b104:	e79b000a 	ldr	r0, [fp, sl]
3480b108:	ebfffae8 	bl	34809cb0 <free>
			child->argc = 0;
3480b10c:	e5896004 	str	r6, [r9, #4]
			child->argv=NULL;
3480b110:	e78b600a 	str	r6, [fp, sl]
3480b114:	ea000005 	b	3480b130 <free_pipe_list+0xb0>
		} else if (child->group) {
3480b118:	e5990008 	ldr	r0, [r9, #8]
3480b11c:	e3500000 	cmp	r0, #0
3480b120:	0a000002 	beq	3480b130 <free_pipe_list+0xb0>
			ret_code = free_pipe_list(child->group,indent+3);
3480b124:	e59d1008 	ldr	r1, [sp, #8]
3480b128:	ebffffd4 	bl	3480b080 <free_pipe_list>
3480b12c:	e1a05000 	mov	r5, r0
	for (i=0; i<pi->num_progs; i++) {
3480b130:	e2877001 	add	r7, r7, #1
3480b134:	eaffffdd 	b	3480b0b0 <free_pipe_list+0x30>
	free(pi->progs);   /* children are an array, they get freed all at once */
3480b138:	e5940004 	ldr	r0, [r4, #4]
3480b13c:	ebfffadb 	bl	34809cb0 <free>
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
3480b140:	e5947008 	ldr	r7, [r4, #8]
		pi->next=NULL;
		free(pi);
3480b144:	e1a00004 	mov	r0, r4
	pi->progs=NULL;
3480b148:	e5846004 	str	r6, [r4, #4]
		pi->next=NULL;
3480b14c:	e5846008 	str	r6, [r4, #8]
		free(pi);
3480b150:	ebfffad6 	bl	34809cb0 <free>
	for (pi=head; pi; pi=next) {
3480b154:	e1a04007 	mov	r4, r7
3480b158:	eaffffcd 	b	3480b094 <free_pipe_list+0x14>
	}
	return rcode;
}
3480b15c:	e1a00005 	mov	r0, r5
3480b160:	e28dd010 	add	sp, sp, #16
3480b164:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480b168 <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
3480b168:	e92d4010 	push	{r4, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
3480b16c:	ebfffb59 	bl	34809ed8 <malloc>
3480b170:	e3500000 	cmp	r0, #0
3480b174:	18bd8010 	popne	{r4, pc}
	    printf("ERROR : memory not allocated\n");
3480b178:	e59f0004 	ldr	r0, [pc, #4]	; 3480b184 <xmalloc+0x1c>
3480b17c:	ebfff986 	bl	3480979c <printf>
	    for(;;);
3480b180:	eafffffe 	b	3480b180 <xmalloc+0x18>
3480b184:	34824ea3 	.word	0x34824ea3

3480b188 <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
3480b188:	e92d4010 	push	{r4, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
3480b18c:	ebfffcfc 	bl	3480a584 <realloc>
3480b190:	e3500000 	cmp	r0, #0
3480b194:	18bd8010 	popne	{r4, pc}
	    printf("ERROR : memory not allocated\n");
3480b198:	e59f0004 	ldr	r0, [pc, #4]	; 3480b1a4 <xrealloc+0x1c>
3480b19c:	ebfff97e 	bl	3480979c <printf>
	    for(;;);
3480b1a0:	eafffffe 	b	3480b1a0 <xrealloc+0x18>
3480b1a4:	34824ea3 	.word	0x34824ea3

3480b1a8 <done_command>:
	struct child_prog *prog=ctx->child;
3480b1a8:	e5903000 	ldr	r3, [r0]
{
3480b1ac:	e92d4070 	push	{r4, r5, r6, lr}
	struct pipe *pi=ctx->pipe;
3480b1b0:	e5906008 	ldr	r6, [r0, #8]
	if (prog && prog->group == NULL
3480b1b4:	e3530000 	cmp	r3, #0
3480b1b8:	0a000008 	beq	3480b1e0 <done_command+0x38>
3480b1bc:	e5932008 	ldr	r2, [r3, #8]
3480b1c0:	e3520000 	cmp	r2, #0
3480b1c4:	1a000002 	bne	3480b1d4 <done_command+0x2c>
		 && prog->argv == NULL
3480b1c8:	e5933000 	ldr	r3, [r3]
3480b1cc:	e3530000 	cmp	r3, #0
3480b1d0:	0a000013 	beq	3480b224 <done_command+0x7c>
		pi->num_progs++;
3480b1d4:	e5963000 	ldr	r3, [r6]
3480b1d8:	e2833001 	add	r3, r3, #1
3480b1dc:	e5863000 	str	r3, [r6]
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480b1e0:	e5961000 	ldr	r1, [r6]
3480b1e4:	e3a05014 	mov	r5, #20
3480b1e8:	e1a04000 	mov	r4, r0
3480b1ec:	e5960004 	ldr	r0, [r6, #4]
3480b1f0:	e0215591 	mla	r1, r1, r5, r5
3480b1f4:	ebffffe3 	bl	3480b188 <xrealloc>
	prog = pi->progs + pi->num_progs;
3480b1f8:	e5963000 	ldr	r3, [r6]
	prog->argv = NULL;
3480b1fc:	e3a02000 	mov	r2, #0
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480b200:	e5860004 	str	r0, [r6, #4]
	prog = pi->progs + pi->num_progs;
3480b204:	e0050395 	mul	r5, r5, r3
3480b208:	e0803005 	add	r3, r0, r5
	prog->argv = NULL;
3480b20c:	e7802005 	str	r2, [r0, r5]
	prog->group = NULL;
3480b210:	e5832008 	str	r2, [r3, #8]
	prog->sp = 0;
3480b214:	e583200c 	str	r2, [r3, #12]
	prog->type = ctx->type;
3480b218:	e5942018 	ldr	r2, [r4, #24]
	ctx->child = prog;
3480b21c:	e5843000 	str	r3, [r4]
	prog->type = ctx->type;
3480b220:	e5832010 	str	r2, [r3, #16]
}
3480b224:	e3a00000 	mov	r0, #0
3480b228:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b22c <do_showvar>:
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b22c:	e3520001 	cmp	r2, #1
{
3480b230:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480b234:	e58d3000 	str	r3, [sp]
3480b238:	e1a07002 	mov	r7, r2
		for (cur = top_vars; cur; cur = cur->next) {
3480b23c:	059f30d4 	ldreq	r3, [pc, #212]	; 3480b318 <do_showvar+0xec>
3480b240:	05934000 	ldreq	r4, [r3]
	if (argc == 1) {		/* Print all env variables	*/
3480b244:	1a00000d 	bne	3480b280 <do_showvar+0x54>
		for (cur = top_vars; cur; cur = cur->next) {
3480b248:	e3540000 	cmp	r4, #0
3480b24c:	0a00002e 	beq	3480b30c <do_showvar+0xe0>
			printf ("%s=%s\n", cur->name, cur->value);
3480b250:	e8940006 	ldm	r4, {r1, r2}
3480b254:	e59f00c0 	ldr	r0, [pc, #192]	; 3480b31c <do_showvar+0xf0>
3480b258:	ebfff94f 	bl	3480979c <printf>
			if (ctrlc ()) {
3480b25c:	ebfff970 	bl	34809824 <ctrlc>
3480b260:	e3500000 	cmp	r0, #0
3480b264:	0a000003 	beq	3480b278 <do_showvar+0x4c>
				puts ("\n ** Abort\n");
3480b268:	e59f00b0 	ldr	r0, [pc, #176]	; 3480b320 <do_showvar+0xf4>
3480b26c:	ebfff93e 	bl	3480976c <puts>
				return 1;
3480b270:	e3a00001 	mov	r0, #1
3480b274:	ea000025 	b	3480b310 <do_showvar+0xe4>
		for (cur = top_vars; cur; cur = cur->next) {
3480b278:	e5944010 	ldr	r4, [r4, #16]
3480b27c:	eafffff1 	b	3480b248 <do_showvar+0x1c>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b280:	e59fb090 	ldr	fp, [pc, #144]	; 3480b318 <do_showvar+0xec>
3480b284:	e3a04000 	mov	r4, #0
3480b288:	e3a06001 	mov	r6, #1
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480b28c:	e1560007 	cmp	r6, r7
3480b290:	aa00001d 	bge	3480b30c <do_showvar+0xe0>
		char *name = argv[i];
3480b294:	e59d3000 	ldr	r3, [sp]
		k = -1;
3480b298:	e3e0a000 	mvn	sl, #0
		for (cur = top_vars; cur; cur = cur->next) {
3480b29c:	e59b5000 	ldr	r5, [fp]
		char *name = argv[i];
3480b2a0:	e7939106 	ldr	r9, [r3, r6, lsl #2]
		for (cur = top_vars; cur; cur = cur->next) {
3480b2a4:	e3550000 	cmp	r5, #0
3480b2a8:	0a00000f 	beq	3480b2ec <do_showvar+0xc0>
			if(strcmp (cur->name, name) == 0) {
3480b2ac:	e1a01009 	mov	r1, r9
3480b2b0:	e5950000 	ldr	r0, [r5]
3480b2b4:	eb004159 	bl	3481b820 <strcmp>
3480b2b8:	e2503000 	subs	r3, r0, #0
3480b2bc:	1a000005 	bne	3480b2d8 <do_showvar+0xac>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
3480b2c0:	e8950006 	ldm	r5, {r1, r2}
3480b2c4:	e59f0050 	ldr	r0, [pc, #80]	; 3480b31c <do_showvar+0xf0>
3480b2c8:	e58d3004 	str	r3, [sp, #4]
3480b2cc:	ebfff932 	bl	3480979c <printf>
				k = 0;
3480b2d0:	e59d3004 	ldr	r3, [sp, #4]
3480b2d4:	e1a0a003 	mov	sl, r3
			}
			if (ctrlc ()) {
3480b2d8:	ebfff951 	bl	34809824 <ctrlc>
3480b2dc:	e3500000 	cmp	r0, #0
3480b2e0:	1affffe0 	bne	3480b268 <do_showvar+0x3c>
		for (cur = top_vars; cur; cur = cur->next) {
3480b2e4:	e5955010 	ldr	r5, [r5, #16]
3480b2e8:	eaffffed 	b	3480b2a4 <do_showvar+0x78>
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
3480b2ec:	e37a0001 	cmn	sl, #1
3480b2f0:	1a000003 	bne	3480b304 <do_showvar+0xd8>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
3480b2f4:	e2844001 	add	r4, r4, #1
			printf ("## Error: \"%s\" not defined\n", name);
3480b2f8:	e1a01009 	mov	r1, r9
3480b2fc:	e59f0020 	ldr	r0, [pc, #32]	; 3480b324 <do_showvar+0xf8>
3480b300:	ebfff925 	bl	3480979c <printf>
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480b304:	e2866001 	add	r6, r6, #1
3480b308:	eaffffdf 	b	3480b28c <do_showvar+0x60>
		}
	}
	return rcode;
3480b30c:	e1a00004 	mov	r0, r4
}
3480b310:	e28dd008 	add	sp, sp, #8
3480b314:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b318:	34828aa0 	.word	0x34828aa0
3480b31c:	34823e49 	.word	0x34823e49
3480b320:	34824ec1 	.word	0x34824ec1
3480b324:	34823fb5 	.word	0x34823fb5

3480b328 <is_assignment>:
	if (s == NULL)
3480b328:	e3500000 	cmp	r0, #0
3480b32c:	012fff1e 	bxeq	lr
	if (!isalpha(*s)) return 0;
3480b330:	e59f2048 	ldr	r2, [pc, #72]	; 3480b380 <is_assignment+0x58>
3480b334:	e5d03000 	ldrb	r3, [r0]
3480b338:	e1a01002 	mov	r1, r2
3480b33c:	e7d23003 	ldrb	r3, [r2, r3]
3480b340:	e2133003 	ands	r3, r3, #3
3480b344:	0a00000b 	beq	3480b378 <is_assignment+0x50>
	while(isalnum(*s) || *s=='_') ++s;
3480b348:	e5f03001 	ldrb	r3, [r0, #1]!
3480b34c:	e7d12003 	ldrb	r2, [r1, r3]
3480b350:	e2122007 	ands	r2, r2, #7
3480b354:	13a02001 	movne	r2, #1
3480b358:	e353005f 	cmp	r3, #95	; 0x5f
3480b35c:	03822001 	orreq	r2, r2, #1
3480b360:	e3520000 	cmp	r2, #0
3480b364:	1afffff7 	bne	3480b348 <is_assignment+0x20>
	return *s=='=';
3480b368:	e243003d 	sub	r0, r3, #61	; 0x3d
3480b36c:	e16f0f10 	clz	r0, r0
3480b370:	e1a002a0 	lsr	r0, r0, #5
3480b374:	e12fff1e 	bx	lr
		return 0;
3480b378:	e1a00003 	mov	r0, r3
}
3480b37c:	e12fff1e 	bx	lr
3480b380:	34820934 	.word	0x34820934

3480b384 <file_get>:
	if (i->p && *i->p) {
3480b384:	e5903000 	ldr	r3, [r0]
{
3480b388:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480b38c:	e1a04000 	mov	r4, r0
	if (i->p && *i->p) {
3480b390:	e3530000 	cmp	r3, #0
3480b394:	1a000062 	bne	3480b524 <file_get+0x1a0>
3480b398:	ea00002d 	b	3480b454 <file_get+0xd0>
			while(! i->p  || strlen(i->p)==0 ) {
3480b39c:	eb00414d 	bl	3481b8d8 <strlen>
3480b3a0:	e3500000 	cmp	r0, #0
3480b3a4:	1a000052 	bne	3480b4f4 <file_get+0x170>
	i->__promptme = 1;
3480b3a8:	e3a03001 	mov	r3, #1
	n = strlen(console_buffer);
3480b3ac:	e59f7194 	ldr	r7, [pc, #404]	; 3480b548 <file_get+0x1c4>
	i->__promptme = 1;
3480b3b0:	e5843004 	str	r3, [r4, #4]
	console_buffer[n+1]= '\0';
3480b3b4:	e3a05000 	mov	r5, #0
	if (i->promptmode == 1) {
3480b3b8:	e5943008 	ldr	r3, [r4, #8]
	do_repeat = 0;
3480b3bc:	e3a09000 	mov	r9, #0
3480b3c0:	e59f6184 	ldr	r6, [pc, #388]	; 3480b54c <file_get+0x1c8>
3480b3c4:	e1a0a007 	mov	sl, r7
	if (i->promptmode == 1) {
3480b3c8:	e3530001 	cmp	r3, #1
		n = readline(CONFIG_SYS_PROMPT);
3480b3cc:	059f017c 	ldreq	r0, [pc, #380]	; 3480b550 <file_get+0x1cc>
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
3480b3d0:	159f017c 	ldrne	r0, [pc, #380]	; 3480b554 <file_get+0x1d0>
3480b3d4:	eb000b8a 	bl	3480e204 <readline>
	if (n == -1 ) {
3480b3d8:	e3700001 	cmn	r0, #1
	n = strlen(console_buffer);
3480b3dc:	e1a00007 	mov	r0, r7
		flag_repeat = 0;
3480b3e0:	03a03000 	moveq	r3, #0
		i->__promptme = 0;
3480b3e4:	05843004 	streq	r3, [r4, #4]
		flag_repeat = 0;
3480b3e8:	05863004 	streq	r3, [r6, #4]
	n = strlen(console_buffer);
3480b3ec:	eb004139 	bl	3481b8d8 <strlen>
	console_buffer[n] = '\n';
3480b3f0:	e1a03007 	mov	r3, r7
3480b3f4:	e3a0200a 	mov	r2, #10
3480b3f8:	e7e32000 	strb	r2, [r3, r0]!
	console_buffer[n+1]= '\0';
3480b3fc:	e5c35001 	strb	r5, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
3480b400:	ebfff921 	bl	3480988c <had_ctrlc>
3480b404:	e1500005 	cmp	r0, r5
3480b408:	15865004 	strne	r5, [r6, #4]
	clear_ctrlc();
3480b40c:	ebfff922 	bl	3480989c <clear_ctrlc>
	if (i->promptmode == 1) {
3480b410:	e594b008 	ldr	fp, [r4, #8]
	do_repeat = 0;
3480b414:	e59f5130 	ldr	r5, [pc, #304]	; 3480b54c <file_get+0x1c8>
3480b418:	e5869008 	str	r9, [r6, #8]
	if (i->promptmode == 1) {
3480b41c:	e35b0001 	cmp	fp, #1
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b420:	e5d73000 	ldrb	r3, [r7]
	if (i->promptmode == 1) {
3480b424:	1a000013 	bne	3480b478 <file_get+0xf4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b428:	e353000a 	cmp	r3, #10
3480b42c:	e285600c 	add	r6, r5, #12
3480b430:	1a00000b 	bne	3480b464 <file_get+0xe0>
3480b434:	e5953004 	ldr	r3, [r5, #4]
3480b438:	e1530009 	cmp	r3, r9
				do_repeat = 1;
3480b43c:	1585b008 	strne	fp, [r5, #8]
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b440:	1a000002 	bne	3480b450 <file_get+0xcc>
			strcpy(the_command,console_buffer);
3480b444:	e59f10fc 	ldr	r1, [pc, #252]	; 3480b548 <file_get+0x1c4>
3480b448:	e1a00006 	mov	r0, r6
3480b44c:	eb0040c3 	bl	3481b760 <strcpy>
		i->p = the_command;
3480b450:	e5846000 	str	r6, [r4]
			while(! i->p  || strlen(i->p)==0 ) {
3480b454:	e5940000 	ldr	r0, [r4]
3480b458:	e3500000 	cmp	r0, #0
3480b45c:	1affffce 	bne	3480b39c <file_get+0x18>
3480b460:	eaffffd0 	b	3480b3a8 <file_get+0x24>
				strcpy(the_command,console_buffer);
3480b464:	e59f10dc 	ldr	r1, [pc, #220]	; 3480b548 <file_get+0x1c4>
3480b468:	e1a00006 	mov	r0, r6
3480b46c:	eb0040bb 	bl	3481b760 <strcpy>
				flag_repeat = 1;
3480b470:	e585b004 	str	fp, [r5, #4]
3480b474:	eafffff5 	b	3480b450 <file_get+0xcc>
		if (console_buffer[0] != '\n') {
3480b478:	e353000a 	cmp	r3, #10
3480b47c:	0a000015 	beq	3480b4d8 <file_get+0x154>
			if (strlen(the_command) + strlen(console_buffer)
3480b480:	e285700c 	add	r7, r5, #12
3480b484:	e1a00007 	mov	r0, r7
3480b488:	eb004112 	bl	3481b8d8 <strlen>
3480b48c:	e1a0b000 	mov	fp, r0
3480b490:	e59f00b0 	ldr	r0, [pc, #176]	; 3480b548 <file_get+0x1c4>
3480b494:	eb00410f 	bl	3481b8d8 <strlen>
3480b498:	e080000b 	add	r0, r0, fp
3480b49c:	e35000ff 	cmp	r0, #255	; 0xff
3480b4a0:	8a000008 	bhi	3480b4c8 <file_get+0x144>
				n = strlen(the_command);
3480b4a4:	e1a00007 	mov	r0, r7
3480b4a8:	eb00410a 	bl	3481b8d8 <strlen>
				the_command[n-1] = ' ';
3480b4ac:	e3a03020 	mov	r3, #32
3480b4b0:	e0855000 	add	r5, r5, r0
				strcpy(&the_command[n],console_buffer);
3480b4b4:	e59f108c 	ldr	r1, [pc, #140]	; 3480b548 <file_get+0x1c4>
3480b4b8:	e0870000 	add	r0, r7, r0
				the_command[n-1] = ' ';
3480b4bc:	e5c5300b 	strb	r3, [r5, #11]
				strcpy(&the_command[n],console_buffer);
3480b4c0:	eb0040a6 	bl	3481b760 <strcpy>
3480b4c4:	ea000003 	b	3480b4d8 <file_get+0x154>
				the_command[0] = '\n';
3480b4c8:	e3a0300a 	mov	r3, #10
				the_command[1] = '\0';
3480b4cc:	e5c5900d 	strb	r9, [r5, #13]
				the_command[0] = '\n';
3480b4d0:	e5c5300c 	strb	r3, [r5, #12]
				flag_repeat = 0;
3480b4d4:	e5859004 	str	r9, [r5, #4]
		if (i->__promptme == 0) {
3480b4d8:	e5943004 	ldr	r3, [r4, #4]
3480b4dc:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
3480b4e0:	03a0200a 	moveq	r2, #10
			the_command[1] = '\0';
3480b4e4:	05c6300d 	strbeq	r3, [r6, #13]
			the_command[0] = '\n';
3480b4e8:	05c6200c 	strbeq	r2, [r6, #12]
		i->p = console_buffer;
3480b4ec:	e584a000 	str	sl, [r4]
3480b4f0:	eaffffd7 	b	3480b454 <file_get+0xd0>
			if (i->p && *i->p) {
3480b4f4:	e5940000 	ldr	r0, [r4]
			i->promptmode=2;
3480b4f8:	e3a03002 	mov	r3, #2
3480b4fc:	e5843008 	str	r3, [r4, #8]
			if (i->p && *i->p) {
3480b500:	e3500000 	cmp	r0, #0
3480b504:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b508:	e5d03000 	ldrb	r3, [r0]
3480b50c:	e3530000 	cmp	r3, #0
3480b510:	0a00000a 	beq	3480b540 <file_get+0x1bc>
				ch = *i->p++;
3480b514:	e2803001 	add	r3, r0, #1
3480b518:	e5843000 	str	r3, [r4]
3480b51c:	e5d00000 	ldrb	r0, [r0]
3480b520:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if (i->p && *i->p) {
3480b524:	e5d32000 	ldrb	r2, [r3]
3480b528:	e3520000 	cmp	r2, #0
3480b52c:	0affffc8 	beq	3480b454 <file_get+0xd0>
		ch = *i->p++;
3480b530:	e2832001 	add	r2, r3, #1
3480b534:	e5802000 	str	r2, [r0]
3480b538:	e5d30000 	ldrb	r0, [r3]
3480b53c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	ch = 0;
3480b540:	e1a00003 	mov	r0, r3
}
3480b544:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b548:	3482a154 	.word	0x3482a154
3480b54c:	34828aa0 	.word	0x34828aa0
3480b550:	34824ecd 	.word	0x34824ecd
3480b554:	34824ed5 	.word	0x34824ed5

3480b558 <b_addchr>:
{
3480b558:	e92d4070 	push	{r4, r5, r6, lr}
3480b55c:	e1a06001 	mov	r6, r1
	if (o->length + len > o->maxlen) {
3480b560:	e5903004 	ldr	r3, [r0, #4]
{
3480b564:	e1a04000 	mov	r4, r0
	if (o->length + len > o->maxlen) {
3480b568:	e5901008 	ldr	r1, [r0, #8]
3480b56c:	e1530001 	cmp	r3, r1
3480b570:	ba00000a 	blt	3480b5a0 <b_addchr+0x48>
		char *old_data = o->data;
3480b574:	e5905000 	ldr	r5, [r0]
		o->maxlen += max(2*len, B_CHUNK);
3480b578:	e2813064 	add	r3, r1, #100	; 0x64
3480b57c:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
3480b580:	e2811065 	add	r1, r1, #101	; 0x65
3480b584:	e1a00005 	mov	r0, r5
3480b588:	ebfffbfd 	bl	3480a584 <realloc>
		if (o->data == NULL) {
3480b58c:	e3500000 	cmp	r0, #0
		o->data = realloc(o->data, 1 + o->maxlen);
3480b590:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
3480b594:	1a000001 	bne	3480b5a0 <b_addchr+0x48>
			free(old_data);
3480b598:	e1a00005 	mov	r0, r5
3480b59c:	ebfff9c3 	bl	34809cb0 <free>
	return o->data == NULL;
3480b5a0:	e5943000 	ldr	r3, [r4]
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b5a4:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
3480b5a8:	15942004 	ldrne	r2, [r4, #4]
	o->data[o->length] = '\0';
3480b5ac:	13a00000 	movne	r0, #0
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b5b0:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
3480b5b4:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
3480b5b8:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480b5bc:	15942000 	ldrne	r2, [r4]
	o->length++;
3480b5c0:	12833001 	addne	r3, r3, #1
3480b5c4:	15843004 	strne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480b5c8:	17c20003 	strbne	r0, [r2, r3]
}
3480b5cc:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b5d0 <b_addqchr>:
	if (quote && strchr("*?[\\",ch)) {
3480b5d0:	e3520000 	cmp	r2, #0
{
3480b5d4:	e92d4070 	push	{r4, r5, r6, lr}
3480b5d8:	e1a04000 	mov	r4, r0
3480b5dc:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
3480b5e0:	1a000003 	bne	3480b5f4 <b_addqchr+0x24>
	return b_addchr(o, ch);
3480b5e4:	e1a01005 	mov	r1, r5
3480b5e8:	e1a00004 	mov	r0, r4
}
3480b5ec:	e8bd4070 	pop	{r4, r5, r6, lr}
	return b_addchr(o, ch);
3480b5f0:	eaffffd8 	b	3480b558 <b_addchr>
	if (quote && strchr("*?[\\",ch)) {
3480b5f4:	e59f0020 	ldr	r0, [pc, #32]	; 3480b61c <b_addqchr+0x4c>
3480b5f8:	eb0040a1 	bl	3481b884 <strchr>
3480b5fc:	e3500000 	cmp	r0, #0
3480b600:	0afffff7 	beq	3480b5e4 <b_addqchr+0x14>
		rc = b_addchr(o, '\\');
3480b604:	e3a0105c 	mov	r1, #92	; 0x5c
3480b608:	e1a00004 	mov	r0, r4
3480b60c:	ebffffd1 	bl	3480b558 <b_addchr>
		if (rc) return rc;
3480b610:	e3500000 	cmp	r0, #0
3480b614:	0afffff2 	beq	3480b5e4 <b_addqchr+0x14>
}
3480b618:	e8bd8070 	pop	{r4, r5, r6, pc}
3480b61c:	34824ed8 	.word	0x34824ed8

3480b620 <get_local_var>:
	if (!s)
3480b620:	e3500000 	cmp	r0, #0
3480b624:	0a00001d 	beq	3480b6a0 <get_local_var+0x80>
{
3480b628:	e92d4070 	push	{r4, r5, r6, lr}
3480b62c:	e1a05000 	mov	r5, r0
	if (*s == '$')
3480b630:	e5d03000 	ldrb	r3, [r0]
3480b634:	e59f406c 	ldr	r4, [pc, #108]	; 3480b6a8 <get_local_var+0x88>
3480b638:	e3530024 	cmp	r3, #36	; 0x24
	for (cur = top_vars; cur; cur=cur->next)
3480b63c:	15944000 	ldrne	r4, [r4]
	if (*s == '$')
3480b640:	1a00000b 	bne	3480b674 <get_local_var+0x54>
		return get_dollar_var(s[1]);
3480b644:	e5d03001 	ldrb	r3, [r0, #1]
	buf[0] = '\0';
3480b648:	e3a00000 	mov	r0, #0
3480b64c:	e5c4010c 	strb	r0, [r4, #268]	; 0x10c
	switch (ch) {
3480b650:	e353003f 	cmp	r3, #63	; 0x3f
3480b654:	18bd8070 	popne	{r4, r5, r6, pc}
			sprintf(buf, "%u", (unsigned int)last_return_code);
3480b658:	e5942134 	ldr	r2, [r4, #308]	; 0x134
3480b65c:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b660:	e59f1044 	ldr	r1, [pc, #68]	; 3480b6ac <get_local_var+0x8c>
3480b664:	eb0044e7 	bl	3481ca08 <sprintf>
	return buf;
3480b668:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b66c:	e8bd8070 	pop	{r4, r5, r6, pc}
	for (cur = top_vars; cur; cur=cur->next)
3480b670:	e5944010 	ldr	r4, [r4, #16]
3480b674:	e3540000 	cmp	r4, #0
3480b678:	1a000001 	bne	3480b684 <get_local_var+0x64>
		return NULL;
3480b67c:	e3a00000 	mov	r0, #0
3480b680:	e8bd8070 	pop	{r4, r5, r6, pc}
		if(strcmp(cur->name, s)==0)
3480b684:	e1a01005 	mov	r1, r5
3480b688:	e5940000 	ldr	r0, [r4]
3480b68c:	eb004063 	bl	3481b820 <strcmp>
3480b690:	e3500000 	cmp	r0, #0
3480b694:	1afffff5 	bne	3480b670 <get_local_var+0x50>
			return cur->value;
3480b698:	e5940004 	ldr	r0, [r4, #4]
3480b69c:	e8bd8070 	pop	{r4, r5, r6, pc}
		return NULL;
3480b6a0:	e3a00000 	mov	r0, #0
}
3480b6a4:	e12fff1e 	bx	lr
3480b6a8:	34828aa0 	.word	0x34828aa0
3480b6ac:	34823170 	.word	0x34823170

3480b6b0 <set_local_var>:
	if (!isalpha(*s))
3480b6b0:	e5d03000 	ldrb	r3, [r0]
3480b6b4:	e59f2190 	ldr	r2, [pc, #400]	; 3480b84c <set_local_var+0x19c>
3480b6b8:	e7d23003 	ldrb	r3, [r2, r3]
3480b6bc:	e3130003 	tst	r3, #3
3480b6c0:	0a00001f 	beq	3480b744 <set_local_var+0x94>
{
3480b6c4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480b6c8:	e1a09001 	mov	r9, r1
	name=strdup(s);
3480b6cc:	eb0040bb 	bl	3481b9c0 <strdup>
3480b6d0:	e1a07000 	mov	r7, r0
	if (getenv(name) != NULL) {
3480b6d4:	ebfff12a 	bl	34807b84 <getenv>
3480b6d8:	e2504000 	subs	r4, r0, #0
3480b6dc:	0a000005 	beq	3480b6f8 <set_local_var+0x48>
		printf ("ERROR: "
3480b6e0:	e59f0168 	ldr	r0, [pc, #360]	; 3480b850 <set_local_var+0x1a0>
3480b6e4:	ebfff82c 	bl	3480979c <printf>
		free(name);
3480b6e8:	e1a00007 	mov	r0, r7
3480b6ec:	ebfff96f 	bl	34809cb0 <free>
		return -1;
3480b6f0:	e3e00000 	mvn	r0, #0
3480b6f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	value = strchr(name, '=');
3480b6f8:	e3a0103d 	mov	r1, #61	; 0x3d
3480b6fc:	e1a00007 	mov	r0, r7
3480b700:	eb00405f 	bl	3481b884 <strchr>
	for(cur = top_vars; cur; cur = cur->next) {
3480b704:	e59f3148 	ldr	r3, [pc, #328]	; 3480b854 <set_local_var+0x1a4>
3480b708:	e3500000 	cmp	r0, #0
3480b70c:	03a00001 	moveq	r0, #1
	*value++ = 0;
3480b710:	e5c04000 	strb	r4, [r0]
3480b714:	e280a001 	add	sl, r0, #1
	for(cur = top_vars; cur; cur = cur->next) {
3480b718:	e5935000 	ldr	r5, [r3]
3480b71c:	e1a04003 	mov	r4, r3
3480b720:	e3550000 	cmp	r5, #0
3480b724:	0a000008 	beq	3480b74c <set_local_var+0x9c>
		if(strcmp(cur->name, name)==0)
3480b728:	e1a01007 	mov	r1, r7
3480b72c:	e5950000 	ldr	r0, [r5]
3480b730:	eb00403a 	bl	3481b820 <strcmp>
3480b734:	e3500000 	cmp	r0, #0
3480b738:	0a00001c 	beq	3480b7b0 <set_local_var+0x100>
	for(cur = top_vars; cur; cur = cur->next) {
3480b73c:	e5955010 	ldr	r5, [r5, #16]
3480b740:	eafffff6 	b	3480b720 <set_local_var+0x70>
		return -1;
3480b744:	e3e00000 	mvn	r0, #0
}
3480b748:	e12fff1e 	bx	lr
		cur = malloc(sizeof(struct variables));
3480b74c:	e3a00014 	mov	r0, #20
3480b750:	ebfff9e0 	bl	34809ed8 <malloc>
		if(!cur) {
3480b754:	e2506000 	subs	r6, r0, #0
3480b758:	0a00001f 	beq	3480b7dc <set_local_var+0x12c>
			cur->name = strdup(name);
3480b75c:	e1a00007 	mov	r0, r7
3480b760:	eb004096 	bl	3481b9c0 <strdup>
			if(cur->name == 0) {
3480b764:	e3500000 	cmp	r0, #0
			cur->name = strdup(name);
3480b768:	e5860000 	str	r0, [r6]
			if(cur->name == 0) {
3480b76c:	1a000002 	bne	3480b77c <set_local_var+0xcc>
				free(cur);
3480b770:	e1a00006 	mov	r0, r6
3480b774:	ebfff94d 	bl	34809cb0 <free>
3480b778:	ea000017 	b	3480b7dc <set_local_var+0x12c>
				cur->value = strdup(value);
3480b77c:	e1a0000a 	mov	r0, sl
				struct variables *bottom = top_vars;
3480b780:	e594b000 	ldr	fp, [r4]
				cur->value = strdup(value);
3480b784:	eb00408d 	bl	3481b9c0 <strdup>
				cur->next = 0;
3480b788:	e5865010 	str	r5, [r6, #16]
				cur->value = strdup(value);
3480b78c:	e5860004 	str	r0, [r6, #4]
				cur->flg_export = flg_export;
3480b790:	e5869008 	str	r9, [r6, #8]
				cur->flg_read_only = 0;
3480b794:	e586500c 	str	r5, [r6, #12]
				while(bottom->next) bottom=bottom->next;
3480b798:	e59b4010 	ldr	r4, [fp, #16]
3480b79c:	e3540000 	cmp	r4, #0
3480b7a0:	11a0b004 	movne	fp, r4
3480b7a4:	1afffffb 	bne	3480b798 <set_local_var+0xe8>
				bottom->next = cur;
3480b7a8:	e58b6010 	str	r6, [fp, #16]
3480b7ac:	ea00000b 	b	3480b7e0 <set_local_var+0x130>
		if(strcmp(cur->value, value)==0) {
3480b7b0:	e1a0100a 	mov	r1, sl
3480b7b4:	e5950004 	ldr	r0, [r5, #4]
3480b7b8:	eb004018 	bl	3481b820 <strcmp>
3480b7bc:	e3500000 	cmp	r0, #0
3480b7c0:	0a00000a 	beq	3480b7f0 <set_local_var+0x140>
			if(cur->flg_read_only) {
3480b7c4:	e595300c 	ldr	r3, [r5, #12]
3480b7c8:	e3530000 	cmp	r3, #0
3480b7cc:	0a00000e 	beq	3480b80c <set_local_var+0x15c>
				error_msg("%s: readonly variable", name);
3480b7d0:	e1a01007 	mov	r1, r7
3480b7d4:	e59f007c 	ldr	r0, [pc, #124]	; 3480b858 <set_local_var+0x1a8>
3480b7d8:	ebfff7ef 	bl	3480979c <printf>
			result = -1;
3480b7dc:	e3e04000 	mvn	r4, #0
		free(name);
3480b7e0:	e1a00007 	mov	r0, r7
3480b7e4:	ebfff931 	bl	34809cb0 <free>
	return result;
3480b7e8:	e1a00004 	mov	r0, r4
3480b7ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			if(flg_export>0 && cur->flg_export==0)
3480b7f0:	e3590000 	cmp	r9, #0
3480b7f4:	da000012 	ble	3480b844 <set_local_var+0x194>
3480b7f8:	e5954008 	ldr	r4, [r5, #8]
3480b7fc:	e3540000 	cmp	r4, #0
				cur->flg_export=flg_export;
3480b800:	05859008 	streq	r9, [r5, #8]
			if(flg_export>0 && cur->flg_export==0)
3480b804:	0afffff5 	beq	3480b7e0 <set_local_var+0x130>
3480b808:	ea00000d 	b	3480b844 <set_local_var+0x194>
				if(flg_export>0 || cur->flg_export>1)
3480b80c:	e3590000 	cmp	r9, #0
3480b810:	ca000002 	bgt	3480b820 <set_local_var+0x170>
3480b814:	e5953008 	ldr	r3, [r5, #8]
3480b818:	e3530001 	cmp	r3, #1
3480b81c:	da000001 	ble	3480b828 <set_local_var+0x178>
					cur->flg_export=1;
3480b820:	e3a03001 	mov	r3, #1
3480b824:	e5853008 	str	r3, [r5, #8]
				free(cur->value);
3480b828:	e5950004 	ldr	r0, [r5, #4]
	int result=0;
3480b82c:	e3a04000 	mov	r4, #0
				free(cur->value);
3480b830:	ebfff91e 	bl	34809cb0 <free>
				cur->value = strdup(value);
3480b834:	e1a0000a 	mov	r0, sl
3480b838:	eb004060 	bl	3481b9c0 <strdup>
3480b83c:	e5850004 	str	r0, [r5, #4]
3480b840:	eaffffe6 	b	3480b7e0 <set_local_var+0x130>
				result++;
3480b844:	e3a04001 	mov	r4, #1
3480b848:	eaffffe4 	b	3480b7e0 <set_local_var+0x130>
3480b84c:	34820934 	.word	0x34820934
3480b850:	34824edd 	.word	0x34824edd
3480b854:	34828aa0 	.word	0x34828aa0
3480b858:	34824f20 	.word	0x34824f20

3480b85c <insert_var_value_sub>:
{
3480b85c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	char *p, *p1, *res_str = NULL;
3480b860:	e3a04000 	mov	r4, #0
{
3480b864:	e1a05000 	mov	r5, r0
	int done = 0;
3480b868:	e1a09004 	mov	r9, r4
	int res_str_len = 0;
3480b86c:	e1a06004 	mov	r6, r4
{
3480b870:	e58d1008 	str	r1, [sp, #8]
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480b874:	e3a01003 	mov	r1, #3
3480b878:	e1a00005 	mov	r0, r5
3480b87c:	eb004000 	bl	3481b884 <strchr>
3480b880:	e2507000 	subs	r7, r0, #0
3480b884:	0a00008b 	beq	3480bab8 <insert_var_value_sub+0x25c>
		if (p != inp) {
3480b888:	e1570005 	cmp	r7, r5
3480b88c:	0a00000a 	beq	3480b8bc <insert_var_value_sub+0x60>
			len = p - inp;
3480b890:	e065a007 	rsb	sl, r5, r7
			res_str = xrealloc(res_str, (res_str_len + len));
3480b894:	e1a00004 	mov	r0, r4
3480b898:	e086900a 	add	r9, r6, sl
3480b89c:	e1a01009 	mov	r1, r9
3480b8a0:	ebfffe38 	bl	3480b188 <xrealloc>
3480b8a4:	e1a04000 	mov	r4, r0
			strncpy((res_str + res_str_len), inp, len);
3480b8a8:	e0800006 	add	r0, r0, r6
			res_str_len += len;
3480b8ac:	e1a06009 	mov	r6, r9
			strncpy((res_str + res_str_len), inp, len);
3480b8b0:	e1a0200a 	mov	r2, sl
3480b8b4:	e1a01005 	mov	r1, r5
3480b8b8:	eb003fae 	bl	3481b778 <strncpy>
		inp = ++p;
3480b8bc:	e2877001 	add	r7, r7, #1
		*p = '\0';
3480b8c0:	e3a09000 	mov	r9, #0
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480b8c4:	e3a01003 	mov	r1, #3
3480b8c8:	e1a00007 	mov	r0, r7
3480b8cc:	eb003fec 	bl	3481b884 <strchr>
	if (!src)
3480b8d0:	e1570009 	cmp	r7, r9
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480b8d4:	e58d0004 	str	r0, [sp, #4]
		*p = '\0';
3480b8d8:	e5c09000 	strb	r9, [r0]
	if (!src)
3480b8dc:	0a000070 	beq	3480baa4 <insert_var_value_sub+0x248>
	sep = strchr(src, ':');
3480b8e0:	e3a0103a 	mov	r1, #58	; 0x3a
3480b8e4:	e1a00007 	mov	r0, r7
3480b8e8:	eb003fe5 	bl	3481b884 <strchr>
	if (sep) {
3480b8ec:	e250a000 	subs	sl, r0, #0
3480b8f0:	1a000003 	bne	3480b904 <insert_var_value_sub+0xa8>
	int expand_empty = 0;
3480b8f4:	e3a03000 	mov	r3, #0
	int assign = 0;
3480b8f8:	e1a09003 	mov	r9, r3
	char *default_val = NULL;
3480b8fc:	e1a05003 	mov	r5, r3
3480b900:	ea00000f 	b	3480b944 <insert_var_value_sub+0xe8>
		if (*(sep + 1) == '-')
3480b904:	e5da3001 	ldrb	r3, [sl, #1]
		*sep = '\0';
3480b908:	e5ca9000 	strb	r9, [sl]
		if (*(sep + 1) == '-')
3480b90c:	e353002d 	cmp	r3, #45	; 0x2d
	int expand_empty = 0;
3480b910:	01a03009 	moveq	r3, r9
			default_val = sep+2;
3480b914:	028a5002 	addeq	r5, sl, #2
3480b918:	01a09003 	moveq	r9, r3
		if (*(sep + 1) == '-')
3480b91c:	0a000008 	beq	3480b944 <insert_var_value_sub+0xe8>
		if (*(sep + 1) == '=') {
3480b920:	e353003d 	cmp	r3, #61	; 0x3d
	int expand_empty = 0;
3480b924:	01a03009 	moveq	r3, r9
			default_val = sep+2;
3480b928:	028a5002 	addeq	r5, sl, #2
			assign = 1;
3480b92c:	03a09001 	moveq	r9, #1
		if (*(sep + 1) == '=') {
3480b930:	0a000003 	beq	3480b944 <insert_var_value_sub+0xe8>
		if (*(sep + 1) == '+') {
3480b934:	e353002b 	cmp	r3, #43	; 0x2b
3480b938:	1affffed 	bne	3480b8f4 <insert_var_value_sub+0x98>
			default_val = sep+2;
3480b93c:	e28a5002 	add	r5, sl, #2
			expand_empty = 1;
3480b940:	e3a03001 	mov	r3, #1
	p = getenv(src);
3480b944:	e1a00007 	mov	r0, r7
3480b948:	e58d300c 	str	r3, [sp, #12]
3480b94c:	ebfff08c 	bl	34807b84 <getenv>
	if (!p)
3480b950:	e250b000 	subs	fp, r0, #0
3480b954:	e59d300c 	ldr	r3, [sp, #12]
3480b958:	1a000007 	bne	3480b97c <insert_var_value_sub+0x120>
		p = get_local_var(src);
3480b95c:	e1a00007 	mov	r0, r7
3480b960:	ebffff2e 	bl	3480b620 <get_local_var>
	if (!p || strlen(p) == 0) {
3480b964:	e250b000 	subs	fp, r0, #0
3480b968:	e59d300c 	ldr	r3, [sp, #12]
3480b96c:	1a000002 	bne	3480b97c <insert_var_value_sub+0x120>
		if (assign) {
3480b970:	e3590000 	cmp	r9, #0
3480b974:	0a000020 	beq	3480b9fc <insert_var_value_sub+0x1a0>
3480b978:	ea000006 	b	3480b998 <insert_var_value_sub+0x13c>
	if (!p || strlen(p) == 0) {
3480b97c:	e1a0000b 	mov	r0, fp
3480b980:	e58d300c 	str	r3, [sp, #12]
3480b984:	eb003fd3 	bl	3481b8d8 <strlen>
3480b988:	e3500000 	cmp	r0, #0
3480b98c:	e59d300c 	ldr	r3, [sp, #12]
3480b990:	0afffff6 	beq	3480b970 <insert_var_value_sub+0x114>
3480b994:	ea000013 	b	3480b9e8 <insert_var_value_sub+0x18c>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
3480b998:	e1a00007 	mov	r0, r7
3480b99c:	eb003fcd 	bl	3481b8d8 <strlen>
3480b9a0:	e1a09000 	mov	r9, r0
3480b9a4:	e1a00005 	mov	r0, r5
3480b9a8:	eb003fca 	bl	3481b8d8 <strlen>
3480b9ac:	e0890000 	add	r0, r9, r0
3480b9b0:	e2800002 	add	r0, r0, #2
3480b9b4:	ebfff947 	bl	34809ed8 <malloc>
			if (var) {
3480b9b8:	e2509000 	subs	r9, r0, #0
3480b9bc:	0a000006 	beq	3480b9dc <insert_var_value_sub+0x180>
				sprintf(var, "%s=%s", src, default_val);
3480b9c0:	e59f1150 	ldr	r1, [pc, #336]	; 3480bb18 <insert_var_value_sub+0x2bc>
3480b9c4:	e1a03005 	mov	r3, r5
3480b9c8:	e1a02007 	mov	r2, r7
3480b9cc:	eb00440d 	bl	3481ca08 <sprintf>
				set_local_var(var, 0);
3480b9d0:	e3a01000 	mov	r1, #0
3480b9d4:	e1a00009 	mov	r0, r9
3480b9d8:	ebffff34 	bl	3480b6b0 <set_local_var>
			free(var);
3480b9dc:	e1a00009 	mov	r0, r9
3480b9e0:	ebfff8b2 	bl	34809cb0 <free>
3480b9e4:	ea000004 	b	3480b9fc <insert_var_value_sub+0x1a0>
	} else if (expand_empty) {
3480b9e8:	e3530000 	cmp	r3, #0
3480b9ec:	0a000005 	beq	3480ba08 <insert_var_value_sub+0x1ac>
		p += strlen(p);
3480b9f0:	e1a0000b 	mov	r0, fp
3480b9f4:	eb003fb7 	bl	3481b8d8 <strlen>
3480b9f8:	e08b5000 	add	r5, fp, r0
	if (sep)
3480b9fc:	e35a0000 	cmp	sl, #0
3480ba00:	1a000003 	bne	3480ba14 <insert_var_value_sub+0x1b8>
3480ba04:	ea000004 	b	3480ba1c <insert_var_value_sub+0x1c0>
3480ba08:	e35a0000 	cmp	sl, #0
3480ba0c:	e1a0500b 	mov	r5, fp
3480ba10:	0a000003 	beq	3480ba24 <insert_var_value_sub+0x1c8>
		*sep = ':';
3480ba14:	e3a0303a 	mov	r3, #58	; 0x3a
3480ba18:	e5ca3000 	strb	r3, [sl]
		if ((p1 = lookup_param(inp))) {
3480ba1c:	e3550000 	cmp	r5, #0
3480ba20:	0a00001f 	beq	3480baa4 <insert_var_value_sub+0x248>
			if (tag_subst)
3480ba24:	e59d3008 	ldr	r3, [sp, #8]
				len = res_str_len + strlen(p1) + 2;
3480ba28:	e1a00005 	mov	r0, r5
			if (tag_subst)
3480ba2c:	e3530000 	cmp	r3, #0
3480ba30:	0a000003 	beq	3480ba44 <insert_var_value_sub+0x1e8>
3480ba34:	e2867002 	add	r7, r6, #2
				len = res_str_len + strlen(p1) + 2;
3480ba38:	eb003fa6 	bl	3481b8d8 <strlen>
3480ba3c:	e0877000 	add	r7, r7, r0
3480ba40:	ea000001 	b	3480ba4c <insert_var_value_sub+0x1f0>
				len = res_str_len + strlen(p1);
3480ba44:	eb003fa3 	bl	3481b8d8 <strlen>
3480ba48:	e0807006 	add	r7, r0, r6
			res_str = xrealloc(res_str, (1 + len));
3480ba4c:	e1a00004 	mov	r0, r4
3480ba50:	e2871001 	add	r1, r7, #1
3480ba54:	ebfffdcb 	bl	3480b188 <xrealloc>
			if (tag_subst) {
3480ba58:	e59d3008 	ldr	r3, [sp, #8]
			res_str = xrealloc(res_str, (1 + len));
3480ba5c:	e1a04000 	mov	r4, r0
			if (tag_subst) {
3480ba60:	e3530000 	cmp	r3, #0
3480ba64:	0a00000a 	beq	3480ba94 <insert_var_value_sub+0x238>
				strcpy((res_str + res_str_len + 1), p1);
3480ba68:	e2869001 	add	r9, r6, #1
3480ba6c:	e1a01005 	mov	r1, r5
3480ba70:	e0809009 	add	r9, r0, r9
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480ba74:	e3a0a004 	mov	sl, #4
				strcpy((res_str + res_str_len + 1), p1);
3480ba78:	e1a00009 	mov	r0, r9
3480ba7c:	eb003f37 	bl	3481b760 <strcpy>
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480ba80:	e7c4a006 	strb	sl, [r4, r6]
				res_str[res_str_len + 1 + strlen(p1)] =
3480ba84:	e1a00005 	mov	r0, r5
3480ba88:	eb003f92 	bl	3481b8d8 <strlen>
3480ba8c:	e7c9a000 	strb	sl, [r9, r0]
3480ba90:	ea000002 	b	3480baa0 <insert_var_value_sub+0x244>
				strcpy((res_str + res_str_len), p1);
3480ba94:	e1a01005 	mov	r1, r5
3480ba98:	e0800006 	add	r0, r0, r6
3480ba9c:	eb003f2f 	bl	3481b760 <strcpy>
			res_str_len = len;
3480baa0:	e1a06007 	mov	r6, r7
		*p = SPECIAL_VAR_SYMBOL;
3480baa4:	e59d5004 	ldr	r5, [sp, #4]
3480baa8:	e3a03003 	mov	r3, #3
		done = 1;
3480baac:	e3a09001 	mov	r9, #1
		*p = SPECIAL_VAR_SYMBOL;
3480bab0:	e4c53001 	strb	r3, [r5], #1
3480bab4:	eaffff6e 	b	3480b874 <insert_var_value_sub+0x18>
	if (done) {
3480bab8:	e3590000 	cmp	r9, #0
3480babc:	0a000010 	beq	3480bb04 <insert_var_value_sub+0x2a8>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480bac0:	e1a00005 	mov	r0, r5
3480bac4:	eb003f83 	bl	3481b8d8 <strlen>
3480bac8:	e2861001 	add	r1, r6, #1
3480bacc:	e0811000 	add	r1, r1, r0
3480bad0:	e1a00004 	mov	r0, r4
3480bad4:	ebfffdab 	bl	3480b188 <xrealloc>
3480bad8:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
3480badc:	e0800006 	add	r0, r0, r6
			*p = ' ';
3480bae0:	e3a06020 	mov	r6, #32
		strcpy((res_str + res_str_len), inp);
3480bae4:	e1a01005 	mov	r1, r5
3480bae8:	eb003f1c 	bl	3481b760 <strcpy>
		while ((p = strchr(res_str, '\n'))) {
3480baec:	e3a0100a 	mov	r1, #10
3480baf0:	e1a00004 	mov	r0, r4
3480baf4:	eb003f62 	bl	3481b884 <strchr>
3480baf8:	e3500000 	cmp	r0, #0
			*p = ' ';
3480bafc:	15c06000 	strbne	r6, [r0]
3480bb00:	1afffff9 	bne	3480baec <insert_var_value_sub+0x290>
	return (res_str == NULL) ? inp : res_str;
3480bb04:	e3540000 	cmp	r4, #0
3480bb08:	11a00004 	movne	r0, r4
3480bb0c:	01a00005 	moveq	r0, r5
}
3480bb10:	e28dd010 	add	sp, sp, #16
3480bb14:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480bb18:	34824f36 	.word	0x34824f36

3480bb1c <unset_local_var>:
	if (name) {
3480bb1c:	e3500000 	cmp	r0, #0
3480bb20:	012fff1e 	bxeq	lr
		for (cur = top_vars; cur; cur=cur->next) {
3480bb24:	e59f3088 	ldr	r3, [pc, #136]	; 3480bbb4 <unset_local_var+0x98>
{
3480bb28:	e92d4070 	push	{r4, r5, r6, lr}
3480bb2c:	e1a05000 	mov	r5, r0
3480bb30:	e1a06003 	mov	r6, r3
		for (cur = top_vars; cur; cur=cur->next) {
3480bb34:	e5934000 	ldr	r4, [r3]
3480bb38:	e3540000 	cmp	r4, #0
3480bb3c:	0a000006 	beq	3480bb5c <unset_local_var+0x40>
			if(strcmp(cur->name, name)==0)
3480bb40:	e1a01005 	mov	r1, r5
3480bb44:	e5940000 	ldr	r0, [r4]
3480bb48:	eb003f34 	bl	3481b820 <strcmp>
3480bb4c:	e3500000 	cmp	r0, #0
3480bb50:	0a000002 	beq	3480bb60 <unset_local_var+0x44>
		for (cur = top_vars; cur; cur=cur->next) {
3480bb54:	e5944010 	ldr	r4, [r4, #16]
3480bb58:	eafffff6 	b	3480bb38 <unset_local_var+0x1c>
3480bb5c:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(cur->flg_read_only) {
3480bb60:	e594300c 	ldr	r3, [r4, #12]
			struct variables *next = top_vars;
3480bb64:	e5966000 	ldr	r6, [r6]
			if(cur->flg_read_only) {
3480bb68:	e3530000 	cmp	r3, #0
3480bb6c:	0a000003 	beq	3480bb80 <unset_local_var+0x64>
				error_msg("%s: readonly variable", name);
3480bb70:	e1a01005 	mov	r1, r5
3480bb74:	e59f003c 	ldr	r0, [pc, #60]	; 3480bbb8 <unset_local_var+0x9c>
}
3480bb78:	e8bd4070 	pop	{r4, r5, r6, lr}
				error_msg("%s: readonly variable", name);
3480bb7c:	eafff706 	b	3480979c <printf>
				free(cur->name);
3480bb80:	e5940000 	ldr	r0, [r4]
3480bb84:	ebfff849 	bl	34809cb0 <free>
				free(cur->value);
3480bb88:	e5940004 	ldr	r0, [r4, #4]
3480bb8c:	ebfff847 	bl	34809cb0 <free>
				while (next->next != cur)
3480bb90:	e5963010 	ldr	r3, [r6, #16]
3480bb94:	e1530004 	cmp	r3, r4
3480bb98:	11a06003 	movne	r6, r3
3480bb9c:	1afffffb 	bne	3480bb90 <unset_local_var+0x74>
				next->next = cur->next;
3480bba0:	e5943010 	ldr	r3, [r4, #16]
			free(cur);
3480bba4:	e1a00004 	mov	r0, r4
				next->next = cur->next;
3480bba8:	e5863010 	str	r3, [r6, #16]
}
3480bbac:	e8bd4070 	pop	{r4, r5, r6, lr}
			free(cur);
3480bbb0:	eafff83e 	b	34809cb0 <free>
3480bbb4:	34828aa0 	.word	0x34828aa0
3480bbb8:	34824f20 	.word	0x34824f20

3480bbbc <new_pipe>:
struct pipe *new_pipe(void) {
3480bbbc:	e92d4010 	push	{r4, lr}
	pi = xmalloc(sizeof(struct pipe));
3480bbc0:	e3a00014 	mov	r0, #20
3480bbc4:	ebfffd67 	bl	3480b168 <xmalloc>
	pi->num_progs = 0;
3480bbc8:	e3a02000 	mov	r2, #0
3480bbcc:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
3480bbd0:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
3480bbd4:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
3480bbd8:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
3480bbdc:	e5802010 	str	r2, [r0, #16]
}
3480bbe0:	e8bd8010 	pop	{r4, pc}

3480bbe4 <done_pipe>:
{
3480bbe4:	e92d4070 	push	{r4, r5, r6, lr}
3480bbe8:	e1a04000 	mov	r4, r0
3480bbec:	e1a05001 	mov	r5, r1
	done_command(ctx);  /* implicit closure of previous command */
3480bbf0:	ebfffd6c 	bl	3480b1a8 <done_command>
	ctx->pipe->followup = type;
3480bbf4:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
3480bbf8:	e594200c 	ldr	r2, [r4, #12]
	ctx->pipe->followup = type;
3480bbfc:	e583500c 	str	r5, [r3, #12]
	ctx->child = NULL;
3480bc00:	e3a05000 	mov	r5, #0
	ctx->pipe->r_mode = ctx->w;
3480bc04:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
3480bc08:	ebffffeb 	bl	3480bbbc <new_pipe>
	ctx->pipe->next = new_p;
3480bc0c:	e5943008 	ldr	r3, [r4, #8]
3480bc10:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
3480bc14:	e5840008 	str	r0, [r4, #8]
	done_command(ctx);  /* set up new pipe to accept commands */
3480bc18:	e1a00004 	mov	r0, r4
	ctx->child = NULL;
3480bc1c:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
3480bc20:	ebfffd60 	bl	3480b1a8 <done_command>
}
3480bc24:	e1a00005 	mov	r0, r5
3480bc28:	e8bd8070 	pop	{r4, r5, r6, pc}

3480bc2c <reserved_word>:
{
3480bc2c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480bc30:	e1a07000 	mov	r7, r0
	for (r=reserved_list;
3480bc34:	e59f6144 	ldr	r6, [pc, #324]	; 3480bd80 <reserved_word+0x154>
{
3480bc38:	e1a04001 	mov	r4, r1
	for (r=reserved_list;
3480bc3c:	e2865084 	add	r5, r6, #132	; 0x84
		if (strcmp(dest->data, r->literal) == 0) {
3480bc40:	e5961000 	ldr	r1, [r6]
3480bc44:	e5970000 	ldr	r0, [r7]
3480bc48:	eb003ef4 	bl	3481b820 <strcmp>
3480bc4c:	e3500000 	cmp	r0, #0
3480bc50:	1a000045 	bne	3480bd6c <reserved_word+0x140>
			if (r->flag & FLAG_START) {
3480bc54:	e5963008 	ldr	r3, [r6, #8]
3480bc58:	e3130b02 	tst	r3, #2048	; 0x800
3480bc5c:	0a00001e 	beq	3480bcdc <reserved_word+0xb0>
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480bc60:	e3a0001c 	mov	r0, #28
3480bc64:	ebfffd3f 	bl	3480b168 <xmalloc>
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480bc68:	e594500c 	ldr	r5, [r4, #12]
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480bc6c:	e1a09000 	mov	r9, r0
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480bc70:	e355000c 	cmp	r5, #12
3480bc74:	13550006 	cmpne	r5, #6
3480bc78:	03a05001 	moveq	r5, #1
3480bc7c:	13a05000 	movne	r5, #0
3480bc80:	1a000003 	bne	3480bc94 <reserved_word+0x68>
					syntax();
3480bc84:	ebfffcfa 	bl	3480b074 <syntax_err>
					free(new);
3480bc88:	e1a00009 	mov	r0, r9
3480bc8c:	ebfff807 	bl	34809cb0 <free>
3480bc90:	ea00001a 	b	3480bd00 <reserved_word+0xd4>
				*new = *ctx;   /* physical copy */
3480bc94:	e1a0e004 	mov	lr, r4
3480bc98:	e1a0c000 	mov	ip, r0
3480bc9c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
3480bca0:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
3480bca4:	e89e0007 	ldm	lr, {r0, r1, r2}
3480bca8:	e88c0007 	stm	ip, {r0, r1, r2}
	ctx->pipe=NULL;
3480bcac:	e5845008 	str	r5, [r4, #8]
	ctx->child=NULL;
3480bcb0:	e5845000 	str	r5, [r4]
	ctx->list_head=new_pipe();
3480bcb4:	ebffffc0 	bl	3480bbbc <new_pipe>
	ctx->w=RES_NONE;
3480bcb8:	e584500c 	str	r5, [r4, #12]
	ctx->list_head=new_pipe();
3480bcbc:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
3480bcc0:	e5840008 	str	r0, [r4, #8]
	done_command(ctx);   /* creates the memory for working child */
3480bcc4:	e1a00004 	mov	r0, r4
	ctx->stack=NULL;
3480bcc8:	e5845014 	str	r5, [r4, #20]
	ctx->old_flag=0;
3480bccc:	e5845010 	str	r5, [r4, #16]
	done_command(ctx);   /* creates the memory for working child */
3480bcd0:	ebfffd34 	bl	3480b1a8 <done_command>
				ctx->stack=new;
3480bcd4:	e5849014 	str	r9, [r4, #20]
3480bcd8:	ea00000e 	b	3480bd18 <reserved_word+0xec>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
3480bcdc:	e594300c 	ldr	r3, [r4, #12]
3480bce0:	e3530000 	cmp	r3, #0
3480bce4:	0a000004 	beq	3480bcfc <reserved_word+0xd0>
3480bce8:	e5943010 	ldr	r3, [r4, #16]
3480bcec:	e5962004 	ldr	r2, [r6, #4]
3480bcf0:	e1a03253 	asr	r3, r3, r2
3480bcf4:	e3130001 	tst	r3, #1
3480bcf8:	1a000006 	bne	3480bd18 <reserved_word+0xec>
				syntax();
3480bcfc:	ebfffcdc 	bl	3480b074 <syntax_err>
				ctx->w = RES_SNTX;
3480bd00:	e3a0300d 	mov	r3, #13
3480bd04:	e584300c 	str	r3, [r4, #12]
				b_reset(dest);
3480bd08:	e1a00007 	mov	r0, r7
3480bd0c:	ebfffcc4 	bl	3480b024 <b_reset>
				return 1;
3480bd10:	e3a00001 	mov	r0, #1
3480bd14:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			ctx->w=r->code;
3480bd18:	e5963004 	ldr	r3, [r6, #4]
3480bd1c:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
3480bd20:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
3480bd24:	e3130001 	tst	r3, #1
			ctx->old_flag = r->flag;
3480bd28:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
3480bd2c:	0afffff5 	beq	3480bd08 <reserved_word+0xdc>
				done_pipe(ctx,PIPE_SEQ);
3480bd30:	e3a01001 	mov	r1, #1
3480bd34:	e1a00004 	mov	r0, r4
3480bd38:	ebffffa9 	bl	3480bbe4 <done_pipe>
				old = ctx->stack;
3480bd3c:	e594e014 	ldr	lr, [r4, #20]
				old->child->group = ctx->list_head;
3480bd40:	e5942004 	ldr	r2, [r4, #4]
3480bd44:	e59e3000 	ldr	r3, [lr]
				*ctx = *old;   /* physical copy */
3480bd48:	e1a0c00e 	mov	ip, lr
				old->child->group = ctx->list_head;
3480bd4c:	e5832008 	str	r2, [r3, #8]
				*ctx = *old;   /* physical copy */
3480bd50:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
3480bd54:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
3480bd58:	e89c0007 	ldm	ip, {r0, r1, r2}
3480bd5c:	e8840007 	stm	r4, {r0, r1, r2}
				free(old);
3480bd60:	e1a0000e 	mov	r0, lr
3480bd64:	ebfff7d1 	bl	34809cb0 <free>
3480bd68:	eaffffe6 	b	3480bd08 <reserved_word+0xdc>
		r<reserved_list+NRES; r++) {
3480bd6c:	e286600c 	add	r6, r6, #12
	for (r=reserved_list;
3480bd70:	e1560005 	cmp	r6, r5
3480bd74:	3affffb1 	bcc	3480bc40 <reserved_word+0x14>
	return 0;
3480bd78:	e3a00000 	mov	r0, #0
}
3480bd7c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480bd80:	348276b4 	.word	0x348276b4

3480bd84 <done_word>:
	if (dest->length == 0 && !dest->nonnull) {
3480bd84:	e5903004 	ldr	r3, [r0, #4]
{
3480bd88:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	struct child_prog *child=ctx->child;
3480bd8c:	e5917000 	ldr	r7, [r1]
	if (dest->length == 0 && !dest->nonnull) {
3480bd90:	e3530000 	cmp	r3, #0
3480bd94:	1a000004 	bne	3480bdac <done_word+0x28>
3480bd98:	e5903010 	ldr	r3, [r0, #16]
3480bd9c:	e3530000 	cmp	r3, #0
3480bda0:	1a000001 	bne	3480bdac <done_word+0x28>
		return 0;
3480bda4:	e3a00000 	mov	r0, #0
3480bda8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		if (child->group) {
3480bdac:	e5973008 	ldr	r3, [r7, #8]
3480bdb0:	e1a05001 	mov	r5, r1
3480bdb4:	e1a06000 	mov	r6, r0
3480bdb8:	e3530000 	cmp	r3, #0
3480bdbc:	0a000001 	beq	3480bdc8 <done_word+0x44>
			syntax();
3480bdc0:	ebfffcab 	bl	3480b074 <syntax_err>
3480bdc4:	ea00001d 	b	3480be40 <done_word+0xbc>
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
3480bdc8:	e5973000 	ldr	r3, [r7]
3480bdcc:	e3530000 	cmp	r3, #0
3480bdd0:	1a00000a 	bne	3480be00 <done_word+0x7c>
3480bdd4:	e5913018 	ldr	r3, [r1, #24]
3480bdd8:	e3130002 	tst	r3, #2
3480bddc:	0a000007 	beq	3480be00 <done_word+0x7c>
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
3480bde0:	ebffff91 	bl	3480bc2c <reserved_word>
3480bde4:	e3500000 	cmp	r0, #0
3480bde8:	0a000004 	beq	3480be00 <done_word+0x7c>
3480bdec:	e595000c 	ldr	r0, [r5, #12]
3480bdf0:	e240000d 	sub	r0, r0, #13
3480bdf4:	e16f0f10 	clz	r0, r0
3480bdf8:	e1a002a0 	lsr	r0, r0, #5
3480bdfc:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480be00:	e5963000 	ldr	r3, [r6]
3480be04:	e3a00001 	mov	r0, #1
3480be08:	e3530000 	cmp	r3, #0
3480be0c:	1a000003 	bne	3480be20 <done_word+0x9c>
		str = malloc(cnt);
3480be10:	ebfff830 	bl	34809ed8 <malloc>
		if (!str) return 1;
3480be14:	e2509000 	subs	r9, r0, #0
3480be18:	1a00000a 	bne	3480be48 <done_word+0xc4>
3480be1c:	ea000007 	b	3480be40 <done_word+0xbc>
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480be20:	e5d32000 	ldrb	r2, [r3]
3480be24:	e3520000 	cmp	r2, #0
3480be28:	0afffff8 	beq	3480be10 <done_word+0x8c>
			if (*s == '\\') s++;
3480be2c:	e352005c 	cmp	r2, #92	; 0x5c
			cnt++;
3480be30:	e2800001 	add	r0, r0, #1
			if (*s == '\\') s++;
3480be34:	02833001 	addeq	r3, r3, #1
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480be38:	e2833001 	add	r3, r3, #1
3480be3c:	eafffff1 	b	3480be08 <done_word+0x84>
		if (!str) return 1;
3480be40:	e3a00001 	mov	r0, #1
3480be44:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		if ( child->argv == NULL) {
3480be48:	e5970000 	ldr	r0, [r7]
3480be4c:	e3500000 	cmp	r0, #0
			child->argc=0;
3480be50:	05870004 	streq	r0, [r7, #4]
		argc = ++child->argc;
3480be54:	e5974004 	ldr	r4, [r7, #4]
3480be58:	e2843001 	add	r3, r4, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480be5c:	e2844002 	add	r4, r4, #2
3480be60:	e1a04104 	lsl	r4, r4, #2
		argc = ++child->argc;
3480be64:	e5873004 	str	r3, [r7, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480be68:	e1a01004 	mov	r1, r4
3480be6c:	ebfff9c4 	bl	3480a584 <realloc>
		if (child->argv == NULL) return 1;
3480be70:	e3500000 	cmp	r0, #0
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480be74:	e5870000 	str	r0, [r7]
		if (child->argv == NULL) return 1;
3480be78:	0afffff0 	beq	3480be40 <done_word+0xbc>
		child->argv[argc-1]=str;
3480be7c:	e0800004 	add	r0, r0, r4
3480be80:	e5009008 	str	r9, [r0, #-8]
		child->argv[argc]=NULL;
3480be84:	e5973000 	ldr	r3, [r7]
3480be88:	e0834004 	add	r4, r3, r4
3480be8c:	e3a03000 	mov	r3, #0
3480be90:	e5043004 	str	r3, [r4, #-4]
		for (s = dest->data; s && *s; s++,str++) {
3480be94:	e5963000 	ldr	r3, [r6]
3480be98:	e3530000 	cmp	r3, #0
3480be9c:	1a00000d 	bne	3480bed8 <done_word+0x154>
		*str = '\0';
3480bea0:	e3a04000 	mov	r4, #0
	b_reset(dest);
3480bea4:	e1a00006 	mov	r0, r6
		*str = '\0';
3480bea8:	e5c94000 	strb	r4, [r9]
	b_reset(dest);
3480beac:	ebfffc5c 	bl	3480b024 <b_reset>
	if (ctx->w == RES_FOR) {
3480beb0:	e595300c 	ldr	r3, [r5, #12]
3480beb4:	e3530006 	cmp	r3, #6
3480beb8:	1affffb9 	bne	3480bda4 <done_word+0x20>
		done_word(dest,ctx);
3480bebc:	e1a01005 	mov	r1, r5
3480bec0:	e1a00006 	mov	r0, r6
3480bec4:	ebffffae 	bl	3480bd84 <done_word>
		done_pipe(ctx,PIPE_SEQ);
3480bec8:	e3a01001 	mov	r1, #1
3480becc:	e1a00005 	mov	r0, r5
3480bed0:	ebffff43 	bl	3480bbe4 <done_pipe>
3480bed4:	eaffffb2 	b	3480bda4 <done_word+0x20>
		for (s = dest->data; s && *s; s++,str++) {
3480bed8:	e5d32000 	ldrb	r2, [r3]
3480bedc:	e3520000 	cmp	r2, #0
3480bee0:	0affffee 	beq	3480bea0 <done_word+0x11c>
			if (*s == '\\') s++;
3480bee4:	e352005c 	cmp	r2, #92	; 0x5c
3480bee8:	02833001 	addeq	r3, r3, #1
			*str = *s;
3480beec:	e4d32001 	ldrb	r2, [r3], #1
3480bef0:	e4c92001 	strb	r2, [r9], #1
3480bef4:	eaffffe7 	b	3480be98 <done_word+0x114>

3480bef8 <mapset>:
	for (s=set; *s; s++) map[*s] = code;
3480bef8:	e59f2018 	ldr	r2, [pc, #24]	; 3480bf18 <mapset+0x20>
3480befc:	e2400001 	sub	r0, r0, #1
3480bf00:	e5f03001 	ldrb	r3, [r0, #1]!
3480bf04:	e3530000 	cmp	r3, #0
3480bf08:	10823003 	addne	r3, r2, r3
3480bf0c:	15c31138 	strbne	r1, [r3, #312]	; 0x138
3480bf10:	1afffffa 	bne	3480bf00 <mapset+0x8>
}
3480bf14:	e12fff1e 	bx	lr
3480bf18:	34828aa0 	.word	0x34828aa0

3480bf1c <update_ifs_map>:
{
3480bf1c:	e92d4013 	push	{r0, r1, r4, lr}
	ifs = (uchar *)getenv("IFS");
3480bf20:	e59f006c 	ldr	r0, [pc, #108]	; 3480bf94 <update_ifs_map+0x78>
3480bf24:	ebffef16 	bl	34807b84 <getenv>
3480bf28:	e59f4068 	ldr	r4, [pc, #104]	; 3480bf98 <update_ifs_map+0x7c>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480bf2c:	e3500000 	cmp	r0, #0
3480bf30:	059f3064 	ldreq	r3, [pc, #100]	; 3480bf9c <update_ifs_map+0x80>
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480bf34:	e3a02c01 	mov	r2, #256	; 0x100
3480bf38:	e3a01000 	mov	r1, #0
	ifs = (uchar *)getenv("IFS");
3480bf3c:	15840238 	strne	r0, [r4, #568]	; 0x238
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480bf40:	e59f0058 	ldr	r0, [pc, #88]	; 3480bfa0 <update_ifs_map+0x84>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480bf44:	05843238 	streq	r3, [r4, #568]	; 0x238
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480bf48:	eb003f0b 	bl	3481bb7c <memset>
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480bf4c:	e3a03004 	mov	r3, #4
		mapset(subst, 3);       /* never flow through */
3480bf50:	e28d0004 	add	r0, sp, #4
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480bf54:	e5cd3004 	strb	r3, [sp, #4]
		mapset(subst, 3);       /* never flow through */
3480bf58:	e3a01003 	mov	r1, #3
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480bf5c:	e3a03000 	mov	r3, #0
3480bf60:	e5cd3005 	strb	r3, [sp, #5]
		mapset(subst, 3);       /* never flow through */
3480bf64:	ebffffe3 	bl	3480bef8 <mapset>
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
3480bf68:	e3a01003 	mov	r1, #3
3480bf6c:	e59f0030 	ldr	r0, [pc, #48]	; 3480bfa4 <update_ifs_map+0x88>
3480bf70:	ebffffe0 	bl	3480bef8 <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
3480bf74:	e3a01001 	mov	r1, #1
3480bf78:	e59f0028 	ldr	r0, [pc, #40]	; 3480bfa8 <update_ifs_map+0x8c>
3480bf7c:	ebffffdd 	bl	3480bef8 <mapset>
	mapset(ifs, 2);            /* also flow through if quoted */
3480bf80:	e3a01002 	mov	r1, #2
3480bf84:	e5940238 	ldr	r0, [r4, #568]	; 0x238
3480bf88:	ebffffda 	bl	3480bef8 <mapset>
}
3480bf8c:	e28dd008 	add	sp, sp, #8
3480bf90:	e8bd8010 	pop	{r4, pc}
3480bf94:	34824f3c 	.word	0x34824f3c
3480bf98:	34828aa0 	.word	0x34828aa0
3480bf9c:	34824f40 	.word	0x34824f40
3480bfa0:	34828bd8 	.word	0x34828bd8
3480bfa4:	34824f44 	.word	0x34824f44
3480bfa8:	34824f49 	.word	0x34824f49

3480bfac <parse_string_outer>:
{
3480bfac:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	if ( !s || !*s)
3480bfb0:	e2504000 	subs	r4, r0, #0
{
3480bfb4:	e24dd018 	sub	sp, sp, #24
	if ( !s || !*s)
3480bfb8:	0a00002e 	beq	3480c078 <parse_string_outer+0xcc>
3480bfbc:	e5d43000 	ldrb	r3, [r4]
3480bfc0:	e3530000 	cmp	r3, #0
3480bfc4:	0a00002b 	beq	3480c078 <parse_string_outer+0xcc>
3480bfc8:	e1a05001 	mov	r5, r1
	if (!(p = strchr(s, '\n')) || *++p) {
3480bfcc:	e3a0100a 	mov	r1, #10
3480bfd0:	eb003e2b 	bl	3481b884 <strchr>
3480bfd4:	e3500000 	cmp	r0, #0
3480bfd8:	e59f90a4 	ldr	r9, [pc, #164]	; 3480c084 <parse_string_outer+0xd8>
3480bfdc:	e59f70a4 	ldr	r7, [pc, #164]	; 3480c088 <parse_string_outer+0xdc>
3480bfe0:	0a000002 	beq	3480bff0 <parse_string_outer+0x44>
3480bfe4:	e5d03001 	ldrb	r3, [r0, #1]
3480bfe8:	e3530000 	cmp	r3, #0
3480bfec:	0a000017 	beq	3480c050 <parse_string_outer+0xa4>
		p = xmalloc(strlen(s) + 2);
3480bff0:	e1a00004 	mov	r0, r4
3480bff4:	eb003e37 	bl	3481b8d8 <strlen>
3480bff8:	e2800002 	add	r0, r0, #2
3480bffc:	ebfffc59 	bl	3480b168 <xmalloc>
		strcpy(p, s);
3480c000:	e1a01004 	mov	r1, r4
		p = xmalloc(strlen(s) + 2);
3480c004:	e1a06000 	mov	r6, r0
		strcpy(p, s);
3480c008:	eb003dd4 	bl	3481b760 <strcpy>
		strcat(p, "\n");
3480c00c:	e59f1078 	ldr	r1, [pc, #120]	; 3480c08c <parse_string_outer+0xe0>
3480c010:	e1a00006 	mov	r0, r6
3480c014:	eb003de0 	bl	3481b79c <strcat>
	i->__promptme=1;
3480c018:	e3a03001 	mov	r3, #1
		rcode = parse_stream_outer(&input, flag);
3480c01c:	e1a01005 	mov	r1, r5
3480c020:	e28d0004 	add	r0, sp, #4
	i->__promptme=1;
3480c024:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c028:	e58d300c 	str	r3, [sp, #12]
	i->peek = static_peek;
3480c02c:	e58d9014 	str	r9, [sp, #20]
	i->get = static_get;
3480c030:	e58d7010 	str	r7, [sp, #16]
	i->p = s;
3480c034:	e58d6004 	str	r6, [sp, #4]
		rcode = parse_stream_outer(&input, flag);
3480c038:	eb0001f3 	bl	3480c80c <parse_stream_outer>
3480c03c:	e1a04000 	mov	r4, r0
		free(p);
3480c040:	e1a00006 	mov	r0, r6
3480c044:	ebfff719 	bl	34809cb0 <free>
3480c048:	e1a00004 	mov	r0, r4
3480c04c:	ea00000a 	b	3480c07c <parse_string_outer+0xd0>
	i->__promptme=1;
3480c050:	e3a03001 	mov	r3, #1
	return parse_stream_outer(&input, flag);
3480c054:	e1a01005 	mov	r1, r5
3480c058:	e28d0004 	add	r0, sp, #4
	i->peek = static_peek;
3480c05c:	e58d9014 	str	r9, [sp, #20]
	i->get = static_get;
3480c060:	e58d7010 	str	r7, [sp, #16]
	i->__promptme=1;
3480c064:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c068:	e58d300c 	str	r3, [sp, #12]
	i->p = s;
3480c06c:	e58d4004 	str	r4, [sp, #4]
	return parse_stream_outer(&input, flag);
3480c070:	eb0001e5 	bl	3480c80c <parse_stream_outer>
3480c074:	ea000000 	b	3480c07c <parse_string_outer+0xd0>
		return 1;
3480c078:	e3a00001 	mov	r0, #1
}
3480c07c:	e28dd018 	add	sp, sp, #24
3480c080:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480c084:	3480b05c 	.word	0x3480b05c
3480c088:	3480b040 	.word	0x3480b040
3480c08c:	34824f42 	.word	0x34824f42

3480c090 <run_list_real>:
{
3480c090:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c094:	e1a03000 	mov	r3, r0
{
3480c098:	e24dd028 	sub	sp, sp, #40	; 0x28
3480c09c:	e1a05000 	mov	r5, r0
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c0a0:	e3530000 	cmp	r3, #0
3480c0a4:	0a00001f 	beq	3480c128 <run_list_real+0x98>
		if ((rpipe->r_mode == RES_IN ||
3480c0a8:	e5932010 	ldr	r2, [r3, #16]
3480c0ac:	e5933008 	ldr	r3, [r3, #8]
3480c0b0:	e242100c 	sub	r1, r2, #12
3480c0b4:	e2422006 	sub	r2, r2, #6
3480c0b8:	e16f1f11 	clz	r1, r1
3480c0bc:	e16f2f12 	clz	r2, r2
3480c0c0:	e1a012a1 	lsr	r1, r1, #5
3480c0c4:	e1a022a2 	lsr	r2, r2, #5
3480c0c8:	e1920001 	orrs	r0, r2, r1
3480c0cc:	0afffff3 	beq	3480c0a0 <run_list_real+0x10>
		    rpipe->r_mode == RES_FOR) &&
3480c0d0:	e3530000 	cmp	r3, #0
3480c0d4:	1a000004 	bne	3480c0ec <run_list_real+0x5c>
				syntax();
3480c0d8:	ebfffbe5 	bl	3480b074 <syntax_err>
				flag_repeat = 0;
3480c0dc:	e59f3710 	ldr	r3, [pc, #1808]	; 3480c7f4 <run_list_real+0x764>
3480c0e0:	e3a02000 	mov	r2, #0
3480c0e4:	e5832004 	str	r2, [r3, #4]
3480c0e8:	ea0001bb 	b	3480c7dc <run_list_real+0x74c>
		if ((rpipe->r_mode == RES_IN &&
3480c0ec:	e3510000 	cmp	r1, #0
3480c0f0:	0a000006 	beq	3480c110 <run_list_real+0x80>
3480c0f4:	e5932010 	ldr	r2, [r3, #16]
3480c0f8:	e352000c 	cmp	r2, #12
3480c0fc:	1affffe7 	bne	3480c0a0 <run_list_real+0x10>
			rpipe->next->progs->argv != NULL))||
3480c100:	e5932004 	ldr	r2, [r3, #4]
			(rpipe->next->r_mode == RES_IN &&
3480c104:	e5922000 	ldr	r2, [r2]
3480c108:	e3520000 	cmp	r2, #0
3480c10c:	ea000003 	b	3480c120 <run_list_real+0x90>
			rpipe->next->progs->argv != NULL))||
3480c110:	e3520000 	cmp	r2, #0
3480c114:	0affffe1 	beq	3480c0a0 <run_list_real+0x10>
			(rpipe->r_mode == RES_FOR &&
3480c118:	e5932010 	ldr	r2, [r3, #16]
3480c11c:	e352000c 	cmp	r2, #12
3480c120:	0affffde 	beq	3480c0a0 <run_list_real+0x10>
3480c124:	eaffffeb 	b	3480c0d8 <run_list_real+0x48>
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c128:	e3a0900b 	mov	r9, #11
3480c12c:	e3a07001 	mov	r7, #1
3480c130:	e1a06003 	mov	r6, r3
3480c134:	e1a0b003 	mov	fp, r3
3480c138:	e58d3000 	str	r3, [sp]
3480c13c:	e58d301c 	str	r3, [sp, #28]
3480c140:	e58d300c 	str	r3, [sp, #12]
3480c144:	e58d3008 	str	r3, [sp, #8]
3480c148:	e58d3004 	str	r3, [sp, #4]
3480c14c:	e58d3014 	str	r3, [sp, #20]
3480c150:	e58d3010 	str	r3, [sp, #16]
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480c154:	e3550000 	cmp	r5, #0
3480c158:	0a000031 	beq	3480c224 <run_list_real+0x194>
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
3480c15c:	e5953010 	ldr	r3, [r5, #16]
3480c160:	e2433006 	sub	r3, r3, #6
3480c164:	e3530002 	cmp	r3, #2
3480c168:	8a00000a 	bhi	3480c198 <run_list_real+0x108>
				ctrlc();
3480c16c:	ebfff5ac 	bl	34809824 <ctrlc>
				if ((had_ctrlc())) {
3480c170:	ebfff5c5 	bl	3480988c <had_ctrlc>
3480c174:	e3500000 	cmp	r0, #0
3480c178:	1a000197 	bne	3480c7dc <run_list_real+0x74c>
				if (!rpipe) {
3480c17c:	e59d3000 	ldr	r3, [sp]
3480c180:	e3530000 	cmp	r3, #0
					flag_rep = 0;
3480c184:	01a03000 	moveq	r3, r0
				if (!rpipe) {
3480c188:	058d5000 	streq	r5, [sp]
				flag_restore = 0;
3480c18c:	058d0008 	streq	r0, [sp, #8]
					flag_rep = 0;
3480c190:	058d3004 	streq	r3, [sp, #4]
				flag_restore = 0;
3480c194:	158d0008 	strne	r0, [sp, #8]
		rmode = pi->r_mode;
3480c198:	e5954010 	ldr	r4, [r5, #16]
		if (rmode == skip_more_in_this_rmode && flag_skip) {
3480c19c:	e1540009 	cmp	r4, r9
3480c1a0:	13a07000 	movne	r7, #0
3480c1a4:	02077001 	andeq	r7, r7, #1
3480c1a8:	e3570000 	cmp	r7, #0
3480c1ac:	0a000004 	beq	3480c1c4 <run_list_real+0x134>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
3480c1b0:	e595700c 	ldr	r7, [r5, #12]
3480c1b4:	e1a04009 	mov	r4, r9
3480c1b8:	e2577001 	subs	r7, r7, #1
3480c1bc:	13a07001 	movne	r7, #1
3480c1c0:	ea00017f 	b	3480c7c4 <run_list_real+0x734>
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c1c4:	e59d201c 	ldr	r2, [sp, #28]
3480c1c8:	e2443002 	sub	r3, r4, #2
3480c1cc:	e3d33002 	bics	r3, r3, #2
3480c1d0:	e59d300c 	ldr	r3, [sp, #12]
3480c1d4:	01a03002 	moveq	r3, r2
		if (rmode == RES_THEN &&  if_code) continue;
3480c1d8:	e2442002 	sub	r2, r4, #2
3480c1dc:	e16f2f12 	clz	r2, r2
3480c1e0:	e3530000 	cmp	r3, #0
3480c1e4:	e1a022a2 	lsr	r2, r2, #5
3480c1e8:	03a02000 	moveq	r2, #0
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c1ec:	e58d300c 	str	r3, [sp, #12]
		if (rmode == RES_THEN &&  if_code) continue;
3480c1f0:	e3520000 	cmp	r2, #0
3480c1f4:	1a00016c 	bne	3480c7ac <run_list_real+0x71c>
		if (rmode == RES_ELSE && !if_code) continue;
3480c1f8:	e59d100c 	ldr	r1, [sp, #12]
3480c1fc:	e16f3f13 	clz	r3, r3
3480c200:	e1a032a3 	lsr	r3, r3, #5
3480c204:	e3540004 	cmp	r4, #4
3480c208:	03510000 	cmpeq	r1, #0
3480c20c:	0a000169 	beq	3480c7b8 <run_list_real+0x728>
		if (rmode == RES_ELIF && !if_code) break;
3480c210:	e3540003 	cmp	r4, #3
3480c214:	13a07000 	movne	r7, #0
3480c218:	02037001 	andeq	r7, r3, #1
3480c21c:	e3570000 	cmp	r7, #0
3480c220:	0a000001 	beq	3480c22c <run_list_real+0x19c>
	return rcode;
3480c224:	e1a00006 	mov	r0, r6
3480c228:	ea00016f 	b	3480c7ec <run_list_real+0x75c>
		if (rmode == RES_FOR && pi->num_progs) {
3480c22c:	e3540006 	cmp	r4, #6
3480c230:	1a00007f 	bne	3480c434 <run_list_real+0x3a4>
3480c234:	e5953000 	ldr	r3, [r5]
3480c238:	e3530000 	cmp	r3, #0
3480c23c:	0a00008e 	beq	3480c47c <run_list_real+0x3ec>
			if (!list) {
3480c240:	e35b0000 	cmp	fp, #0
3480c244:	1a00005f 	bne	3480c3c8 <run_list_real+0x338>
				if (!pi->next->progs->argv) continue;
3480c248:	e5953008 	ldr	r3, [r5, #8]
3480c24c:	e5933004 	ldr	r3, [r3, #4]
3480c250:	e5939000 	ldr	r9, [r3]
3480c254:	e3590000 	cmp	r9, #0
3480c258:	0a000153 	beq	3480c7ac <run_list_real+0x71c>
					pi->progs->argv[0]);
3480c25c:	e5953004 	ldr	r3, [r5, #4]
				list = make_list_in(pi->next->progs->argv,
3480c260:	e5933000 	ldr	r3, [r3]
3480c264:	e5933000 	ldr	r3, [r3]
	int name_len = strlen(name);
3480c268:	e1a00003 	mov	r0, r3
				list = make_list_in(pi->next->progs->argv,
3480c26c:	e58d3020 	str	r3, [sp, #32]
	int name_len = strlen(name);
3480c270:	eb003d98 	bl	3481b8d8 <strlen>
3480c274:	e58d0024 	str	r0, [sp, #36]	; 0x24
	list = xmalloc(sizeof(*list));
3480c278:	e3a00004 	mov	r0, #4
3480c27c:	ebfffbb9 	bl	3480b168 <xmalloc>
3480c280:	e1a0b000 	mov	fp, r0
3480c284:	e2493004 	sub	r3, r9, #4
3480c288:	e58d3018 	str	r3, [sp, #24]
	int n = 0;
3480c28c:	e58d7004 	str	r7, [sp, #4]
	for (i = 0; inp[i]; i++) {
3480c290:	e59d3018 	ldr	r3, [sp, #24]
3480c294:	e5b30004 	ldr	r0, [r3, #4]!
3480c298:	e3500000 	cmp	r0, #0
3480c29c:	e58d3018 	str	r3, [sp, #24]
3480c2a0:	0a00003e 	beq	3480c3a0 <run_list_real+0x310>
	return insert_var_value_sub(inp, 0);
3480c2a4:	e3a01000 	mov	r1, #0
3480c2a8:	ebfffd6b 	bl	3480b85c <insert_var_value_sub>
3480c2ac:	e1a07000 	mov	r7, r0
3480c2b0:	e58d0010 	str	r0, [sp, #16]
		while (*p1) {
3480c2b4:	e5d73000 	ldrb	r3, [r7]
3480c2b8:	e3530000 	cmp	r3, #0
3480c2bc:	0a00002f 	beq	3480c380 <run_list_real+0x2f0>
			if ((*p1 == ' ')) {
3480c2c0:	e3530020 	cmp	r3, #32
				p1++;
3480c2c4:	02877001 	addeq	r7, r7, #1
			if ((*p1 == ' ')) {
3480c2c8:	0afffff9 	beq	3480c2b4 <run_list_real+0x224>
			if ((p2 = strchr(p1, ' '))) {
3480c2cc:	e3a01020 	mov	r1, #32
3480c2d0:	e1a00007 	mov	r0, r7
3480c2d4:	eb003d6a 	bl	3481b884 <strchr>
3480c2d8:	e2503000 	subs	r3, r0, #0
3480c2dc:	e58d3014 	str	r3, [sp, #20]
				len = p2 - p1;
3480c2e0:	1067a003 	rsbne	sl, r7, r3
			if ((p2 = strchr(p1, ' '))) {
3480c2e4:	1a000004 	bne	3480c2fc <run_list_real+0x26c>
				len = strlen(p1);
3480c2e8:	e1a00007 	mov	r0, r7
3480c2ec:	eb003d79 	bl	3481b8d8 <strlen>
3480c2f0:	e1a0a000 	mov	sl, r0
				p2 = p1 + len;
3480c2f4:	e0873000 	add	r3, r7, r0
3480c2f8:	e58d3014 	str	r3, [sp, #20]
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c2fc:	e59d3004 	ldr	r3, [sp, #4]
3480c300:	e1a0000b 	mov	r0, fp
3480c304:	e2839002 	add	r9, r3, #2
3480c308:	e1a09109 	lsl	r9, r9, #2
3480c30c:	e1a01009 	mov	r1, r9
			list[n] = xmalloc(2 + name_len + len);
3480c310:	e2499008 	sub	r9, r9, #8
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c314:	ebfffb9b 	bl	3480b188 <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
3480c318:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c31c:	e1a0b000 	mov	fp, r0
			list[n] = xmalloc(2 + name_len + len);
3480c320:	e2830002 	add	r0, r3, #2
3480c324:	e080000a 	add	r0, r0, sl
3480c328:	ebfffb8e 	bl	3480b168 <xmalloc>
			strcpy(list[n], name);
3480c32c:	e59d1020 	ldr	r1, [sp, #32]
			list[n] = xmalloc(2 + name_len + len);
3480c330:	e78b0009 	str	r0, [fp, r9]
			strcpy(list[n], name);
3480c334:	eb003d09 	bl	3481b760 <strcpy>
			strcat(list[n], "=");
3480c338:	e59f14b8 	ldr	r1, [pc, #1208]	; 3480c7f8 <run_list_real+0x768>
3480c33c:	e79b0009 	ldr	r0, [fp, r9]
3480c340:	eb003d15 	bl	3481b79c <strcat>
			strncat(list[n], p1, len);
3480c344:	e1a0200a 	mov	r2, sl
3480c348:	e1a01007 	mov	r1, r7
3480c34c:	e79b0009 	ldr	r0, [fp, r9]
3480c350:	eb003d1d 	bl	3481b7cc <strncat>
			list[n++][name_len + len + 1] = '\0';
3480c354:	e59d3004 	ldr	r3, [sp, #4]
3480c358:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
			p1 = p2;
3480c35c:	e59d7014 	ldr	r7, [sp, #20]
			list[n++][name_len + len + 1] = '\0';
3480c360:	e2833001 	add	r3, r3, #1
3480c364:	e58d3004 	str	r3, [sp, #4]
3480c368:	e79b3009 	ldr	r3, [fp, r9]
3480c36c:	e0833002 	add	r3, r3, r2
3480c370:	e083a00a 	add	sl, r3, sl
3480c374:	e3a03000 	mov	r3, #0
3480c378:	e5ca3001 	strb	r3, [sl, #1]
3480c37c:	eaffffcc 	b	3480c2b4 <run_list_real+0x224>
		if (p3 != inp[i]) free(p3);
3480c380:	e59d3018 	ldr	r3, [sp, #24]
3480c384:	e59d2010 	ldr	r2, [sp, #16]
3480c388:	e5933000 	ldr	r3, [r3]
3480c38c:	e1520003 	cmp	r2, r3
3480c390:	0affffbe 	beq	3480c290 <run_list_real+0x200>
3480c394:	e1a00002 	mov	r0, r2
3480c398:	ebfff644 	bl	34809cb0 <free>
3480c39c:	eaffffbb 	b	3480c290 <run_list_real+0x200>
	list[n] = NULL;
3480c3a0:	e59d3004 	ldr	r3, [sp, #4]
				pi->progs->argv[0] = NULL;
3480c3a4:	e58db014 	str	fp, [sp, #20]
	list[n] = NULL;
3480c3a8:	e78b0103 	str	r0, [fp, r3, lsl #2]
				save_name = pi->progs->argv[0];
3480c3ac:	e5953004 	ldr	r3, [r5, #4]
3480c3b0:	e5933000 	ldr	r3, [r3]
3480c3b4:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
3480c3b8:	e5830000 	str	r0, [r3]
				flag_rep = 1;
3480c3bc:	e3a03001 	mov	r3, #1
3480c3c0:	e58d3004 	str	r3, [sp, #4]
				save_name = pi->progs->argv[0];
3480c3c4:	e58d2010 	str	r2, [sp, #16]
3480c3c8:	e5953004 	ldr	r3, [r5, #4]
			if (!(*list)) {
3480c3cc:	e59b9000 	ldr	r9, [fp]
				free(pi->progs->argv[0]);
3480c3d0:	e5933000 	ldr	r3, [r3]
			if (!(*list)) {
3480c3d4:	e3590000 	cmp	r9, #0
				free(pi->progs->argv[0]);
3480c3d8:	e5930000 	ldr	r0, [r3]
			if (!(*list)) {
3480c3dc:	1a00000b 	bne	3480c410 <run_list_real+0x380>
				free(pi->progs->argv[0]);
3480c3e0:	ebfff632 	bl	34809cb0 <free>
				free(save_list);
3480c3e4:	e59d0014 	ldr	r0, [sp, #20]
		skip_more_in_this_rmode = RES_XXXX;
3480c3e8:	e3a0400b 	mov	r4, #11
				free(save_list);
3480c3ec:	ebfff62f 	bl	34809cb0 <free>
				pi->progs->argv[0] = save_name;
3480c3f0:	e5953004 	ldr	r3, [r5, #4]
		flag_skip = 1;
3480c3f4:	e3a07001 	mov	r7, #1
				pi->progs->argv[0] = save_name;
3480c3f8:	e59d2010 	ldr	r2, [sp, #16]
				list = NULL;
3480c3fc:	e1a0b009 	mov	fp, r9
				flag_rep = 0;
3480c400:	e58d9004 	str	r9, [sp, #4]
				pi->progs->argv[0] = save_name;
3480c404:	e5933000 	ldr	r3, [r3]
3480c408:	e5832000 	str	r2, [r3]
				continue;
3480c40c:	ea0000ec 	b	3480c7c4 <run_list_real+0x734>
				if (pi->progs->argv[0])
3480c410:	e3500000 	cmp	r0, #0
3480c414:	0a000000 	beq	3480c41c <run_list_real+0x38c>
					free(pi->progs->argv[0]);
3480c418:	ebfff624 	bl	34809cb0 <free>
				pi->progs->argv[0] = *list++;
3480c41c:	e5953004 	ldr	r3, [r5, #4]
3480c420:	e28bb004 	add	fp, fp, #4
3480c424:	e51b2004 	ldr	r2, [fp, #-4]
3480c428:	e5933000 	ldr	r3, [r3]
3480c42c:	e5832000 	str	r2, [r3]
3480c430:	ea000011 	b	3480c47c <run_list_real+0x3ec>
		if (rmode == RES_IN) continue;
3480c434:	e354000c 	cmp	r4, #12
3480c438:	0a0000db 	beq	3480c7ac <run_list_real+0x71c>
		if (rmode == RES_DO) {
3480c43c:	e3540009 	cmp	r4, #9
3480c440:	1a000003 	bne	3480c454 <run_list_real+0x3c4>
			if (!flag_rep) continue;
3480c444:	e59d3004 	ldr	r3, [sp, #4]
3480c448:	e3530000 	cmp	r3, #0
3480c44c:	0a0000d6 	beq	3480c7ac <run_list_real+0x71c>
3480c450:	ea000009 	b	3480c47c <run_list_real+0x3ec>
		if ((rmode == RES_DONE)) {
3480c454:	e354000a 	cmp	r4, #10
3480c458:	1a000007 	bne	3480c47c <run_list_real+0x3ec>
				rpipe = NULL;
3480c45c:	e59d3004 	ldr	r3, [sp, #4]
3480c460:	e3530000 	cmp	r3, #0
3480c464:	e59d3000 	ldr	r3, [sp]
3480c468:	03a03000 	moveq	r3, #0
3480c46c:	e58d3000 	str	r3, [sp]
3480c470:	e59d3008 	ldr	r3, [sp, #8]
3480c474:	13a03001 	movne	r3, #1
3480c478:	e58d3008 	str	r3, [sp, #8]
		if (pi->num_progs == 0) continue;
3480c47c:	e5953000 	ldr	r3, [r5]
3480c480:	e3530000 	cmp	r3, #0
3480c484:	0a0000c8 	beq	3480c7ac <run_list_real+0x71c>
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480c488:	e59f2364 	ldr	r2, [pc, #868]	; 3480c7f4 <run_list_real+0x764>
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480c48c:	e3530001 	cmp	r3, #1
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480c490:	e5926008 	ldr	r6, [r2, #8]
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480c494:	1a0000a7 	bne	3480c738 <run_list_real+0x6a8>
3480c498:	e5959004 	ldr	r9, [r5, #4]
		if (pi->num_progs == 1 && child->group) {
3480c49c:	e5990008 	ldr	r0, [r9, #8]
3480c4a0:	e3500000 	cmp	r0, #0
3480c4a4:	0a000001 	beq	3480c4b0 <run_list_real+0x420>
		rcode = run_list_real(child->group);
3480c4a8:	ebfffef8 	bl	3480c090 <run_list_real>
3480c4ac:	ea000098 	b	3480c714 <run_list_real+0x684>
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
3480c4b0:	e5993000 	ldr	r3, [r9]
3480c4b4:	e3530000 	cmp	r3, #0
3480c4b8:	11a0a000 	movne	sl, r0
3480c4bc:	0a00009d 	beq	3480c738 <run_list_real+0x6a8>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
3480c4c0:	e793710a 	ldr	r7, [r3, sl, lsl #2]
3480c4c4:	e58d3018 	str	r3, [sp, #24]
3480c4c8:	e1a00007 	mov	r0, r7
3480c4cc:	ebfffb95 	bl	3480b328 <is_assignment>
3480c4d0:	e3500000 	cmp	r0, #0
3480c4d4:	e59d3018 	ldr	r3, [sp, #24]
3480c4d8:	128aa001 	addne	sl, sl, #1
3480c4dc:	1afffff7 	bne	3480c4c0 <run_list_real+0x430>
		if (i!=0 && child->argv[i]==NULL) {
3480c4e0:	e35a0000 	cmp	sl, #0
3480c4e4:	0a000030 	beq	3480c5ac <run_list_real+0x51c>
3480c4e8:	e3570000 	cmp	r7, #0
3480c4ec:	11a0a000 	movne	sl, r0
3480c4f0:	1a00002d 	bne	3480c5ac <run_list_real+0x51c>
					*value=0;
3480c4f4:	e1a0a007 	mov	sl, r7
			for (i=0; child->argv[i]!=NULL; i++) {
3480c4f8:	e5993000 	ldr	r3, [r9]
3480c4fc:	e7930007 	ldr	r0, [r3, r7]
3480c500:	e3500000 	cmp	r0, #0
3480c504:	0a000016 	beq	3480c564 <run_list_real+0x4d4>
				name = xstrdup(child->argv[i]);
3480c508:	eb003d2c 	bl	3481b9c0 <strdup>
				value = strchr(name, '=');
3480c50c:	e3a0103d 	mov	r1, #61	; 0x3d
				name = xstrdup(child->argv[i]);
3480c510:	e1a06000 	mov	r6, r0
				value = strchr(name, '=');
3480c514:	eb003cda 	bl	3481b884 <strchr>
				if (value)
3480c518:	e3500000 	cmp	r0, #0
					*value=0;
3480c51c:	15c0a000 	strbne	sl, [r0]
				free(name);
3480c520:	e1a00006 	mov	r0, r6
3480c524:	ebfff5e1 	bl	34809cb0 <free>
				p = insert_var_value(child->argv[i]);
3480c528:	e5993000 	ldr	r3, [r9]
	return insert_var_value_sub(inp, 0);
3480c52c:	e3a01000 	mov	r1, #0
3480c530:	e7930007 	ldr	r0, [r3, r7]
3480c534:	ebfffcc8 	bl	3480b85c <insert_var_value_sub>
				set_local_var(p, export_me);
3480c538:	e3a01000 	mov	r1, #0
	return insert_var_value_sub(inp, 0);
3480c53c:	e1a06000 	mov	r6, r0
				set_local_var(p, export_me);
3480c540:	ebfffc5a 	bl	3480b6b0 <set_local_var>
				if (p != child->argv[i]) free(p);
3480c544:	e5993000 	ldr	r3, [r9]
3480c548:	e7933007 	ldr	r3, [r3, r7]
3480c54c:	e1560003 	cmp	r6, r3
3480c550:	0a000001 	beq	3480c55c <run_list_real+0x4cc>
3480c554:	e1a00006 	mov	r0, r6
3480c558:	ebfff5d4 	bl	34809cb0 <free>
3480c55c:	e2877004 	add	r7, r7, #4
3480c560:	eaffffe4 	b	3480c4f8 <run_list_real+0x468>
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
3480c564:	e1a06000 	mov	r6, r0
3480c568:	ea000073 	b	3480c73c <run_list_real+0x6ac>
	return insert_var_value_sub(inp, 0);
3480c56c:	e1a00003 	mov	r0, r3
3480c570:	e3a01000 	mov	r1, #0
3480c574:	ebfffcb8 	bl	3480b85c <insert_var_value_sub>
			set_local_var(p, 0);
3480c578:	e3a01000 	mov	r1, #0
	return insert_var_value_sub(inp, 0);
3480c57c:	e1a07000 	mov	r7, r0
			set_local_var(p, 0);
3480c580:	ebfffc4a 	bl	3480b6b0 <set_local_var>
			if (p != child->argv[i]) {
3480c584:	e5993000 	ldr	r3, [r9]
3480c588:	e793300a 	ldr	r3, [r3, sl]
3480c58c:	e1570003 	cmp	r7, r3
3480c590:	0a000004 	beq	3480c5a8 <run_list_real+0x518>
				child->sp--;
3480c594:	e599300c 	ldr	r3, [r9, #12]
				free(p);
3480c598:	e1a00007 	mov	r0, r7
				child->sp--;
3480c59c:	e2433001 	sub	r3, r3, #1
3480c5a0:	e589300c 	str	r3, [r9, #12]
				free(p);
3480c5a4:	ebfff5c1 	bl	34809cb0 <free>
3480c5a8:	e28aa004 	add	sl, sl, #4
		for (i = 0; is_assignment(child->argv[i]); i++) {
3480c5ac:	e5993000 	ldr	r3, [r9]
3480c5b0:	e083700a 	add	r7, r3, sl
3480c5b4:	e793300a 	ldr	r3, [r3, sl]
3480c5b8:	e1a00003 	mov	r0, r3
3480c5bc:	e58d3018 	str	r3, [sp, #24]
3480c5c0:	ebfffb58 	bl	3480b328 <is_assignment>
3480c5c4:	e3500000 	cmp	r0, #0
3480c5c8:	e59d3018 	ldr	r3, [sp, #24]
3480c5cc:	1affffe6 	bne	3480c56c <run_list_real+0x4dc>
		if (child->sp) {
3480c5d0:	e599200c 	ldr	r2, [r9, #12]
3480c5d4:	e3520000 	cmp	r2, #0
3480c5d8:	0a00003d 	beq	3480c6d4 <run_list_real+0x644>
	noeval_str = get_local_var("HUSH_NO_EVAL");
3480c5dc:	e59f0218 	ldr	r0, [pc, #536]	; 3480c7fc <run_list_real+0x76c>
3480c5e0:	ebfffc0e 	bl	3480b620 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c5e4:	e3500000 	cmp	r0, #0
	int noeval = 0;
3480c5e8:	058d0018 	streq	r0, [sp, #24]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c5ec:	0a000005 	beq	3480c608 <run_list_real+0x578>
3480c5f0:	e5d00000 	ldrb	r0, [r0]
	int noeval = 0;
3480c5f4:	e3500030 	cmp	r0, #48	; 0x30
3480c5f8:	13500000 	cmpne	r0, #0
3480c5fc:	13a03001 	movne	r3, #1
3480c600:	03a03000 	moveq	r3, #0
3480c604:	e58d3018 	str	r3, [sp, #24]
	for (n = 0; inp[n]; n++) {
3480c608:	e3a09000 	mov	r9, #0
3480c60c:	e2477004 	sub	r7, r7, #4
	char *str = NULL;
3480c610:	e1a06009 	mov	r6, r9
	int len = 2;
3480c614:	e3a03002 	mov	r3, #2
3480c618:	e58d3020 	str	r3, [sp, #32]
	for (n = 0; inp[n]; n++) {
3480c61c:	e5b7a004 	ldr	sl, [r7, #4]!
3480c620:	e35a0000 	cmp	sl, #0
3480c624:	0a00001c 	beq	3480c69c <run_list_real+0x60c>
		p = insert_var_value_sub(inp[n], noeval);
3480c628:	e59d1018 	ldr	r1, [sp, #24]
3480c62c:	e1a0000a 	mov	r0, sl
3480c630:	ebfffc89 	bl	3480b85c <insert_var_value_sub>
3480c634:	e1a0a000 	mov	sl, r0
		str = xrealloc(str, (len + strlen(p)));
3480c638:	eb003ca6 	bl	3481b8d8 <strlen>
3480c63c:	e59d3020 	ldr	r3, [sp, #32]
3480c640:	e0801003 	add	r1, r0, r3
3480c644:	e1a00006 	mov	r0, r6
3480c648:	ebffface 	bl	3480b188 <xrealloc>
		if (n) {
3480c64c:	e3590000 	cmp	r9, #0
		str = xrealloc(str, (len + strlen(p)));
3480c650:	e1a06000 	mov	r6, r0
			*str = '\0';
3480c654:	05c09000 	strbeq	r9, [r0]
		if (n) {
3480c658:	0a000001 	beq	3480c664 <run_list_real+0x5d4>
			strcat(str, " ");
3480c65c:	e59f119c 	ldr	r1, [pc, #412]	; 3480c800 <run_list_real+0x770>
3480c660:	eb003c4d 	bl	3481b79c <strcat>
		strcat(str, p);
3480c664:	e1a0100a 	mov	r1, sl
3480c668:	e1a00006 	mov	r0, r6
3480c66c:	eb003c4a 	bl	3481b79c <strcat>
		len = strlen(str) + 3;
3480c670:	e1a00006 	mov	r0, r6
3480c674:	eb003c97 	bl	3481b8d8 <strlen>
3480c678:	e2803003 	add	r3, r0, #3
3480c67c:	e58d3020 	str	r3, [sp, #32]
		if (p != inp[n]) free(p);
3480c680:	e5973000 	ldr	r3, [r7]
3480c684:	e15a0003 	cmp	sl, r3
3480c688:	0a000001 	beq	3480c694 <run_list_real+0x604>
3480c68c:	e1a0000a 	mov	r0, sl
3480c690:	ebfff586 	bl	34809cb0 <free>
	for (n = 0; inp[n]; n++) {
3480c694:	e2899001 	add	r9, r9, #1
3480c698:	eaffffdf 	b	3480c61c <run_list_real+0x58c>
	len = strlen(str);
3480c69c:	e1a00006 	mov	r0, r6
3480c6a0:	eb003c8c 	bl	3481b8d8 <strlen>
	*(str + len) = '\n';
3480c6a4:	e1a03006 	mov	r3, r6
3480c6a8:	e3a0200a 	mov	r2, #10
3480c6ac:	e7e32000 	strb	r2, [r3, r0]!
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c6b0:	e3a01005 	mov	r1, #5
	*(str + len + 1) = '\0';
3480c6b4:	e5c3a001 	strb	sl, [r3, #1]
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c6b8:	e1a00006 	mov	r0, r6
3480c6bc:	ebfffe3a 	bl	3480bfac <parse_string_outer>
			free(str);
3480c6c0:	e1a00006 	mov	r0, r6
3480c6c4:	ebfff579 	bl	34809cb0 <free>
			return last_return_code;
3480c6c8:	e59f3124 	ldr	r3, [pc, #292]	; 3480c7f4 <run_list_real+0x764>
3480c6cc:	e5936134 	ldr	r6, [r3, #308]	; 0x134
3480c6d0:	ea000010 	b	3480c718 <run_list_real+0x688>
		if (strchr(child->argv[i], ';')) {
3480c6d4:	e3a0103b 	mov	r1, #59	; 0x3b
3480c6d8:	e1a00003 	mov	r0, r3
3480c6dc:	eb003c68 	bl	3481b884 <strchr>
3480c6e0:	e3500000 	cmp	r0, #0
3480c6e4:	0a000004 	beq	3480c6fc <run_list_real+0x66c>
			printf("Unknown command '%s' - try 'help' or use "
3480c6e8:	e5993000 	ldr	r3, [r9]
3480c6ec:	e59f0110 	ldr	r0, [pc, #272]	; 3480c804 <run_list_real+0x774>
3480c6f0:	e793100a 	ldr	r1, [r3, sl]
3480c6f4:	ebfff428 	bl	3480979c <printf>
3480c6f8:	ea00000e 	b	3480c738 <run_list_real+0x6a8>
		return cmd_process(flag, child->argc, child->argv,
3480c6fc:	e2960000 	adds	r0, r6, #0
3480c700:	e59f3100 	ldr	r3, [pc, #256]	; 3480c808 <run_list_real+0x778>
3480c704:	e5992000 	ldr	r2, [r9]
3480c708:	13a00001 	movne	r0, #1
3480c70c:	e5991004 	ldr	r1, [r9, #4]
3480c710:	ebfff357 	bl	34809474 <cmd_process>
3480c714:	e1a06000 	mov	r6, r0
		if (rcode < -1) {
3480c718:	e3760001 	cmn	r6, #1
3480c71c:	aa000006 	bge	3480c73c <run_list_real+0x6ac>
			last_return_code = -rcode - 2;
3480c720:	e59f20cc 	ldr	r2, [pc, #204]	; 3480c7f4 <run_list_real+0x764>
3480c724:	e3e03001 	mvn	r3, #1
3480c728:	e0663003 	rsb	r3, r6, r3
			return -2;	/* exit */
3480c72c:	e3e00001 	mvn	r0, #1
			last_return_code = -rcode - 2;
3480c730:	e5823134 	str	r3, [r2, #308]	; 0x134
			return -2;	/* exit */
3480c734:	ea00002c 	b	3480c7ec <run_list_real+0x75c>
	return -1;
3480c738:	e3e06000 	mvn	r6, #0
		last_return_code=(rcode == 0) ? 0 : 1;
3480c73c:	e59f20b0 	ldr	r2, [pc, #176]	; 3480c7f4 <run_list_real+0x764>
3480c740:	e2963000 	adds	r3, r6, #0
3480c744:	13a03001 	movne	r3, #1
3480c748:	e5823134 	str	r3, [r2, #308]	; 0x134
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480c74c:	e3c42002 	bic	r2, r4, #2
3480c750:	e3520001 	cmp	r2, #1
3480c754:	0a000022 	beq	3480c7e4 <run_list_real+0x754>
		if (rmode == RES_WHILE)
3480c758:	e3540007 	cmp	r4, #7
			flag_rep = !last_return_code;
3480c75c:	02232001 	eoreq	r2, r3, #1
		if (rmode == RES_WHILE)
3480c760:	0a000002 	beq	3480c770 <run_list_real+0x6e0>
			flag_rep = last_return_code;
3480c764:	e3540008 	cmp	r4, #8
3480c768:	e59d2004 	ldr	r2, [sp, #4]
3480c76c:	01a02003 	moveq	r2, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480c770:	e3560000 	cmp	r6, #0
			flag_rep = last_return_code;
3480c774:	e58d2004 	str	r2, [sp, #4]
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480c778:	1a000002 	bne	3480c788 <run_list_real+0x6f8>
3480c77c:	e595300c 	ldr	r3, [r5, #12]
		skip_more_in_this_rmode = RES_XXXX;
3480c780:	e3530003 	cmp	r3, #3
3480c784:	ea000006 	b	3480c7a4 <run_list_real+0x714>
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480c788:	e3530000 	cmp	r3, #0
		skip_more_in_this_rmode = RES_XXXX;
3480c78c:	03a0400b 	moveq	r4, #11
		flag_skip = 1;
3480c790:	03a07001 	moveq	r7, #1
3480c794:	01a06003 	moveq	r6, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480c798:	0a000009 	beq	3480c7c4 <run_list_real+0x734>
		     (rcode!=EXIT_SUCCESS && pi->followup==PIPE_AND) )
3480c79c:	e595300c 	ldr	r3, [r5, #12]
		skip_more_in_this_rmode = RES_XXXX;
3480c7a0:	e3530002 	cmp	r3, #2
3480c7a4:	13a0400b 	movne	r4, #11
3480c7a8:	ea000000 	b	3480c7b0 <run_list_real+0x720>
3480c7ac:	e3a0400b 	mov	r4, #11
		flag_skip = 1;
3480c7b0:	e3a07001 	mov	r7, #1
3480c7b4:	ea000002 	b	3480c7c4 <run_list_real+0x734>
		skip_more_in_this_rmode = RES_XXXX;
3480c7b8:	e3a0400b 	mov	r4, #11
3480c7bc:	e58d200c 	str	r2, [sp, #12]
3480c7c0:	eafffffa 	b	3480c7b0 <run_list_real+0x720>
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480c7c4:	e59d3008 	ldr	r3, [sp, #8]
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c7c8:	e1a09004 	mov	r9, r4
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480c7cc:	e3530000 	cmp	r3, #0
3480c7d0:	05955008 	ldreq	r5, [r5, #8]
3480c7d4:	159d5000 	ldrne	r5, [sp]
3480c7d8:	eafffe5d 	b	3480c154 <run_list_real+0xc4>
					return 1;
3480c7dc:	e3a00001 	mov	r0, #1
3480c7e0:	ea000001 	b	3480c7ec <run_list_real+0x75c>
3480c7e4:	e58d601c 	str	r6, [sp, #28]
3480c7e8:	eaffffdd 	b	3480c764 <run_list_real+0x6d4>
}
3480c7ec:	e28dd028 	add	sp, sp, #40	; 0x28
3480c7f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480c7f4:	34828aa0 	.word	0x34828aa0
3480c7f8:	348226d6 	.word	0x348226d6
3480c7fc:	34824f4e 	.word	0x34824f4e
3480c800:	34825157 	.word	0x34825157
3480c804:	34824f5b 	.word	0x34824f5b
3480c808:	34828aa4 	.word	0x34828aa4

3480c80c <parse_stream_outer>:
{
3480c80c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int code = 0;
3480c810:	e3a05000 	mov	r5, #0
		m = map[ch];
3480c814:	e59f95f4 	ldr	r9, [pc, #1524]	; 3480ce10 <parse_stream_outer+0x604>
{
3480c818:	e24dd030 	sub	sp, sp, #48	; 0x30
3480c81c:	e1a04000 	mov	r4, r0
3480c820:	e1a0a001 	mov	sl, r1
	o_string temp=NULL_O_STRING;
3480c824:	e3a02014 	mov	r2, #20
3480c828:	e3a01000 	mov	r1, #0
3480c82c:	e1a0000d 	mov	r0, sp
3480c830:	eb003cd1 	bl	3481bb7c <memset>
	ctx->pipe=NULL;
3480c834:	e3a06000 	mov	r6, #0
		ctx.type = flag;
3480c838:	e58da02c 	str	sl, [sp, #44]	; 0x2c
	ctx->pipe=NULL;
3480c83c:	e58d601c 	str	r6, [sp, #28]
	ctx->child=NULL;
3480c840:	e58d6014 	str	r6, [sp, #20]
	ctx->list_head=new_pipe();
3480c844:	ebfffcdc 	bl	3480bbbc <new_pipe>
3480c848:	e58d0018 	str	r0, [sp, #24]
	ctx->pipe=ctx->list_head;
3480c84c:	e58d001c 	str	r0, [sp, #28]
	done_command(ctx);   /* creates the memory for working child */
3480c850:	e28d0014 	add	r0, sp, #20
	ctx->w=RES_NONE;
3480c854:	e58d6020 	str	r6, [sp, #32]
	ctx->stack=NULL;
3480c858:	e58d6028 	str	r6, [sp, #40]	; 0x28
	ctx->old_flag=0;
3480c85c:	e58d6024 	str	r6, [sp, #36]	; 0x24
	done_command(ctx);   /* creates the memory for working child */
3480c860:	ebfffa50 	bl	3480b1a8 <done_command>
		update_ifs_map();
3480c864:	ebfffdac 	bl	3480bf1c <update_ifs_map>
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
3480c868:	e20a3006 	and	r3, sl, #6
3480c86c:	e3530002 	cmp	r3, #2
3480c870:	0a000002 	beq	3480c880 <parse_stream_outer+0x74>
3480c874:	e1a01006 	mov	r1, r6
3480c878:	e59f0594 	ldr	r0, [pc, #1428]	; 3480ce14 <parse_stream_outer+0x608>
3480c87c:	ebfffd9d 	bl	3480bef8 <mapset>
		inp->promptmode=1;
3480c880:	e3a03001 	mov	r3, #1
3480c884:	e5843008 	str	r3, [r4, #8]
	while ((ch=b_getch(input))!=EOF) {
3480c888:	e594300c 	ldr	r3, [r4, #12]
3480c88c:	e1a00004 	mov	r0, r4
3480c890:	e12fff33 	blx	r3
3480c894:	e3700001 	cmn	r0, #1
3480c898:	e1a0b000 	mov	fp, r0
3480c89c:	0a000106 	beq	3480ccbc <parse_stream_outer+0x4b0>
		m = map[ch];
3480c8a0:	e089200b 	add	r2, r9, fp
3480c8a4:	e5d26138 	ldrb	r6, [r2, #312]	; 0x138
		if (input->__promptme == 0) return 1;
3480c8a8:	e5942004 	ldr	r2, [r4, #4]
3480c8ac:	e3520000 	cmp	r2, #0
3480c8b0:	0a000103 	beq	3480ccc4 <parse_stream_outer+0x4b8>
		next = (ch == '\n') ? 0 : b_peek(input);
3480c8b4:	e35b000a 	cmp	fp, #10
3480c8b8:	03a07000 	moveq	r7, #0
3480c8bc:	0a000003 	beq	3480c8d0 <parse_stream_outer+0xc4>
3480c8c0:	e5942010 	ldr	r2, [r4, #16]
3480c8c4:	e1a00004 	mov	r0, r4
3480c8c8:	e12fff32 	blx	r2
3480c8cc:	e1a07000 	mov	r7, r0
		if (m==0 || ((m==1 || m==2) && dest->quote)) {
3480c8d0:	e3560000 	cmp	r6, #0
3480c8d4:	0a0000b6 	beq	3480cbb4 <parse_stream_outer+0x3a8>
3480c8d8:	e2462001 	sub	r2, r6, #1
3480c8dc:	e3520001 	cmp	r2, #1
3480c8e0:	8a00000f 	bhi	3480c924 <parse_stream_outer+0x118>
3480c8e4:	e59d200c 	ldr	r2, [sp, #12]
3480c8e8:	e3520000 	cmp	r2, #0
3480c8ec:	1a0000b0 	bne	3480cbb4 <parse_stream_outer+0x3a8>
			if (m==2) {  /* unquoted IFS */
3480c8f0:	e3560002 	cmp	r6, #2
3480c8f4:	1a000013 	bne	3480c948 <parse_stream_outer+0x13c>
				if (done_word(dest, ctx)) {
3480c8f8:	e28d1014 	add	r1, sp, #20
3480c8fc:	e1a0000d 	mov	r0, sp
3480c900:	ebfffd1f 	bl	3480bd84 <done_word>
3480c904:	e3500000 	cmp	r0, #0
3480c908:	1a0000ed 	bne	3480ccc4 <parse_stream_outer+0x4b8>
				if (end_trigger != '\0' && ch=='\n')
3480c90c:	e35b000a 	cmp	fp, #10
3480c910:	1affffdc 	bne	3480c888 <parse_stream_outer+0x7c>
					done_pipe(ctx,PIPE_SEQ);
3480c914:	e3a01001 	mov	r1, #1
3480c918:	e28d0014 	add	r0, sp, #20
3480c91c:	ebfffcb0 	bl	3480bbe4 <done_pipe>
3480c920:	ea000001 	b	3480c92c <parse_stream_outer+0x120>
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480c924:	e35b000a 	cmp	fp, #10
3480c928:	1a00000d 	bne	3480c964 <parse_stream_outer+0x158>
3480c92c:	e59d200c 	ldr	r2, [sp, #12]
3480c930:	e3520000 	cmp	r2, #0
3480c934:	0a000005 	beq	3480c950 <parse_stream_outer+0x144>
			if (m!=2) switch (ch) {
3480c938:	e3560002 	cmp	r6, #2
3480c93c:	0affffd1 	beq	3480c888 <parse_stream_outer+0x7c>
3480c940:	e35b0026 	cmp	fp, #38	; 0x26
3480c944:	ea000008 	b	3480c96c <parse_stream_outer+0x160>
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480c948:	e35b000a 	cmp	fp, #10
3480c94c:	1a000004 	bne	3480c964 <parse_stream_outer+0x158>
3480c950:	e59d2020 	ldr	r2, [sp, #32]
3480c954:	e3520000 	cmp	r2, #0
3480c958:	1afffff6 	bne	3480c938 <parse_stream_outer+0x12c>
				return 0;
3480c95c:	e1a07002 	mov	r7, r2
3480c960:	ea0000dc 	b	3480ccd8 <parse_stream_outer+0x4cc>
			if (m!=2) switch (ch) {
3480c964:	e35b0026 	cmp	fp, #38	; 0x26
3480c968:	0a0000ad 	beq	3480cc24 <parse_stream_outer+0x418>
3480c96c:	8a00000c 	bhi	3480c9a4 <parse_stream_outer+0x198>
3480c970:	e35b0022 	cmp	fp, #34	; 0x22
3480c974:	0a00009e 	beq	3480cbf4 <parse_stream_outer+0x3e8>
3480c978:	8a000004 	bhi	3480c990 <parse_stream_outer+0x184>
3480c97c:	e35b0004 	cmp	fp, #4
3480c980:	1a0000cb 	bne	3480ccb4 <parse_stream_outer+0x4a8>
			dest->nonnull = 1;
3480c984:	e3a03001 	mov	r3, #1
3480c988:	e58d3010 	str	r3, [sp, #16]
3480c98c:	ea0000bf 	b	3480cc90 <parse_stream_outer+0x484>
			if (m!=2) switch (ch) {
3480c990:	e35b0023 	cmp	fp, #35	; 0x23
3480c994:	0a00000f 	beq	3480c9d8 <parse_stream_outer+0x1cc>
3480c998:	e35b0024 	cmp	fp, #36	; 0x24
3480c99c:	0a00002e 	beq	3480ca5c <parse_stream_outer+0x250>
3480c9a0:	ea0000c3 	b	3480ccb4 <parse_stream_outer+0x4a8>
3480c9a4:	e35b003b 	cmp	fp, #59	; 0x3b
3480c9a8:	0a000098 	beq	3480cc10 <parse_stream_outer+0x404>
3480c9ac:	8a000004 	bhi	3480c9c4 <parse_stream_outer+0x1b8>
3480c9b0:	e35b0027 	cmp	fp, #39	; 0x27
3480c9b4:	1a0000be 	bne	3480ccb4 <parse_stream_outer+0x4a8>
			dest->nonnull = 1;
3480c9b8:	e3a03001 	mov	r3, #1
3480c9bc:	e58d3010 	str	r3, [sp, #16]
3480c9c0:	ea000083 	b	3480cbd4 <parse_stream_outer+0x3c8>
			if (m!=2) switch (ch) {
3480c9c4:	e35b005c 	cmp	fp, #92	; 0x5c
3480c9c8:	0a000017 	beq	3480ca2c <parse_stream_outer+0x220>
3480c9cc:	e35b007c 	cmp	fp, #124	; 0x7c
3480c9d0:	0a00009d 	beq	3480cc4c <parse_stream_outer+0x440>
3480c9d4:	ea0000b6 	b	3480ccb4 <parse_stream_outer+0x4a8>
			if (dest->length == 0 && !dest->quote) {
3480c9d8:	e59d3004 	ldr	r3, [sp, #4]
3480c9dc:	e3530000 	cmp	r3, #0
3480c9e0:	1a00000c 	bne	3480ca18 <parse_stream_outer+0x20c>
3480c9e4:	e59d300c 	ldr	r3, [sp, #12]
3480c9e8:	e3530000 	cmp	r3, #0
3480c9ec:	1a000009 	bne	3480ca18 <parse_stream_outer+0x20c>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
3480c9f0:	e5943010 	ldr	r3, [r4, #16]
3480c9f4:	e1a00004 	mov	r0, r4
3480c9f8:	e12fff33 	blx	r3
3480c9fc:	e350000a 	cmp	r0, #10
3480ca00:	13700001 	cmnne	r0, #1
3480ca04:	0affff9f 	beq	3480c888 <parse_stream_outer+0x7c>
3480ca08:	e594300c 	ldr	r3, [r4, #12]
3480ca0c:	e1a00004 	mov	r0, r4
3480ca10:	e12fff33 	blx	r3
3480ca14:	eafffff5 	b	3480c9f0 <parse_stream_outer+0x1e4>
				b_addqchr(dest, ch, dest->quote);
3480ca18:	e59d200c 	ldr	r2, [sp, #12]
3480ca1c:	e3a01023 	mov	r1, #35	; 0x23
3480ca20:	e1a0000d 	mov	r0, sp
3480ca24:	ebfffae9 	bl	3480b5d0 <b_addqchr>
3480ca28:	eaffff96 	b	3480c888 <parse_stream_outer+0x7c>
			if (next == EOF) {
3480ca2c:	e3770001 	cmn	r7, #1
3480ca30:	0a00009f 	beq	3480ccb4 <parse_stream_outer+0x4a8>
			b_addqchr(dest, '\\', dest->quote);
3480ca34:	e59d200c 	ldr	r2, [sp, #12]
3480ca38:	e1a0100b 	mov	r1, fp
3480ca3c:	e1a0000d 	mov	r0, sp
3480ca40:	ebfffae2 	bl	3480b5d0 <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
3480ca44:	e594300c 	ldr	r3, [r4, #12]
3480ca48:	e1a00004 	mov	r0, r4
3480ca4c:	e12fff33 	blx	r3
3480ca50:	e59d200c 	ldr	r2, [sp, #12]
3480ca54:	e1a01000 	mov	r1, r0
3480ca58:	eafffff0 	b	3480ca20 <parse_stream_outer+0x214>
	int ch = input->peek(input);  /* first character after the $ */
3480ca5c:	e5942010 	ldr	r2, [r4, #16]
3480ca60:	e1a00004 	mov	r0, r4
	if (isalpha(ch)) {
3480ca64:	e59f63ac 	ldr	r6, [pc, #940]	; 3480ce18 <parse_stream_outer+0x60c>
	int ch = input->peek(input);  /* first character after the $ */
3480ca68:	e12fff32 	blx	r2
	if (isalpha(ch)) {
3480ca6c:	e6ef2070 	uxtb	r2, r0
	int ch = input->peek(input);  /* first character after the $ */
3480ca70:	e1a07000 	mov	r7, r0
	if (isalpha(ch)) {
3480ca74:	e7d62002 	ldrb	r2, [r6, r2]
3480ca78:	e3120003 	tst	r2, #3
3480ca7c:	0a000019 	beq	3480cae8 <parse_stream_outer+0x2dc>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ca80:	e3a01003 	mov	r1, #3
3480ca84:	e1a0000d 	mov	r0, sp
3480ca88:	ebfffab2 	bl	3480b558 <b_addchr>
		ctx->child->sp++;
3480ca8c:	e59d2014 	ldr	r2, [sp, #20]
3480ca90:	e592300c 	ldr	r3, [r2, #12]
3480ca94:	e2833001 	add	r3, r3, #1
3480ca98:	e582300c 	str	r3, [r2, #12]
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
3480ca9c:	e5943010 	ldr	r3, [r4, #16]
3480caa0:	e1a00004 	mov	r0, r4
3480caa4:	e12fff33 	blx	r3
3480caa8:	e6ef3070 	uxtb	r3, r0
3480caac:	e1a07000 	mov	r7, r0
3480cab0:	e7d63003 	ldrb	r3, [r6, r3]
3480cab4:	e2133007 	ands	r3, r3, #7
3480cab8:	13a03001 	movne	r3, #1
3480cabc:	e350005f 	cmp	r0, #95	; 0x5f
3480cac0:	03833001 	orreq	r3, r3, #1
3480cac4:	e3530000 	cmp	r3, #0
3480cac8:	0a000035 	beq	3480cba4 <parse_stream_outer+0x398>
			b_getch(input);
3480cacc:	e594300c 	ldr	r3, [r4, #12]
3480cad0:	e1a00004 	mov	r0, r4
3480cad4:	e12fff33 	blx	r3
			b_addchr(dest,ch);
3480cad8:	e1a01007 	mov	r1, r7
3480cadc:	e1a0000d 	mov	r0, sp
3480cae0:	ebfffa9c 	bl	3480b558 <b_addchr>
3480cae4:	eaffffec 	b	3480ca9c <parse_stream_outer+0x290>
	} else switch (ch) {
3480cae8:	e350003f 	cmp	r0, #63	; 0x3f
3480caec:	0a00000c 	beq	3480cb24 <parse_stream_outer+0x318>
3480caf0:	e350007b 	cmp	r0, #123	; 0x7b
3480caf4:	1a00002e 	bne	3480cbb4 <parse_stream_outer+0x3a8>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480caf8:	e3a01003 	mov	r1, #3
3480cafc:	e1a0000d 	mov	r0, sp
3480cb00:	ebfffa94 	bl	3480b558 <b_addchr>
			ctx->child->sp++;
3480cb04:	e59d2014 	ldr	r2, [sp, #20]
			b_getch(input);
3480cb08:	e1a00004 	mov	r0, r4
			ctx->child->sp++;
3480cb0c:	e592300c 	ldr	r3, [r2, #12]
3480cb10:	e2833001 	add	r3, r3, #1
3480cb14:	e582300c 	str	r3, [r2, #12]
			b_getch(input);
3480cb18:	e594300c 	ldr	r3, [r4, #12]
3480cb1c:	e12fff33 	blx	r3
3480cb20:	ea000013 	b	3480cb74 <parse_stream_outer+0x368>
			ctx->child->sp++;
3480cb24:	e59d1014 	ldr	r1, [sp, #20]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480cb28:	e1a0000d 	mov	r0, sp
			ctx->child->sp++;
3480cb2c:	e591200c 	ldr	r2, [r1, #12]
3480cb30:	e2822001 	add	r2, r2, #1
3480cb34:	e581200c 	str	r2, [r1, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480cb38:	e3a01003 	mov	r1, #3
3480cb3c:	ebfffa85 	bl	3480b558 <b_addchr>
			b_addchr(dest, '$');
3480cb40:	e1a0100b 	mov	r1, fp
3480cb44:	e1a0000d 	mov	r0, sp
3480cb48:	ebfffa82 	bl	3480b558 <b_addchr>
			b_addchr(dest, '?');
3480cb4c:	e1a01007 	mov	r1, r7
3480cb50:	e1a0000d 	mov	r0, sp
3480cb54:	ebfffa7f 	bl	3480b558 <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480cb58:	e3a01003 	mov	r1, #3
3480cb5c:	e1a0000d 	mov	r0, sp
3480cb60:	ebfffa7c 	bl	3480b558 <b_addchr>
	if (advance) b_getch(input);
3480cb64:	e594300c 	ldr	r3, [r4, #12]
3480cb68:	e1a00004 	mov	r0, r4
3480cb6c:	e12fff33 	blx	r3
3480cb70:	eaffff44 	b	3480c888 <parse_stream_outer+0x7c>
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
3480cb74:	e594300c 	ldr	r3, [r4, #12]
3480cb78:	e1a00004 	mov	r0, r4
3480cb7c:	e12fff33 	blx	r3
3480cb80:	e350007d 	cmp	r0, #125	; 0x7d
3480cb84:	13700001 	cmnne	r0, #1
3480cb88:	e1a01000 	mov	r1, r0
3480cb8c:	0a000002 	beq	3480cb9c <parse_stream_outer+0x390>
				b_addchr(dest,ch);
3480cb90:	e1a0000d 	mov	r0, sp
3480cb94:	ebfffa6f 	bl	3480b558 <b_addchr>
3480cb98:	eafffff5 	b	3480cb74 <parse_stream_outer+0x368>
			if (ch != '}') {
3480cb9c:	e350007d 	cmp	r0, #125	; 0x7d
3480cba0:	1a000043 	bne	3480ccb4 <parse_stream_outer+0x4a8>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480cba4:	e3a01003 	mov	r1, #3
3480cba8:	e1a0000d 	mov	r0, sp
3480cbac:	ebfffa69 	bl	3480b558 <b_addchr>
3480cbb0:	eaffff34 	b	3480c888 <parse_stream_outer+0x7c>
			b_addqchr(dest,'$',dest->quote);
3480cbb4:	e59d200c 	ldr	r2, [sp, #12]
3480cbb8:	e1a0100b 	mov	r1, fp
3480cbbc:	eaffff97 	b	3480ca20 <parse_stream_outer+0x214>
				if(input->__promptme == 0) return 1;
3480cbc0:	e5943004 	ldr	r3, [r4, #4]
3480cbc4:	e3530000 	cmp	r3, #0
3480cbc8:	0a00003d 	beq	3480ccc4 <parse_stream_outer+0x4b8>
				b_addchr(dest,ch);
3480cbcc:	e1a0000d 	mov	r0, sp
3480cbd0:	ebfffa60 	bl	3480b558 <b_addchr>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
3480cbd4:	e594300c 	ldr	r3, [r4, #12]
3480cbd8:	e1a00004 	mov	r0, r4
3480cbdc:	e12fff33 	blx	r3
3480cbe0:	e3500027 	cmp	r0, #39	; 0x27
3480cbe4:	13700001 	cmnne	r0, #1
3480cbe8:	e1a01000 	mov	r1, r0
3480cbec:	1afffff3 	bne	3480cbc0 <parse_stream_outer+0x3b4>
3480cbf0:	ea00002d 	b	3480ccac <parse_stream_outer+0x4a0>
			dest->nonnull = 1;
3480cbf4:	e3a03001 	mov	r3, #1
3480cbf8:	e58d3010 	str	r3, [sp, #16]
			dest->quote = !dest->quote;
3480cbfc:	e59d300c 	ldr	r3, [sp, #12]
3480cc00:	e16f3f13 	clz	r3, r3
3480cc04:	e1a032a3 	lsr	r3, r3, #5
3480cc08:	e58d300c 	str	r3, [sp, #12]
3480cc0c:	eaffff1d 	b	3480c888 <parse_stream_outer+0x7c>
			done_word(dest, ctx);
3480cc10:	e28d1014 	add	r1, sp, #20
3480cc14:	e1a0000d 	mov	r0, sp
3480cc18:	ebfffc59 	bl	3480bd84 <done_word>
			done_pipe(ctx,PIPE_SEQ);
3480cc1c:	e3a01001 	mov	r1, #1
3480cc20:	ea000012 	b	3480cc70 <parse_stream_outer+0x464>
			done_word(dest, ctx);
3480cc24:	e28d1014 	add	r1, sp, #20
3480cc28:	e1a0000d 	mov	r0, sp
3480cc2c:	ebfffc54 	bl	3480bd84 <done_word>
			if (next=='&') {
3480cc30:	e3570026 	cmp	r7, #38	; 0x26
3480cc34:	1a00001e 	bne	3480ccb4 <parse_stream_outer+0x4a8>
				b_getch(input);
3480cc38:	e594300c 	ldr	r3, [r4, #12]
3480cc3c:	e1a00004 	mov	r0, r4
3480cc40:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
3480cc44:	e3a01002 	mov	r1, #2
3480cc48:	ea000008 	b	3480cc70 <parse_stream_outer+0x464>
			done_word(dest, ctx);
3480cc4c:	e28d1014 	add	r1, sp, #20
3480cc50:	e1a0000d 	mov	r0, sp
3480cc54:	ebfffc4a 	bl	3480bd84 <done_word>
			if (next=='|') {
3480cc58:	e357007c 	cmp	r7, #124	; 0x7c
3480cc5c:	1a000014 	bne	3480ccb4 <parse_stream_outer+0x4a8>
				b_getch(input);
3480cc60:	e594300c 	ldr	r3, [r4, #12]
3480cc64:	e1a00004 	mov	r0, r4
3480cc68:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
3480cc6c:	e3a01003 	mov	r1, #3
3480cc70:	e28d0014 	add	r0, sp, #20
3480cc74:	ebfffbda 	bl	3480bbe4 <done_pipe>
3480cc78:	eaffff02 	b	3480c888 <parse_stream_outer+0x7c>
				if (input->__promptme == 0)
3480cc7c:	e5943004 	ldr	r3, [r4, #4]
3480cc80:	e3530000 	cmp	r3, #0
3480cc84:	0a00000e 	beq	3480ccc4 <parse_stream_outer+0x4b8>
				b_addchr(dest, ch);
3480cc88:	e1a0000d 	mov	r0, sp
3480cc8c:	ebfffa31 	bl	3480b558 <b_addchr>
			while (ch = b_getch(input), ch != EOF &&
3480cc90:	e594300c 	ldr	r3, [r4, #12]
3480cc94:	e1a00004 	mov	r0, r4
3480cc98:	e12fff33 	blx	r3
3480cc9c:	e3500004 	cmp	r0, #4
3480cca0:	13700001 	cmnne	r0, #1
3480cca4:	e1a01000 	mov	r1, r0
3480cca8:	1afffff3 	bne	3480cc7c <parse_stream_outer+0x470>
			if (ch == EOF) {
3480ccac:	e3710001 	cmn	r1, #1
3480ccb0:	1afffef4 	bne	3480c888 <parse_stream_outer+0x7c>
			syntax();   /* this is really an internal logic error */
3480ccb4:	ebfff8ee 	bl	3480b074 <syntax_err>
3480ccb8:	ea000001 	b	3480ccc4 <parse_stream_outer+0x4b8>
	if (end_trigger != '\0') return -1;
3480ccbc:	e1a07000 	mov	r7, r0
3480ccc0:	ea000004 	b	3480ccd8 <parse_stream_outer+0x4cc>
		if (rcode == 1) flag_repeat = 0;
3480ccc4:	e59f2144 	ldr	r2, [pc, #324]	; 3480ce10 <parse_stream_outer+0x604>
3480ccc8:	e3a03000 	mov	r3, #0
3480cccc:	e3a07001 	mov	r7, #1
3480ccd0:	e5823004 	str	r3, [r2, #4]
3480ccd4:	ea000008 	b	3480ccfc <parse_stream_outer+0x4f0>
		if (rcode != 1 && ctx.old_flag != 0) {
3480ccd8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3480ccdc:	e3530000 	cmp	r3, #0
3480cce0:	0a000002 	beq	3480ccf0 <parse_stream_outer+0x4e4>
			syntax();
3480cce4:	ebfff8e2 	bl	3480b074 <syntax_err>
			flag_repeat = 0;
3480cce8:	e3a03000 	mov	r3, #0
3480ccec:	e5893004 	str	r3, [r9, #4]
		if (rcode != 1 && ctx.old_flag == 0) {
3480ccf0:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
3480ccf4:	e3560000 	cmp	r6, #0
3480ccf8:	0a00001f 	beq	3480cd7c <parse_stream_outer+0x570>
			if (ctx.old_flag != 0) {
3480ccfc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3480cd00:	e3530000 	cmp	r3, #0
3480cd04:	0a000003 	beq	3480cd18 <parse_stream_outer+0x50c>
				free(ctx.stack);
3480cd08:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
3480cd0c:	ebfff3e7 	bl	34809cb0 <free>
				b_reset(&temp);
3480cd10:	e1a0000d 	mov	r0, sp
3480cd14:	ebfff8c2 	bl	3480b024 <b_reset>
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
3480cd18:	e5943004 	ldr	r3, [r4, #4]
3480cd1c:	e3530000 	cmp	r3, #0
3480cd20:	1a000001 	bne	3480cd2c <parse_stream_outer+0x520>
3480cd24:	e59f00f0 	ldr	r0, [pc, #240]	; 3480ce1c <parse_stream_outer+0x610>
3480cd28:	ebfff29b 	bl	3480979c <printf>
			temp.nonnull = 0;
3480cd2c:	e3a01000 	mov	r1, #0
			inp->__promptme = 1;
3480cd30:	e3a03001 	mov	r3, #1
3480cd34:	e5843004 	str	r3, [r4, #4]
			inp->p = NULL;
3480cd38:	e5841000 	str	r1, [r4]
			free_pipe_list(ctx.list_head,0);
3480cd3c:	e59d0018 	ldr	r0, [sp, #24]
			temp.nonnull = 0;
3480cd40:	e58d1010 	str	r1, [sp, #16]
			temp.quote = 0;
3480cd44:	e58d100c 	str	r1, [sp, #12]
			free_pipe_list(ctx.list_head,0);
3480cd48:	ebfff8cc 	bl	3480b080 <free_pipe_list>
	b_reset(o);
3480cd4c:	e1a0000d 	mov	r0, sp
3480cd50:	ebfff8b3 	bl	3480b024 <b_reset>
	free(o->data);
3480cd54:	e59d0000 	ldr	r0, [sp]
3480cd58:	ebfff3d4 	bl	34809cb0 <free>
	o->data = NULL;
3480cd5c:	e3a03000 	mov	r3, #0
3480cd60:	e58d3000 	str	r3, [sp]
	o->maxlen = 0;
3480cd64:	e58d3008 	str	r3, [sp, #8]
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
3480cd68:	e3770001 	cmn	r7, #1
3480cd6c:	0a000023 	beq	3480ce00 <parse_stream_outer+0x5f4>
3480cd70:	e31a0001 	tst	sl, #1
3480cd74:	0afffeae 	beq	3480c834 <parse_stream_outer+0x28>
3480cd78:	ea000020 	b	3480ce00 <parse_stream_outer+0x5f4>
			done_word(&temp, &ctx);
3480cd7c:	e28d1014 	add	r1, sp, #20
3480cd80:	e1a0000d 	mov	r0, sp
3480cd84:	ebfffbfe 	bl	3480bd84 <done_word>
			done_pipe(&ctx,PIPE_SEQ);
3480cd88:	e3a01001 	mov	r1, #1
3480cd8c:	e28d0014 	add	r0, sp, #20
3480cd90:	ebfffb93 	bl	3480bbe4 <done_pipe>
			code = run_list(ctx.list_head);
3480cd94:	e59db018 	ldr	fp, [sp, #24]
		rcode = run_list_real(pi);
3480cd98:	e1a0000b 	mov	r0, fp
3480cd9c:	ebfffcbb 	bl	3480c090 <run_list_real>
	free_pipe_list(pi,0);
3480cda0:	e1a01006 	mov	r1, r6
		rcode = run_list_real(pi);
3480cda4:	e1a05000 	mov	r5, r0
	free_pipe_list(pi,0);
3480cda8:	e1a0000b 	mov	r0, fp
3480cdac:	ebfff8b3 	bl	3480b080 <free_pipe_list>
			if (code == -2) {	/* exit */
3480cdb0:	e3750002 	cmn	r5, #2
3480cdb4:	1a00000d 	bne	3480cdf0 <parse_stream_outer+0x5e4>
	b_reset(o);
3480cdb8:	e1a0000d 	mov	r0, sp
3480cdbc:	ebfff898 	bl	3480b024 <b_reset>
	free(o->data);
3480cdc0:	e59d0000 	ldr	r0, [sp]
3480cdc4:	ebfff3b9 	bl	34809cb0 <free>
				if (inp->peek == file_peek) {
3480cdc8:	e5942010 	ldr	r2, [r4, #16]
3480cdcc:	e59f304c 	ldr	r3, [pc, #76]	; 3480ce20 <parse_stream_outer+0x614>
	o->data = NULL;
3480cdd0:	e58d6000 	str	r6, [sp]
	o->maxlen = 0;
3480cdd4:	e58d6008 	str	r6, [sp, #8]
				if (inp->peek == file_peek) {
3480cdd8:	e1520003 	cmp	r2, r3
3480cddc:	1a000006 	bne	3480cdfc <parse_stream_outer+0x5f0>
					printf("exit not allowed from main input shell.\n");
3480cde0:	e59f003c 	ldr	r0, [pc, #60]	; 3480ce24 <parse_stream_outer+0x618>
				code = 0;
3480cde4:	e1a05006 	mov	r5, r6
					printf("exit not allowed from main input shell.\n");
3480cde8:	ebfff26b 	bl	3480979c <printf>
					continue;
3480cdec:	eaffffdd 	b	3480cd68 <parse_stream_outer+0x55c>
			if (code == -1)
3480cdf0:	e3750001 	cmn	r5, #1
			    flag_repeat = 0;
3480cdf4:	05896004 	streq	r6, [r9, #4]
3480cdf8:	eaffffd3 	b	3480cd4c <parse_stream_outer+0x540>
				code = 0;
3480cdfc:	e1a05006 	mov	r5, r6
	return (code != 0) ? 1 : 0;
3480ce00:	e2950000 	adds	r0, r5, #0
3480ce04:	13a00001 	movne	r0, #1
}
3480ce08:	e28dd030 	add	sp, sp, #48	; 0x30
3480ce0c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480ce10:	34828aa0 	.word	0x34828aa0
3480ce14:	34824f93 	.word	0x34824f93
3480ce18:	34820934 	.word	0x34820934
3480ce1c:	34824fc1 	.word	0x34824fc1
3480ce20:	3480b068 	.word	0x3480b068
3480ce24:	34824f98 	.word	0x34824f98

3480ce28 <parse_file_outer>:
{
3480ce28:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	i->p = NULL;
3480ce2c:	e28d0018 	add	r0, sp, #24
	i->peek = file_peek;
3480ce30:	e59f302c 	ldr	r3, [pc, #44]	; 3480ce64 <parse_file_outer+0x3c>
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480ce34:	e3a01002 	mov	r1, #2
	i->peek = file_peek;
3480ce38:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
3480ce3c:	e59f3024 	ldr	r3, [pc, #36]	; 3480ce68 <parse_file_outer+0x40>
3480ce40:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
3480ce44:	e3a03001 	mov	r3, #1
3480ce48:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480ce4c:	e58d300c 	str	r3, [sp, #12]
	i->p = NULL;
3480ce50:	e3a03000 	mov	r3, #0
3480ce54:	e5203014 	str	r3, [r0, #-20]!	; 0xffffffec
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480ce58:	ebfffe6b 	bl	3480c80c <parse_stream_outer>
}
3480ce5c:	e28dd01c 	add	sp, sp, #28
3480ce60:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
3480ce64:	3480b068 	.word	0x3480b068
3480ce68:	3480b384 	.word	0x3480b384

3480ce6c <u_boot_hush_start>:
{
3480ce6c:	e92d4070 	push	{r4, r5, r6, lr}
	if (top_vars == NULL) {
3480ce70:	e59f503c 	ldr	r5, [pc, #60]	; 3480ceb4 <u_boot_hush_start+0x48>
3480ce74:	e5954000 	ldr	r4, [r5]
3480ce78:	e3540000 	cmp	r4, #0
3480ce7c:	1a00000a 	bne	3480ceac <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
3480ce80:	e3a00014 	mov	r0, #20
3480ce84:	ebfff413 	bl	34809ed8 <malloc>
		top_vars->name = "HUSH_VERSION";
3480ce88:	e59f3028 	ldr	r3, [pc, #40]	; 3480ceb8 <u_boot_hush_start+0x4c>
		top_vars = malloc(sizeof(struct variables));
3480ce8c:	e5850000 	str	r0, [r5]
		top_vars->next = 0;
3480ce90:	e5804010 	str	r4, [r0, #16]
		top_vars->name = "HUSH_VERSION";
3480ce94:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
3480ce98:	e59f301c 	ldr	r3, [pc, #28]	; 3480cebc <u_boot_hush_start+0x50>
		top_vars->flg_export = 0;
3480ce9c:	e5804008 	str	r4, [r0, #8]
		top_vars->value = "0.01";
3480cea0:	e5803004 	str	r3, [r0, #4]
		top_vars->flg_read_only = 1;
3480cea4:	e3a03001 	mov	r3, #1
3480cea8:	e580300c 	str	r3, [r0, #12]
}
3480ceac:	e3a00000 	mov	r0, #0
3480ceb0:	e8bd8070 	pop	{r4, r5, r6, pc}
3480ceb4:	34828aa0 	.word	0x34828aa0
3480ceb8:	34824fce 	.word	0x34824fce
3480cebc:	34824fdb 	.word	0x34824fdb

3480cec0 <__fswab32>:
3480cec0:	e6bf0f30 	rev	r0, r0
3480cec4:	e12fff1e 	bx	lr

3480cec8 <image_get_data_size>:
image_get_hdr_l(size)		/* image_get_size */
3480cec8:	e590000c 	ldr	r0, [r0, #12]
3480cecc:	eafffffb 	b	3480cec0 <__fswab32>

3480ced0 <image_check_magic>:
{
3480ced0:	e92d4010 	push	{r4, lr}
image_get_hdr_l(magic)		/* image_get_magic */
3480ced4:	e5900000 	ldr	r0, [r0]
3480ced8:	ebfffff8 	bl	3480cec0 <__fswab32>
}
3480cedc:	e59f300c 	ldr	r3, [pc, #12]	; 3480cef0 <image_check_magic+0x20>
3480cee0:	e0630000 	rsb	r0, r3, r0
3480cee4:	e16f0f10 	clz	r0, r0
3480cee8:	e1a002a0 	lsr	r0, r0, #5
3480ceec:	e8bd8010 	pop	{r4, pc}
3480cef0:	27051956 	.word	0x27051956

3480cef4 <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
3480cef4:	e92d4030 	push	{r4, r5, lr}
3480cef8:	e24dd044 	sub	sp, sp, #68	; 0x44
3480cefc:	e1a04000 	mov	r4, r0
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
3480cf00:	e1a01000 	mov	r1, r0
3480cf04:	e3a02040 	mov	r2, #64	; 0x40
3480cf08:	e1a0000d 	mov	r0, sp
3480cf0c:	eb003b55 	bl	3481bc68 <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
3480cf10:	e3a02040 	mov	r2, #64	; 0x40
3480cf14:	e1a0100d 	mov	r1, sp
image_set_hdr_l(hcrc)		/* image_set_hcrc */
3480cf18:	e3a00000 	mov	r0, #0
3480cf1c:	e58d0004 	str	r0, [sp, #4]
3480cf20:	eb0033d0 	bl	34819e68 <crc32>
3480cf24:	e1a05000 	mov	r5, r0
image_get_hdr_l(hcrc)		/* image_get_hcrc */
3480cf28:	e5940004 	ldr	r0, [r4, #4]
3480cf2c:	ebffffe3 	bl	3480cec0 <__fswab32>

	return (hcrc == image_get_hcrc(hdr));
}
3480cf30:	e0600005 	rsb	r0, r0, r5
3480cf34:	e16f0f10 	clz	r0, r0
3480cf38:	e1a002a0 	lsr	r0, r0, #5
3480cf3c:	e28dd044 	add	sp, sp, #68	; 0x44
3480cf40:	e8bd8030 	pop	{r4, r5, pc}

3480cf44 <image_check_dcrc>:

int image_check_dcrc(const image_header_t *hdr)
{
3480cf44:	e92d4070 	push	{r4, r5, r6, lr}
3480cf48:	e1a04000 	mov	r4, r0
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480cf4c:	ebffffdd 	bl	3480cec8 <image_get_data_size>
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480cf50:	e3a03801 	mov	r3, #65536	; 0x10000
3480cf54:	e1a02000 	mov	r2, r0
3480cf58:	e2841040 	add	r1, r4, #64	; 0x40
3480cf5c:	e3a00000 	mov	r0, #0
3480cf60:	eb0033c5 	bl	34819e7c <crc32_wd>
3480cf64:	e1a05000 	mov	r5, r0
image_get_hdr_l(dcrc)		/* image_get_dcrc */
3480cf68:	e5940018 	ldr	r0, [r4, #24]
3480cf6c:	ebffffd3 	bl	3480cec0 <__fswab32>

	return (dcrc == image_get_dcrc(hdr));
}
3480cf70:	e0600005 	rsb	r0, r0, r5
3480cf74:	e16f0f10 	clz	r0, r0
3480cf78:	e1a002a0 	lsr	r0, r0, #5
3480cf7c:	e8bd8070 	pop	{r4, r5, r6, pc}

3480cf80 <image_multi_count>:
 *
 * returns:
 *     number of components
 */
ulong image_multi_count(const image_header_t *hdr)
{
3480cf80:	e280303c 	add	r3, r0, #60	; 0x3c
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
3480cf84:	e3a00000 	mov	r0, #0
3480cf88:	e5b32004 	ldr	r2, [r3, #4]!
3480cf8c:	e3520000 	cmp	r2, #0
3480cf90:	12800001 	addne	r0, r0, #1
3480cf94:	1afffffb 	bne	3480cf88 <image_multi_count+0x8>
		count++;

	return count;
}
3480cf98:	e12fff1e 	bx	lr

3480cf9c <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
3480cf9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480cfa0:	e1a0a001 	mov	sl, r1
3480cfa4:	e1a0b003 	mov	fp, r3
3480cfa8:	e1a07002 	mov	r7, r2
3480cfac:	e1a05000 	mov	r5, r0
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480cfb0:	ebfffff2 	bl	3480cf80 <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480cfb4:	e15a0000 	cmp	sl, r0
	count = image_multi_count(hdr);
3480cfb8:	e1a06000 	mov	r6, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
3480cfbc:	23a03000 	movcs	r3, #0
3480cfc0:	258b3000 	strcs	r3, [fp]
		*data = 0;
3480cfc4:	25873000 	strcs	r3, [r7]
	if (idx < count) {
3480cfc8:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
		*len = uimage_to_cpu(size[idx]);
3480cfcc:	e1a0910a 	lsl	r9, sl, #2
	return ((ulong)hdr + image_get_header_size());
3480cfd0:	e2854040 	add	r4, r5, #64	; 0x40
3480cfd4:	e794010a 	ldr	r0, [r4, sl, lsl #2]
3480cfd8:	e285a03c 	add	sl, r5, #60	; 0x3c
3480cfdc:	e289903c 	add	r9, r9, #60	; 0x3c
3480cfe0:	e0855009 	add	r5, r5, r9
		offset = 0;
3480cfe4:	e3a09000 	mov	r9, #0
		*len = uimage_to_cpu(size[idx]);
3480cfe8:	ebffffb4 	bl	3480cec0 <__fswab32>
3480cfec:	e58b0000 	str	r0, [fp]
		for (i = 0; i < idx; i++) {
3480cff0:	e15a0005 	cmp	sl, r5
3480cff4:	0a000005 	beq	3480d010 <image_multi_getimg+0x74>
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
3480cff8:	e5ba0004 	ldr	r0, [sl, #4]!
3480cffc:	ebffffaf 	bl	3480cec0 <__fswab32>
3480d000:	e2800003 	add	r0, r0, #3
3480d004:	e3c00003 	bic	r0, r0, #3
3480d008:	e0899000 	add	r9, r9, r0
3480d00c:	eafffff7 	b	3480cff0 <image_multi_getimg+0x54>
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
3480d010:	e2866001 	add	r6, r6, #1
3480d014:	e0844106 	add	r4, r4, r6, lsl #2
		*data = img_data + offset;
3480d018:	e0844009 	add	r4, r4, r9
3480d01c:	e5874000 	str	r4, [r7]
3480d020:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480d024 <getenv_yesno>:
/*****************************************************************************/
/* Shared dual-format routines */
/*****************************************************************************/
#ifndef USE_HOSTCC
int getenv_yesno(char *var)
{
3480d024:	e92d4010 	push	{r4, lr}
	char *s = getenv(var);
3480d028:	ebffead5 	bl	34807b84 <getenv>
	return (s && (*s == 'n')) ? 0 : 1;
3480d02c:	e3500000 	cmp	r0, #0
3480d030:	0a000003 	beq	3480d044 <getenv_yesno+0x20>
3480d034:	e5d00000 	ldrb	r0, [r0]
3480d038:	e250006e 	subs	r0, r0, #110	; 0x6e
3480d03c:	13a00001 	movne	r0, #1
3480d040:	e8bd8010 	pop	{r4, pc}
3480d044:	e3a00001 	mov	r0, #1
}
3480d048:	e8bd8010 	pop	{r4, pc}

3480d04c <getenv_bootm_low>:

ulong getenv_bootm_low(void)
{
3480d04c:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
3480d050:	e59f0020 	ldr	r0, [pc, #32]	; 3480d078 <getenv_bootm_low+0x2c>
3480d054:	ebffeaca 	bl	34807b84 <getenv>
	if (s) {
3480d058:	e3500000 	cmp	r0, #0
3480d05c:	0a000003 	beq	3480d070 <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d060:	e3a02010 	mov	r2, #16
3480d064:	e3a01000 	mov	r1, #0
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480d068:	e8bd4010 	pop	{r4, lr}
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d06c:	ea003dbc 	b	3481c764 <simple_strtoul>
}
3480d070:	e3a00202 	mov	r0, #536870912	; 0x20000000
3480d074:	e8bd8010 	pop	{r4, pc}
3480d078:	348250a1 	.word	0x348250a1

3480d07c <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
3480d07c:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
3480d080:	e59f0048 	ldr	r0, [pc, #72]	; 3480d0d0 <getenv_bootm_size+0x54>
3480d084:	ebffeabe 	bl	34807b84 <getenv>
	if (s) {
3480d088:	e2504000 	subs	r4, r0, #0
3480d08c:	0a000003 	beq	3480d0a0 <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d090:	e3a02010 	mov	r2, #16
3480d094:	e3a01000 	mov	r1, #0
3480d098:	eb003e22 	bl	3481c928 <simple_strtoull>
		return tmp;
3480d09c:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
3480d0a0:	e59f002c 	ldr	r0, [pc, #44]	; 3480d0d4 <getenv_bootm_size+0x58>
3480d0a4:	ebffeab6 	bl	34807b84 <getenv>
	if (s)
3480d0a8:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
3480d0ac:	01a00003 	moveq	r0, r3
	if (s)
3480d0b0:	0a000002 	beq	3480d0c0 <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d0b4:	e3a02010 	mov	r2, #16
3480d0b8:	e1a01004 	mov	r1, r4
3480d0bc:	eb003e19 	bl	3481c928 <simple_strtoull>


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
3480d0c0:	e5983000 	ldr	r3, [r8]
3480d0c4:	e593301c 	ldr	r3, [r3, #28]
3480d0c8:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
3480d0cc:	e8bd8010 	pop	{r4, pc}
3480d0d0:	348250ab 	.word	0x348250ab
3480d0d4:	348250a1 	.word	0x348250a1

3480d0d8 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
3480d0d8:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
3480d0dc:	e59f0020 	ldr	r0, [pc, #32]	; 3480d104 <getenv_bootm_mapsize+0x2c>
3480d0e0:	ebffeaa7 	bl	34807b84 <getenv>
	if (s) {
3480d0e4:	e3500000 	cmp	r0, #0
3480d0e8:	0a000003 	beq	3480d0fc <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d0ec:	e3a02010 	mov	r2, #16
3480d0f0:	e3a01000 	mov	r1, #0
3480d0f4:	eb003e0b 	bl	3481c928 <simple_strtoull>
		return tmp;
3480d0f8:	e8bd8010 	pop	{r4, pc}
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
3480d0fc:	e8bd4010 	pop	{r4, lr}
	return getenv_bootm_size();
3480d100:	eaffffdd 	b	3480d07c <getenv_bootm_size>
3480d104:	348250b6 	.word	0x348250b6

3480d108 <memmove_wd>:

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
3480d108:	e1510000 	cmp	r1, r0
3480d10c:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
3480d110:	ea003ad4 	b	3481bc68 <memmove>

3480d114 <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
3480d114:	e92d4010 	push	{r4, lr}
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
3480d118:	e1a01000 	mov	r1, r0
{
3480d11c:	e1a04000 	mov	r4, r0
	printf("%d Bytes = ", size);
3480d120:	e59f0014 	ldr	r0, [pc, #20]	; 3480d13c <genimg_print_size+0x28>
3480d124:	ebfff19c 	bl	3480979c <printf>
	print_size(size, "\n");
3480d128:	e1a00004 	mov	r0, r4
3480d12c:	e59f200c 	ldr	r2, [pc, #12]	; 3480d140 <genimg_print_size+0x2c>
3480d130:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
3480d134:	e8bd4010 	pop	{r4, lr}
	print_size(size, "\n");
3480d138:	ea003361 	b	34819ec4 <print_size>
3480d13c:	348250c4 	.word	0x348250c4
3480d140:	34824f42 	.word	0x34824f42

3480d144 <get_table_entry_name>:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
3480d144:	e5903000 	ldr	r3, [r0]
3480d148:	e3530000 	cmp	r3, #0
3480d14c:	ba000005 	blt	3480d168 <get_table_entry_name+0x24>
		if (table->id == id)
3480d150:	e1530002 	cmp	r3, r2
3480d154:	1a000001 	bne	3480d160 <get_table_entry_name+0x1c>
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
3480d158:	e5900008 	ldr	r0, [r0, #8]
3480d15c:	e12fff1e 	bx	lr
	for (; table->id >= 0; ++table) {
3480d160:	e280000c 	add	r0, r0, #12
3480d164:	eafffff6 	b	3480d144 <get_table_entry_name>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
3480d168:	e1a00001 	mov	r0, r1
}
3480d16c:	e12fff1e 	bx	lr

3480d170 <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
3480d170:	e1a02000 	mov	r2, r0
3480d174:	e59f1004 	ldr	r1, [pc, #4]	; 3480d180 <genimg_get_os_name+0x10>
3480d178:	e59f0004 	ldr	r0, [pc, #4]	; 3480d184 <genimg_get_os_name+0x14>
3480d17c:	eafffff0 	b	3480d144 <get_table_entry_name>
3480d180:	348250d0 	.word	0x348250d0
3480d184:	3481fec0 	.word	0x3481fec0

3480d188 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
3480d188:	e1a02000 	mov	r2, r0
3480d18c:	e59f1004 	ldr	r1, [pc, #4]	; 3480d198 <genimg_get_arch_name+0x10>
3480d190:	e59f0004 	ldr	r0, [pc, #4]	; 3480d19c <genimg_get_arch_name+0x14>
3480d194:	eaffffea 	b	3480d144 <get_table_entry_name>
3480d198:	348250db 	.word	0x348250db
3480d19c:	3481ff14 	.word	0x3481ff14

3480d1a0 <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
3480d1a0:	e1a02000 	mov	r2, r0
3480d1a4:	e59f1004 	ldr	r1, [pc, #4]	; 3480d1b0 <genimg_get_type_name+0x10>
3480d1a8:	e59f0004 	ldr	r0, [pc, #4]	; 3480d1b4 <genimg_get_type_name+0x14>
3480d1ac:	eaffffe4 	b	3480d144 <get_table_entry_name>
3480d1b0:	348250f0 	.word	0x348250f0
3480d1b4:	34820010 	.word	0x34820010

3480d1b8 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
3480d1b8:	e1a02000 	mov	r2, r0
3480d1bc:	e59f1004 	ldr	r1, [pc, #4]	; 3480d1c8 <genimg_get_comp_name+0x10>
3480d1c0:	e59f0004 	ldr	r0, [pc, #4]	; 3480d1cc <genimg_get_comp_name+0x14>
3480d1c4:	eaffffde 	b	3480d144 <get_table_entry_name>
3480d1c8:	348250fe 	.word	0x348250fe
3480d1cc:	348200dc 	.word	0x348200dc

3480d1d0 <image_print_contents>:
{
3480d1d0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480d1d4:	e2803020 	add	r3, r0, #32
{
3480d1d8:	e24dd014 	sub	sp, sp, #20
3480d1dc:	e1a04000 	mov	r4, r0
	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480d1e0:	e3a02020 	mov	r2, #32
3480d1e4:	e59f1138 	ldr	r1, [pc, #312]	; 3480d324 <image_print_contents+0x154>
3480d1e8:	e59f0138 	ldr	r0, [pc, #312]	; 3480d328 <image_print_contents+0x158>
3480d1ec:	ebfff16a 	bl	3480979c <printf>
	printf("%sImage Type:   ", p);
3480d1f0:	e59f112c 	ldr	r1, [pc, #300]	; 3480d324 <image_print_contents+0x154>
3480d1f4:	e59f0130 	ldr	r0, [pc, #304]	; 3480d32c <image_print_contents+0x15c>
3480d1f8:	ebfff167 	bl	3480979c <printf>
	os = genimg_get_os_name(image_get_os(hdr));
3480d1fc:	e5d4001c 	ldrb	r0, [r4, #28]
3480d200:	ebffffda 	bl	3480d170 <genimg_get_os_name>
3480d204:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
3480d208:	e5d4001d 	ldrb	r0, [r4, #29]
3480d20c:	ebffffdd 	bl	3480d188 <genimg_get_arch_name>
3480d210:	e1a05000 	mov	r5, r0
	type = genimg_get_type_name(image_get_type(hdr));
3480d214:	e5d4001e 	ldrb	r0, [r4, #30]
3480d218:	ebffffe0 	bl	3480d1a0 <genimg_get_type_name>
3480d21c:	e1a07000 	mov	r7, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
3480d220:	e5d4001f 	ldrb	r0, [r4, #31]
3480d224:	ebffffe3 	bl	3480d1b8 <genimg_get_comp_name>
	printf("%s %s %s (%s)\n", arch, os, type, comp);
3480d228:	e1a03007 	mov	r3, r7
3480d22c:	e1a02006 	mov	r2, r6
3480d230:	e58d0000 	str	r0, [sp]
3480d234:	e1a01005 	mov	r1, r5
3480d238:	e59f00f0 	ldr	r0, [pc, #240]	; 3480d330 <image_print_contents+0x160>
3480d23c:	ebfff156 	bl	3480979c <printf>
	printf("%sData Size:    ", p);
3480d240:	e59f10dc 	ldr	r1, [pc, #220]	; 3480d324 <image_print_contents+0x154>
3480d244:	e59f00e8 	ldr	r0, [pc, #232]	; 3480d334 <image_print_contents+0x164>
3480d248:	ebfff153 	bl	3480979c <printf>
	genimg_print_size(image_get_data_size(hdr));
3480d24c:	e1a00004 	mov	r0, r4
3480d250:	ebffff1c 	bl	3480cec8 <image_get_data_size>
3480d254:	ebffffae 	bl	3480d114 <genimg_print_size>
image_get_hdr_l(load)		/* image_get_load */
3480d258:	e5940010 	ldr	r0, [r4, #16]
3480d25c:	ebffff17 	bl	3480cec0 <__fswab32>
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
3480d260:	e59f10bc 	ldr	r1, [pc, #188]	; 3480d324 <image_print_contents+0x154>
3480d264:	e1a02000 	mov	r2, r0
3480d268:	e59f00c8 	ldr	r0, [pc, #200]	; 3480d338 <image_print_contents+0x168>
3480d26c:	ebfff14a 	bl	3480979c <printf>
image_get_hdr_l(ep)		/* image_get_ep */
3480d270:	e5940014 	ldr	r0, [r4, #20]
3480d274:	ebffff11 	bl	3480cec0 <__fswab32>
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
3480d278:	e59f10a4 	ldr	r1, [pc, #164]	; 3480d324 <image_print_contents+0x154>
3480d27c:	e1a02000 	mov	r2, r0
3480d280:	e59f00b4 	ldr	r0, [pc, #180]	; 3480d33c <image_print_contents+0x16c>
3480d284:	ebfff144 	bl	3480979c <printf>
	if (image_check_type(hdr, IH_TYPE_MULTI) ||
3480d288:	e5d4301e 	ldrb	r3, [r4, #30]
3480d28c:	e20330fd 	and	r3, r3, #253	; 0xfd
3480d290:	e3530004 	cmp	r3, #4
3480d294:	1a000020 	bne	3480d31c <image_print_contents+0x14c>
		ulong count = image_multi_count(hdr);
3480d298:	e1a00004 	mov	r0, r4
		for (i = 0; i < count; i++) {
3480d29c:	e3a05000 	mov	r5, #0
		ulong count = image_multi_count(hdr);
3480d2a0:	ebffff36 	bl	3480cf80 <image_multi_count>
		printf("%sContents:\n", p);
3480d2a4:	e59f1078 	ldr	r1, [pc, #120]	; 3480d324 <image_print_contents+0x154>
		ulong count = image_multi_count(hdr);
3480d2a8:	e1a06000 	mov	r6, r0
		printf("%sContents:\n", p);
3480d2ac:	e59f008c 	ldr	r0, [pc, #140]	; 3480d340 <image_print_contents+0x170>
3480d2b0:	ebfff139 	bl	3480979c <printf>
		for (i = 0; i < count; i++) {
3480d2b4:	e1550006 	cmp	r5, r6
3480d2b8:	0a000017 	beq	3480d31c <image_print_contents+0x14c>
			image_multi_getimg(hdr, i, &data, &len);
3480d2bc:	e28d300c 	add	r3, sp, #12
3480d2c0:	e28d2008 	add	r2, sp, #8
3480d2c4:	e1a01005 	mov	r1, r5
3480d2c8:	e1a00004 	mov	r0, r4
3480d2cc:	ebffff32 	bl	3480cf9c <image_multi_getimg>
			printf("%s   Image %d: ", p, i);
3480d2d0:	e1a02005 	mov	r2, r5
3480d2d4:	e59f1048 	ldr	r1, [pc, #72]	; 3480d324 <image_print_contents+0x154>
3480d2d8:	e59f0064 	ldr	r0, [pc, #100]	; 3480d344 <image_print_contents+0x174>
3480d2dc:	ebfff12e 	bl	3480979c <printf>
			genimg_print_size(len);
3480d2e0:	e59d000c 	ldr	r0, [sp, #12]
3480d2e4:	ebffff8a 	bl	3480d114 <genimg_print_size>
			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
3480d2e8:	e5d4201e 	ldrb	r2, [r4, #30]
3480d2ec:	e2953000 	adds	r3, r5, #0
3480d2f0:	13a03001 	movne	r3, #1
3480d2f4:	e3520006 	cmp	r2, #6
3480d2f8:	13a03000 	movne	r3, #0
3480d2fc:	e3530000 	cmp	r3, #0
3480d300:	0a000003 	beq	3480d314 <image_print_contents+0x144>
				printf("%s    Offset = 0x%08lx\n", p, data);
3480d304:	e59d2008 	ldr	r2, [sp, #8]
3480d308:	e59f1014 	ldr	r1, [pc, #20]	; 3480d324 <image_print_contents+0x154>
3480d30c:	e59f0034 	ldr	r0, [pc, #52]	; 3480d348 <image_print_contents+0x178>
3480d310:	ebfff121 	bl	3480979c <printf>
		for (i = 0; i < count; i++) {
3480d314:	e2855001 	add	r5, r5, #1
3480d318:	eaffffe5 	b	3480d2b4 <image_print_contents+0xe4>
}
3480d31c:	e28dd014 	add	sp, sp, #20
3480d320:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480d324:	34825155 	.word	0x34825155
3480d328:	34825112 	.word	0x34825112
3480d32c:	34825128 	.word	0x34825128
3480d330:	34825139 	.word	0x34825139
3480d334:	34825148 	.word	0x34825148
3480d338:	34825159 	.word	0x34825159
3480d33c:	3482516f 	.word	0x3482516f
3480d340:	34825185 	.word	0x34825185
3480d344:	34825192 	.word	0x34825192
3480d348:	348251a2 	.word	0x348251a2

3480d34c <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
3480d34c:	e92d4070 	push	{r4, r5, r6, lr}
3480d350:	e1a04000 	mov	r4, r0
3480d354:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480d358:	e5943000 	ldr	r3, [r4]
3480d35c:	e3530000 	cmp	r3, #0
3480d360:	ba00000a 	blt	3480d390 <get_table_entry_id+0x44>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
3480d364:	e5940004 	ldr	r0, [r4, #4]
3480d368:	e3500000 	cmp	r0, #0
3480d36c:	0a000005 	beq	3480d388 <get_table_entry_id+0x3c>
3480d370:	e1a01005 	mov	r1, r5
3480d374:	eb003929 	bl	3481b820 <strcmp>
3480d378:	e3500000 	cmp	r0, #0
3480d37c:	1a000001 	bne	3480d388 <get_table_entry_id+0x3c>
#endif
			return (t->id);
3480d380:	e5940000 	ldr	r0, [r4]
3480d384:	e8bd8070 	pop	{r4, r5, r6, pc}
	for (t = table; t->id >= 0; ++t) {
3480d388:	e284400c 	add	r4, r4, #12
3480d38c:	eafffff1 	b	3480d358 <get_table_entry_id+0xc>
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
3480d390:	e3e00000 	mvn	r0, #0
}
3480d394:	e8bd8070 	pop	{r4, r5, r6, pc}

3480d398 <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
	return (get_table_entry_id(uimage_os, "OS", name));
3480d398:	e1a02000 	mov	r2, r0
3480d39c:	e59f1004 	ldr	r1, [pc, #4]	; 3480d3a8 <genimg_get_os_id+0x10>
3480d3a0:	e59f0004 	ldr	r0, [pc, #4]	; 3480d3ac <genimg_get_os_id+0x14>
3480d3a4:	eaffffe8 	b	3480d34c <get_table_entry_id>
3480d3a8:	348254cc 	.word	0x348254cc
3480d3ac:	3481fec0 	.word	0x3481fec0

3480d3b0 <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
	return (get_table_entry_id(uimage_arch, "CPU", name));
3480d3b0:	e1a02000 	mov	r2, r0
3480d3b4:	e59f1004 	ldr	r1, [pc, #4]	; 3480d3c0 <genimg_get_arch_id+0x10>
3480d3b8:	e59f0004 	ldr	r0, [pc, #4]	; 3480d3c4 <genimg_get_arch_id+0x14>
3480d3bc:	eaffffe2 	b	3480d34c <get_table_entry_id>
3480d3c0:	34821aa4 	.word	0x34821aa4
3480d3c4:	3481ff14 	.word	0x3481ff14

3480d3c8 <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
	return (get_table_entry_id(uimage_type, "Image", name));
3480d3c8:	e1a02000 	mov	r2, r0
3480d3cc:	e59f1004 	ldr	r1, [pc, #4]	; 3480d3d8 <genimg_get_type_id+0x10>
3480d3d0:	e59f0004 	ldr	r0, [pc, #4]	; 3480d3dc <genimg_get_type_id+0x14>
3480d3d4:	eaffffdc 	b	3480d34c <get_table_entry_id>
3480d3d8:	34825416 	.word	0x34825416
3480d3dc:	34820010 	.word	0x34820010

3480d3e0 <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
	return (get_table_entry_id(uimage_comp, "Compression", name));
3480d3e0:	e1a02000 	mov	r2, r0
3480d3e4:	e59f1004 	ldr	r1, [pc, #4]	; 3480d3f0 <genimg_get_comp_id+0x10>
3480d3e8:	e59f0004 	ldr	r0, [pc, #4]	; 3480d3f4 <genimg_get_comp_id+0x14>
3480d3ec:	eaffffd6 	b	3480d34c <get_table_entry_id>
3480d3f0:	34825106 	.word	0x34825106
3480d3f4:	348200dc 	.word	0x348200dc

3480d3f8 <genimg_get_format>:
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 */
int genimg_get_format(void *img_addr)
{
3480d3f8:	e92d4010 	push	{r4, lr}
#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
	char *fit_hdr;
#endif

	hdr = (const image_header_t *)img_addr;
	if (image_check_magic(hdr))
3480d3fc:	ebfffeb3 	bl	3480ced0 <image_check_magic>
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
3480d400:	e2900000 	adds	r0, r0, #0
3480d404:	13a00001 	movne	r0, #1
3480d408:	e8bd8010 	pop	{r4, pc}

3480d40c <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
3480d40c:	e12fff1e 	bx	lr

3480d410 <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
3480d410:	e3a00000 	mov	r0, #0
3480d414:	e12fff1e 	bx	lr

3480d418 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480d418:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d41c:	e3500002 	cmp	r0, #2
{
3480d420:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
	*rd_start = 0;
3480d424:	e3a04000 	mov	r4, #0
{
3480d428:	e1a06002 	mov	r6, r2
3480d42c:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
	*rd_start = 0;
3480d430:	e5894000 	str	r4, [r9]
	*rd_end = 0;
3480d434:	e5874000 	str	r4, [r7]
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d438:	da000008 	ble	3480d460 <boot_get_ramdisk+0x48>
3480d43c:	e1a05001 	mov	r5, r1
3480d440:	e59f11d4 	ldr	r1, [pc, #468]	; 3480d61c <boot_get_ramdisk+0x204>
3480d444:	e5950008 	ldr	r0, [r5, #8]
3480d448:	e1a0a003 	mov	sl, r3
3480d44c:	eb0038f3 	bl	3481b820 <strcmp>
3480d450:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
3480d454:	058d0000 	streq	r0, [sp]
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d458:	0a00006a 	beq	3480d608 <boot_get_ramdisk+0x1f0>
3480d45c:	ea00001d 	b	3480d4d8 <boot_get_ramdisk+0xc0>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d460:	e5923044 	ldr	r3, [r2, #68]	; 0x44
3480d464:	e3530000 	cmp	r3, #0
3480d468:	0a00000d 	beq	3480d4a4 <boot_get_ramdisk+0x8c>
3480d46c:	e5d63022 	ldrb	r3, [r6, #34]	; 0x22
3480d470:	e3530004 	cmp	r3, #4
3480d474:	1a00000a 	bne	3480d4a4 <boot_get_ramdisk+0x8c>
	show_boot_progress(id);
3480d478:	e3a0000d 	mov	r0, #13
3480d47c:	eb00012a 	bl	3480d92c <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
3480d480:	e5961000 	ldr	r1, [r6]
3480d484:	e59f0194 	ldr	r0, [pc, #404]	; 3480d620 <boot_get_ramdisk+0x208>
3480d488:	ebfff0c3 	bl	3480979c <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
3480d48c:	e28d3004 	add	r3, sp, #4
3480d490:	e1a0200d 	mov	r2, sp
3480d494:	e3a01001 	mov	r1, #1
3480d498:	e5960000 	ldr	r0, [r6]
3480d49c:	ebfffebe 	bl	3480cf9c <image_multi_getimg>
3480d4a0:	ea000004 	b	3480d4b8 <boot_get_ramdisk+0xa0>
3480d4a4:	e3a0000e 	mov	r0, #14
3480d4a8:	eb00011f 	bl	3480d92c <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
3480d4ac:	e3a03000 	mov	r3, #0
3480d4b0:	e58d3000 	str	r3, [sp]
3480d4b4:	e58d3004 	str	r3, [sp, #4]
	}

	if (!rd_data) {
3480d4b8:	e59d4000 	ldr	r4, [sp]
3480d4bc:	e3540000 	cmp	r4, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
		*rd_end = rd_data + rd_len;
3480d4c0:	159d3004 	ldrne	r3, [sp, #4]
		*rd_start = rd_data;
3480d4c4:	15894000 	strne	r4, [r9]
		*rd_end = rd_data + rd_len;
3480d4c8:	10834004 	addne	r4, r3, r4
3480d4cc:	15874000 	strne	r4, [r7]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
3480d4d0:	13a04000 	movne	r4, #0
3480d4d4:	ea00004d 	b	3480d610 <boot_get_ramdisk+0x1f8>
				rd_addr = simple_strtoul(argv[2], NULL, 16);
3480d4d8:	e1a01004 	mov	r1, r4
3480d4dc:	e3a02010 	mov	r2, #16
3480d4e0:	e5950008 	ldr	r0, [r5, #8]
3480d4e4:	eb003c9e 	bl	3481c764 <simple_strtoul>
3480d4e8:	e1a05000 	mov	r5, r0
		switch (genimg_get_format((void *)rd_addr)) {
3480d4ec:	ebffffc1 	bl	3480d3f8 <genimg_get_format>
3480d4f0:	e3500001 	cmp	r0, #1
3480d4f4:	e1a04000 	mov	r4, r0
3480d4f8:	1a00003a 	bne	3480d5e8 <boot_get_ramdisk+0x1d0>
			printf("## Loading init Ramdisk from Legacy "
3480d4fc:	e1a01005 	mov	r1, r5
3480d500:	e59f011c 	ldr	r0, [pc, #284]	; 3480d624 <boot_get_ramdisk+0x20c>
3480d504:	ebfff0a4 	bl	3480979c <printf>
3480d508:	e3a00009 	mov	r0, #9
3480d50c:	eb000106 	bl	3480d92c <__show_boot_progress>
	if (!image_check_magic(rd_hdr)) {
3480d510:	e1a00005 	mov	r0, r5
			rd_hdr = image_get_ramdisk(rd_addr, arch,
3480d514:	e5966084 	ldr	r6, [r6, #132]	; 0x84
	if (!image_check_magic(rd_hdr)) {
3480d518:	ebfffe6c 	bl	3480ced0 <image_check_magic>
3480d51c:	e3500000 	cmp	r0, #0
3480d520:	1a000003 	bne	3480d534 <boot_get_ramdisk+0x11c>
		puts("Bad Magic Number\n");
3480d524:	e59f00fc 	ldr	r0, [pc, #252]	; 3480d628 <boot_get_ramdisk+0x210>
3480d528:	ebfff08f 	bl	3480976c <puts>
	show_boot_progress(-id);
3480d52c:	e3e00009 	mvn	r0, #9
3480d530:	ea000006 	b	3480d550 <boot_get_ramdisk+0x138>
	if (!image_check_hcrc(rd_hdr)) {
3480d534:	e1a00005 	mov	r0, r5
3480d538:	ebfffe6d 	bl	3480cef4 <image_check_hcrc>
3480d53c:	e3500000 	cmp	r0, #0
3480d540:	1a000004 	bne	3480d558 <boot_get_ramdisk+0x140>
		puts("Bad Header Checksum\n");
3480d544:	e59f00e0 	ldr	r0, [pc, #224]	; 3480d62c <boot_get_ramdisk+0x214>
3480d548:	ebfff087 	bl	3480976c <puts>
3480d54c:	e3e0000a 	mvn	r0, #10
3480d550:	eb0000f5 	bl	3480d92c <__show_boot_progress>
3480d554:	ea00002d 	b	3480d610 <boot_get_ramdisk+0x1f8>
	show_boot_progress(id);
3480d558:	e3a0000a 	mov	r0, #10
3480d55c:	eb0000f2 	bl	3480d92c <__show_boot_progress>
	image_print_contents(rd_hdr);
3480d560:	e1a00005 	mov	r0, r5
3480d564:	ebffff19 	bl	3480d1d0 <image_print_contents>
	if (verify) {
3480d568:	e3560000 	cmp	r6, #0
3480d56c:	0a00000b 	beq	3480d5a0 <boot_get_ramdisk+0x188>
		puts("   Verifying Checksum ... ");
3480d570:	e59f00b8 	ldr	r0, [pc, #184]	; 3480d630 <boot_get_ramdisk+0x218>
3480d574:	ebfff07c 	bl	3480976c <puts>
		if (!image_check_dcrc(rd_hdr)) {
3480d578:	e1a00005 	mov	r0, r5
3480d57c:	ebfffe70 	bl	3480cf44 <image_check_dcrc>
3480d580:	e3500000 	cmp	r0, #0
3480d584:	1a000003 	bne	3480d598 <boot_get_ramdisk+0x180>
			puts("Bad Data CRC\n");
3480d588:	e59f00a4 	ldr	r0, [pc, #164]	; 3480d634 <boot_get_ramdisk+0x21c>
3480d58c:	ebfff076 	bl	3480976c <puts>
	show_boot_progress(-id);
3480d590:	e3e0000b 	mvn	r0, #11
3480d594:	eaffffed 	b	3480d550 <boot_get_ramdisk+0x138>
		puts("OK\n");
3480d598:	e59f0098 	ldr	r0, [pc, #152]	; 3480d638 <boot_get_ramdisk+0x220>
3480d59c:	ebfff072 	bl	3480976c <puts>
	show_boot_progress(id);
3480d5a0:	e3a0000b 	mov	r0, #11
3480d5a4:	eb0000e0 	bl	3480d92c <__show_boot_progress>
	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
3480d5a8:	e5d5301c 	ldrb	r3, [r5, #28]
3480d5ac:	e3530005 	cmp	r3, #5
3480d5b0:	1a000005 	bne	3480d5cc <boot_get_ramdisk+0x1b4>
3480d5b4:	e5d5301d 	ldrb	r3, [r5, #29]
3480d5b8:	e153000a 	cmp	r3, sl
3480d5bc:	1a000002 	bne	3480d5cc <boot_get_ramdisk+0x1b4>
	    !image_check_arch(rd_hdr, arch) ||
3480d5c0:	e5d5301e 	ldrb	r3, [r5, #30]
3480d5c4:	e3530003 	cmp	r3, #3
3480d5c8:	0a00000a 	beq	3480d5f8 <boot_get_ramdisk+0x1e0>
		printf("No Linux %s Ramdisk Image\n",
3480d5cc:	e1a0000a 	mov	r0, sl
3480d5d0:	ebfffeec 	bl	3480d188 <genimg_get_arch_name>
3480d5d4:	e1a01000 	mov	r1, r0
3480d5d8:	e59f005c 	ldr	r0, [pc, #92]	; 3480d63c <boot_get_ramdisk+0x224>
3480d5dc:	ebfff06e 	bl	3480979c <printf>
	show_boot_progress(-id);
3480d5e0:	e3e0000c 	mvn	r0, #12
3480d5e4:	eaffffd9 	b	3480d550 <boot_get_ramdisk+0x138>
				puts("Wrong Ramdisk Image Format\n");
3480d5e8:	e59f0050 	ldr	r0, [pc, #80]	; 3480d640 <boot_get_ramdisk+0x228>
				return 1;
3480d5ec:	e3a04001 	mov	r4, #1
				puts("Wrong Ramdisk Image Format\n");
3480d5f0:	ebfff05d 	bl	3480976c <puts>
				return 1;
3480d5f4:	ea000005 	b	3480d610 <boot_get_ramdisk+0x1f8>
	return ((ulong)hdr + image_get_header_size());
3480d5f8:	e2853040 	add	r3, r5, #64	; 0x40
			rd_len = image_get_data_size(rd_hdr);
3480d5fc:	e1a00005 	mov	r0, r5
			rd_data = image_get_data(rd_hdr);
3480d600:	e58d3000 	str	r3, [sp]
			rd_len = image_get_data_size(rd_hdr);
3480d604:	ebfffe2f 	bl	3480cec8 <image_get_data_size>
3480d608:	e58d0004 	str	r0, [sp, #4]
	} else if (images->legacy_hdr_valid &&
3480d60c:	eaffffa9 	b	3480d4b8 <boot_get_ramdisk+0xa0>
}
3480d610:	e1a00004 	mov	r0, r4
3480d614:	e28dd00c 	add	sp, sp, #12
3480d618:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480d61c:	348261af 	.word	0x348261af
3480d620:	34825229 	.word	0x34825229
3480d624:	348251ba 	.word	0x348251ba
3480d628:	34821ca1 	.word	0x34821ca1
3480d62c:	34821cb6 	.word	0x34821cb6
3480d630:	34821ccb 	.word	0x34821ccb
3480d634:	34821ce9 	.word	0x34821ce9
3480d638:	34821bd5 	.word	0x34821bd5
3480d63c:	348251f2 	.word	0x348251f2
3480d640:	3482520d 	.word	0x3482520d

3480d644 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480d644:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480d648:	e1a09000 	mov	r9, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d64c:	e59f0110 	ldr	r0, [pc, #272]	; 3480d764 <boot_ramdisk_high+0x120>
{
3480d650:	e1a05001 	mov	r5, r1
3480d654:	e1a06002 	mov	r6, r2
3480d658:	e1a04003 	mov	r4, r3
3480d65c:	e59d7018 	ldr	r7, [sp, #24]
	if ((s = getenv("initrd_high")) != NULL) {
3480d660:	ebffe947 	bl	34807b84 <getenv>
3480d664:	e3500000 	cmp	r0, #0
3480d668:	0a000029 	beq	3480d714 <boot_ramdisk_high+0xd0>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
3480d66c:	e3a02010 	mov	r2, #16
3480d670:	e3a01000 	mov	r1, #0
3480d674:	eb003c3a 	bl	3481c764 <simple_strtoul>
		if (initrd_high == ~0)
3480d678:	e3700001 	cmn	r0, #1
		initrd_high = simple_strtoul(s, NULL, 16);
3480d67c:	e1a03000 	mov	r3, r0
		if (initrd_high == ~0)
3480d680:	1a00001a 	bne	3480d6f0 <boot_ramdisk_high+0xac>
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
3480d684:	e3550000 	cmp	r5, #0
3480d688:	0a00001a 	beq	3480d6f8 <boot_ramdisk_high+0xb4>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480d68c:	e0853006 	add	r3, r5, r6
			*initrd_start = rd_data;
3480d690:	e5845000 	str	r5, [r4]
			lmb_reserve(lmb, rd_data, rd_len);
3480d694:	e1a02006 	mov	r2, r6
			*initrd_end = rd_data + rd_len;
3480d698:	e5873000 	str	r3, [r7]
			lmb_reserve(lmb, rd_data, rd_len);
3480d69c:	e1a01005 	mov	r1, r5
3480d6a0:	e1a00009 	mov	r0, r9
3480d6a4:	eb003753 	bl	3481b3f8 <lmb_reserve>
3480d6a8:	ea00000e 	b	3480d6e8 <boot_ramdisk_high+0xa4>
	show_boot_progress(id);
3480d6ac:	e3a0000c 	mov	r0, #12
3480d6b0:	eb00009d 	bl	3480d92c <__show_boot_progress>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480d6b4:	e5942000 	ldr	r2, [r4]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480d6b8:	e59f00a8 	ldr	r0, [pc, #168]	; 3480d768 <boot_ramdisk_high+0x124>
			*initrd_end = *initrd_start + rd_len;
3480d6bc:	e0862002 	add	r2, r6, r2
3480d6c0:	e5872000 	str	r2, [r7]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480d6c4:	e5941000 	ldr	r1, [r4]
3480d6c8:	ebfff033 	bl	3480979c <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
3480d6cc:	e5940000 	ldr	r0, [r4]
3480d6d0:	e3a03801 	mov	r3, #65536	; 0x10000
3480d6d4:	e1a02006 	mov	r2, r6
3480d6d8:	e1a01005 	mov	r1, r5
3480d6dc:	ebfffe89 	bl	3480d108 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
3480d6e0:	e59f0084 	ldr	r0, [pc, #132]	; 3480d76c <boot_ramdisk_high+0x128>
3480d6e4:	ebfff020 	bl	3480976c <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480d6e8:	e3a00000 	mov	r0, #0
3480d6ec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	if (rd_data) {
3480d6f0:	e3550000 	cmp	r5, #0
3480d6f4:	1a000003 	bne	3480d708 <boot_ramdisk_high+0xc4>
		*initrd_start = 0;
3480d6f8:	e3a00000 	mov	r0, #0
3480d6fc:	e5840000 	str	r0, [r4]
		*initrd_end = 0;
3480d700:	e5870000 	str	r0, [r7]
3480d704:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			if (initrd_high)
3480d708:	e3530000 	cmp	r3, #0
3480d70c:	0a000008 	beq	3480d734 <boot_ramdisk_high+0xf0>
3480d710:	ea000002 	b	3480d720 <boot_ramdisk_high+0xdc>
	if (rd_data) {
3480d714:	e3550000 	cmp	r5, #0
3480d718:	0afffff6 	beq	3480d6f8 <boot_ramdisk_high+0xb4>
		initrd_high = ~0;
3480d71c:	e3e03000 	mvn	r3, #0
				*initrd_start = (ulong)lmb_alloc_base(lmb,
3480d720:	e3a02a01 	mov	r2, #4096	; 0x1000
3480d724:	e1a01006 	mov	r1, r6
3480d728:	e1a00009 	mov	r0, r9
3480d72c:	eb00378e 	bl	3481b56c <lmb_alloc_base>
3480d730:	ea000003 	b	3480d744 <boot_ramdisk_high+0x100>
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
3480d734:	e3a02a01 	mov	r2, #4096	; 0x1000
3480d738:	e1a01006 	mov	r1, r6
3480d73c:	e1a00009 	mov	r0, r9
3480d740:	eb003796 	bl	3481b5a0 <lmb_alloc>
3480d744:	e5840000 	str	r0, [r4]
			if (*initrd_start == 0) {
3480d748:	e5943000 	ldr	r3, [r4]
3480d74c:	e3530000 	cmp	r3, #0
3480d750:	1affffd5 	bne	3480d6ac <boot_ramdisk_high+0x68>
				puts("ramdisk - allocation error\n");
3480d754:	e59f0014 	ldr	r0, [pc, #20]	; 3480d770 <boot_ramdisk_high+0x12c>
3480d758:	ebfff003 	bl	3480976c <puts>

error:
	return -1;
3480d75c:	e3e00000 	mvn	r0, #0
3480d760:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480d764:	34825271 	.word	0x34825271
3480d768:	34825299 	.word	0x34825299
3480d76c:	34821bd5 	.word	0x34821bd5
3480d770:	3482527d 	.word	0x3482527d

3480d774 <delete_char.part.0>:
#endif
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
3480d774:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480d778:	e1a07003 	mov	r7, r3

	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480d77c:	e5513001 	ldrb	r3, [r1, #-1]
static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
3480d780:	e1a04002 	mov	r4, r2
	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480d784:	e2416001 	sub	r6, r1, #1
static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
3480d788:	e59d9018 	ldr	r9, [sp, #24]
	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480d78c:	e3530009 	cmp	r3, #9
3480d790:	01a05000 	moveq	r5, r0
3480d794:	1a00001e 	bne	3480d814 <delete_char.part.0+0xa0>
		while (*colp > plen) {
3480d798:	e5943000 	ldr	r3, [r4]
3480d79c:	e1530009 	cmp	r3, r9
3480d7a0:	da000005 	ble	3480d7bc <delete_char.part.0+0x48>
			puts (erase_seq);
3480d7a4:	e59f0090 	ldr	r0, [pc, #144]	; 3480d83c <delete_char.part.0+0xc8>
3480d7a8:	ebffefef 	bl	3480976c <puts>
			(*colp)--;
3480d7ac:	e5943000 	ldr	r3, [r4]
3480d7b0:	e2433001 	sub	r3, r3, #1
3480d7b4:	e5843000 	str	r3, [r4]
3480d7b8:	eafffff6 	b	3480d798 <delete_char.part.0+0x24>
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
3480d7bc:	e59f907c 	ldr	r9, [pc, #124]	; 3480d840 <delete_char.part.0+0xcc>
		for (s=buffer; s<p; ++s) {
3480d7c0:	e1550006 	cmp	r5, r6
3480d7c4:	e1a03005 	mov	r3, r5
3480d7c8:	2a000016 	bcs	3480d828 <delete_char.part.0+0xb4>
			if (*s == '\t') {
3480d7cc:	e5d33000 	ldrb	r3, [r3]
3480d7d0:	e2855001 	add	r5, r5, #1
3480d7d4:	e5940000 	ldr	r0, [r4]
3480d7d8:	e3530009 	cmp	r3, #9
3480d7dc:	1a000007 	bne	3480d800 <delete_char.part.0+0x8c>
				puts (tab_seq+((*colp) & 07));
3480d7e0:	e2000007 	and	r0, r0, #7
3480d7e4:	e0890000 	add	r0, r9, r0
3480d7e8:	ebffefdf 	bl	3480976c <puts>
				*colp += 8 - ((*colp) & 07);
3480d7ec:	e5943000 	ldr	r3, [r4]
3480d7f0:	e3c33007 	bic	r3, r3, #7
3480d7f4:	e2833008 	add	r3, r3, #8
3480d7f8:	e5843000 	str	r3, [r4]
3480d7fc:	eaffffef 	b	3480d7c0 <delete_char.part.0+0x4c>
			} else {
				++(*colp);
3480d800:	e2800001 	add	r0, r0, #1
3480d804:	e5840000 	str	r0, [r4]
				putc (*s);
3480d808:	e5550001 	ldrb	r0, [r5, #-1]
3480d80c:	ebffefca 	bl	3480973c <putc>
3480d810:	eaffffea 	b	3480d7c0 <delete_char.part.0+0x4c>
			}
		}
	} else {
		puts (erase_seq);
3480d814:	e59f0020 	ldr	r0, [pc, #32]	; 3480d83c <delete_char.part.0+0xc8>
3480d818:	ebffefd3 	bl	3480976c <puts>
		(*colp)--;
3480d81c:	e5943000 	ldr	r3, [r4]
3480d820:	e2433001 	sub	r3, r3, #1
3480d824:	e5843000 	str	r3, [r4]
	}
	(*np)--;
3480d828:	e5973000 	ldr	r3, [r7]
	return (p);
}
3480d82c:	e1a00006 	mov	r0, r6
	(*np)--;
3480d830:	e2433001 	sub	r3, r3, #1
3480d834:	e5873000 	str	r3, [r7]
}
3480d838:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480d83c:	34820124 	.word	0x34820124
3480d840:	34820128 	.word	0x34820128

3480d844 <cread_add_char>:
	if (insert || *num == *eol_num) {
3480d844:	e3510000 	cmp	r1, #0
{
3480d848:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480d84c:	e59d6018 	ldr	r6, [sp, #24]
3480d850:	e1a05002 	mov	r5, r2
3480d854:	e1a07000 	mov	r7, r0
3480d858:	e59d201c 	ldr	r2, [sp, #28]
3480d85c:	e5934000 	ldr	r4, [r3]
	if (insert || *num == *eol_num) {
3480d860:	1a000002 	bne	3480d870 <cread_add_char+0x2c>
3480d864:	e5950000 	ldr	r0, [r5]
3480d868:	e1500004 	cmp	r0, r4
3480d86c:	1a000022 	bne	3480d8fc <cread_add_char+0xb8>
		if (*eol_num > len - 1) {
3480d870:	e2422001 	sub	r2, r2, #1
3480d874:	e1540002 	cmp	r4, r2
3480d878:	9a000002 	bls	3480d888 <cread_add_char+0x44>
			getcmd_cbeep();
3480d87c:	e3a00007 	mov	r0, #7
}
3480d880:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
			getcmd_cbeep();
3480d884:	eaffefac 	b	3480973c <putc>
	if (insert) {
3480d888:	e3510000 	cmp	r1, #0
		(*eol_num)++;
3480d88c:	e2844001 	add	r4, r4, #1
3480d890:	e5834000 	str	r4, [r3]
	if (insert) {
3480d894:	0a000018 	beq	3480d8fc <cread_add_char+0xb8>
		wlen = *eol_num - *num;
3480d898:	e5951000 	ldr	r1, [r5]
3480d89c:	e0614004 	rsb	r4, r1, r4
		if (wlen > 1) {
3480d8a0:	e3540001 	cmp	r4, #1
3480d8a4:	9a000004 	bls	3480d8bc <cread_add_char+0x78>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
3480d8a8:	e2810001 	add	r0, r1, #1
3480d8ac:	e2442001 	sub	r2, r4, #1
3480d8b0:	e0861001 	add	r1, r6, r1
3480d8b4:	e0860000 	add	r0, r6, r0
3480d8b8:	eb0038ea 	bl	3481bc68 <memmove>
		buf[*num] = ichar;
3480d8bc:	e5953000 	ldr	r3, [r5]
		putnstr(buf + *num, wlen);
3480d8c0:	e1a01004 	mov	r1, r4
3480d8c4:	e59f005c 	ldr	r0, [pc, #92]	; 3480d928 <cread_add_char+0xe4>
		buf[*num] = ichar;
3480d8c8:	e7c67003 	strb	r7, [r6, r3]
		putnstr(buf + *num, wlen);
3480d8cc:	e5952000 	ldr	r2, [r5]
3480d8d0:	e0862002 	add	r2, r6, r2
3480d8d4:	ebffefb0 	bl	3480979c <printf>
		(*num)++;
3480d8d8:	e5953000 	ldr	r3, [r5]
3480d8dc:	e2833001 	add	r3, r3, #1
3480d8e0:	e5853000 	str	r3, [r5]
		while (--wlen) {
3480d8e4:	e2544001 	subs	r4, r4, #1
3480d8e8:	0a000002 	beq	3480d8f8 <cread_add_char+0xb4>
			getcmd_putch(CTL_BACKSPACE);
3480d8ec:	e3a00008 	mov	r0, #8
3480d8f0:	ebffef91 	bl	3480973c <putc>
3480d8f4:	eafffffa 	b	3480d8e4 <cread_add_char+0xa0>
3480d8f8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		buf[*num] = ichar;
3480d8fc:	e5953000 	ldr	r3, [r5]
		putnstr(buf + *num, wlen);
3480d900:	e3a01001 	mov	r1, #1
3480d904:	e59f001c 	ldr	r0, [pc, #28]	; 3480d928 <cread_add_char+0xe4>
		buf[*num] = ichar;
3480d908:	e7c67003 	strb	r7, [r6, r3]
		putnstr(buf + *num, wlen);
3480d90c:	e5952000 	ldr	r2, [r5]
3480d910:	e0862002 	add	r2, r6, r2
3480d914:	ebffefa0 	bl	3480979c <printf>
		(*num)++;
3480d918:	e5953000 	ldr	r3, [r5]
3480d91c:	e2833001 	add	r3, r3, #1
3480d920:	e5853000 	str	r3, [r5]
3480d924:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480d928:	34825617 	.word	0x34825617

3480d92c <__show_boot_progress>:
void inline __show_boot_progress (int val) {}
3480d92c:	e12fff1e 	bx	lr

3480d930 <readline_into_buffer>:
	if (gd->flags & GD_FLG_RELOC) {
3480d930:	e5983004 	ldr	r3, [r8, #4]
{
3480d934:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480d938:	e1a05000 	mov	r5, r0
3480d93c:	e24dd020 	sub	sp, sp, #32
3480d940:	e1a04001 	mov	r4, r1
	if (gd->flags & GD_FLG_RELOC) {
3480d944:	e2133001 	ands	r3, r3, #1
3480d948:	0a0001b3 	beq	3480e01c <readline_into_buffer+0x6ec>
		if (!initted) {
3480d94c:	e59f9890 	ldr	r9, [pc, #2192]	; 3480e1e4 <readline_into_buffer+0x8b4>
3480d950:	e1a0b002 	mov	fp, r2
3480d954:	e5993000 	ldr	r3, [r9]
3480d958:	e3530000 	cmp	r3, #0
3480d95c:	1a000013 	bne	3480d9b0 <readline_into_buffer+0x80>
	hist_cur = -1;
3480d960:	e59f2880 	ldr	r2, [pc, #2176]	; 3480e1e8 <readline_into_buffer+0x8b8>
3480d964:	e3e01000 	mvn	r1, #0
		hist_list[i][0] = '\0';
3480d968:	e1a0c003 	mov	ip, r3
	for (i = 0; i < HIST_MAX; i++) {
3480d96c:	e3010414 	movw	r0, #5140	; 0x1414
	hist_max = 0;
3480d970:	e5893004 	str	r3, [r9, #4]
	hist_cur = -1;
3480d974:	e5821000 	str	r1, [r2]
3480d978:	e2891060 	add	r1, r9, #96	; 0x60
	hist_num = 0;
3480d97c:	e1a02009 	mov	r2, r9
	hist_add_idx = 0;
3480d980:	e5893008 	str	r3, [r9, #8]
	hist_num = 0;
3480d984:	e5a2300c 	str	r3, [r2, #12]!
3480d988:	e081e003 	add	lr, r1, r3
		hist_list[i][0] = '\0';
3480d98c:	e7c3c001 	strb	ip, [r3, r1]
3480d990:	e2833c01 	add	r3, r3, #256	; 0x100
		hist_list[i] = hist_lines[i];
3480d994:	e5a2e004 	str	lr, [r2, #4]!
3480d998:	e2833001 	add	r3, r3, #1
	for (i = 0; i < HIST_MAX; i++) {
3480d99c:	e1530000 	cmp	r3, r0
3480d9a0:	1afffff8 	bne	3480d988 <readline_into_buffer+0x58>
			initted = 1;
3480d9a4:	e59f3838 	ldr	r3, [pc, #2104]	; 3480e1e4 <readline_into_buffer+0x8b4>
3480d9a8:	e3a02001 	mov	r2, #1
3480d9ac:	e5832000 	str	r2, [r3]
		if (prompt)
3480d9b0:	e3550000 	cmp	r5, #0
3480d9b4:	0a000001 	beq	3480d9c0 <readline_into_buffer+0x90>
			puts (prompt);
3480d9b8:	e1a00005 	mov	r0, r5
3480d9bc:	ebffef6a 	bl	3480976c <puts>
	unsigned long num = 0;
3480d9c0:	e3a03000 	mov	r3, #0
	int init_len = strlen(buf);
3480d9c4:	e1a00004 	mov	r0, r4
	unsigned long num = 0;
3480d9c8:	e58d3010 	str	r3, [sp, #16]
	unsigned long eol_num = 0;
3480d9cc:	e58d3014 	str	r3, [sp, #20]
	int init_len = strlen(buf);
3480d9d0:	eb0037c0 	bl	3481b8d8 <strlen>
	if (init_len)
3480d9d4:	e3500000 	cmp	r0, #0
3480d9d8:	10845000 	addne	r5, r4, r0
3480d9dc:	11a06004 	movne	r6, r4
3480d9e0:	1a000006 	bne	3480da00 <readline_into_buffer+0xd0>
			uint64_t etime = endtick(timeout);
3480d9e4:	e1a03fcb 	asr	r3, fp, #31
			BEGINNING_OF_LINE();
3480d9e8:	e3a07001 	mov	r7, #1
			uint64_t etime = endtick(timeout);
3480d9ec:	e1a0200b 	mov	r2, fp
			BEGINNING_OF_LINE();
3480d9f0:	e3a05000 	mov	r5, #0
3480d9f4:	e1a0a007 	mov	sl, r7
			uint64_t etime = endtick(timeout);
3480d9f8:	e1cd20f8 	strd	r2, [sp, #8]
3480d9fc:	ea000026 	b	3480da9c <readline_into_buffer+0x16c>
	while (strsize--) {
3480da00:	e1560005 	cmp	r6, r5
3480da04:	0afffff6 	beq	3480d9e4 <readline_into_buffer+0xb4>
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480da08:	e3a03c01 	mov	r3, #256	; 0x100
3480da0c:	e4d60001 	ldrb	r0, [r6], #1
3480da10:	e28d2010 	add	r2, sp, #16
3480da14:	e58d3004 	str	r3, [sp, #4]
3480da18:	e58d4000 	str	r4, [sp]
3480da1c:	e28d3014 	add	r3, sp, #20
3480da20:	e3a01001 	mov	r1, #1
3480da24:	ebffff86 	bl	3480d844 <cread_add_char>
3480da28:	eafffff4 	b	3480da00 <readline_into_buffer+0xd0>
			while (!tstc()) {	/* while no incoming data */
3480da2c:	ebffef36 	bl	3480970c <tstc>
3480da30:	e3500000 	cmp	r0, #0
3480da34:	0a000027 	beq	3480dad8 <readline_into_buffer+0x1a8>
			first = 0;
3480da38:	e3a07000 	mov	r7, #0
		ichar = getcmd_getch();
3480da3c:	ebffef26 	bl	348096dc <getc>
3480da40:	e6ef0070 	uxtb	r0, r0
		if ((ichar == '\n') || (ichar == '\r')) {
3480da44:	e350000a 	cmp	r0, #10
3480da48:	1350000d 	cmpne	r0, #13
3480da4c:	03a06001 	moveq	r6, #1
3480da50:	13a06000 	movne	r6, #0
3480da54:	0a000025 	beq	3480daf0 <readline_into_buffer+0x1c0>
		if (esc_len != 0) {
3480da58:	e3550000 	cmp	r5, #0
3480da5c:	0a00005c 	beq	3480dbd4 <readline_into_buffer+0x2a4>
			if (esc_len == 1) {
3480da60:	e3550001 	cmp	r5, #1
3480da64:	1a00003c 	bne	3480db5c <readline_into_buffer+0x22c>
				if (ichar == '[') {
3480da68:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
3480da6c:	05cd0019 	strbeq	r0, [sp, #25]
					esc_len = 2;
3480da70:	03a05002 	moveq	r5, #2
				if (ichar == '[') {
3480da74:	0a000008 	beq	3480da9c <readline_into_buffer+0x16c>
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480da78:	e3a03c01 	mov	r3, #256	; 0x100
3480da7c:	e5dd0018 	ldrb	r0, [sp, #24]
3480da80:	e58d3004 	str	r3, [sp, #4]
3480da84:	e28d2010 	add	r2, sp, #16
3480da88:	e58d4000 	str	r4, [sp]
3480da8c:	e28d3014 	add	r3, sp, #20
3480da90:	e1a0100a 	mov	r1, sl
3480da94:	ebffff6a 	bl	3480d844 <cread_add_char>
			if (num < eol_num) {
3480da98:	e3a05000 	mov	r5, #0
		if (first && timeout) {
3480da9c:	e35b0000 	cmp	fp, #0
3480daa0:	03a03000 	moveq	r3, #0
3480daa4:	12073001 	andne	r3, r7, #1
3480daa8:	e3530000 	cmp	r3, #0
3480daac:	0affffe2 	beq	3480da3c <readline_into_buffer+0x10c>
			uint64_t etime = endtick(timeout);
3480dab0:	ebffcd98 	bl	34801118 <get_ticks>
3480dab4:	e1a07001 	mov	r7, r1
3480dab8:	e1a06000 	mov	r6, r0
3480dabc:	ebffcd99 	bl	34801128 <get_tbclk>
3480dac0:	e0832b90 	umull	r2, r3, r0, fp
3480dac4:	e59d100c 	ldr	r1, [sp, #12]
3480dac8:	e0233190 	mla	r3, r0, r1, r3
3480dacc:	e0966002 	adds	r6, r6, r2
3480dad0:	e0a77003 	adc	r7, r7, r3
3480dad4:	eaffffd4 	b	3480da2c <readline_into_buffer+0xfc>
				if (get_ticks() >= etime)
3480dad8:	ebffcd8e 	bl	34801118 <get_ticks>
3480dadc:	e1510007 	cmp	r1, r7
3480dae0:	01500006 	cmpeq	r0, r6
3480dae4:	3affffd0 	bcc	3480da2c <readline_into_buffer+0xfc>
					return -2;	/* timed out */
3480dae8:	e3e00001 	mvn	r0, #1
3480daec:	ea0001ba 	b	3480e1dc <readline_into_buffer+0x8ac>
			putc('\n');
3480daf0:	e3a0000a 	mov	r0, #10
3480daf4:	ebffef10 	bl	3480973c <putc>
	*len = eol_num;
3480daf8:	e59d5014 	ldr	r5, [sp, #20]
	buf[eol_num] = '\0';	/* lose the newline */
3480dafc:	e3a03000 	mov	r3, #0
3480db00:	e7c43005 	strb	r3, [r4, r5]
	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
3480db04:	e5d43000 	ldrb	r3, [r4]
3480db08:	e3530021 	cmp	r3, #33	; 0x21
3480db0c:	13530000 	cmpne	r3, #0
3480db10:	0a00013c 	beq	3480e008 <readline_into_buffer+0x6d8>
	strcpy(hist_list[hist_add_idx], line);
3480db14:	e5993008 	ldr	r3, [r9, #8]
3480db18:	e1a01004 	mov	r1, r4
3480db1c:	e59f66c0 	ldr	r6, [pc, #1728]	; 3480e1e4 <readline_into_buffer+0x8b4>
3480db20:	e0893103 	add	r3, r9, r3, lsl #2
3480db24:	e5930010 	ldr	r0, [r3, #16]
3480db28:	eb00370c 	bl	3481b760 <strcpy>
	if (++hist_add_idx >= HIST_MAX)
3480db2c:	e5993008 	ldr	r3, [r9, #8]
	if (hist_add_idx > hist_max)
3480db30:	e5992004 	ldr	r2, [r9, #4]
	if (++hist_add_idx >= HIST_MAX)
3480db34:	e2833001 	add	r3, r3, #1
3480db38:	e3530013 	cmp	r3, #19
3480db3c:	c3a03000 	movgt	r3, #0
	if (hist_add_idx > hist_max)
3480db40:	e1530002 	cmp	r3, r2
	if (++hist_add_idx >= HIST_MAX)
3480db44:	e5863008 	str	r3, [r6, #8]
		hist_max = hist_add_idx;
3480db48:	c5863004 	strgt	r3, [r6, #4]
	hist_num++;
3480db4c:	e599300c 	ldr	r3, [r9, #12]
3480db50:	e2833001 	add	r3, r3, #1
3480db54:	e589300c 	str	r3, [r9, #12]
3480db58:	ea00012a 	b	3480e008 <readline_into_buffer+0x6d8>
			switch (ichar) {
3480db5c:	e2403041 	sub	r3, r0, #65	; 0x41
3480db60:	e3530007 	cmp	r3, #7
3480db64:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480db68:	ea000007 	b	3480db8c <readline_into_buffer+0x25c>
3480db6c:	3480de90 	.word	0x3480de90
3480db70:	3480ded8 	.word	0x3480ded8
3480db74:	3480dca4 	.word	0x3480dca4
3480db78:	3480dcc8 	.word	0x3480dcc8
3480db7c:	3480db8c 	.word	0x3480db8c
3480db80:	3480db8c 	.word	0x3480db8c
3480db84:	3480db8c 	.word	0x3480db8c
3480db88:	3480dc78 	.word	0x3480dc78
				esc_save[esc_len++] = ichar;
3480db8c:	e28d3020 	add	r3, sp, #32
3480db90:	e0833005 	add	r3, r3, r5
3480db94:	e2855001 	add	r5, r5, #1
3480db98:	e5430008 	strb	r0, [r3, #-8]
3480db9c:	e28d3018 	add	r3, sp, #24
3480dba0:	e0835005 	add	r5, r3, r5
3480dba4:	e1a06003 	mov	r6, r3
	while (strsize--) {
3480dba8:	e1560005 	cmp	r6, r5
3480dbac:	0affffb9 	beq	3480da98 <readline_into_buffer+0x168>
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480dbb0:	e3a03c01 	mov	r3, #256	; 0x100
3480dbb4:	e4d60001 	ldrb	r0, [r6], #1
3480dbb8:	e28d2010 	add	r2, sp, #16
3480dbbc:	e58d3004 	str	r3, [sp, #4]
3480dbc0:	e58d4000 	str	r4, [sp]
3480dbc4:	e28d3014 	add	r3, sp, #20
3480dbc8:	e1a0100a 	mov	r1, sl
3480dbcc:	ebffff1c 	bl	3480d844 <cread_add_char>
3480dbd0:	eafffff4 	b	3480dba8 <readline_into_buffer+0x278>
		switch (ichar) {
3480dbd4:	e350000b 	cmp	r0, #11
3480dbd8:	0a00005b 	beq	3480dd4c <readline_into_buffer+0x41c>
3480dbdc:	8a00000d 	bhi	3480dc18 <readline_into_buffer+0x2e8>
3480dbe0:	e3500004 	cmp	r0, #4
3480dbe4:	0a00003f 	beq	3480dce8 <readline_into_buffer+0x3b8>
3480dbe8:	8a000005 	bhi	3480dc04 <readline_into_buffer+0x2d4>
3480dbec:	e3500002 	cmp	r0, #2
3480dbf0:	0a000034 	beq	3480dcc8 <readline_into_buffer+0x398>
3480dbf4:	8a000028 	bhi	3480dc9c <readline_into_buffer+0x36c>
3480dbf8:	e3500001 	cmp	r0, #1
3480dbfc:	1a0000f9 	bne	3480dfe8 <readline_into_buffer+0x6b8>
3480dc00:	ea00001c 	b	3480dc78 <readline_into_buffer+0x348>
3480dc04:	e3500006 	cmp	r0, #6
3480dc08:	0a000025 	beq	3480dca4 <readline_into_buffer+0x374>
3480dc0c:	3a00005f 	bcc	3480dd90 <readline_into_buffer+0x460>
3480dc10:	e3500008 	cmp	r0, #8
3480dc14:	ea000015 	b	3480dc70 <readline_into_buffer+0x340>
3480dc18:	e3500015 	cmp	r0, #21
3480dc1c:	0a000066 	beq	3480ddbc <readline_into_buffer+0x48c>
3480dc20:	8a000007 	bhi	3480dc44 <readline_into_buffer+0x314>
3480dc24:	e350000f 	cmp	r0, #15
3480dc28:	022aa001 	eoreq	sl, sl, #1
3480dc2c:	0affff9a 	beq	3480da9c <readline_into_buffer+0x16c>
3480dc30:	e3500010 	cmp	r0, #16
3480dc34:	0a000095 	beq	3480de90 <readline_into_buffer+0x560>
3480dc38:	e350000e 	cmp	r0, #14
3480dc3c:	1a0000e9 	bne	3480dfe8 <readline_into_buffer+0x6b8>
3480dc40:	ea0000a4 	b	3480ded8 <readline_into_buffer+0x5a8>
3480dc44:	e350001b 	cmp	r0, #27
				esc_save[esc_len] = ichar;
3480dc48:	05cd0018 	strbeq	r0, [sp, #24]
				esc_len = 1;
3480dc4c:	03a05001 	moveq	r5, #1
		switch (ichar) {
3480dc50:	0affff91 	beq	3480da9c <readline_into_buffer+0x16c>
3480dc54:	8a000002 	bhi	3480dc64 <readline_into_buffer+0x334>
3480dc58:	e3500018 	cmp	r0, #24
3480dc5c:	0a000056 	beq	3480ddbc <readline_into_buffer+0x48c>
3480dc60:	ea0000e0 	b	3480dfe8 <readline_into_buffer+0x6b8>
3480dc64:	e350007f 	cmp	r0, #127	; 0x7f
3480dc68:	0a00006b 	beq	3480de1c <readline_into_buffer+0x4ec>
3480dc6c:	e35000ff 	cmp	r0, #255	; 0xff
3480dc70:	0a000069 	beq	3480de1c <readline_into_buffer+0x4ec>
3480dc74:	ea0000db 	b	3480dfe8 <readline_into_buffer+0x6b8>
			BEGINNING_OF_LINE();
3480dc78:	e59d5010 	ldr	r5, [sp, #16]
3480dc7c:	e3550000 	cmp	r5, #0
3480dc80:	0affff85 	beq	3480da9c <readline_into_buffer+0x16c>
3480dc84:	e3a00008 	mov	r0, #8
3480dc88:	ebffeeab 	bl	3480973c <putc>
3480dc8c:	e59d3010 	ldr	r3, [sp, #16]
3480dc90:	e2433001 	sub	r3, r3, #1
3480dc94:	e58d3010 	str	r3, [sp, #16]
3480dc98:	eafffff6 	b	3480dc78 <readline_into_buffer+0x348>
			*buf = '\0';	/* discard input */
3480dc9c:	e5c45000 	strb	r5, [r4]
3480dca0:	ea000107 	b	3480e0c4 <readline_into_buffer+0x794>
			if (num < eol_num) {
3480dca4:	e59d3010 	ldr	r3, [sp, #16]
3480dca8:	e59d2014 	ldr	r2, [sp, #20]
3480dcac:	e1530002 	cmp	r3, r2
3480dcb0:	2affff78 	bcs	3480da98 <readline_into_buffer+0x168>
				getcmd_putch(buf[num]);
3480dcb4:	e7d40003 	ldrb	r0, [r4, r3]
3480dcb8:	ebffee9f 	bl	3480973c <putc>
				num++;
3480dcbc:	e59d3010 	ldr	r3, [sp, #16]
3480dcc0:	e2833001 	add	r3, r3, #1
3480dcc4:	ea0000c5 	b	3480dfe0 <readline_into_buffer+0x6b0>
			if (num) {
3480dcc8:	e59d5010 	ldr	r5, [sp, #16]
3480dccc:	e3550000 	cmp	r5, #0
3480dcd0:	0affff71 	beq	3480da9c <readline_into_buffer+0x16c>
				getcmd_putch(CTL_BACKSPACE);
3480dcd4:	e3a00008 	mov	r0, #8
3480dcd8:	ebffee97 	bl	3480973c <putc>
				num--;
3480dcdc:	e59d3010 	ldr	r3, [sp, #16]
3480dce0:	e2433001 	sub	r3, r3, #1
3480dce4:	ea0000bd 	b	3480dfe0 <readline_into_buffer+0x6b0>
			if (num < eol_num) {
3480dce8:	e59d0010 	ldr	r0, [sp, #16]
3480dcec:	e59d6014 	ldr	r6, [sp, #20]
3480dcf0:	e1500006 	cmp	r0, r6
3480dcf4:	2affff68 	bcs	3480da9c <readline_into_buffer+0x16c>
3480dcf8:	e2466001 	sub	r6, r6, #1
				if (wlen) {
3480dcfc:	e0566000 	subs	r6, r6, r0
3480dd00:	0a000009 	beq	3480dd2c <readline_into_buffer+0x3fc>
					memmove(&buf[num], &buf[num+1], wlen);
3480dd04:	e2801001 	add	r1, r0, #1
3480dd08:	e1a02006 	mov	r2, r6
3480dd0c:	e0841001 	add	r1, r4, r1
3480dd10:	e0840000 	add	r0, r4, r0
3480dd14:	eb0037d3 	bl	3481bc68 <memmove>
					putnstr(buf + num, wlen);
3480dd18:	e59d2010 	ldr	r2, [sp, #16]
3480dd1c:	e1a01006 	mov	r1, r6
3480dd20:	e59f04c4 	ldr	r0, [pc, #1220]	; 3480e1ec <readline_into_buffer+0x8bc>
3480dd24:	e0842002 	add	r2, r4, r2
3480dd28:	ebffee9b 	bl	3480979c <printf>
				getcmd_putch(' ');
3480dd2c:	e3a00020 	mov	r0, #32
3480dd30:	ebffee81 	bl	3480973c <putc>
					getcmd_putch(CTL_BACKSPACE);
3480dd34:	e3a00008 	mov	r0, #8
3480dd38:	ebffee7f 	bl	3480973c <putc>
				} while (wlen--);
3480dd3c:	e3560000 	cmp	r6, #0
3480dd40:	e2466001 	sub	r6, r6, #1
3480dd44:	1afffffa 	bne	3480dd34 <readline_into_buffer+0x404>
3480dd48:	ea00004c 	b	3480de80 <readline_into_buffer+0x550>
			ERASE_TO_EOL();
3480dd4c:	e59d3010 	ldr	r3, [sp, #16]
3480dd50:	e59d1014 	ldr	r1, [sp, #20]
3480dd54:	e1530001 	cmp	r3, r1
3480dd58:	2affff4f 	bcs	3480da9c <readline_into_buffer+0x16c>
3480dd5c:	e59f248c 	ldr	r2, [pc, #1164]	; 3480e1f0 <readline_into_buffer+0x8c0>
3480dd60:	e0631001 	rsb	r1, r3, r1
3480dd64:	e59f0488 	ldr	r0, [pc, #1160]	; 3480e1f4 <readline_into_buffer+0x8c4>
3480dd68:	ebffee8b 	bl	3480979c <printf>
3480dd6c:	e3a00008 	mov	r0, #8
3480dd70:	ebffee71 	bl	3480973c <putc>
3480dd74:	e59d3014 	ldr	r3, [sp, #20]
3480dd78:	e59d2010 	ldr	r2, [sp, #16]
3480dd7c:	e2433001 	sub	r3, r3, #1
3480dd80:	e1530002 	cmp	r3, r2
3480dd84:	e58d3014 	str	r3, [sp, #20]
3480dd88:	8afffff7 	bhi	3480dd6c <readline_into_buffer+0x43c>
3480dd8c:	eaffff42 	b	3480da9c <readline_into_buffer+0x16c>
			REFRESH_TO_EOL();
3480dd90:	e59d3010 	ldr	r3, [sp, #16]
3480dd94:	e59d1014 	ldr	r1, [sp, #20]
3480dd98:	e1530001 	cmp	r3, r1
3480dd9c:	2affff3e 	bcs	3480da9c <readline_into_buffer+0x16c>
3480dda0:	e0842003 	add	r2, r4, r3
3480dda4:	e0631001 	rsb	r1, r3, r1
3480dda8:	e59f043c 	ldr	r0, [pc, #1084]	; 3480e1ec <readline_into_buffer+0x8bc>
3480ddac:	ebffee7a 	bl	3480979c <printf>
3480ddb0:	e59d3014 	ldr	r3, [sp, #20]
3480ddb4:	e58d3010 	str	r3, [sp, #16]
3480ddb8:	eaffff37 	b	3480da9c <readline_into_buffer+0x16c>
			BEGINNING_OF_LINE();
3480ddbc:	e59d3010 	ldr	r3, [sp, #16]
3480ddc0:	e3530000 	cmp	r3, #0
3480ddc4:	0a000005 	beq	3480dde0 <readline_into_buffer+0x4b0>
3480ddc8:	e3a00008 	mov	r0, #8
3480ddcc:	ebffee5a 	bl	3480973c <putc>
3480ddd0:	e59d3010 	ldr	r3, [sp, #16]
3480ddd4:	e2433001 	sub	r3, r3, #1
3480ddd8:	e58d3010 	str	r3, [sp, #16]
3480dddc:	eafffff6 	b	3480ddbc <readline_into_buffer+0x48c>
			ERASE_TO_EOL();
3480dde0:	e59d1014 	ldr	r1, [sp, #20]
3480dde4:	e3510000 	cmp	r1, #0
3480dde8:	0affff2b 	beq	3480da9c <readline_into_buffer+0x16c>
3480ddec:	e59f23fc 	ldr	r2, [pc, #1020]	; 3480e1f0 <readline_into_buffer+0x8c0>
3480ddf0:	e59f03fc 	ldr	r0, [pc, #1020]	; 3480e1f4 <readline_into_buffer+0x8c4>
3480ddf4:	ebffee68 	bl	3480979c <printf>
3480ddf8:	e3a00008 	mov	r0, #8
3480ddfc:	ebffee4e 	bl	3480973c <putc>
3480de00:	e59d3014 	ldr	r3, [sp, #20]
3480de04:	e59d2010 	ldr	r2, [sp, #16]
3480de08:	e2433001 	sub	r3, r3, #1
3480de0c:	e1530002 	cmp	r3, r2
3480de10:	e58d3014 	str	r3, [sp, #20]
3480de14:	8afffff7 	bhi	3480ddf8 <readline_into_buffer+0x4c8>
3480de18:	eaffff1f 	b	3480da9c <readline_into_buffer+0x16c>
			if (num) {
3480de1c:	e59d1010 	ldr	r1, [sp, #16]
3480de20:	e3510000 	cmp	r1, #0
3480de24:	0affff1c 	beq	3480da9c <readline_into_buffer+0x16c>
				wlen = eol_num - num;
3480de28:	e59d6014 	ldr	r6, [sp, #20]
				num--;
3480de2c:	e2410001 	sub	r0, r1, #1
3480de30:	e58d0010 	str	r0, [sp, #16]
				memmove(&buf[num], &buf[num+1], wlen);
3480de34:	e0840000 	add	r0, r4, r0
				wlen = eol_num - num;
3480de38:	e0616006 	rsb	r6, r1, r6
				memmove(&buf[num], &buf[num+1], wlen);
3480de3c:	e0841001 	add	r1, r4, r1
3480de40:	e1a02006 	mov	r2, r6
3480de44:	eb003787 	bl	3481bc68 <memmove>
				getcmd_putch(CTL_BACKSPACE);
3480de48:	e3a00008 	mov	r0, #8
3480de4c:	ebffee3a 	bl	3480973c <putc>
				putnstr(buf + num, wlen);
3480de50:	e59d2010 	ldr	r2, [sp, #16]
3480de54:	e1a01006 	mov	r1, r6
3480de58:	e59f038c 	ldr	r0, [pc, #908]	; 3480e1ec <readline_into_buffer+0x8bc>
3480de5c:	e0842002 	add	r2, r4, r2
3480de60:	ebffee4d 	bl	3480979c <printf>
				getcmd_putch(' ');
3480de64:	e3a00020 	mov	r0, #32
3480de68:	ebffee33 	bl	3480973c <putc>
					getcmd_putch(CTL_BACKSPACE);
3480de6c:	e3a00008 	mov	r0, #8
3480de70:	ebffee31 	bl	3480973c <putc>
				} while (wlen--);
3480de74:	e3560000 	cmp	r6, #0
3480de78:	e2466001 	sub	r6, r6, #1
3480de7c:	1afffffa 	bne	3480de6c <readline_into_buffer+0x53c>
				eol_num--;
3480de80:	e59d3014 	ldr	r3, [sp, #20]
3480de84:	e2433001 	sub	r3, r3, #1
3480de88:	e58d3014 	str	r3, [sp, #20]
3480de8c:	eaffff02 	b	3480da9c <readline_into_buffer+0x16c>
	if (hist_cur < 0)
3480de90:	e59f3350 	ldr	r3, [pc, #848]	; 3480e1e8 <readline_into_buffer+0x8b8>
3480de94:	e5932000 	ldr	r2, [r3]
3480de98:	e3520000 	cmp	r2, #0
3480de9c:	ba000025 	blt	3480df38 <readline_into_buffer+0x608>
	if (--hist_cur < 0)
3480dea0:	e2421001 	sub	r1, r2, #1
3480dea4:	e3710001 	cmn	r1, #1
3480dea8:	e5831000 	str	r1, [r3]
		hist_cur = hist_max;
3480deac:	05991004 	ldreq	r1, [r9, #4]
3480deb0:	05831000 	streq	r1, [r3]
	if (hist_cur == hist_add_idx) {
3480deb4:	e5931000 	ldr	r1, [r3]
3480deb8:	e5993008 	ldr	r3, [r9, #8]
3480debc:	e1510003 	cmp	r1, r3
		ret = hist_list[hist_cur];
3480dec0:	159f331c 	ldrne	r3, [pc, #796]	; 3480e1e4 <readline_into_buffer+0x8b4>
		hist_cur = old_cur;
3480dec4:	059f331c 	ldreq	r3, [pc, #796]	; 3480e1e8 <readline_into_buffer+0x8b8>
		ret = hist_list[hist_cur];
3480dec8:	10833101 	addne	r3, r3, r1, lsl #2
		hist_cur = old_cur;
3480decc:	05832000 	streq	r2, [r3]
	if (hist_cur == hist_add_idx) {
3480ded0:	1a000012 	bne	3480df20 <readline_into_buffer+0x5f0>
3480ded4:	ea000017 	b	3480df38 <readline_into_buffer+0x608>
	if (hist_cur < 0)
3480ded8:	e59f2308 	ldr	r2, [pc, #776]	; 3480e1e8 <readline_into_buffer+0x8b8>
3480dedc:	e5923000 	ldr	r3, [r2]
3480dee0:	e3530000 	cmp	r3, #0
3480dee4:	ba000013 	blt	3480df38 <readline_into_buffer+0x608>
	if (hist_cur == hist_add_idx)
3480dee8:	e5991008 	ldr	r1, [r9, #8]
3480deec:	e1530001 	cmp	r3, r1
3480def0:	0a000010 	beq	3480df38 <readline_into_buffer+0x608>
	if (++hist_cur > hist_max)
3480def4:	e59f02e8 	ldr	r0, [pc, #744]	; 3480e1e4 <readline_into_buffer+0x8b4>
3480def8:	e2833001 	add	r3, r3, #1
3480defc:	e5823000 	str	r3, [r2]
3480df00:	e5900004 	ldr	r0, [r0, #4]
3480df04:	e1530000 	cmp	r3, r0
		hist_cur = 0;
3480df08:	c3a03000 	movgt	r3, #0
3480df0c:	c5823000 	strgt	r3, [r2]
	if (hist_cur == hist_add_idx) {
3480df10:	e5923000 	ldr	r3, [r2]
3480df14:	e1530001 	cmp	r3, r1
3480df18:	0a000004 	beq	3480df30 <readline_into_buffer+0x600>
		ret = hist_list[hist_cur];
3480df1c:	e0893103 	add	r3, r9, r3, lsl #2
3480df20:	e5935010 	ldr	r5, [r3, #16]
			if (!hline) {
3480df24:	e3550000 	cmp	r5, #0
3480df28:	1a000005 	bne	3480df44 <readline_into_buffer+0x614>
3480df2c:	ea000001 	b	3480df38 <readline_into_buffer+0x608>
		ret = "";
3480df30:	e59f52b8 	ldr	r5, [pc, #696]	; 3480e1f0 <readline_into_buffer+0x8c0>
3480df34:	ea000002 	b	3480df44 <readline_into_buffer+0x614>
				getcmd_cbeep();
3480df38:	e3a00007 	mov	r0, #7
3480df3c:	ebffedfe 	bl	3480973c <putc>
3480df40:	eafffed4 	b	3480da98 <readline_into_buffer+0x168>
			BEGINNING_OF_LINE();
3480df44:	e59d3010 	ldr	r3, [sp, #16]
3480df48:	e3530000 	cmp	r3, #0
3480df4c:	0a000005 	beq	3480df68 <readline_into_buffer+0x638>
3480df50:	e3a00008 	mov	r0, #8
3480df54:	ebffedf8 	bl	3480973c <putc>
3480df58:	e59d3010 	ldr	r3, [sp, #16]
3480df5c:	e2433001 	sub	r3, r3, #1
3480df60:	e58d3010 	str	r3, [sp, #16]
3480df64:	eafffff6 	b	3480df44 <readline_into_buffer+0x614>
			ERASE_TO_EOL();
3480df68:	e59d1014 	ldr	r1, [sp, #20]
3480df6c:	e3510000 	cmp	r1, #0
3480df70:	1a00000e 	bne	3480dfb0 <readline_into_buffer+0x680>
			strcpy(buf, hline);
3480df74:	e1a01005 	mov	r1, r5
3480df78:	e1a00004 	mov	r0, r4
3480df7c:	eb0035f7 	bl	3481b760 <strcpy>
			eol_num = strlen(buf);
3480df80:	e1a00004 	mov	r0, r4
3480df84:	eb003653 	bl	3481b8d8 <strlen>
			REFRESH_TO_EOL();
3480df88:	e59d1010 	ldr	r1, [sp, #16]
			eol_num = strlen(buf);
3480df8c:	e58d0014 	str	r0, [sp, #20]
			REFRESH_TO_EOL();
3480df90:	e1510000 	cmp	r1, r0
3480df94:	2afffebf 	bcs	3480da98 <readline_into_buffer+0x168>
3480df98:	e0842001 	add	r2, r4, r1
3480df9c:	e0611000 	rsb	r1, r1, r0
3480dfa0:	e59f0244 	ldr	r0, [pc, #580]	; 3480e1ec <readline_into_buffer+0x8bc>
3480dfa4:	ebffedfc 	bl	3480979c <printf>
3480dfa8:	e59d3014 	ldr	r3, [sp, #20]
3480dfac:	ea00000b 	b	3480dfe0 <readline_into_buffer+0x6b0>
			ERASE_TO_EOL();
3480dfb0:	e59f2238 	ldr	r2, [pc, #568]	; 3480e1f0 <readline_into_buffer+0x8c0>
3480dfb4:	e59f0238 	ldr	r0, [pc, #568]	; 3480e1f4 <readline_into_buffer+0x8c4>
3480dfb8:	ebffedf7 	bl	3480979c <printf>
3480dfbc:	e3a00008 	mov	r0, #8
3480dfc0:	ebffeddd 	bl	3480973c <putc>
3480dfc4:	e59d3014 	ldr	r3, [sp, #20]
3480dfc8:	e59d2010 	ldr	r2, [sp, #16]
3480dfcc:	e2433001 	sub	r3, r3, #1
3480dfd0:	e1530002 	cmp	r3, r2
3480dfd4:	e58d3014 	str	r3, [sp, #20]
3480dfd8:	8afffff7 	bhi	3480dfbc <readline_into_buffer+0x68c>
3480dfdc:	eaffffe4 	b	3480df74 <readline_into_buffer+0x644>
			REFRESH_TO_EOL();
3480dfe0:	e58d3010 	str	r3, [sp, #16]
3480dfe4:	eafffeab 	b	3480da98 <readline_into_buffer+0x168>
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
3480dfe8:	e3a03c01 	mov	r3, #256	; 0x100
3480dfec:	e58d4000 	str	r4, [sp]
3480dff0:	e58d3004 	str	r3, [sp, #4]
3480dff4:	e28d2010 	add	r2, sp, #16
3480dff8:	e28d3014 	add	r3, sp, #20
3480dffc:	e1a0100a 	mov	r1, sl
3480e000:	ebfffe0f 	bl	3480d844 <cread_add_char>
3480e004:	eafffea4 	b	3480da9c <readline_into_buffer+0x16c>
	hist_cur = hist_add_idx;
3480e008:	e5992008 	ldr	r2, [r9, #8]
		return rc < 0 ? rc : len;
3480e00c:	e1a00005 	mov	r0, r5
	hist_cur = hist_add_idx;
3480e010:	e59f31d0 	ldr	r3, [pc, #464]	; 3480e1e8 <readline_into_buffer+0x8b8>
3480e014:	e5832000 	str	r2, [r3]
3480e018:	ea00006f 	b	3480e1dc <readline_into_buffer+0x8ac>
	if (prompt) {
3480e01c:	e3500000 	cmp	r0, #0
	int	n = 0;				/* buffer index		*/
3480e020:	e58d3014 	str	r3, [sp, #20]
	int	plen = 0;			/* prompt length	*/
3480e024:	01a07000 	moveq	r7, r0
	if (prompt) {
3480e028:	0a000003 	beq	3480e03c <readline_into_buffer+0x70c>
		plen = strlen (prompt);
3480e02c:	eb003629 	bl	3481b8d8 <strlen>
3480e030:	e1a07000 	mov	r7, r0
		puts (prompt);
3480e034:	e1a00005 	mov	r0, r5
3480e038:	ebffedcb 	bl	3480976c <puts>
					puts (tab_seq+(col&07));
3480e03c:	e59f91b4 	ldr	r9, [pc, #436]	; 3480e1f8 <readline_into_buffer+0x8c8>
	col = plen;
3480e040:	e1a05004 	mov	r5, r4
3480e044:	e58d7018 	str	r7, [sp, #24]
		c = getc();
3480e048:	ebffeda3 	bl	348096dc <getc>
		switch (c) {
3480e04c:	e6ef6070 	uxtb	r6, r0
3480e050:	e356000a 	cmp	r6, #10
3480e054:	0a000012 	beq	3480e0a4 <readline_into_buffer+0x774>
3480e058:	ca000006 	bgt	3480e078 <readline_into_buffer+0x748>
3480e05c:	e3560003 	cmp	r6, #3
3480e060:	0a000015 	beq	3480e0bc <readline_into_buffer+0x78c>
3480e064:	e3560008 	cmp	r6, #8
3480e068:	0a000035 	beq	3480e144 <readline_into_buffer+0x814>
3480e06c:	e3560000 	cmp	r6, #0
3480e070:	0afffff4 	beq	3480e048 <readline_into_buffer+0x718>
3480e074:	ea00003d 	b	3480e170 <readline_into_buffer+0x840>
3480e078:	e3560015 	cmp	r6, #21
3480e07c:	0a000012 	beq	3480e0cc <readline_into_buffer+0x79c>
3480e080:	ca000002 	bgt	3480e090 <readline_into_buffer+0x760>
3480e084:	e356000d 	cmp	r6, #13
3480e088:	0a000005 	beq	3480e0a4 <readline_into_buffer+0x774>
3480e08c:	ea000037 	b	3480e170 <readline_into_buffer+0x840>
3480e090:	e3560017 	cmp	r6, #23
3480e094:	0a000019 	beq	3480e100 <readline_into_buffer+0x7d0>
3480e098:	e356007f 	cmp	r6, #127	; 0x7f
3480e09c:	0a000028 	beq	3480e144 <readline_into_buffer+0x814>
3480e0a0:	ea000032 	b	3480e170 <readline_into_buffer+0x840>
			*p = '\0';
3480e0a4:	e3a03000 	mov	r3, #0
			puts ("\r\n");
3480e0a8:	e59f014c 	ldr	r0, [pc, #332]	; 3480e1fc <readline_into_buffer+0x8cc>
			*p = '\0';
3480e0ac:	e5c53000 	strb	r3, [r5]
			puts ("\r\n");
3480e0b0:	ebffedad 	bl	3480976c <puts>
			return (p - p_buf);
3480e0b4:	e0640005 	rsb	r0, r4, r5
3480e0b8:	ea000047 	b	3480e1dc <readline_into_buffer+0x8ac>
			p_buf[0] = '\0';	/* discard input */
3480e0bc:	e3a03000 	mov	r3, #0
3480e0c0:	e5c43000 	strb	r3, [r4]
			return (-1);
3480e0c4:	e3e00000 	mvn	r0, #0
3480e0c8:	ea000043 	b	3480e1dc <readline_into_buffer+0x8ac>
			while (col > plen) {
3480e0cc:	e59d3018 	ldr	r3, [sp, #24]
3480e0d0:	e1530007 	cmp	r3, r7
3480e0d4:	da000005 	ble	3480e0f0 <readline_into_buffer+0x7c0>
				puts (erase_seq);
3480e0d8:	e59f0120 	ldr	r0, [pc, #288]	; 3480e200 <readline_into_buffer+0x8d0>
3480e0dc:	ebffeda2 	bl	3480976c <puts>
				--col;
3480e0e0:	e59d3018 	ldr	r3, [sp, #24]
3480e0e4:	e2433001 	sub	r3, r3, #1
3480e0e8:	e58d3018 	str	r3, [sp, #24]
3480e0ec:	eafffff6 	b	3480e0cc <readline_into_buffer+0x79c>
			n = 0;
3480e0f0:	e3a03000 	mov	r3, #0
3480e0f4:	e1a05004 	mov	r5, r4
3480e0f8:	e58d3014 	str	r3, [sp, #20]
3480e0fc:	eaffffd1 	b	3480e048 <readline_into_buffer+0x718>
	if (*np == 0) {
3480e100:	e59d3014 	ldr	r3, [sp, #20]
3480e104:	e3530000 	cmp	r3, #0
3480e108:	0a000006 	beq	3480e128 <readline_into_buffer+0x7f8>
3480e10c:	e1a01005 	mov	r1, r5
3480e110:	e58d7000 	str	r7, [sp]
3480e114:	e28d3014 	add	r3, sp, #20
3480e118:	e28d2018 	add	r2, sp, #24
3480e11c:	e1a00004 	mov	r0, r4
3480e120:	ebfffd93 	bl	3480d774 <delete_char.part.0>
3480e124:	e1a05000 	mov	r5, r0
			while ((n > 0) && (*p != ' ')) {
3480e128:	e59d3014 	ldr	r3, [sp, #20]
3480e12c:	e3530000 	cmp	r3, #0
3480e130:	daffffc4 	ble	3480e048 <readline_into_buffer+0x718>
3480e134:	e5d53000 	ldrb	r3, [r5]
3480e138:	e3530020 	cmp	r3, #32
3480e13c:	1afffff2 	bne	3480e10c <readline_into_buffer+0x7dc>
3480e140:	eaffffc0 	b	3480e048 <readline_into_buffer+0x718>
	if (*np == 0) {
3480e144:	e59d3014 	ldr	r3, [sp, #20]
3480e148:	e3530000 	cmp	r3, #0
3480e14c:	0affffbd 	beq	3480e048 <readline_into_buffer+0x718>
3480e150:	e1a01005 	mov	r1, r5
3480e154:	e58d7000 	str	r7, [sp]
3480e158:	e28d3014 	add	r3, sp, #20
3480e15c:	e28d2018 	add	r2, sp, #24
3480e160:	e1a00004 	mov	r0, r4
3480e164:	ebfffd82 	bl	3480d774 <delete_char.part.0>
3480e168:	e1a05000 	mov	r5, r0
3480e16c:	eaffffb5 	b	3480e048 <readline_into_buffer+0x718>
			if (n < CONFIG_SYS_CBSIZE-2) {
3480e170:	e59d3014 	ldr	r3, [sp, #20]
3480e174:	e35300fd 	cmp	r3, #253	; 0xfd
3480e178:	ca000014 	bgt	3480e1d0 <readline_into_buffer+0x8a0>
				if (c == '\t') {	/* expand TABs		*/
3480e17c:	e3560009 	cmp	r6, #9
3480e180:	e59d0018 	ldr	r0, [sp, #24]
3480e184:	1a000007 	bne	3480e1a8 <readline_into_buffer+0x878>
					puts (tab_seq+(col&07));
3480e188:	e2000007 	and	r0, r0, #7
3480e18c:	e0890000 	add	r0, r9, r0
3480e190:	ebffed75 	bl	3480976c <puts>
					col += 8 - (col&07);
3480e194:	e59d3018 	ldr	r3, [sp, #24]
3480e198:	e3c33007 	bic	r3, r3, #7
3480e19c:	e2833008 	add	r3, r3, #8
3480e1a0:	e58d3018 	str	r3, [sp, #24]
3480e1a4:	ea000003 	b	3480e1b8 <readline_into_buffer+0x888>
					++col;		/* echo input		*/
3480e1a8:	e2800001 	add	r0, r0, #1
3480e1ac:	e58d0018 	str	r0, [sp, #24]
					putc (c);
3480e1b0:	e1a00006 	mov	r0, r6
3480e1b4:	ebffed60 	bl	3480973c <putc>
				*p++ = c;
3480e1b8:	e5c56000 	strb	r6, [r5]
3480e1bc:	e2855001 	add	r5, r5, #1
				++n;
3480e1c0:	e59d3014 	ldr	r3, [sp, #20]
3480e1c4:	e2833001 	add	r3, r3, #1
3480e1c8:	e58d3014 	str	r3, [sp, #20]
3480e1cc:	eaffff9d 	b	3480e048 <readline_into_buffer+0x718>
				putc ('\a');
3480e1d0:	e3a00007 	mov	r0, #7
3480e1d4:	ebffed58 	bl	3480973c <putc>
3480e1d8:	eaffff9a 	b	3480e048 <readline_into_buffer+0x718>
}
3480e1dc:	e28dd020 	add	sp, sp, #32
3480e1e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480e1e4:	34828ce0 	.word	0x34828ce0
3480e1e8:	34827738 	.word	0x34827738
3480e1ec:	34825617 	.word	0x34825617
3480e1f0:	34822afd 	.word	0x34822afd
3480e1f4:	3482561c 	.word	0x3482561c
3480e1f8:	34820128 	.word	0x34820128
3480e1fc:	34825620 	.word	0x34825620
3480e200:	34820124 	.word	0x34820124

3480e204 <readline>:
	console_buffer[0] = '\0';
3480e204:	e59f1010 	ldr	r1, [pc, #16]	; 3480e21c <readline+0x18>
3480e208:	e3a02000 	mov	r2, #0
3480e20c:	e5412b84 	strb	r2, [r1, #-2948]	; 0xfffff47c
	return readline_into_buffer(prompt, console_buffer, 0);
3480e210:	e2411d2e 	sub	r1, r1, #2944	; 0xb80
3480e214:	e2411004 	sub	r1, r1, #4
3480e218:	eafffdc4 	b	3480d930 <readline_into_buffer>
3480e21c:	3482acd8 	.word	0x3482acd8

3480e220 <parse_line>:

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
3480e220:	e92d4010 	push	{r4, lr}
3480e224:	e241e004 	sub	lr, r1, #4
	int nargs = 0;
3480e228:	e3a04000 	mov	r4, #0
3480e22c:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
3480e230:	e4d03001 	ldrb	r3, [r0], #1
3480e234:	e3530020 	cmp	r3, #32
3480e238:	13530009 	cmpne	r3, #9
3480e23c:	0afffffa 	beq	3480e22c <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
3480e240:	e3530000 	cmp	r3, #0
3480e244:	0a00000b 	beq	3480e278 <parse_line+0x58>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
3480e248:	e2844001 	add	r4, r4, #1
3480e24c:	e5ae2004 	str	r2, [lr, #4]!
3480e250:	e1a0c002 	mov	ip, r2

		/* find end of string */
		while (*line && !isblank(*line))
3480e254:	e4d23001 	ldrb	r3, [r2], #1
3480e258:	e3530000 	cmp	r3, #0
3480e25c:	0a000005 	beq	3480e278 <parse_line+0x58>
3480e260:	e3530009 	cmp	r3, #9
3480e264:	13530020 	cmpne	r3, #32
3480e268:	13a03001 	movne	r3, #1
3480e26c:	03a03000 	moveq	r3, #0
3480e270:	1afffff6 	bne	3480e250 <parse_line+0x30>
3480e274:	ea000001 	b	3480e280 <parse_line+0x60>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
3480e278:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
3480e27c:	ea000006 	b	3480e29c <parse_line+0x7c>
	while (nargs < CONFIG_SYS_MAXARGS) {
3480e280:	e3540010 	cmp	r4, #16
		}

		*line++ = '\0';		/* terminate current arg	 */
3480e284:	e28c0001 	add	r0, ip, #1
3480e288:	e5cc3000 	strb	r3, [ip]
	while (nargs < CONFIG_SYS_MAXARGS) {
3480e28c:	1affffe6 	bne	3480e22c <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
3480e290:	e1a01004 	mov	r1, r4
3480e294:	e59f0008 	ldr	r0, [pc, #8]	; 3480e2a4 <parse_line+0x84>
3480e298:	ebffed3f 	bl	3480979c <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
3480e29c:	e1a00004 	mov	r0, r4
3480e2a0:	e8bd8010 	pop	{r4, pc}
3480e2a4:	34825623 	.word	0x34825623

3480e2a8 <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480e2a8:	e3a01003 	mov	r1, #3
3480e2ac:	eafff73e 	b	3480bfac <parse_string_outer>

3480e2b0 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480e2b0:	e3710001 	cmn	r1, #1
{
3480e2b4:	e92d4070 	push	{r4, r5, r6, lr}
3480e2b8:	e1a05000 	mov	r5, r0
3480e2bc:	e1a04001 	mov	r4, r1
	if (len == -1) {
3480e2c0:	1a000001 	bne	3480e2cc <run_command_list+0x1c>
		len = strlen(cmd);
3480e2c4:	eb003583 	bl	3481b8d8 <strlen>
3480e2c8:	ea000009 	b	3480e2f4 <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
3480e2cc:	e2810001 	add	r0, r1, #1
3480e2d0:	ebffef00 	bl	34809ed8 <malloc>
		if (!buff)
3480e2d4:	e2506000 	subs	r6, r0, #0
3480e2d8:	0a000009 	beq	3480e304 <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
3480e2dc:	e1a01005 	mov	r1, r5
3480e2e0:	e1a02004 	mov	r2, r4
		buff[len] = '\0';
3480e2e4:	e1a05006 	mov	r5, r6
		memcpy(buff, cmd, len);
3480e2e8:	eb003643 	bl	3481bbfc <memcpy>
		buff[len] = '\0';
3480e2ec:	e3a03000 	mov	r3, #0
3480e2f0:	e7c63004 	strb	r3, [r6, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e2f4:	e1a00005 	mov	r0, r5
3480e2f8:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480e2fc:	e8bd4070 	pop	{r4, r5, r6, lr}
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e300:	eafff729 	b	3480bfac <parse_string_outer>
}
3480e304:	e3a00001 	mov	r0, #1
3480e308:	e8bd8070 	pop	{r4, r5, r6, pc}

3480e30c <main_loop>:
{
3480e30c:	e92d4070 	push	{r4, r5, r6, lr}
	u_boot_hush_start ();
3480e310:	ebfffad5 	bl	3480ce6c <u_boot_hush_start>
	s = getenv ("bootdelay");
3480e314:	e59f00f4 	ldr	r0, [pc, #244]	; 3480e410 <main_loop+0x104>
3480e318:	ebffe619 	bl	34807b84 <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
3480e31c:	e3500000 	cmp	r0, #0
3480e320:	03a05001 	moveq	r5, #1
3480e324:	0a000003 	beq	3480e338 <main_loop+0x2c>
3480e328:	e3a0200a 	mov	r2, #10
3480e32c:	e3a01000 	mov	r1, #0
3480e330:	eb003957 	bl	3481c894 <simple_strtol>
3480e334:	e1a05000 	mov	r5, r0
		s = getenv ("bootcmd");
3480e338:	e59f00d4 	ldr	r0, [pc, #212]	; 3480e414 <main_loop+0x108>
3480e33c:	ebffe610 	bl	34807b84 <getenv>
	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e340:	e3500000 	cmp	r0, #0
3480e344:	13750001 	cmnne	r5, #1
3480e348:	e1a06000 	mov	r6, r0
3480e34c:	0a00002d 	beq	3480e408 <main_loop+0xfc>
	if (bootdelay >= 0)
3480e350:	e3550000 	cmp	r5, #0
3480e354:	aa000001 	bge	3480e360 <main_loop+0x54>
	int abort = 0;
3480e358:	e3a04000 	mov	r4, #0
3480e35c:	ea000017 	b	3480e3c0 <main_loop+0xb4>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
3480e360:	e1a01005 	mov	r1, r5
3480e364:	e59f00ac 	ldr	r0, [pc, #172]	; 3480e418 <main_loop+0x10c>
3480e368:	ebffed0b 	bl	3480979c <printf>
		if (tstc()) {	/* we got a key press	*/
3480e36c:	ebffece6 	bl	3480970c <tstc>
3480e370:	e3500000 	cmp	r0, #0
3480e374:	0afffff7 	beq	3480e358 <main_loop+0x4c>
			(void) getc();  /* consume input	*/
3480e378:	ebffecd7 	bl	348096dc <getc>
			puts ("\b\b\b 0");
3480e37c:	e59f0098 	ldr	r0, [pc, #152]	; 3480e41c <main_loop+0x110>
			abort = 1;	/* don't auto boot	*/
3480e380:	e3a04001 	mov	r4, #1
			puts ("\b\b\b 0");
3480e384:	ebffecf8 	bl	3480976c <puts>
3480e388:	ea00000c 	b	3480e3c0 <main_loop+0xb4>
			udelay(10000);
3480e38c:	e3020710 	movw	r0, #10000	; 0x2710
3480e390:	eb00369d 	bl	3481be0c <udelay>
		for (i=0; !abort && i<100; ++i) {
3480e394:	e2544001 	subs	r4, r4, #1
3480e398:	0a000010 	beq	3480e3e0 <main_loop+0xd4>
			if (tstc()) {	/* we got a key press	*/
3480e39c:	ebffecda 	bl	3480970c <tstc>
3480e3a0:	e3500000 	cmp	r0, #0
3480e3a4:	0afffff8 	beq	3480e38c <main_loop+0x80>
				abort  = 1;	/* don't auto boot	*/
3480e3a8:	e3a04001 	mov	r4, #1
				bootdelay = 0;	/* no more delay	*/
3480e3ac:	e3a05000 	mov	r5, #0
				(void) getc();  /* consume input	*/
3480e3b0:	ebffecc9 	bl	348096dc <getc>
		printf("\b\b\b%2d ", bootdelay);
3480e3b4:	e1a01005 	mov	r1, r5
3480e3b8:	e59f0060 	ldr	r0, [pc, #96]	; 3480e420 <main_loop+0x114>
3480e3bc:	ebffecf6 	bl	3480979c <printf>
3480e3c0:	e2243001 	eor	r3, r4, #1
	while ((bootdelay > 0) && (!abort)) {
3480e3c4:	e3550000 	cmp	r5, #0
3480e3c8:	d3a03000 	movle	r3, #0
3480e3cc:	c2033001 	andgt	r3, r3, #1
3480e3d0:	e3530000 	cmp	r3, #0
3480e3d4:	0a000003 	beq	3480e3e8 <main_loop+0xdc>
3480e3d8:	e3a04065 	mov	r4, #101	; 0x65
3480e3dc:	eaffffec 	b	3480e394 <main_loop+0x88>
		--bootdelay;
3480e3e0:	e2455001 	sub	r5, r5, #1
3480e3e4:	eafffff2 	b	3480e3b4 <main_loop+0xa8>
	putc('\n');
3480e3e8:	e3a0000a 	mov	r0, #10
3480e3ec:	ebffecd2 	bl	3480973c <putc>
	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e3f0:	e3540000 	cmp	r4, #0
3480e3f4:	1a000003 	bne	3480e408 <main_loop+0xfc>
		run_command_list(s, -1, 0);
3480e3f8:	e1a02004 	mov	r2, r4
3480e3fc:	e3e01000 	mvn	r1, #0
3480e400:	e1a00006 	mov	r0, r6
3480e404:	ebffffa9 	bl	3480e2b0 <run_command_list>
	parse_file_outer();
3480e408:	ebfffa86 	bl	3480ce28 <parse_file_outer>
	for (;;);
3480e40c:	eafffffe 	b	3480e40c <main_loop+0x100>
3480e410:	34825642 	.word	0x34825642
3480e414:	34821b29 	.word	0x34821b29
3480e418:	3482564c 	.word	0x3482564c
3480e41c:	3482566f 	.word	0x3482566f
3480e420:	34825675 	.word	0x34825675

3480e424 <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
3480e424:	e3520001 	cmp	r2, #1
3480e428:	da000015 	ble	3480e484 <do_run+0x60>
{
3480e42c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480e430:	e1a05002 	mov	r5, r2
3480e434:	e2834004 	add	r4, r3, #4
	if (argc < 2)
3480e438:	e3a06001 	mov	r6, #1
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
3480e43c:	e1a07004 	mov	r7, r4
3480e440:	e2844004 	add	r4, r4, #4
3480e444:	e5970000 	ldr	r0, [r7]
3480e448:	ebffe5cd 	bl	34807b84 <getenv>
3480e44c:	e3500000 	cmp	r0, #0
3480e450:	1a000003 	bne	3480e464 <do_run+0x40>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
3480e454:	e5971000 	ldr	r1, [r7]
3480e458:	e59f0034 	ldr	r0, [pc, #52]	; 3480e494 <do_run+0x70>
3480e45c:	ebffecce 	bl	3480979c <printf>
3480e460:	ea000009 	b	3480e48c <do_run+0x68>
	return parse_string_outer(cmd,
3480e464:	e3a01003 	mov	r1, #3
3480e468:	ebfff6cf 	bl	3480bfac <parse_string_outer>
			return 1;
		}

		if (run_command(arg, flag) != 0)
3480e46c:	e3500000 	cmp	r0, #0
3480e470:	1a000005 	bne	3480e48c <do_run+0x68>
	for (i=1; i<argc; ++i) {
3480e474:	e2866001 	add	r6, r6, #1
3480e478:	e1560005 	cmp	r6, r5
3480e47c:	1affffee 	bne	3480e43c <do_run+0x18>
3480e480:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return CMD_RET_USAGE;
3480e484:	e3e00000 	mvn	r0, #0
			return 1;
	}
	return 0;
}
3480e488:	e12fff1e 	bx	lr
			return 1;
3480e48c:	e3a00001 	mov	r0, #1
}
3480e490:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480e494:	34823fb5 	.word	0x34823fb5

3480e498 <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
3480e498:	e92d4030 	push	{r4, r5, lr}
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e49c:	e1a031a1 	lsr	r3, r1, #3
3480e4a0:	e1a0e121 	lsr	lr, r1, #2
{
3480e4a4:	e24dd084 	sub	sp, sp, #132	; 0x84
	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e4a8:	e3a0c000 	mov	ip, #0
3480e4ac:	e3530000 	cmp	r3, #0
3480e4b0:	e1a0200c 	mov	r2, ip
3480e4b4:	0a000006 	beq	3480e4d4 <get_ram_size+0x3c>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
3480e4b8:	e7902103 	ldr	r2, [r0, r3, lsl #2]
3480e4bc:	e78d210c 	str	r2, [sp, ip, lsl #2]
		sync ();
		*addr = ~cnt;
3480e4c0:	e1e02003 	mvn	r2, r3
3480e4c4:	e7802103 	str	r2, [r0, r3, lsl #2]
3480e4c8:	e28cc001 	add	ip, ip, #1
	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e4cc:	e1a030c3 	asr	r3, r3, #1
3480e4d0:	eafffff5 	b	3480e4ac <get_ram_size+0x14>
	}

	addr = base;
	sync ();
	save[i] = *addr;
3480e4d4:	e590c000 	ldr	ip, [r0]
3480e4d8:	e28d4080 	add	r4, sp, #128	; 0x80
	sync ();
	*addr = 0;
3480e4dc:	e5803000 	str	r3, [r0]
	save[i] = *addr;
3480e4e0:	e0844102 	add	r4, r4, r2, lsl #2

	sync ();
	if ((val = *addr) != 0) {
3480e4e4:	e5903000 	ldr	r3, [r0]
	save[i] = *addr;
3480e4e8:	e504c080 	str	ip, [r4, #-128]	; 0xffffff80
	if ((val = *addr) != 0) {
3480e4ec:	e3530000 	cmp	r3, #0
3480e4f0:	03a03001 	moveq	r3, #1
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
3480e4f4:	1580c000 	strne	ip, [r0]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e4f8:	13a03001 	movne	r3, #1
	if ((val = *addr) != 0) {
3480e4fc:	0a000010 	beq	3480e544 <get_ram_size+0xac>
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e500:	e153000e 	cmp	r3, lr
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
3480e504:	32422001 	subcc	r2, r2, #1
3480e508:	379d1102 	ldrcc	r1, [sp, r2, lsl #2]
3480e50c:	37801103 	strcc	r1, [r0, r3, lsl #2]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e510:	31a03083 	lslcc	r3, r3, #1
3480e514:	3afffff9 	bcc	3480e500 <get_ram_size+0x68>
		}
		return (0);
3480e518:	e3a00000 	mov	r0, #0
3480e51c:	ea000014 	b	3480e574 <get_ram_size+0xdc>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
3480e520:	e2422001 	sub	r2, r2, #1
		val = *addr;
3480e524:	e7905103 	ldr	r5, [r0, r3, lsl #2]
		*addr = save[--i];
3480e528:	e79d4102 	ldr	r4, [sp, r2, lsl #2]
		addr = base + cnt;	/* pointer arith! */
3480e52c:	e1a0c103 	lsl	ip, r3, #2
		*addr = save[--i];
3480e530:	e7804103 	str	r4, [r0, r3, lsl #2]
		if (val != ~cnt) {
3480e534:	e1e04003 	mvn	r4, r3
3480e538:	e1550004 	cmp	r5, r4
3480e53c:	e1a03083 	lsl	r3, r3, #1
3480e540:	1a000002 	bne	3480e550 <get_ram_size+0xb8>
	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e544:	e153000e 	cmp	r3, lr
3480e548:	3afffff4 	bcc	3480e520 <get_ram_size+0x88>
3480e54c:	ea000007 	b	3480e570 <get_ram_size+0xd8>
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e550:	e153000e 	cmp	r3, lr
				addr  = base + cnt;
				*addr = save[--i];
3480e554:	32422001 	subcc	r2, r2, #1
3480e558:	379d1102 	ldrcc	r1, [sp, r2, lsl #2]
3480e55c:	37801103 	strcc	r1, [r0, r3, lsl #2]
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e560:	31a03083 	lslcc	r3, r3, #1
3480e564:	3afffff9 	bcc	3480e550 <get_ram_size+0xb8>
			}
			return (size);
3480e568:	e1a0000c 	mov	r0, ip
3480e56c:	ea000000 	b	3480e574 <get_ram_size+0xdc>
		}
	}

	return (maxsize);
3480e570:	e1a00001 	mov	r0, r1
}
3480e574:	e28dd084 	add	sp, sp, #132	; 0x84
3480e578:	e8bd8030 	pop	{r4, r5, pc}

3480e57c <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480e57c:	e2403030 	sub	r3, r0, #48	; 0x30
3480e580:	e6ef2073 	uxtb	r2, r3
3480e584:	e3520009 	cmp	r2, #9
3480e588:	8a000001 	bhi	3480e594 <hex1_bin+0x18>
		return (c - '0');
3480e58c:	e1a00003 	mov	r0, r3
3480e590:	e12fff1e 	bx	lr
	if (c >= 'a' && c <= 'f')
3480e594:	e2403061 	sub	r3, r0, #97	; 0x61
3480e598:	e3530005 	cmp	r3, #5
3480e59c:	8a000001 	bhi	3480e5a8 <hex1_bin+0x2c>
		return (c + 10 - 'a');
3480e5a0:	e2400057 	sub	r0, r0, #87	; 0x57
3480e5a4:	e12fff1e 	bx	lr
	if (c >= 'A' && c <= 'F')
3480e5a8:	e2403041 	sub	r3, r0, #65	; 0x41
3480e5ac:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
3480e5b0:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
3480e5b4:	83e00000 	mvnhi	r0, #0
}
3480e5b8:	e12fff1e 	bx	lr

3480e5bc <hex2_bin>:

static int hex2_bin (char *s)
{
3480e5bc:	e92d4070 	push	{r4, r5, r6, lr}
3480e5c0:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480e5c4:	e5d00000 	ldrb	r0, [r0]
3480e5c8:	ebffffeb 	bl	3480e57c <hex1_bin>
3480e5cc:	e2505000 	subs	r5, r0, #0
3480e5d0:	ba000005 	blt	3480e5ec <hex2_bin+0x30>
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
3480e5d4:	e5d40001 	ldrb	r0, [r4, #1]
3480e5d8:	ebffffe7 	bl	3480e57c <hex1_bin>
3480e5dc:	e3500000 	cmp	r0, #0
3480e5e0:	ba000001 	blt	3480e5ec <hex2_bin+0x30>
		return (-1);
	}

	return ((i<<4) + j);
3480e5e4:	e0800205 	add	r0, r0, r5, lsl #4
3480e5e8:	e8bd8070 	pop	{r4, r5, r6, pc}
		return (-1);
3480e5ec:	e3e00000 	mvn	r0, #0
}
3480e5f0:	e8bd8070 	pop	{r4, r5, r6, pc}

3480e5f4 <srec_decode>:
{
3480e5f4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480e5f8:	e1a07001 	mov	r7, r1
3480e5fc:	e1a09002 	mov	r9, r2
3480e600:	e1a06003 	mov	r6, r3
3480e604:	e1a0a000 	mov	sl, r0
3480e608:	e2800001 	add	r0, r0, #1
	for (; *input; ++input) {
3480e60c:	e5503001 	ldrb	r3, [r0, #-1]
3480e610:	e3530000 	cmp	r3, #0
3480e614:	0a000002 	beq	3480e624 <srec_decode+0x30>
		if (*input == 'S') {		/* skip 'S' */
3480e618:	e3530053 	cmp	r3, #83	; 0x53
3480e61c:	1afffff8 	bne	3480e604 <srec_decode+0x10>
			++input;
3480e620:	e1a0a000 	mov	sl, r0
	if (*input == '\0') {			/* no more data?	*/
3480e624:	e5dab000 	ldrb	fp, [sl]
3480e628:	e35b0000 	cmp	fp, #0
3480e62c:	0a000081 	beq	3480e838 <srec_decode+0x244>
	if ((*count = hex2_bin(input)) < 0) {
3480e630:	e28a0001 	add	r0, sl, #1
3480e634:	ebffffe0 	bl	3480e5bc <hex2_bin>
3480e638:	e3500000 	cmp	r0, #0
3480e63c:	e5870000 	str	r0, [r7]
3480e640:	aa000001 	bge	3480e64c <srec_decode+0x58>
		return (SREC_E_NOSREC);
3480e644:	e3e00001 	mvn	r0, #1
3480e648:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	switch (v) {				/* record type		*/
3480e64c:	e24b3030 	sub	r3, fp, #48	; 0x30
	chksum += *count;
3480e650:	e6ef4070 	uxtb	r4, r0
	input  += 2;
3480e654:	e28a5003 	add	r5, sl, #3
	switch (v) {				/* record type		*/
3480e658:	e3530009 	cmp	r3, #9
3480e65c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480e660:	ea000076 	b	3480e840 <srec_decode+0x24c>
3480e664:	3480e68c 	.word	0x3480e68c
3480e668:	3480e69c 	.word	0x3480e69c
3480e66c:	3480e6ac 	.word	0x3480e6ac
3480e670:	3480e6bc 	.word	0x3480e6bc
3480e674:	3480e840 	.word	0x3480e840
3480e678:	3480e6cc 	.word	0x3480e6cc
3480e67c:	3480e840 	.word	0x3480e840
3480e680:	3480e6dc 	.word	0x3480e6dc
3480e684:	3480e6ec 	.word	0x3480e6ec
3480e688:	3480e6fc 	.word	0x3480e6fc
		*count   -= 3;			/* - checksum and addr	*/
3480e68c:	e2400003 	sub	r0, r0, #3
		srec_type = SREC_START;		/* 2 byte addr field	*/
3480e690:	e3a0b000 	mov	fp, #0
		*count   -= 3;			/* - checksum and addr	*/
3480e694:	e5870000 	str	r0, [r7]
		break;
3480e698:	ea00001a 	b	3480e708 <srec_decode+0x114>
		*count   -= 3;			/* - checksum and addr	*/
3480e69c:	e2400003 	sub	r0, r0, #3
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
3480e6a0:	e3a0b001 	mov	fp, #1
		*count   -= 3;			/* - checksum and addr	*/
3480e6a4:	e5870000 	str	r0, [r7]
		break;
3480e6a8:	ea000016 	b	3480e708 <srec_decode+0x114>
		*count   -= 4;			/* - checksum and addr	*/
3480e6ac:	e2400004 	sub	r0, r0, #4
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
3480e6b0:	e3a0b002 	mov	fp, #2
		*count   -= 4;			/* - checksum and addr	*/
3480e6b4:	e5870000 	str	r0, [r7]
		break;
3480e6b8:	ea000012 	b	3480e708 <srec_decode+0x114>
		*count   -= 5;			/* - checksum and addr	*/
3480e6bc:	e2400005 	sub	r0, r0, #5
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
3480e6c0:	e3a0b003 	mov	fp, #3
		*count   -= 5;			/* - checksum and addr	*/
3480e6c4:	e5870000 	str	r0, [r7]
		break;
3480e6c8:	ea00000e 	b	3480e708 <srec_decode+0x114>
		*count    = 0;			/* no data		*/
3480e6cc:	e3a02000 	mov	r2, #0
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
3480e6d0:	e3a0b005 	mov	fp, #5
		*count    = 0;			/* no data		*/
3480e6d4:	e5872000 	str	r2, [r7]
		break;
3480e6d8:	ea00000a 	b	3480e708 <srec_decode+0x114>
		*count   -= 5;			/* - checksum and addr	*/
3480e6dc:	e2400005 	sub	r0, r0, #5
		srec_type = SREC_END4;		/* 4 byte addr field	*/
3480e6e0:	e3a0b007 	mov	fp, #7
		*count   -= 5;			/* - checksum and addr	*/
3480e6e4:	e5870000 	str	r0, [r7]
		break;
3480e6e8:	ea000006 	b	3480e708 <srec_decode+0x114>
		*count   -= 4;			/* - checksum and addr	*/
3480e6ec:	e2400004 	sub	r0, r0, #4
		srec_type = SREC_END3;		/* 3 byte addr field	*/
3480e6f0:	e3a0b008 	mov	fp, #8
		*count   -= 4;			/* - checksum and addr	*/
3480e6f4:	e5870000 	str	r0, [r7]
		break;
3480e6f8:	ea000002 	b	3480e708 <srec_decode+0x114>
		srec_type = SREC_END2;		/* 2 byte addr field	*/
3480e6fc:	e3a0b009 	mov	fp, #9
		*count   -= 3;			/* - checksum and addr	*/
3480e700:	e2400003 	sub	r0, r0, #3
3480e704:	e5870000 	str	r0, [r7]
3480e708:	e6ef3073 	uxtb	r3, r3
	*addr = 0;
3480e70c:	e3a02000 	mov	r2, #0
3480e710:	e5892000 	str	r2, [r9]
3480e714:	e3530009 	cmp	r3, #9
3480e718:	8a000048 	bhi	3480e840 <srec_decode+0x24c>
3480e71c:	e3a02001 	mov	r2, #1
3480e720:	e1a03312 	lsl	r3, r2, r3
3480e724:	e3002223 	movw	r2, #547	; 0x223
3480e728:	e0022003 	and	r2, r2, r3
3480e72c:	e3520000 	cmp	r2, #0
3480e730:	1a000015 	bne	3480e78c <srec_decode+0x198>
3480e734:	e3130f41 	tst	r3, #260	; 0x104
3480e738:	1a000009 	bne	3480e764 <srec_decode+0x170>
3480e73c:	e3130088 	tst	r3, #136	; 0x88
3480e740:	0a00003e 	beq	3480e840 <srec_decode+0x24c>
		if ((v = hex2_bin(input)) < 0) {
3480e744:	e1a00005 	mov	r0, r5
3480e748:	ebffff9b 	bl	3480e5bc <hex2_bin>
3480e74c:	e3500000 	cmp	r0, #0
3480e750:	baffffbb 	blt	3480e644 <srec_decode+0x50>
		chksum += v;
3480e754:	e0844000 	add	r4, r4, r0
		input  += 2;
3480e758:	e28a5005 	add	r5, sl, #5
		chksum += v;
3480e75c:	e6ef4074 	uxtb	r4, r4
		*addr  += v;
3480e760:	e5890000 	str	r0, [r9]
		if ((v = hex2_bin(input)) < 0) {
3480e764:	e1a00005 	mov	r0, r5
3480e768:	ebffff93 	bl	3480e5bc <hex2_bin>
3480e76c:	e3500000 	cmp	r0, #0
3480e770:	baffffb3 	blt	3480e644 <srec_decode+0x50>
		*addr <<= 8;
3480e774:	e5993000 	ldr	r3, [r9]
		chksum += v;
3480e778:	e0844000 	add	r4, r4, r0
3480e77c:	e6ef4074 	uxtb	r4, r4
		input  += 2;
3480e780:	e2855002 	add	r5, r5, #2
		*addr  += v;
3480e784:	e0803403 	add	r3, r0, r3, lsl #8
3480e788:	e5893000 	str	r3, [r9]
		if ((v = hex2_bin(input)) < 0) {
3480e78c:	e1a00005 	mov	r0, r5
3480e790:	ebffff89 	bl	3480e5bc <hex2_bin>
3480e794:	e3500000 	cmp	r0, #0
3480e798:	baffffa9 	blt	3480e644 <srec_decode+0x50>
		*addr <<= 8;
3480e79c:	e599a000 	ldr	sl, [r9]
		chksum += v;
3480e7a0:	e0844000 	add	r4, r4, r0
3480e7a4:	e6ef4074 	uxtb	r4, r4
		*addr  += v;
3480e7a8:	e080a40a 	add	sl, r0, sl, lsl #8
		if ((v = hex2_bin(input)) < 0) {
3480e7ac:	e2850002 	add	r0, r5, #2
		*addr  += v;
3480e7b0:	e589a000 	str	sl, [r9]
		if ((v = hex2_bin(input)) < 0) {
3480e7b4:	ebffff80 	bl	3480e5bc <hex2_bin>
3480e7b8:	e3500000 	cmp	r0, #0
3480e7bc:	baffffa0 	blt	3480e644 <srec_decode+0x50>
		*addr  += v;
3480e7c0:	e080a40a 	add	sl, r0, sl, lsl #8
		chksum += v;
3480e7c4:	e0844000 	add	r4, r4, r0
3480e7c8:	e6ef4074 	uxtb	r4, r4
		input  += 2;
3480e7cc:	e2855004 	add	r5, r5, #4
		*addr  += v;
3480e7d0:	e589a000 	str	sl, [r9]
	for (i=0; i < *count; ++i) {
3480e7d4:	e1a09006 	mov	r9, r6
3480e7d8:	e5972000 	ldr	r2, [r7]
3480e7dc:	e0663009 	rsb	r3, r6, r9
		if ((v = hex2_bin(input)) < 0) {
3480e7e0:	e1a00005 	mov	r0, r5
	for (i=0; i < *count; ++i) {
3480e7e4:	e1530002 	cmp	r3, r2
3480e7e8:	aa000008 	bge	3480e810 <srec_decode+0x21c>
		if ((v = hex2_bin(input)) < 0) {
3480e7ec:	ebffff72 	bl	3480e5bc <hex2_bin>
3480e7f0:	e3500000 	cmp	r0, #0
3480e7f4:	baffff92 	blt	3480e644 <srec_decode+0x50>
		data[i] = v;
3480e7f8:	e6ef0070 	uxtb	r0, r0
		input  += 2;
3480e7fc:	e2855002 	add	r5, r5, #2
		chksum += v;
3480e800:	e0804004 	add	r4, r0, r4
		data[i] = v;
3480e804:	e4c90001 	strb	r0, [r9], #1
		chksum += v;
3480e808:	e6ef4074 	uxtb	r4, r4
3480e80c:	eafffff1 	b	3480e7d8 <srec_decode+0x1e4>
	if ((v = hex2_bin(input)) < 0) {
3480e810:	ebffff69 	bl	3480e5bc <hex2_bin>
3480e814:	e3500000 	cmp	r0, #0
3480e818:	baffff89 	blt	3480e644 <srec_decode+0x50>
	if ((unsigned char)v != (unsigned char)~chksum) {
3480e81c:	e1e04004 	mvn	r4, r4
3480e820:	e6ef0070 	uxtb	r0, r0
3480e824:	e6ef4074 	uxtb	r4, r4
	return (srec_type);
3480e828:	e1500004 	cmp	r0, r4
3480e82c:	01a0000b 	moveq	r0, fp
3480e830:	13e00002 	mvnne	r0, #2
3480e834:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		return (SREC_EMPTY);
3480e838:	e3a0000a 	mov	r0, #10
3480e83c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		return (SREC_E_BADTYPE);
3480e840:	e3e00000 	mvn	r0, #0
}
3480e844:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480e848 <get_current>:

static struct serial_device *get_current(void)
{
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480e848:	e5983004 	ldr	r3, [r8, #4]
{
3480e84c:	e92d4010 	push	{r4, lr}
	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480e850:	e3130001 	tst	r3, #1
3480e854:	0a000003 	beq	3480e868 <get_current+0x20>
3480e858:	e59f301c 	ldr	r3, [pc, #28]	; 3480e87c <get_current+0x34>
3480e85c:	e5930000 	ldr	r0, [r3]
3480e860:	e3500000 	cmp	r0, #0
3480e864:	18bd8010 	popne	{r4, pc}
		dev = default_serial_console();
3480e868:	eb00259c 	bl	34817ee0 <default_serial_console>

		/* We must have a console device */
		if (!dev)
3480e86c:	e3500000 	cmp	r0, #0
3480e870:	18bd8010 	popne	{r4, pc}
			panic("Cannot find console");
3480e874:	e59f0004 	ldr	r0, [pc, #4]	; 3480e880 <get_current+0x38>
3480e878:	eb00386c 	bl	3481ca30 <panic>
3480e87c:	3482a258 	.word	0x3482a258
3480e880:	3482567d 	.word	0x3482567d

3480e884 <serial_register>:
	dev->next = serial_devices;
3480e884:	e59f300c 	ldr	r3, [pc, #12]	; 3480e898 <serial_register+0x14>
3480e888:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
3480e88c:	e5830004 	str	r0, [r3, #4]
	dev->next = serial_devices;
3480e890:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
3480e894:	e12fff1e 	bx	lr
3480e898:	3482a258 	.word	0x3482a258

3480e89c <serial_stdio_init>:
	struct serial_device *s = serial_devices;
3480e89c:	e59f307c 	ldr	r3, [pc, #124]	; 3480e920 <serial_stdio_init+0x84>
{
3480e8a0:	e92d4010 	push	{r4, lr}
3480e8a4:	e24dd040 	sub	sp, sp, #64	; 0x40
	struct serial_device *s = serial_devices;
3480e8a8:	e5934004 	ldr	r4, [r3, #4]
	while (s) {
3480e8ac:	e3540000 	cmp	r4, #0
3480e8b0:	0a000018 	beq	3480e918 <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
3480e8b4:	e3a0203c 	mov	r2, #60	; 0x3c
3480e8b8:	e3a01000 	mov	r1, #0
3480e8bc:	e28d0004 	add	r0, sp, #4
3480e8c0:	eb0034ad 	bl	3481bb7c <memset>
		strcpy(dev.name, s->name);
3480e8c4:	e1a01004 	mov	r1, r4
3480e8c8:	e28d000c 	add	r0, sp, #12
3480e8cc:	eb0033a3 	bl	3481b760 <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e8d0:	e3a03003 	mov	r3, #3
		stdio_register(&dev);
3480e8d4:	e28d0004 	add	r0, sp, #4
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e8d8:	e58d3004 	str	r3, [sp, #4]
		dev.start = s->init;
3480e8dc:	e5943010 	ldr	r3, [r4, #16]
3480e8e0:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->uninit;
3480e8e4:	e5943014 	ldr	r3, [r4, #20]
3480e8e8:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
3480e8ec:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3480e8f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
3480e8f4:	e5943028 	ldr	r3, [r4, #40]	; 0x28
3480e8f8:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
3480e8fc:	e594301c 	ldr	r3, [r4, #28]
3480e900:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
3480e904:	e5943020 	ldr	r3, [r4, #32]
3480e908:	e58d302c 	str	r3, [sp, #44]	; 0x2c
		stdio_register(&dev);
3480e90c:	eb000080 	bl	3480eb14 <stdio_register>
		s = s->next;
3480e910:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e914:	eaffffe4 	b	3480e8ac <serial_stdio_init+0x10>
}
3480e918:	e28dd040 	add	sp, sp, #64	; 0x40
3480e91c:	e8bd8010 	pop	{r4, pc}
3480e920:	3482a258 	.word	0x3482a258

3480e924 <serial_assign>:
	for (s = serial_devices; s; s = s->next) {
3480e924:	e59f3040 	ldr	r3, [pc, #64]	; 3480e96c <serial_assign+0x48>
{
3480e928:	e92d4070 	push	{r4, r5, r6, lr}
3480e92c:	e1a06000 	mov	r6, r0
3480e930:	e1a05003 	mov	r5, r3
	for (s = serial_devices; s; s = s->next) {
3480e934:	e5934004 	ldr	r4, [r3, #4]
3480e938:	e3540000 	cmp	r4, #0
3480e93c:	0a000008 	beq	3480e964 <serial_assign+0x40>
		if (strcmp(s->name, name) == 0) {
3480e940:	e1a01006 	mov	r1, r6
3480e944:	e1a00004 	mov	r0, r4
3480e948:	eb0033b4 	bl	3481b820 <strcmp>
3480e94c:	e3500000 	cmp	r0, #0
3480e950:	1a000001 	bne	3480e95c <serial_assign+0x38>
			serial_current = s;
3480e954:	e5854000 	str	r4, [r5]
			return 0;
3480e958:	e8bd8070 	pop	{r4, r5, r6, pc}
	for (s = serial_devices; s; s = s->next) {
3480e95c:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e960:	eafffff4 	b	3480e938 <serial_assign+0x14>
	return 1;
3480e964:	e3a00001 	mov	r0, #1
}
3480e968:	e8bd8070 	pop	{r4, r5, r6, pc}
3480e96c:	3482a258 	.word	0x3482a258

3480e970 <serial_initialize>:
{
3480e970:	e92d4010 	push	{r4, lr}
	serial_register(&s5p_serial0_device);
3480e974:	e59f0024 	ldr	r0, [pc, #36]	; 3480e9a0 <serial_initialize+0x30>
3480e978:	ebffffc1 	bl	3480e884 <serial_register>
	serial_register(&s5p_serial1_device);
3480e97c:	e59f0020 	ldr	r0, [pc, #32]	; 3480e9a4 <serial_initialize+0x34>
3480e980:	ebffffbf 	bl	3480e884 <serial_register>
	serial_register(&s5p_serial2_device);
3480e984:	e59f001c 	ldr	r0, [pc, #28]	; 3480e9a8 <serial_initialize+0x38>
3480e988:	ebffffbd 	bl	3480e884 <serial_register>
	serial_register(&s5p_serial3_device);
3480e98c:	e59f0018 	ldr	r0, [pc, #24]	; 3480e9ac <serial_initialize+0x3c>
3480e990:	ebffffbb 	bl	3480e884 <serial_register>
	serial_assign(default_serial_console()->name);
3480e994:	eb002551 	bl	34817ee0 <default_serial_console>
}
3480e998:	e8bd4010 	pop	{r4, lr}
	serial_assign(default_serial_console()->name);
3480e99c:	eaffffe0 	b	3480e924 <serial_assign>
3480e9a0:	34827f24 	.word	0x34827f24
3480e9a4:	34827fb4 	.word	0x34827fb4
3480e9a8:	34827f84 	.word	0x34827f84
3480e9ac:	34827f54 	.word	0x34827f54

3480e9b0 <serial_reinit_all>:
	for (s = serial_devices; s; s = s->next)
3480e9b0:	e59f3020 	ldr	r3, [pc, #32]	; 3480e9d8 <serial_reinit_all+0x28>
{
3480e9b4:	e92d4010 	push	{r4, lr}
	for (s = serial_devices; s; s = s->next)
3480e9b8:	e5934004 	ldr	r4, [r3, #4]
3480e9bc:	e3540000 	cmp	r4, #0
3480e9c0:	0a000003 	beq	3480e9d4 <serial_reinit_all+0x24>
		s->init();
3480e9c4:	e5943010 	ldr	r3, [r4, #16]
3480e9c8:	e12fff33 	blx	r3
	for (s = serial_devices; s; s = s->next)
3480e9cc:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e9d0:	eafffff9 	b	3480e9bc <serial_reinit_all+0xc>
}
3480e9d4:	e8bd8010 	pop	{r4, pc}
3480e9d8:	3482a258 	.word	0x3482a258

3480e9dc <serial_init>:
		dev = serial_current;
	return dev;
}

int serial_init(void)
{
3480e9dc:	e92d4010 	push	{r4, lr}
	return get_current()->init();
3480e9e0:	ebffff98 	bl	3480e848 <get_current>
}
3480e9e4:	e8bd4010 	pop	{r4, lr}
	return get_current()->init();
3480e9e8:	e5903010 	ldr	r3, [r0, #16]
3480e9ec:	e12fff13 	bx	r3

3480e9f0 <serial_setbrg>:

void serial_setbrg(void)
{
3480e9f0:	e92d4010 	push	{r4, lr}
	get_current()->setbrg();
3480e9f4:	ebffff93 	bl	3480e848 <get_current>
}
3480e9f8:	e8bd4010 	pop	{r4, lr}
	get_current()->setbrg();
3480e9fc:	e5903018 	ldr	r3, [r0, #24]
3480ea00:	e12fff13 	bx	r3

3480ea04 <serial_getc>:

int serial_getc(void)
{
3480ea04:	e92d4010 	push	{r4, lr}
	return get_current()->getc();
3480ea08:	ebffff8e 	bl	3480e848 <get_current>
}
3480ea0c:	e8bd4010 	pop	{r4, lr}
	return get_current()->getc();
3480ea10:	e590301c 	ldr	r3, [r0, #28]
3480ea14:	e12fff13 	bx	r3

3480ea18 <serial_tstc>:

int serial_tstc(void)
{
3480ea18:	e92d4010 	push	{r4, lr}
	return get_current()->tstc();
3480ea1c:	ebffff89 	bl	3480e848 <get_current>
}
3480ea20:	e8bd4010 	pop	{r4, lr}
	return get_current()->tstc();
3480ea24:	e5903020 	ldr	r3, [r0, #32]
3480ea28:	e12fff13 	bx	r3

3480ea2c <serial_putc>:

void serial_putc(const char c)
{
3480ea2c:	e92d4010 	push	{r4, lr}
3480ea30:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
3480ea34:	ebffff83 	bl	3480e848 <get_current>
3480ea38:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3480ea3c:	e1a00004 	mov	r0, r4
}
3480ea40:	e8bd4010 	pop	{r4, lr}
	get_current()->putc(c);
3480ea44:	e12fff13 	bx	r3

3480ea48 <serial_puts>:

void serial_puts(const char *s)
{
3480ea48:	e92d4010 	push	{r4, lr}
3480ea4c:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
3480ea50:	ebffff7c 	bl	3480e848 <get_current>
3480ea54:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3480ea58:	e1a00004 	mov	r0, r4
}
3480ea5c:	e8bd4010 	pop	{r4, lr}
	get_current()->puts(s);
3480ea60:	e12fff13 	bx	r3

3480ea64 <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
3480ea64:	e59f0000 	ldr	r0, [pc]	; 3480ea6c <stdio_get_list+0x8>
3480ea68:	e12fff1e 	bx	lr
3480ea6c:	3482a294 	.word	0x3482a294

3480ea70 <stdio_get_by_name>:
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480ea70:	e3500000 	cmp	r0, #0
3480ea74:	0a000011 	beq	3480eac0 <stdio_get_by_name+0x50>
{
3480ea78:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480ea7c:	e1a07000 	mov	r7, r0
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480ea80:	e59f6040 	ldr	r6, [pc, #64]	; 3480eac8 <stdio_get_by_name+0x58>
3480ea84:	e5b64034 	ldr	r4, [r6, #52]!	; 0x34
3480ea88:	e1540006 	cmp	r4, r6
3480ea8c:	1a000001 	bne	3480ea98 <stdio_get_by_name+0x28>
		return NULL;
3480ea90:	e3a00000 	mov	r0, #0
3480ea94:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
3480ea98:	e1a01007 	mov	r1, r7
3480ea9c:	e244002c 	sub	r0, r4, #44	; 0x2c
3480eaa0:	eb00335e 	bl	3481b820 <strcmp>
3480eaa4:	e3500000 	cmp	r0, #0
3480eaa8:	e2445034 	sub	r5, r4, #52	; 0x34
3480eaac:	1a000001 	bne	3480eab8 <stdio_get_by_name+0x48>
			return dev;
3480eab0:	e1a00005 	mov	r0, r5
3480eab4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	list_for_each(pos, &(devs.list)) {
3480eab8:	e5944000 	ldr	r4, [r4]
3480eabc:	eafffff1 	b	3480ea88 <stdio_get_by_name+0x18>
		return NULL;
3480eac0:	e3a00000 	mov	r0, #0
	}

	return NULL;
}
3480eac4:	e12fff1e 	bx	lr
3480eac8:	3482a260 	.word	0x3482a260

3480eacc <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
3480eacc:	e3500000 	cmp	r0, #0
3480ead0:	012fff1e 	bxeq	lr
{
3480ead4:	e92d4070 	push	{r4, r5, r6, lr}
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
3480ead8:	e3a0103c 	mov	r1, #60	; 0x3c
3480eadc:	e1a05000 	mov	r5, r0
3480eae0:	e3a00001 	mov	r0, #1
3480eae4:	ebffee71 	bl	3480a4b0 <calloc>

	if(!_dev)
3480eae8:	e2504000 	subs	r4, r0, #0
3480eaec:	0a000006 	beq	3480eb0c <stdio_clone+0x40>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
3480eaf0:	e3a0203c 	mov	r2, #60	; 0x3c
3480eaf4:	e1a01005 	mov	r1, r5
3480eaf8:	eb00343f 	bl	3481bbfc <memcpy>
	strncpy(_dev->name, dev->name, 16);
3480eafc:	e3a02010 	mov	r2, #16
3480eb00:	e2851008 	add	r1, r5, #8
3480eb04:	e2840008 	add	r0, r4, #8
3480eb08:	eb00331a 	bl	3481b778 <strncpy>
		return NULL;
3480eb0c:	e1a00004 	mov	r0, r4

	return _dev;
}
3480eb10:	e8bd8070 	pop	{r4, r5, r6, pc}

3480eb14 <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
3480eb14:	e92d4010 	push	{r4, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
3480eb18:	ebffffeb 	bl	3480eacc <stdio_clone>
	if(!_dev)
3480eb1c:	e3500000 	cmp	r0, #0
	__list_add(new, head->prev, head);
3480eb20:	159f3024 	ldrne	r3, [pc, #36]	; 3480eb4c <stdio_register+0x38>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
3480eb24:	12801034 	addne	r1, r0, #52	; 0x34
3480eb28:	15932038 	ldrne	r2, [r3, #56]	; 0x38
	next->prev = new;
3480eb2c:	15831038 	strne	r1, [r3, #56]	; 0x38
	new->next = next;
3480eb30:	12833034 	addne	r3, r3, #52	; 0x34
3480eb34:	15803034 	strne	r3, [r0, #52]	; 0x34
	new->prev = prev;
3480eb38:	15802038 	strne	r2, [r0, #56]	; 0x38
	return 0;
3480eb3c:	13a00000 	movne	r0, #0
	prev->next = new;
3480eb40:	15821000 	strne	r1, [r2]
		return -1;
3480eb44:	03e00000 	mvneq	r0, #0
}
3480eb48:	e8bd8010 	pop	{r4, pc}
3480eb4c:	3482a260 	.word	0x3482a260

3480eb50 <stdio_init>:
	list->next = list;
3480eb50:	e59f3078 	ldr	r3, [pc, #120]	; 3480ebd0 <stdio_init+0x80>

#ifdef CONFIG_ARM_DCC_MULTI
	drv_arm_dcc_init ();
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480eb54:	e3a010fe 	mov	r1, #254	; 0xfe
{
3480eb58:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480eb5c:	e30c0350 	movw	r0, #50000	; 0xc350
{
3480eb60:	e24dd044 	sub	sp, sp, #68	; 0x44
3480eb64:	e2832034 	add	r2, r3, #52	; 0x34
3480eb68:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
3480eb6c:	e5832038 	str	r2, [r3, #56]	; 0x38
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480eb70:	eb00065e 	bl	348104f0 <i2c_init>
	memset (&dev, 0, sizeof (dev));
3480eb74:	e3a0203c 	mov	r2, #60	; 0x3c
3480eb78:	e3a01000 	mov	r1, #0
3480eb7c:	e28d0004 	add	r0, sp, #4
3480eb80:	eb0033fd 	bl	3481bb7c <memset>
	strcpy (dev.name, "serial");
3480eb84:	e59f1048 	ldr	r1, [pc, #72]	; 3480ebd4 <stdio_init+0x84>
3480eb88:	e28d000c 	add	r0, sp, #12
3480eb8c:	eb0032f3 	bl	3481b760 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480eb90:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
	stdio_register (&dev);
3480eb94:	e28d0004 	add	r0, sp, #4
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480eb98:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
3480eb9c:	e59f3034 	ldr	r3, [pc, #52]	; 3480ebd8 <stdio_init+0x88>
3480eba0:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
3480eba4:	e59f3030 	ldr	r3, [pc, #48]	; 3480ebdc <stdio_init+0x8c>
3480eba8:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
3480ebac:	e59f302c 	ldr	r3, [pc, #44]	; 3480ebe0 <stdio_init+0x90>
3480ebb0:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
3480ebb4:	e59f3028 	ldr	r3, [pc, #40]	; 3480ebe4 <stdio_init+0x94>
3480ebb8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
3480ebbc:	ebffffd4 	bl	3480eb14 <stdio_register>
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
#ifdef CONFIG_SERIAL_MULTI
	serial_stdio_init ();
3480ebc0:	ebffff35 	bl	3480e89c <serial_stdio_init>
#ifdef CONFIG_JTAG_CONSOLE
	drv_jtag_console_init ();
#endif

	return (0);
}
3480ebc4:	e3a00000 	mov	r0, #0
3480ebc8:	e28dd044 	add	sp, sp, #68	; 0x44
3480ebcc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
3480ebd0:	3482a260 	.word	0x3482a260
3480ebd4:	34824de2 	.word	0x34824de2
3480ebd8:	3480ea2c 	.word	0x3480ea2c
3480ebdc:	3480ea48 	.word	0x3480ea48
3480ebe0:	3480ea04 	.word	0x3480ea04
3480ebe4:	3480ea18 	.word	0x3480ea18

3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
3480ebe8:	e92d4070 	push	{r4, r5, r6, lr}
3480ebec:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480ebf0:	e59f6048 	ldr	r6, [pc, #72]	; 3480ec40 <CYGACC_COMM_IF_GETC_TIMEOUT+0x58>
  unsigned long counter = 0;
3480ebf4:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480ebf8:	ebffeac3 	bl	3480970c <tstc>
3480ebfc:	e16f0f10 	clz	r0, r0
3480ec00:	e1540006 	cmp	r4, r6
3480ec04:	e1a002a0 	lsr	r0, r0, #5
3480ec08:	03a00000 	moveq	r0, #0
3480ec0c:	e3500000 	cmp	r0, #0
3480ec10:	0a000003 	beq	3480ec24 <CYGACC_COMM_IF_GETC_TIMEOUT+0x3c>
    {
      udelay (DELAY);
3480ec14:	e3a00014 	mov	r0, #20
      counter++;
3480ec18:	e2844001 	add	r4, r4, #1
      udelay (DELAY);
3480ec1c:	eb00347a 	bl	3481be0c <udelay>
3480ec20:	eafffff4 	b	3480ebf8 <CYGACC_COMM_IF_GETC_TIMEOUT+0x10>
    }
  if (tstc ())
3480ec24:	ebffeab8 	bl	3480970c <tstc>
3480ec28:	e3500000 	cmp	r0, #0
3480ec2c:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
3480ec30:	ebffeaa9 	bl	348096dc <getc>
3480ec34:	e5c50000 	strb	r0, [r5]
      return 1;
3480ec38:	e3a00001 	mov	r0, #1
    }
  return 0;
}
3480ec3c:	e8bd8070 	pop	{r4, r5, r6, pc}
3480ec40:	000186a0 	.word	0x000186a0

3480ec44 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
3480ec44:	e92d4013 	push	{r0, r1, r4, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480ec48:	e59f401c 	ldr	r4, [pc, #28]	; 3480ec6c <xyzModem_flush+0x28>
3480ec4c:	e28d1007 	add	r1, sp, #7
3480ec50:	e5943000 	ldr	r3, [r4]
3480ec54:	e5d30000 	ldrb	r0, [r3]
3480ec58:	ebffffe2 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480ec5c:	e3500000 	cmp	r0, #0
3480ec60:	1afffff9 	bne	3480ec4c <xyzModem_flush+0x8>
	return;
    }
}
3480ec64:	e28dd008 	add	sp, sp, #8
3480ec68:	e8bd8010 	pop	{r4, pc}
3480ec6c:	3482a2a8 	.word	0x3482a2a8

3480ec70 <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
3480ec70:	e92d42f3 	push	{r0, r1, r4, r5, r6, r7, r9, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
3480ec74:	e59f423c 	ldr	r4, [pc, #572]	; 3480eeb8 <xyzModem_get_hdr+0x248>
3480ec78:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
3480ec7c:	e3530000 	cmp	r3, #0
3480ec80:	0a000003 	beq	3480ec94 <xyzModem_get_hdr+0x24>
  putc (y);
3480ec84:	e3a00006 	mov	r0, #6
3480ec88:	ebffeaab 	bl	3480973c <putc>
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
3480ec8c:	e3a03000 	mov	r3, #0
3480ec90:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480ec94:	e59f921c 	ldr	r9, [pc, #540]	; 3480eeb8 <xyzModem_get_hdr+0x248>
{
3480ec98:	e3a06000 	mov	r6, #0
3480ec9c:	e1a07006 	mov	r7, r6
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480eca0:	e5943000 	ldr	r3, [r4]
3480eca4:	e28d1007 	add	r1, sp, #7
3480eca8:	e59f5208 	ldr	r5, [pc, #520]	; 3480eeb8 <xyzModem_get_hdr+0x248>
3480ecac:	e5d30000 	ldrb	r0, [r3]
3480ecb0:	ebffffcc 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480ecb4:	e3500000 	cmp	r0, #0
3480ecb8:	0a00001c 	beq	3480ed30 <xyzModem_get_hdr+0xc0>
	{
	  hdr_chars++;
	  switch (c)
3480ecbc:	e5dd3007 	ldrb	r3, [sp, #7]
	  hdr_chars++;
3480ecc0:	e2866001 	add	r6, r6, #1
	  switch (c)
3480ecc4:	e3530002 	cmp	r3, #2
3480ecc8:	0a00001c 	beq	3480ed40 <xyzModem_get_hdr+0xd0>
3480eccc:	8a000005 	bhi	3480ece8 <xyzModem_get_hdr+0x78>
3480ecd0:	e3530001 	cmp	r3, #1
3480ecd4:	1afffff1 	bne	3480eca0 <xyzModem_get_hdr+0x30>
	    {
	    case SOH:
	      xyz.total_SOH++;
3480ecd8:	e595341c 	ldr	r3, [r5, #1052]	; 0x41c
3480ecdc:	e2833001 	add	r3, r3, #1
3480ece0:	e585341c 	str	r3, [r5, #1052]	; 0x41c
3480ece4:	ea000018 	b	3480ed4c <xyzModem_get_hdr+0xdc>
	  switch (c)
3480ece8:	e3530004 	cmp	r3, #4
3480ecec:	0a000009 	beq	3480ed18 <xyzModem_get_hdr+0xa8>
3480ecf0:	e3530018 	cmp	r3, #24
3480ecf4:	1affffe9 	bne	3480eca0 <xyzModem_get_hdr+0x30>
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480ecf8:	e5993424 	ldr	r3, [r9, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480ecfc:	e2877001 	add	r7, r7, #1
3480ed00:	e3570003 	cmp	r7, #3
	      xyz.total_CAN++;
3480ed04:	e2833001 	add	r3, r3, #1
3480ed08:	e5893424 	str	r3, [r9, #1060]	; 0x424
	      if (++can_total == xyzModem_CAN_COUNT)
3480ed0c:	1affffe3 	bne	3480eca0 <xyzModem_get_hdr+0x30>
		{
		  return xyzModem_cancel;
3480ed10:	e3e00004 	mvn	r0, #4
3480ed14:	ea000065 	b	3480eeb0 <xyzModem_get_hdr+0x240>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
3480ed18:	e3560001 	cmp	r6, #1
3480ed1c:	1affffdf 	bne	3480eca0 <xyzModem_get_hdr+0x30>
  putc (y);
3480ed20:	e3a00006 	mov	r0, #6
3480ed24:	ebffea84 	bl	3480973c <putc>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
3480ed28:	e3e00003 	mvn	r0, #3
3480ed2c:	ea00005f 	b	3480eeb0 <xyzModem_get_hdr+0x240>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
3480ed30:	ebffffc3 	bl	3480ec44 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480ed34:	e59f0180 	ldr	r0, [pc, #384]	; 3480eebc <xyzModem_get_hdr+0x24c>
3480ed38:	eb003433 	bl	3481be0c <udelay>
3480ed3c:	ea000021 	b	3480edc8 <xyzModem_get_hdr+0x158>
		xyz.total_STX++;
3480ed40:	e5953420 	ldr	r3, [r5, #1056]	; 0x420
3480ed44:	e2833001 	add	r3, r3, #1
3480ed48:	e5853420 	str	r3, [r5, #1056]	; 0x420
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
3480ed4c:	e5943000 	ldr	r3, [r4]
3480ed50:	e59f1168 	ldr	r1, [pc, #360]	; 3480eec0 <xyzModem_get_hdr+0x250>
3480ed54:	e59f515c 	ldr	r5, [pc, #348]	; 3480eeb8 <xyzModem_get_hdr+0x248>
3480ed58:	e5d30000 	ldrb	r0, [r3]
3480ed5c:	ebffffa1 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
3480ed60:	e3500000 	cmp	r0, #0
3480ed64:	0a000017 	beq	3480edc8 <xyzModem_get_hdr+0x158>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
3480ed68:	e5953000 	ldr	r3, [r5]
3480ed6c:	e59f1150 	ldr	r1, [pc, #336]	; 3480eec4 <xyzModem_get_hdr+0x254>
3480ed70:	e5d30000 	ldrb	r0, [r3]
3480ed74:	ebffff9b 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
3480ed78:	e3500000 	cmp	r0, #0
3480ed7c:	0a000011 	beq	3480edc8 <xyzModem_get_hdr+0x158>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480ed80:	e5dd3007 	ldrb	r3, [sp, #7]
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480ed84:	e3a06000 	mov	r6, #0
  xyz.len = (c == SOH) ? 128 : 1024;
3480ed88:	e3530001 	cmp	r3, #1
3480ed8c:	03a03080 	moveq	r3, #128	; 0x80
3480ed90:	13a03b01 	movne	r3, #1024	; 0x400
3480ed94:	e5843410 	str	r3, [r4, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
3480ed98:	e2853004 	add	r3, r5, #4
3480ed9c:	e5843404 	str	r3, [r4, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
3480eda0:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480eda4:	e59f710c 	ldr	r7, [pc, #268]	; 3480eeb8 <xyzModem_get_hdr+0x248>
3480eda8:	e1560003 	cmp	r6, r3
3480edac:	ba000007 	blt	3480edd0 <xyzModem_get_hdr+0x160>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
3480edb0:	e5973000 	ldr	r3, [r7]
3480edb4:	e59f110c 	ldr	r1, [pc, #268]	; 3480eec8 <xyzModem_get_hdr+0x258>
3480edb8:	e5d30000 	ldrb	r0, [r3]
3480edbc:	ebffff89 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
3480edc0:	e3500000 	cmp	r0, #0
3480edc4:	1a00000c 	bne	3480edfc <xyzModem_get_hdr+0x18c>
      return xyzModem_timeout;
3480edc8:	e3e00002 	mvn	r0, #2
3480edcc:	ea000037 	b	3480eeb0 <xyzModem_get_hdr+0x240>
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480edd0:	e5953000 	ldr	r3, [r5]
3480edd4:	e28d1007 	add	r1, sp, #7
3480edd8:	e5d30000 	ldrb	r0, [r3]
3480eddc:	ebffff81 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (res)
3480ede0:	e3500000 	cmp	r0, #0
3480ede4:	0afffff7 	beq	3480edc8 <xyzModem_get_hdr+0x158>
	  xyz.pkt[i] = c;
3480ede8:	e5dd2007 	ldrb	r2, [sp, #7]
3480edec:	e0853006 	add	r3, r5, r6
  for (i = 0; i < xyz.len; i++)
3480edf0:	e2866001 	add	r6, r6, #1
	  xyz.pkt[i] = c;
3480edf4:	e5c32004 	strb	r2, [r3, #4]
3480edf8:	eaffffe8 	b	3480eda0 <xyzModem_get_hdr+0x130>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
3480edfc:	e5973428 	ldr	r3, [r7, #1064]	; 0x428
3480ee00:	e3530000 	cmp	r3, #0
3480ee04:	1a000008 	bne	3480ee2c <xyzModem_get_hdr+0x1bc>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
3480ee08:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
3480ee0c:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480ee10:	e59f50a0 	ldr	r5, [pc, #160]	; 3480eeb8 <xyzModem_get_hdr+0x248>
3480ee14:	e0233002 	eor	r3, r3, r2
3480ee18:	e35300ff 	cmp	r3, #255	; 0xff
3480ee1c:	0a000009 	beq	3480ee48 <xyzModem_get_hdr+0x1d8>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
3480ee20:	ebffff87 	bl	3480ec44 <xyzModem_flush>
      return xyzModem_frame;
3480ee24:	e3e00005 	mvn	r0, #5
3480ee28:	ea000020 	b	3480eeb0 <xyzModem_get_hdr+0x240>
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
3480ee2c:	e5973000 	ldr	r3, [r7]
3480ee30:	e59f1094 	ldr	r1, [pc, #148]	; 3480eecc <xyzModem_get_hdr+0x25c>
3480ee34:	e5d30000 	ldrb	r0, [r3]
3480ee38:	ebffff6a 	bl	3480ebe8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480ee3c:	e3500000 	cmp	r0, #0
3480ee40:	1afffff0 	bne	3480ee08 <xyzModem_get_hdr+0x198>
3480ee44:	eaffffdf 	b	3480edc8 <xyzModem_get_hdr+0x158>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480ee48:	e5953428 	ldr	r3, [r5, #1064]	; 0x428
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480ee4c:	e5951410 	ldr	r1, [r5, #1040]	; 0x410
  if (xyz.crc_mode)
3480ee50:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480ee54:	01a02003 	moveq	r2, r3
  if (xyz.crc_mode)
3480ee58:	0a000008 	beq	3480ee80 <xyzModem_get_hdr+0x210>
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480ee5c:	e2850004 	add	r0, r5, #4
3480ee60:	eb002bb9 	bl	34819d4c <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
3480ee64:	e5d5240a 	ldrb	r2, [r5, #1034]	; 0x40a
3480ee68:	e5d5340b 	ldrb	r3, [r5, #1035]	; 0x40b
3480ee6c:	e1833402 	orr	r3, r3, r2, lsl #8
3480ee70:	e1500003 	cmp	r0, r3
	  return xyzModem_cksum;
3480ee74:	13e00006 	mvnne	r0, #6
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480ee78:	03a00000 	moveq	r0, #0
3480ee7c:	ea00000b 	b	3480eeb0 <xyzModem_get_hdr+0x240>
      for (i = 0; i < xyz.len; i++)
3480ee80:	e1520001 	cmp	r2, r1
3480ee84:	aa000005 	bge	3480eea0 <xyzModem_get_hdr+0x230>
3480ee88:	e0840002 	add	r0, r4, r2
3480ee8c:	e2822001 	add	r2, r2, #1
	  cksum += xyz.pkt[i];
3480ee90:	e5d00004 	ldrb	r0, [r0, #4]
3480ee94:	e0833000 	add	r3, r3, r0
3480ee98:	e6ff3073 	uxth	r3, r3
3480ee9c:	eafffff7 	b	3480ee80 <xyzModem_get_hdr+0x210>
      if (xyz.crc1 != (cksum & 0xFF))
3480eea0:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
3480eea4:	e6ef3073 	uxtb	r3, r3
3480eea8:	e1520003 	cmp	r2, r3
3480eeac:	eafffff0 	b	3480ee74 <xyzModem_get_hdr+0x204>
}
3480eeb0:	e28dd008 	add	sp, sp, #8
3480eeb4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480eeb8:	3482a2a8 	.word	0x3482a2a8
3480eebc:	0003d090 	.word	0x0003d090
3480eec0:	3482a6b0 	.word	0x3482a6b0
3480eec4:	3482a6b1 	.word	0x3482a6b1
3480eec8:	3482a6b2 	.word	0x3482a6b2
3480eecc:	3482a6b3 	.word	0x3482a6b3

3480eed0 <CYGACC_COMM_IF_PUTC>:
  putc (y);
3480eed0:	e1a00001 	mov	r0, r1
3480eed4:	eaffea18 	b	3480973c <putc>

3480eed8 <parse_num>:
{
3480eed8:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480eedc:	e1a0c000 	mov	ip, r0
3480eee0:	e2800001 	add	r0, r0, #1
  while (*s == ' ')
3480eee4:	e5dce000 	ldrb	lr, [ip]
3480eee8:	e35e0020 	cmp	lr, #32
3480eeec:	0afffffa 	beq	3480eedc <parse_num+0x4>
3480eef0:	e3a05000 	mov	r5, #0
3480eef4:	e3a0600a 	mov	r6, #10
3480eef8:	e3a00001 	mov	r0, #1
  while (*s)
3480eefc:	e5dce000 	ldrb	lr, [ip]
3480ef00:	e35e0000 	cmp	lr, #0
3480ef04:	0a000034 	beq	3480efdc <parse_num+0x104>
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480ef08:	e35e0030 	cmp	lr, #48	; 0x30
3480ef0c:	13a00000 	movne	r0, #0
3480ef10:	02000001 	andeq	r0, r0, #1
3480ef14:	e3500000 	cmp	r0, #0
3480ef18:	0a000007 	beq	3480ef3c <parse_num+0x64>
3480ef1c:	e5dc0001 	ldrb	r0, [ip, #1]
  if ((c >= 'A') && (c <= 'Z'))
3480ef20:	e240e041 	sub	lr, r0, #65	; 0x41
3480ef24:	e35e0019 	cmp	lr, #25
      c = (c - 'A') + 'a';
3480ef28:	92800020 	addls	r0, r0, #32
3480ef2c:	96ef0070 	uxtbls	r0, r0
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480ef30:	e3500078 	cmp	r0, #120	; 0x78
	  s += 2;
3480ef34:	028cc002 	addeq	ip, ip, #2
	  radix = 16;
3480ef38:	03a06010 	moveq	r6, #16
      c = *s++;
3480ef3c:	e5dce000 	ldrb	lr, [ip]
3480ef40:	e28c7001 	add	r7, ip, #1
  return (((c >= '0') && (c <= '9')) ||
3480ef44:	e24e9030 	sub	r9, lr, #48	; 0x30
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ef48:	e24ec041 	sub	ip, lr, #65	; 0x41
  return (((c >= '0') && (c <= '9')) ||
3480ef4c:	e6ef4079 	uxtb	r4, r9
3480ef50:	e3540009 	cmp	r4, #9
3480ef54:	83a04000 	movhi	r4, #0
3480ef58:	93a04001 	movls	r4, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ef5c:	e35c0005 	cmp	ip, #5
3480ef60:	83a00000 	movhi	r0, #0
3480ef64:	93a00001 	movls	r0, #1
3480ef68:	e190c004 	orrs	ip, r0, r4
3480ef6c:	1a000021 	bne	3480eff8 <parse_num+0x120>
3480ef70:	e24e0061 	sub	r0, lr, #97	; 0x61
3480ef74:	e3500005 	cmp	r0, #5
3480ef78:	8a00000e 	bhi	3480efb8 <parse_num+0xe0>
3480ef7c:	ea000002 	b	3480ef8c <parse_num+0xb4>
  else if ((c >= 'a') && (c <= 'f'))
3480ef80:	e24ec061 	sub	ip, lr, #97	; 0x61
3480ef84:	e35c0005 	cmp	ip, #5
3480ef88:	8a000001 	bhi	3480ef94 <parse_num+0xbc>
      ret = (c - 'a' + 0x0a);
3480ef8c:	e24e0057 	sub	r0, lr, #87	; 0x57
3480ef90:	ea000002 	b	3480efa0 <parse_num+0xc8>
  else if ((c >= 'A') && (c <= 'F'))
3480ef94:	e3500000 	cmp	r0, #0
3480ef98:	0a000002 	beq	3480efa8 <parse_num+0xd0>
      ret = (c - 'A' + 0x0A);
3480ef9c:	e24e0037 	sub	r0, lr, #55	; 0x37
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
3480efa0:	e1500006 	cmp	r0, r6
3480efa4:	aa000003 	bge	3480efb8 <parse_num+0xe0>
	  result = (result * radix) + digit;
3480efa8:	e0250695 	mla	r5, r5, r6, r0
      c = *s++;
3480efac:	e1a0c007 	mov	ip, r7
      first = false;
3480efb0:	e3a00000 	mov	r0, #0
	  result = (result * radix) + digit;
3480efb4:	eaffffd0 	b	3480eefc <parse_num+0x24>
	  if (delim != (char *) 0)
3480efb8:	e3530000 	cmp	r3, #0
3480efbc:	0a00000b 	beq	3480eff0 <parse_num+0x118>
3480efc0:	e2433001 	sub	r3, r3, #1
	      while (*dp && (c != *dp))
3480efc4:	e5f30001 	ldrb	r0, [r3, #1]!
3480efc8:	e3500000 	cmp	r0, #0
3480efcc:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
3480efd0:	e15e0000 	cmp	lr, r0
3480efd4:	1afffffa 	bne	3480efc4 <parse_num+0xec>
3480efd8:	e1a0c007 	mov	ip, r7
  if (es != (char **) 0)
3480efdc:	e3520000 	cmp	r2, #0
  *val = result;
3480efe0:	e5815000 	str	r5, [r1]
  return true;
3480efe4:	e3a00001 	mov	r0, #1
      *es = s;
3480efe8:	1582c000 	strne	ip, [r2]
3480efec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	  return false;		/* Malformatted number */
3480eff0:	e1a00003 	mov	r0, r3
3480eff4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
  if ((c >= '0') && (c <= '9'))
3480eff8:	e3540000 	cmp	r4, #0
3480effc:	0affffdf 	beq	3480ef80 <parse_num+0xa8>
      ret = (c - '0');
3480f000:	e1a00009 	mov	r0, r9
3480f004:	eaffffe7 	b	3480efa8 <parse_num+0xd0>

3480f008 <xyzModem_stream_open>:

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480f008:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
3480f00c:	e3a04000 	mov	r4, #0
  xyz.__chan = &dummy;
3480f010:	e59f5128 	ldr	r5, [pc, #296]	; 3480f140 <xyzModem_stream_open+0x138>
  int dummy = 0;
3480f014:	e28d3008 	add	r3, sp, #8
{
3480f018:	e1a09001 	mov	r9, r1
  int dummy = 0;
3480f01c:	e5234004 	str	r4, [r3, #-4]!
  xyz.__chan = &dummy;
3480f020:	e5853000 	str	r3, [r5]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
3480f024:	e3a03001 	mov	r3, #1
3480f028:	e5853428 	str	r3, [r5, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480f02c:	e5903004 	ldr	r3, [r0, #4]
  putc (y);
3480f030:	e3a00043 	mov	r0, #67	; 0x43
  xyz.len = 0;
3480f034:	e5854410 	str	r4, [r5, #1040]	; 0x410
  xyz.at_eof = false;
3480f038:	e585442c 	str	r4, [r5, #1068]	; 0x42c
  xyz.mode = info->mode;
3480f03c:	e5853414 	str	r3, [r5, #1044]	; 0x414
  xyz.tx_ack = false;
3480f040:	e5854430 	str	r4, [r5, #1072]	; 0x430
  xyz.total_retries = 0;
3480f044:	e5854418 	str	r4, [r5, #1048]	; 0x418
  xyz.total_SOH = 0;
3480f048:	e585441c 	str	r4, [r5, #1052]	; 0x41c
  xyz.total_STX = 0;
3480f04c:	e5854420 	str	r4, [r5, #1056]	; 0x420
  xyz.total_CAN = 0;
3480f050:	e5854424 	str	r4, [r5, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
3480f054:	e5854438 	str	r4, [r5, #1080]	; 0x438
  xyz.file_length = 0;
3480f058:	e5854434 	str	r4, [r5, #1076]	; 0x434
  putc (y);
3480f05c:	ebffe9b6 	bl	3480973c <putc>
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480f060:	e5953414 	ldr	r3, [r5, #1044]	; 0x414
3480f064:	e3530001 	cmp	r3, #1
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
3480f068:	05c5340c 	strbeq	r3, [r5, #1036]	; 0x40c
      return 0;
3480f06c:	01a00004 	moveq	r0, r4
  if (xyz.mode == xyzModem_xmodem)
3480f070:	0a000030 	beq	3480f138 <xyzModem_stream_open+0x130>
3480f074:	e1a06005 	mov	r6, r5
3480f078:	e3a0700a 	mov	r7, #10
3480f07c:	e3a05015 	mov	r5, #21
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480f080:	e1a0a004 	mov	sl, r4
  while (retries-- > 0)
3480f084:	e2555001 	subs	r5, r5, #1
3480f088:	0a000028 	beq	3480f130 <xyzModem_stream_open+0x128>
      stat = xyzModem_get_hdr ();
3480f08c:	ebfffef7 	bl	3480ec70 <xyzModem_get_hdr>
      if (stat == 0)
3480f090:	e2504000 	subs	r4, r0, #0
3480f094:	1a000013 	bne	3480f0e8 <xyzModem_stream_open+0xe0>
	  if (xyz.blk == 0)
3480f098:	e5d63408 	ldrb	r3, [r6, #1032]	; 0x408
3480f09c:	e3530000 	cmp	r3, #0
3480f0a0:	1a00000b 	bne	3480f0d4 <xyzModem_stream_open+0xcc>
	      while (*xyz.bufp++);
3480f0a4:	e5963404 	ldr	r3, [r6, #1028]	; 0x404
3480f0a8:	e2830001 	add	r0, r3, #1
3480f0ac:	e5860404 	str	r0, [r6, #1028]	; 0x404
3480f0b0:	e5d32000 	ldrb	r2, [r3]
3480f0b4:	e3520000 	cmp	r2, #0
3480f0b8:	1afffff9 	bne	3480f0a4 <xyzModem_stream_open+0x9c>
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
3480f0bc:	e59f3080 	ldr	r3, [pc, #128]	; 3480f144 <xyzModem_stream_open+0x13c>
3480f0c0:	e59f1080 	ldr	r1, [pc, #128]	; 3480f148 <xyzModem_stream_open+0x140>
3480f0c4:	ebffff83 	bl	3480eed8 <parse_num>
	      xyz.tx_ack = true;
3480f0c8:	e59f3070 	ldr	r3, [pc, #112]	; 3480f140 <xyzModem_stream_open+0x138>
3480f0cc:	e3a02001 	mov	r2, #1
3480f0d0:	e5832430 	str	r2, [r3, #1072]	; 0x430
	  xyz.next_blk = 1;
3480f0d4:	e3a03001 	mov	r3, #1
	  xyz.len = 0;
3480f0d8:	e3a00000 	mov	r0, #0
	  xyz.next_blk = 1;
3480f0dc:	e5c6340c 	strb	r3, [r6, #1036]	; 0x40c
	  xyz.len = 0;
3480f0e0:	e5860410 	str	r0, [r6, #1040]	; 0x410
	  return 0;
3480f0e4:	ea000013 	b	3480f138 <xyzModem_stream_open+0x130>
      else if (stat == xyzModem_timeout)
3480f0e8:	e3740003 	cmn	r4, #3
3480f0ec:	1a00000d 	bne	3480f128 <xyzModem_stream_open+0x120>
	  if (--crc_retries <= 0)
3480f0f0:	e2477001 	sub	r7, r7, #1
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f0f4:	e59f0050 	ldr	r0, [pc, #80]	; 3480f14c <xyzModem_stream_open+0x144>
	  if (--crc_retries <= 0)
3480f0f8:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
3480f0fc:	d586a428 	strle	sl, [r6, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f100:	eb003341 	bl	3481be0c <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f104:	e5963428 	ldr	r3, [r6, #1064]	; 0x428
3480f108:	e3530000 	cmp	r3, #0
  putc (y);
3480f10c:	13a00043 	movne	r0, #67	; 0x43
3480f110:	03a00015 	moveq	r0, #21
3480f114:	ebffe988 	bl	3480973c <putc>
	  xyz.total_retries++;
3480f118:	e5963418 	ldr	r3, [r6, #1048]	; 0x418
3480f11c:	e2833001 	add	r3, r3, #1
3480f120:	e5863418 	str	r3, [r6, #1048]	; 0x418
3480f124:	eaffffd6 	b	3480f084 <xyzModem_stream_open+0x7c>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
3480f128:	e3740005 	cmn	r4, #5
3480f12c:	1affffd4 	bne	3480f084 <xyzModem_stream_open+0x7c>
	  break;
	}
    }
  *err = stat;
  ZM_DEBUG (zm_flush ());
  return -1;
3480f130:	e3e00000 	mvn	r0, #0
  *err = stat;
3480f134:	e5894000 	str	r4, [r9]
}
3480f138:	e28dd00c 	add	sp, sp, #12
3480f13c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480f140:	3482a2a8 	.word	0x3482a2a8
3480f144:	34825157 	.word	0x34825157
3480f148:	3482a6dc 	.word	0x3482a6dc
3480f14c:	0007a120 	.word	0x0007a120

3480f150 <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480f150:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480f154:	e1a09000 	mov	r9, r0
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f158:	e59fb24c 	ldr	fp, [pc, #588]	; 3480f3ac <xyzModem_stream_read+0x25c>
{
3480f15c:	e1a06001 	mov	r6, r1
  total = 0;
3480f160:	e3a07000 	mov	r7, #0
  stat = xyzModem_cancel;
3480f164:	e3e05004 	mvn	r5, #4
{
3480f168:	e58d2004 	str	r2, [sp, #4]
3480f16c:	e1a0400b 	mov	r4, fp
  while (!xyz.at_eof && (size > 0))
3480f170:	e59b142c 	ldr	r1, [fp, #1068]	; 0x42c
3480f174:	e3560000 	cmp	r6, #0
3480f178:	d3a02000 	movle	r2, #0
3480f17c:	c3a02001 	movgt	r2, #1
3480f180:	e3510000 	cmp	r1, #0
3480f184:	13a02000 	movne	r2, #0
3480f188:	e3520000 	cmp	r2, #0
3480f18c:	0a000083 	beq	3480f3a0 <xyzModem_stream_read+0x250>
    {
      if (xyz.len == 0)
3480f190:	e59b2410 	ldr	r2, [fp, #1040]	; 0x410
3480f194:	e3520000 	cmp	r2, #0
3480f198:	03a0a015 	moveq	sl, #21
3480f19c:	1a00006a 	bne	3480f34c <xyzModem_stream_read+0x1fc>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
3480f1a0:	e25aa001 	subs	sl, sl, #1
3480f1a4:	0a000060 	beq	3480f32c <xyzModem_stream_read+0x1dc>
	    {
	      stat = xyzModem_get_hdr ();
3480f1a8:	ebfffeb0 	bl	3480ec70 <xyzModem_get_hdr>
	      if (stat == 0)
3480f1ac:	e2505000 	subs	r5, r0, #0
3480f1b0:	1a00003a 	bne	3480f2a0 <xyzModem_stream_read+0x150>
		{
		  if (xyz.blk == xyz.next_blk)
3480f1b4:	e5d41408 	ldrb	r1, [r4, #1032]	; 0x408
3480f1b8:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
3480f1bc:	e1510002 	cmp	r1, r2
3480f1c0:	1a00002e 	bne	3480f280 <xyzModem_stream_read+0x130>
		    {
		      xyz.tx_ack = true;
3480f1c4:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f1c8:	e0811002 	add	r1, r1, r2
		      xyz.tx_ack = true;
3480f1cc:	e5842430 	str	r2, [r4, #1072]	; 0x430
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f1d0:	e5c4140c 	strb	r1, [r4, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480f1d4:	e5941414 	ldr	r1, [r4, #1044]	; 0x414
3480f1d8:	e1510002 	cmp	r1, r2
3480f1dc:	0a00000e 	beq	3480f21c <xyzModem_stream_read+0xcc>
3480f1e0:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480f1e4:	e3520000 	cmp	r2, #0
3480f1e8:	0a00000b 	beq	3480f21c <xyzModem_stream_read+0xcc>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480f1ec:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480f1f0:	e3520000 	cmp	r2, #0
3480f1f4:	0a000054 	beq	3480f34c <xyzModem_stream_read+0x1fc>
			{
			  xyz.read_length += xyz.len;
3480f1f8:	e59b0410 	ldr	r0, [fp, #1040]	; 0x410
3480f1fc:	e59b1438 	ldr	r1, [fp, #1080]	; 0x438
3480f200:	e0801001 	add	r1, r0, r1
			  if (xyz.read_length > xyz.file_length)
3480f204:	e1510002 	cmp	r1, r2
			  xyz.read_length += xyz.len;
3480f208:	e58b1438 	str	r1, [fp, #1080]	; 0x438
3480f20c:	80822000 	addhi	r2, r2, r0
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480f210:	80612002 	rsbhi	r2, r1, r2
3480f214:	858b2410 	strhi	r2, [fp, #1040]	; 0x410
3480f218:	ea00004b 	b	3480f34c <xyzModem_stream_read+0x1fc>
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480f21c:	e5940404 	ldr	r0, [r4, #1028]	; 0x404
3480f220:	e5942410 	ldr	r2, [r4, #1040]	; 0x410
3480f224:	e0802002 	add	r2, r0, r2
3480f228:	e552c001 	ldrb	ip, [r2, #-1]
3480f22c:	e35c001a 	cmp	ip, #26
3480f230:	0a000002 	beq	3480f240 <xyzModem_stream_read+0xf0>
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480f234:	e3510001 	cmp	r1, #1
3480f238:	1affffeb 	bne	3480f1ec <xyzModem_stream_read+0x9c>
3480f23c:	ea000042 	b	3480f34c <xyzModem_stream_read+0x1fc>
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480f240:	e552c002 	ldrb	ip, [r2, #-2]
3480f244:	e35c001a 	cmp	ip, #26
3480f248:	1afffff9 	bne	3480f234 <xyzModem_stream_read+0xe4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
3480f24c:	e5522003 	ldrb	r2, [r2, #-3]
3480f250:	e352001a 	cmp	r2, #26
3480f254:	1afffff6 	bne	3480f234 <xyzModem_stream_read+0xe4>
			      while (xyz.len
3480f258:	e5942410 	ldr	r2, [r4, #1040]	; 0x410
3480f25c:	e3520000 	cmp	r2, #0
3480f260:	0afffff3 	beq	3480f234 <xyzModem_stream_read+0xe4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
3480f264:	e080c002 	add	ip, r0, r2
3480f268:	e55cc001 	ldrb	ip, [ip, #-1]
3480f26c:	e35c001a 	cmp	ip, #26
3480f270:	1affffef 	bne	3480f234 <xyzModem_stream_read+0xe4>
				  xyz.len--;
3480f274:	e2422001 	sub	r2, r2, #1
3480f278:	e58b2410 	str	r2, [fp, #1040]	; 0x410
3480f27c:	eafffff5 	b	3480f258 <xyzModem_stream_read+0x108>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f280:	e2422001 	sub	r2, r2, #1
3480f284:	e6ef2072 	uxtb	r2, r2
3480f288:	e1510002 	cmp	r1, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
3480f28c:	13e05007 	mvnne	r5, #7
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f290:	1a00001c 	bne	3480f308 <xyzModem_stream_read+0x1b8>
  putc (y);
3480f294:	e3a00006 	mov	r0, #6
3480f298:	ebffe927 	bl	3480973c <putc>
		      continue;	/* Need new header */
3480f29c:	eaffffbf 	b	3480f1a0 <xyzModem_stream_read+0x50>
		    }
		}
	      if (stat == xyzModem_cancel)
3480f2a0:	e3750005 	cmn	r5, #5
3480f2a4:	0a000022 	beq	3480f334 <xyzModem_stream_read+0x1e4>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
3480f2a8:	e3750004 	cmn	r5, #4
3480f2ac:	1a000015 	bne	3480f308 <xyzModem_stream_read+0x1b8>
  putc (y);
3480f2b0:	e3a00006 	mov	r0, #6
3480f2b4:	ebffe920 	bl	3480973c <putc>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
3480f2b8:	e5942414 	ldr	r2, [r4, #1044]	; 0x414
3480f2bc:	e3520002 	cmp	r2, #2
3480f2c0:	1a00000b 	bne	3480f2f4 <xyzModem_stream_read+0x1a4>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
3480f2c4:	e59b2428 	ldr	r2, [fp, #1064]	; 0x428
3480f2c8:	e3520000 	cmp	r2, #0
  putc (y);
3480f2cc:	13a00043 	movne	r0, #67	; 0x43
3480f2d0:	03a00015 	moveq	r0, #21
3480f2d4:	ebffe918 	bl	3480973c <putc>
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
3480f2d8:	e5942418 	ldr	r2, [r4, #1048]	; 0x418
3480f2dc:	e2822001 	add	r2, r2, #1
3480f2e0:	e5842418 	str	r2, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
3480f2e4:	ebfffe61 	bl	3480ec70 <xyzModem_get_hdr>
3480f2e8:	e1a05000 	mov	r5, r0
  putc (y);
3480f2ec:	e3a00006 	mov	r0, #6
3480f2f0:	ebffe911 	bl	3480973c <putc>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
3480f2f4:	e3550000 	cmp	r5, #0
		  xyz.at_eof = true;
3480f2f8:	e3a02001 	mov	r2, #1
3480f2fc:	e584242c 	str	r2, [r4, #1068]	; 0x42c
	  if (stat < 0)
3480f300:	aaffff9a 	bge	3480f170 <xyzModem_stream_read+0x20>
3480f304:	ea00000a 	b	3480f334 <xyzModem_stream_read+0x1e4>
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f308:	e5942428 	ldr	r2, [r4, #1064]	; 0x428
3480f30c:	e3520000 	cmp	r2, #0
  putc (y);
3480f310:	13a00043 	movne	r0, #67	; 0x43
3480f314:	03a00015 	moveq	r0, #21
3480f318:	ebffe907 	bl	3480973c <putc>
	      xyz.total_retries++;
3480f31c:	e5942418 	ldr	r2, [r4, #1048]	; 0x418
3480f320:	e2822001 	add	r2, r2, #1
3480f324:	e5842418 	str	r2, [r4, #1048]	; 0x418
3480f328:	eaffff9c 	b	3480f1a0 <xyzModem_stream_read+0x50>
	  if (stat < 0)
3480f32c:	e3550000 	cmp	r5, #0
3480f330:	aa000005 	bge	3480f34c <xyzModem_stream_read+0x1fc>
	    {
	      *err = stat;
3480f334:	e59d3004 	ldr	r3, [sp, #4]
	      xyz.len = -1;
3480f338:	e3e02000 	mvn	r2, #0
	      *err = stat;
3480f33c:	e5835000 	str	r5, [r3]
	      xyz.len = -1;
3480f340:	e59f3064 	ldr	r3, [pc, #100]	; 3480f3ac <xyzModem_stream_read+0x25c>
3480f344:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
3480f348:	ea000014 	b	3480f3a0 <xyzModem_stream_read+0x250>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
3480f34c:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
3480f350:	e3520000 	cmp	r2, #0
3480f354:	1affff85 	bne	3480f170 <xyzModem_stream_read+0x20>
	{
	  len = xyz.len;
3480f358:	e59b2410 	ldr	r2, [fp, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480f35c:	e1a00009 	mov	r0, r9
3480f360:	e59b1404 	ldr	r1, [fp, #1028]	; 0x404
3480f364:	e1560002 	cmp	r6, r2
3480f368:	b1a0a006 	movlt	sl, r6
3480f36c:	a1a0a002 	movge	sl, r2
3480f370:	e1a0200a 	mov	r2, sl
	  size -= len;
3480f374:	e06a6006 	rsb	r6, sl, r6
	  memcpy (buf, xyz.bufp, len);
3480f378:	eb00321f 	bl	3481bbfc <memcpy>
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480f37c:	e59b2410 	ldr	r2, [fp, #1040]	; 0x410
	  buf += len;
3480f380:	e089900a 	add	r9, r9, sl
	  total += len;
3480f384:	e087700a 	add	r7, r7, sl
	  xyz.len -= len;
3480f388:	e06a2002 	rsb	r2, sl, r2
3480f38c:	e58b2410 	str	r2, [fp, #1040]	; 0x410
	  xyz.bufp += len;
3480f390:	e59b2404 	ldr	r2, [fp, #1028]	; 0x404
3480f394:	e082a00a 	add	sl, r2, sl
3480f398:	e58ba404 	str	sl, [fp, #1028]	; 0x404
3480f39c:	eaffff73 	b	3480f170 <xyzModem_stream_read+0x20>
	}
    }
  return total;
}
3480f3a0:	e1a00007 	mov	r0, r7
3480f3a4:	e28dd008 	add	sp, sp, #8
3480f3a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480f3ac:	3482a2a8 	.word	0x3482a2a8

3480f3b0 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
3480f3b0:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
3480f3b4:	e59f2038 	ldr	r2, [pc, #56]	; 3480f3f4 <xyzModem_stream_close+0x44>
  diag_printf
3480f3b8:	e59f0038 	ldr	r0, [pc, #56]	; 3480f3f8 <xyzModem_stream_close+0x48>
3480f3bc:	e5923418 	ldr	r3, [r2, #1048]	; 0x418
3480f3c0:	e592c428 	ldr	ip, [r2, #1064]	; 0x428
3480f3c4:	e59f1030 	ldr	r1, [pc, #48]	; 3480f3fc <xyzModem_stream_close+0x4c>
3480f3c8:	e58d3004 	str	r3, [sp, #4]
3480f3cc:	e5923424 	ldr	r3, [r2, #1060]	; 0x424
3480f3d0:	e35c0000 	cmp	ip, #0
3480f3d4:	01a01000 	moveq	r1, r0
3480f3d8:	e59f0020 	ldr	r0, [pc, #32]	; 3480f400 <xyzModem_stream_close+0x50>
3480f3dc:	e58d3000 	str	r3, [sp]
3480f3e0:	e5923420 	ldr	r3, [r2, #1056]	; 0x420
3480f3e4:	e592241c 	ldr	r2, [r2, #1052]	; 0x41c
3480f3e8:	ebffe8eb 	bl	3480979c <printf>
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
3480f3ec:	e28dd00c 	add	sp, sp, #12
3480f3f0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
3480f3f4:	3482a2a8 	.word	0x3482a2a8
3480f3f8:	34825691 	.word	0x34825691
3480f3fc:	34824e45 	.word	0x34824e45
3480f400:	34825697 	.word	0x34825697

3480f404 <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
3480f404:	e3500000 	cmp	r0, #0
{
3480f408:	e92d4010 	push	{r4, lr}
3480f40c:	e1a04001 	mov	r4, r1
  if (abort)
3480f410:	0a000018 	beq	3480f478 <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
3480f414:	e59f4074 	ldr	r4, [pc, #116]	; 3480f490 <xyzModem_stream_terminate+0x8c>
3480f418:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f41c:	e2433001 	sub	r3, r3, #1
3480f420:	e3530001 	cmp	r3, #1
3480f424:	88bd8010 	pophi	{r4, pc}
  putc (y);
3480f428:	e3a00018 	mov	r0, #24
3480f42c:	ebffe8c2 	bl	3480973c <putc>
3480f430:	e3a00018 	mov	r0, #24
3480f434:	ebffe8c0 	bl	3480973c <putc>
3480f438:	e3a00018 	mov	r0, #24
3480f43c:	ebffe8be 	bl	3480973c <putc>
3480f440:	e3a00018 	mov	r0, #24
3480f444:	ebffe8bc 	bl	3480973c <putc>
3480f448:	e3a00008 	mov	r0, #8
3480f44c:	ebffe8ba 	bl	3480973c <putc>
3480f450:	e3a00008 	mov	r0, #8
3480f454:	ebffe8b8 	bl	3480973c <putc>
3480f458:	e3a00008 	mov	r0, #8
3480f45c:	ebffe8b6 	bl	3480973c <putc>
3480f460:	e3a00008 	mov	r0, #8
3480f464:	ebffe8b4 	bl	3480973c <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
3480f468:	ebfffdf5 	bl	3480ec44 <xyzModem_flush>
	  xyz.at_eof = true;
3480f46c:	e3a03001 	mov	r3, #1
3480f470:	e584342c 	str	r3, [r4, #1068]	; 0x42c
	  break;
3480f474:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
3480f478:	e12fff34 	blx	r4
3480f47c:	e3500000 	cmp	r0, #0
3480f480:	aafffffc 	bge	3480f478 <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f484:	e59f0008 	ldr	r0, [pc, #8]	; 3480f494 <xyzModem_stream_terminate+0x90>
    }
}
3480f488:	e8bd4010 	pop	{r4, lr}
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f48c:	ea00325e 	b	3481be0c <udelay>
3480f490:	3482a2a8 	.word	0x3482a2a8
3480f494:	0003d090 	.word	0x0003d090

3480f498 <xyzModem_error>:

char *
xyzModem_error (int err)
{
3480f498:	e2800008 	add	r0, r0, #8
3480f49c:	e3500007 	cmp	r0, #7
3480f4a0:	959f3008 	ldrls	r3, [pc, #8]	; 3480f4b0 <xyzModem_error+0x18>
3480f4a4:	97930100 	ldrls	r0, [r3, r0, lsl #2]
  switch (err)
3480f4a8:	859f0004 	ldrhi	r0, [pc, #4]	; 3480f4b4 <xyzModem_error+0x1c>
      break;
    default:
      return "Unknown error";
      break;
    }
}
3480f4ac:	e12fff1e 	bx	lr
3480f4b0:	34820134 	.word	0x34820134
3480f4b4:	348256d8 	.word	0x348256d8

3480f4b8 <get_dev>:
{
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480f4b8:	e3500000 	cmp	r0, #0
3480f4bc:	0a000016 	beq	3480f51c <get_dev+0x64>
{
3480f4c0:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3480f4c4:	e1a07000 	mov	r7, r0
3480f4c8:	e59f4054 	ldr	r4, [pc, #84]	; 3480f524 <get_dev+0x6c>
3480f4cc:	e1a06001 	mov	r6, r1

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
3480f4d0:	e5145008 	ldr	r5, [r4, #-8]
3480f4d4:	e3550000 	cmp	r5, #0
3480f4d8:	0a00000d 	beq	3480f514 <get_dev+0x5c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f4dc:	e1a00005 	mov	r0, r5
		reloc_get_dev = drvr->get_dev;
3480f4e0:	e5149004 	ldr	r9, [r4, #-4]
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f4e4:	eb0030fb 	bl	3481b8d8 <strlen>
3480f4e8:	e1a01005 	mov	r1, r5
3480f4ec:	e1a02000 	mov	r2, r0
3480f4f0:	e1a00007 	mov	r0, r7
3480f4f4:	e2844008 	add	r4, r4, #8
3480f4f8:	eb0030d2 	bl	3481b848 <strncmp>
3480f4fc:	e3500000 	cmp	r0, #0
3480f500:	1afffff2 	bne	3480f4d0 <get_dev+0x18>
			return reloc_get_dev(dev);
3480f504:	e1a00006 	mov	r0, r6
3480f508:	e1a03009 	mov	r3, r9
		drvr++;
	}
	return NULL;
}
3480f50c:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
			return reloc_get_dev(dev);
3480f510:	e12fff13 	bx	r3
}
3480f514:	e3a00000 	mov	r0, #0
3480f518:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3480f51c:	e3a00000 	mov	r0, #0
3480f520:	e12fff1e 	bx	lr
3480f524:	3482015c 	.word	0x3482015c

3480f528 <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f528:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f52c:	e5d0300b 	ldrb	r3, [r0, #11]
3480f530:	e35300ff 	cmp	r3, #255	; 0xff
		puts ("not available\n");
3480f534:	059f01ac 	ldreq	r0, [pc, #428]	; 3480f6e8 <dev_print+0x1c0>
	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f538:	0a000067 	beq	3480f6dc <dev_print+0x1b4>
		return;
	}

	switch (dev_desc->if_type) {
3480f53c:	e5901000 	ldr	r1, [r0]
3480f540:	e1a04000 	mov	r4, r0
3480f544:	e3510008 	cmp	r1, #8
3480f548:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f54c:	ea000021 	b	3480f5d8 <dev_print+0xb0>
3480f550:	3480f5d0 	.word	0x3480f5d0
3480f554:	3480f59c 	.word	0x3480f59c
3480f558:	3480f574 	.word	0x3480f574
3480f55c:	3480f59c 	.word	0x3480f59c
3480f560:	3480f5b0 	.word	0x3480f5b0
3480f564:	3480f5c8 	.word	0x3480f5c8
3480f568:	3480f5b0 	.word	0x3480f5b0
3480f56c:	3480f5b0 	.word	0x3480f5b0
3480f570:	3480f59c 	.word	0x3480f59c
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
3480f574:	e2803056 	add	r3, r0, #86	; 0x56
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480f578:	e5d0200a 	ldrb	r2, [r0, #10]
3480f57c:	e5d01009 	ldrb	r1, [r0, #9]
3480f580:	e58d3004 	str	r3, [sp, #4]
			dev_desc->product,
3480f584:	e2803041 	add	r3, r0, #65	; 0x41
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480f588:	e58d3000 	str	r3, [sp]
3480f58c:	e2803018 	add	r3, r0, #24
3480f590:	e59f0154 	ldr	r0, [pc, #340]	; 3480f6ec <dev_print+0x1c4>
3480f594:	ebffe880 	bl	3480979c <printf>
		break;
3480f598:	ea000012 	b	3480f5e8 <dev_print+0xc0>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
3480f59c:	e2803041 	add	r3, r0, #65	; 0x41
3480f5a0:	e2802056 	add	r2, r0, #86	; 0x56
3480f5a4:	e2801018 	add	r1, r0, #24
3480f5a8:	e59f0140 	ldr	r0, [pc, #320]	; 3480f6f0 <dev_print+0x1c8>
3480f5ac:	ea000003 	b	3480f5c0 <dev_print+0x98>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
3480f5b0:	e2803041 	add	r3, r0, #65	; 0x41
3480f5b4:	e2802056 	add	r2, r0, #86	; 0x56
3480f5b8:	e2801018 	add	r1, r0, #24
3480f5bc:	e59f0130 	ldr	r0, [pc, #304]	; 3480f6f4 <dev_print+0x1cc>
3480f5c0:	ebffe875 	bl	3480979c <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
3480f5c4:	ea000007 	b	3480f5e8 <dev_print+0xc0>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
3480f5c8:	e59f0128 	ldr	r0, [pc, #296]	; 3480f6f8 <dev_print+0x1d0>
3480f5cc:	ea000042 	b	3480f6dc <dev_print+0x1b4>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
3480f5d0:	e59f0124 	ldr	r0, [pc, #292]	; 3480f6fc <dev_print+0x1d4>
3480f5d4:	ea000040 	b	3480f6dc <dev_print+0x1b4>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f5d8:	e59f0120 	ldr	r0, [pc, #288]	; 3480f700 <dev_print+0x1d8>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480f5dc:	e28dd010 	add	sp, sp, #16
3480f5e0:	e8bd4070 	pop	{r4, r5, r6, lr}
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f5e4:	eaffe86c 	b	3480979c <printf>
	puts ("            Type: ");
3480f5e8:	e59f0114 	ldr	r0, [pc, #276]	; 3480f704 <dev_print+0x1dc>
3480f5ec:	ebffe85e 	bl	3480976c <puts>
	if (dev_desc->removable)
3480f5f0:	e5d4300c 	ldrb	r3, [r4, #12]
3480f5f4:	e3530000 	cmp	r3, #0
3480f5f8:	0a000001 	beq	3480f604 <dev_print+0xdc>
		puts ("Removable ");
3480f5fc:	e59f0104 	ldr	r0, [pc, #260]	; 3480f708 <dev_print+0x1e0>
3480f600:	ebffe859 	bl	3480976c <puts>
	switch (dev_desc->type & 0x1F) {
3480f604:	e5d4100b 	ldrb	r1, [r4, #11]
3480f608:	e201101f 	and	r1, r1, #31
3480f60c:	e3510007 	cmp	r1, #7
3480f610:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f614:	ea000010 	b	3480f65c <dev_print+0x134>
3480f618:	3480f638 	.word	0x3480f638
3480f61c:	3480f654 	.word	0x3480f654
3480f620:	3480f65c 	.word	0x3480f65c
3480f624:	3480f65c 	.word	0x3480f65c
3480f628:	3480f65c 	.word	0x3480f65c
3480f62c:	3480f640 	.word	0x3480f640
3480f630:	3480f65c 	.word	0x3480f65c
3480f634:	3480f64c 	.word	0x3480f64c
		puts ("Hard Disk");
3480f638:	e59f00cc 	ldr	r0, [pc, #204]	; 3480f70c <dev_print+0x1e4>
3480f63c:	ea000000 	b	3480f644 <dev_print+0x11c>
		puts ("CD ROM");
3480f640:	e59f00c8 	ldr	r0, [pc, #200]	; 3480f710 <dev_print+0x1e8>
3480f644:	ebffe848 	bl	3480976c <puts>
		break;
3480f648:	ea000005 	b	3480f664 <dev_print+0x13c>
		puts ("Optical Device");
3480f64c:	e59f00c0 	ldr	r0, [pc, #192]	; 3480f714 <dev_print+0x1ec>
3480f650:	eafffffb 	b	3480f644 <dev_print+0x11c>
		puts ("Tape");
3480f654:	e59f00bc 	ldr	r0, [pc, #188]	; 3480f718 <dev_print+0x1f0>
3480f658:	eafffff9 	b	3480f644 <dev_print+0x11c>
		printf ("# %02X #", dev_desc->type & 0x1F);
3480f65c:	e59f00b8 	ldr	r0, [pc, #184]	; 3480f71c <dev_print+0x1f4>
3480f660:	ebffe84d 	bl	3480979c <printf>
	puts ("\n");
3480f664:	e59f00b4 	ldr	r0, [pc, #180]	; 3480f720 <dev_print+0x1f8>
3480f668:	ebffe83f 	bl	3480976c <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480f66c:	e594e010 	ldr	lr, [r4, #16]
3480f670:	e5946014 	ldr	r6, [r4, #20]
3480f674:	e013069e 	muls	r3, lr, r6
		puts ("            Capacity: not available\n");
3480f678:	059f00a4 	ldreq	r0, [pc, #164]	; 3480f724 <dev_print+0x1fc>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480f67c:	0a000016 	beq	3480f6dc <dev_print+0x1b4>
		lba512 = (lba * (dev_desc->blksz/512));
3480f680:	e1a034a6 	lsr	r3, r6, #9
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480f684:	e3a0c00a 	mov	ip, #10
		mb_quot	= mb / 10;
3480f688:	e59f4098 	ldr	r4, [pc, #152]	; 3480f728 <dev_print+0x200>
		lba512 = (lba * (dev_desc->blksz/512));
3480f68c:	e003039e 	mul	r3, lr, r3
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480f690:	e58d6008 	str	r6, [sp, #8]
3480f694:	e58de004 	str	lr, [sp, #4]
	bc_quot = block_count / div_by;
3480f698:	e1a015a3 	lsr	r1, r3, #11
	bc_rem  = block_count - div_by * bc_quot;
3480f69c:	e0433581 	sub	r3, r3, r1, lsl #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480f6a0:	e001019c 	mul	r1, ip, r1
3480f6a4:	e003039c 	mul	r3, ip, r3
3480f6a8:	e08125a3 	add	r2, r1, r3, lsr #11
		mb_quot	= mb / 10;
3480f6ac:	e0810492 	umull	r0, r1, r2, r4
		gb = mb / 1024;
3480f6b0:	e1a00c32 	lsr	r0, r2, ip
		gb_quot	= gb / 10;
3480f6b4:	e0854490 	umull	r4, r5, r0, r4
		mb_quot	= mb / 10;
3480f6b8:	e1a011a1 	lsr	r1, r1, #3
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480f6bc:	e062219c 	mls	r2, ip, r1, r2
		gb_quot	= gb / 10;
3480f6c0:	e1a031a5 	lsr	r3, r5, #3
		gb_rem	= gb - (10 * gb_quot);
3480f6c4:	e060039c 	mls	r0, ip, r3, r0
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480f6c8:	e58d0000 	str	r0, [sp]
3480f6cc:	e59f0058 	ldr	r0, [pc, #88]	; 3480f72c <dev_print+0x204>
3480f6d0:	ebffe831 	bl	3480979c <printf>
}
3480f6d4:	e28dd010 	add	sp, sp, #16
3480f6d8:	e8bd8070 	pop	{r4, r5, r6, pc}
3480f6dc:	e28dd010 	add	sp, sp, #16
3480f6e0:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("            Capacity: not available\n");
3480f6e4:	eaffe820 	b	3480976c <puts>
3480f6e8:	348258ae 	.word	0x348258ae
3480f6ec:	34825770 	.word	0x34825770
3480f6f0:	34825796 	.word	0x34825796
3480f6f4:	348257b3 	.word	0x348257b3
3480f6f8:	348257d0 	.word	0x348257d0
3480f6fc:	348257e1 	.word	0x348257e1
3480f700:	348257f6 	.word	0x348257f6
3480f704:	34825811 	.word	0x34825811
3480f708:	34825824 	.word	0x34825824
3480f70c:	3482582f 	.word	0x3482582f
3480f710:	34825839 	.word	0x34825839
3480f714:	34825840 	.word	0x34825840
3480f718:	3482584f 	.word	0x3482584f
3480f71c:	34825854 	.word	0x34825854
3480f720:	34824f42 	.word	0x34824f42
3480f724:	34825898 	.word	0x34825898
3480f728:	cccccccd 	.word	0xcccccccd
3480f72c:	3482585d 	.word	0x3482585d

3480f730 <init_part>:
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION) || \
    defined(CONFIG_EFI_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
3480f730:	e92d4010 	push	{r4, lr}
3480f734:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
3480f738:	eb000263 	bl	348100cc <test_part_dos>
3480f73c:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
3480f740:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
3480f744:	13a03000 	movne	r3, #0
3480f748:	e5c43008 	strb	r3, [r4, #8]
3480f74c:	e8bd8010 	pop	{r4, pc}

3480f750 <print_part>:
}

void print_part (block_dev_desc_t * dev_desc)
{

		switch (dev_desc->part_type) {
3480f750:	e5d03008 	ldrb	r3, [r0, #8]
3480f754:	e3530002 	cmp	r3, #2
3480f758:	1a000027 	bne	3480f7fc <print_part+0xac>
{
3480f75c:	e92d4010 	push	{r4, lr}
3480f760:	e1a04000 	mov	r4, r0
	puts ("\nPartition Map for ");
3480f764:	e59f0098 	ldr	r0, [pc, #152]	; 3480f804 <print_part+0xb4>
3480f768:	ebffe7ff 	bl	3480976c <puts>
	switch (dev_desc->if_type) {
3480f76c:	e5943000 	ldr	r3, [r4]
3480f770:	e2433001 	sub	r3, r3, #1
3480f774:	e3530007 	cmp	r3, #7
3480f778:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480f77c:	ea000015 	b	3480f7d8 <print_part+0x88>
3480f780:	3480f7a0 	.word	0x3480f7a0
3480f784:	3480f7b0 	.word	0x3480f7b0
3480f788:	3480f7b8 	.word	0x3480f7b8
3480f78c:	3480f7c0 	.word	0x3480f7c0
3480f790:	3480f7c8 	.word	0x3480f7c8
3480f794:	3480f7d0 	.word	0x3480f7d0
3480f798:	3480f7d8 	.word	0x3480f7d8
3480f79c:	3480f7a8 	.word	0x3480f7a8
		puts ("IDE");
3480f7a0:	e59f0060 	ldr	r0, [pc, #96]	; 3480f808 <print_part+0xb8>
3480f7a4:	ea00000c 	b	3480f7dc <print_part+0x8c>
		puts ("SATA");
3480f7a8:	e59f005c 	ldr	r0, [pc, #92]	; 3480f80c <print_part+0xbc>
3480f7ac:	ea00000a 	b	3480f7dc <print_part+0x8c>
		puts ("SCSI");
3480f7b0:	e59f0058 	ldr	r0, [pc, #88]	; 3480f810 <print_part+0xc0>
3480f7b4:	ea000008 	b	3480f7dc <print_part+0x8c>
		puts ("ATAPI");
3480f7b8:	e59f0054 	ldr	r0, [pc, #84]	; 3480f814 <print_part+0xc4>
3480f7bc:	ea000006 	b	3480f7dc <print_part+0x8c>
		puts ("USB");
3480f7c0:	e59f0050 	ldr	r0, [pc, #80]	; 3480f818 <print_part+0xc8>
3480f7c4:	ea000004 	b	3480f7dc <print_part+0x8c>
		puts ("DOC");
3480f7c8:	e59f004c 	ldr	r0, [pc, #76]	; 3480f81c <print_part+0xcc>
3480f7cc:	ea000002 	b	3480f7dc <print_part+0x8c>
		puts ("MMC");
3480f7d0:	e59f0048 	ldr	r0, [pc, #72]	; 3480f820 <print_part+0xd0>
3480f7d4:	ea000000 	b	3480f7dc <print_part+0x8c>
		puts ("UNKNOWN");
3480f7d8:	e59f0044 	ldr	r0, [pc, #68]	; 3480f824 <print_part+0xd4>
3480f7dc:	ebffe7e2 	bl	3480976c <puts>
	printf (" device %d  --   Partition Type: %s\n\n",
3480f7e0:	e5941004 	ldr	r1, [r4, #4]
3480f7e4:	e59f203c 	ldr	r2, [pc, #60]	; 3480f828 <print_part+0xd8>
3480f7e8:	e59f003c 	ldr	r0, [pc, #60]	; 3480f82c <print_part+0xdc>
3480f7ec:	ebffe7ea 	bl	3480979c <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480f7f0:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
3480f7f4:	e8bd4010 	pop	{r4, lr}
		print_part_dos (dev_desc);
3480f7f8:	ea00024c 	b	34810130 <print_part_dos>
	puts ("## Unknown partition table\n");
3480f7fc:	e59f002c 	ldr	r0, [pc, #44]	; 3480f830 <print_part+0xe0>
3480f800:	eaffe7d9 	b	3480976c <puts>
3480f804:	348258bd 	.word	0x348258bd
3480f808:	348258d1 	.word	0x348258d1
3480f80c:	348258d5 	.word	0x348258d5
3480f810:	348258da 	.word	0x348258da
3480f814:	348258df 	.word	0x348258df
3480f818:	348258e5 	.word	0x348258e5
3480f81c:	348258e9 	.word	0x348258e9
3480f820:	34822f7a 	.word	0x34822f7a
3480f824:	348258ed 	.word	0x348258ed
3480f828:	348258f5 	.word	0x348258f5
3480f82c:	348258f9 	.word	0x348258f9
3480f830:	3482591f 	.word	0x3482591f

3480f834 <get_partition_info>:
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
3480f834:	e5d03008 	ldrb	r3, [r0, #8]
3480f838:	e3530002 	cmp	r3, #2
3480f83c:	1a000005 	bne	3480f858 <get_partition_info+0x24>
{
3480f840:	e92d4010 	push	{r4, lr}
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
3480f844:	eb000244 	bl	3481015c <get_partition_info_dos>
3480f848:	e2900000 	adds	r0, r0, #0
3480f84c:	13a00001 	movne	r0, #1
3480f850:	e2600000 	rsb	r0, r0, #0
3480f854:	e8bd8010 	pop	{r4, pc}
	default:
		break;
	}
#endif

	return -1;
3480f858:	e3e00000 	mvn	r0, #0
3480f85c:	e12fff1e 	bx	lr

3480f860 <get_device>:
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480f860:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480f864:	e1a06001 	mov	r6, r1
3480f868:	e1a05000 	mov	r5, r0
3480f86c:	e1a07002 	mov	r7, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f870:	e28d1004 	add	r1, sp, #4
3480f874:	e3a02010 	mov	r2, #16
3480f878:	e1a00006 	mov	r0, r6
3480f87c:	eb0033b8 	bl	3481c764 <simple_strtoul>
	if (*ep) {
3480f880:	e59d3004 	ldr	r3, [sp, #4]
3480f884:	e5d33000 	ldrb	r3, [r3]
3480f888:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
3480f88c:	11a02006 	movne	r2, r6
3480f890:	11a01005 	movne	r1, r5
3480f894:	159f0048 	ldrne	r0, [pc, #72]	; 3480f8e4 <get_device+0x84>
3480f898:	1a00000d 	bne	3480f8d4 <get_device+0x74>
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480f89c:	e1a01000 	mov	r1, r0
3480f8a0:	e1a04000 	mov	r4, r0
3480f8a4:	e1a00005 	mov	r0, r5
3480f8a8:	ebffff02 	bl	3480f4b8 <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f8ac:	e3500000 	cmp	r0, #0
	*dev_desc = get_dev(ifname, dev);
3480f8b0:	e5870000 	str	r0, [r7]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f8b4:	0a000003 	beq	3480f8c8 <get_device+0x68>
3480f8b8:	e5d0300b 	ldrb	r3, [r0, #11]
3480f8bc:	e35300ff 	cmp	r3, #255	; 0xff
		printf("** Bad device %s %s **\n", ifname, dev_str);
		return -1;
	}

	return dev;
3480f8c0:	11a00004 	movne	r0, r4
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f8c4:	1a000004 	bne	3480f8dc <get_device+0x7c>
		printf("** Bad device %s %s **\n", ifname, dev_str);
3480f8c8:	e59f0018 	ldr	r0, [pc, #24]	; 3480f8e8 <get_device+0x88>
3480f8cc:	e1a02006 	mov	r2, r6
3480f8d0:	e1a01005 	mov	r1, r5
3480f8d4:	ebffe7b0 	bl	3480979c <printf>
		return -1;
3480f8d8:	e3e00000 	mvn	r0, #0
}
3480f8dc:	e28dd00c 	add	sp, sp, #12
3480f8e0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480f8e4:	3482593b 	.word	0x3482593b
3480f8e8:	34825961 	.word	0x34825961

3480f8ec <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480f8ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f8f0:	e2516000 	subs	r6, r1, #0
{
3480f8f4:	e24dd060 	sub	sp, sp, #96	; 0x60
3480f8f8:	e1a09000 	mov	r9, r0
3480f8fc:	e1a04003 	mov	r4, r3
3480f900:	e58d2004 	str	r2, [sp, #4]
3480f904:	e59d5080 	ldr	r5, [sp, #128]	; 0x80
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f908:	1a000007 	bne	3480f92c <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
3480f90c:	e59f0294 	ldr	r0, [pc, #660]	; 3480fba8 <get_device_and_partition+0x2bc>
3480f910:	ebffe09b 	bl	34807b84 <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
3480f914:	e2506000 	subs	r6, r0, #0
3480f918:	1a00000c 	bne	3480f950 <get_device_and_partition+0x64>
		printf("** No device specified **\n");
3480f91c:	e59f0288 	ldr	r0, [pc, #648]	; 3480fbac <get_device_and_partition+0x2c0>
	char *dup_str = NULL;
3480f920:	e1a07006 	mov	r7, r6
		printf("** No device specified **\n");
3480f924:	ebffe79c 	bl	3480979c <printf>
3480f928:	ea000037 	b	3480fa0c <get_device_and_partition+0x120>
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f92c:	e1a00006 	mov	r0, r6
3480f930:	eb002fe8 	bl	3481b8d8 <strlen>
3480f934:	e3500000 	cmp	r0, #0
3480f938:	0afffff3 	beq	3480f90c <get_device_and_partition+0x20>
	    !strcmp(dev_part_str, "-"))
3480f93c:	e59f126c 	ldr	r1, [pc, #620]	; 3480fbb0 <get_device_and_partition+0x2c4>
3480f940:	e1a00006 	mov	r0, r6
3480f944:	eb002fb5 	bl	3481b820 <strcmp>
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f948:	e3500000 	cmp	r0, #0
3480f94c:	0affffee 	beq	3480f90c <get_device_and_partition+0x20>
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
3480f950:	e3a0103a 	mov	r1, #58	; 0x3a
3480f954:	e1a00006 	mov	r0, r6
3480f958:	eb002fc9 	bl	3481b884 <strchr>
	if (part_str) {
3480f95c:	e250b000 	subs	fp, r0, #0
3480f960:	01a0a006 	moveq	sl, r6
	char *dup_str = NULL;
3480f964:	01a0700b 	moveq	r7, fp
	if (part_str) {
3480f968:	0a000007 	beq	3480f98c <get_device_and_partition+0xa0>
		dup_str = strdup(dev_part_str);
3480f96c:	e1a00006 	mov	r0, r6
3480f970:	eb003012 	bl	3481b9c0 <strdup>
		dup_str[part_str - dev_part_str] = 0;
3480f974:	e066200b 	rsb	r2, r6, fp
		dup_str = strdup(dev_part_str);
3480f978:	e1a07000 	mov	r7, r0
		dev_str = dup_str;
		part_str++;
3480f97c:	e28bb001 	add	fp, fp, #1
		dev_str = dup_str;
3480f980:	e1a0a000 	mov	sl, r0
		dup_str[part_str - dev_part_str] = 0;
3480f984:	e3a01000 	mov	r1, #0
3480f988:	e7c01002 	strb	r1, [r0, r2]
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
3480f98c:	e59d2004 	ldr	r2, [sp, #4]
3480f990:	e1a0100a 	mov	r1, sl
3480f994:	e1a00009 	mov	r0, r9
3480f998:	ebffffb0 	bl	3480f860 <get_device>
	if (dev < 0)
3480f99c:	e3500000 	cmp	r0, #0
3480f9a0:	ba000019 	blt	3480fa0c <get_device_and_partition+0x120>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
3480f9a4:	e35b0000 	cmp	fp, #0
3480f9a8:	0a000019 	beq	3480fa14 <get_device_and_partition+0x128>
3480f9ac:	e5db2000 	ldrb	r2, [fp]
3480f9b0:	e3520000 	cmp	r2, #0
3480f9b4:	0a000016 	beq	3480fa14 <get_device_and_partition+0x128>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480f9b8:	e1a0000b 	mov	r0, fp
3480f9bc:	e59f11f0 	ldr	r1, [pc, #496]	; 3480fbb4 <get_device_and_partition+0x2c8>
3480f9c0:	eb002f96 	bl	3481b820 <strcmp>
3480f9c4:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
3480f9c8:	03e0b000 	mvneq	fp, #0
	} else if (!strcmp(part_str, "auto")) {
3480f9cc:	0a000011 	beq	3480fa18 <get_device_and_partition+0x12c>
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f9d0:	e3a02010 	mov	r2, #16
3480f9d4:	e1a0000b 	mov	r0, fp
3480f9d8:	e28d100c 	add	r1, sp, #12
3480f9dc:	eb003360 	bl	3481c764 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f9e0:	e59d200c 	ldr	r2, [sp, #12]
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f9e4:	e1a0b000 	mov	fp, r0
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f9e8:	e5d22000 	ldrb	r2, [r2]
3480f9ec:	e3520000 	cmp	r2, #0
3480f9f0:	1a000001 	bne	3480f9fc <get_device_and_partition+0x110>
3480f9f4:	e1903005 	orrs	r3, r0, r5
3480f9f8:	1a000006 	bne	3480fa18 <get_device_and_partition+0x12c>
			printf("** Bad partition specification %s %s **\n",
3480f9fc:	e59f01b4 	ldr	r0, [pc, #436]	; 3480fbb8 <get_device_and_partition+0x2cc>
3480fa00:	e1a02006 	mov	r2, r6
3480fa04:	e1a01009 	mov	r1, r9
3480fa08:	ebffe763 	bl	3480979c <printf>
	int ret = -1;
3480fa0c:	e3e0b000 	mvn	fp, #0
			    ifname, dev_part_str);
			goto cleanup;
3480fa10:	ea00005f 	b	3480fb94 <get_device_and_partition+0x2a8>
		part = PART_UNSPECIFIED;
3480fa14:	e3e0b001 	mvn	fp, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
3480fa18:	e59d3004 	ldr	r3, [sp, #4]
3480fa1c:	e5930000 	ldr	r0, [r3]
3480fa20:	e5d02008 	ldrb	r2, [r0, #8]
3480fa24:	e3520000 	cmp	r2, #0
3480fa28:	135b0000 	cmpne	fp, #0
3480fa2c:	03a02001 	moveq	r2, #1
3480fa30:	13a02000 	movne	r2, #0
3480fa34:	1a000016 	bne	3480fa94 <get_device_and_partition+0x1a8>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
3480fa38:	e5902010 	ldr	r2, [r0, #16]
3480fa3c:	e3520000 	cmp	r2, #0
			printf("** Bad device size - %s %s **\n", ifname,
3480fa40:	01a0200a 	moveq	r2, sl
3480fa44:	01a01009 	moveq	r1, r9
3480fa48:	059f016c 	ldreq	r0, [pc, #364]	; 3480fbbc <get_device_and_partition+0x2d0>
3480fa4c:	0affffed 	beq	3480fa08 <get_device_and_partition+0x11c>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480fa50:	e16f5f15 	clz	r5, r5
3480fa54:	e1a052a5 	lsr	r5, r5, #5
3480fa58:	e35b0000 	cmp	fp, #0
3480fa5c:	d1a03005 	movle	r3, r5
3480fa60:	c3853001 	orrgt	r3, r5, #1
3480fa64:	e3530000 	cmp	r3, #0
			printf("** No partition table - %s %s **\n", ifname,
3480fa68:	11a0200a 	movne	r2, sl
3480fa6c:	11a01009 	movne	r1, r9
3480fa70:	159f0148 	ldrne	r0, [pc, #328]	; 3480fbc0 <get_device_and_partition+0x2d4>
3480fa74:	1affffe3 	bne	3480fa08 <get_device_and_partition+0x11c>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
3480fa78:	e5842004 	str	r2, [r4, #4]
		info->bootable = 0;
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
3480fa7c:	e1a0b003 	mov	fp, r3
		info->blksz = (*dev_desc)->blksz;
3480fa80:	e5902014 	ldr	r2, [r0, #20]
		info->start = 0;
3480fa84:	e5843000 	str	r3, [r4]
		info->bootable = 0;
3480fa88:	e584304c 	str	r3, [r4, #76]	; 0x4c
		info->blksz = (*dev_desc)->blksz;
3480fa8c:	e5842008 	str	r2, [r4, #8]
		goto cleanup;
3480fa90:	ea00003f 	b	3480fb94 <get_device_and_partition+0x2a8>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
3480fa94:	e37b0002 	cmn	fp, #2
3480fa98:	0a000004 	beq	3480fab0 <get_device_and_partition+0x1c4>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480fa9c:	e37b0001 	cmn	fp, #1
3480faa0:	01a0b002 	moveq	fp, r2
3480faa4:	03a05001 	moveq	r5, #1
3480faa8:	0a000019 	beq	3480fb14 <get_device_and_partition+0x228>
3480faac:	ea000000 	b	3480fab4 <get_device_and_partition+0x1c8>
		part = 1;
3480fab0:	e3a0b001 	mov	fp, #1
		ret = get_partition_info(*dev_desc, part, info);
3480fab4:	e1a02004 	mov	r2, r4
3480fab8:	e1a0100b 	mov	r1, fp
3480fabc:	ebffff5c 	bl	3480f834 <get_partition_info>
		if (ret) {
3480fac0:	e2505000 	subs	r5, r0, #0
3480fac4:	0a000024 	beq	3480fb5c <get_device_and_partition+0x270>
			printf("** Invalid partition %d **\n", part);
3480fac8:	e1a0100b 	mov	r1, fp
3480facc:	e59f00f0 	ldr	r0, [pc, #240]	; 3480fbc4 <get_device_and_partition+0x2d8>
3480fad0:	ebffe731 	bl	3480979c <printf>
			goto cleanup;
3480fad4:	e1a0b005 	mov	fp, r5
3480fad8:	ea00002d 	b	3480fb94 <get_device_and_partition+0x2a8>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
3480fadc:	e35b0000 	cmp	fp, #0
3480fae0:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
3480fae4:	0a000012 	beq	3480fb34 <get_device_and_partition+0x248>
3480fae8:	e3520000 	cmp	r2, #0
3480faec:	1a000010 	bne	3480fb34 <get_device_and_partition+0x248>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
3480faf0:	e15b0005 	cmp	fp, r5
3480faf4:	1a000003 	bne	3480fb08 <get_device_and_partition+0x21c>
				tmpinfo = *info;
3480faf8:	e3a02050 	mov	r2, #80	; 0x50
3480fafc:	e1a01004 	mov	r1, r4
3480fb00:	e28d0010 	add	r0, sp, #16
3480fb04:	eb00303c 	bl	3481bbfc <memcpy>
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
3480fb08:	e2855001 	add	r5, r5, #1
3480fb0c:	e3550011 	cmp	r5, #17
3480fb10:	0a00000b 	beq	3480fb44 <get_device_and_partition+0x258>
			ret = get_partition_info(*dev_desc, p, info);
3480fb14:	e59d3004 	ldr	r3, [sp, #4]
3480fb18:	e1a02004 	mov	r2, r4
3480fb1c:	e1a01005 	mov	r1, r5
3480fb20:	e5930000 	ldr	r0, [r3]
3480fb24:	ebffff42 	bl	3480f834 <get_partition_info>
			if (ret)
3480fb28:	e2506000 	subs	r6, r0, #0
3480fb2c:	1afffff5 	bne	3480fb08 <get_device_and_partition+0x21c>
3480fb30:	eaffffe9 	b	3480fadc <get_device_and_partition+0x1f0>
			if (info->bootable)
3480fb34:	e3520000 	cmp	r2, #0
3480fb38:	e1a0b005 	mov	fp, r5
3480fb3c:	0affffeb 	beq	3480faf0 <get_device_and_partition+0x204>
3480fb40:	ea000005 	b	3480fb5c <get_device_and_partition+0x270>
		}
		/* If we found any acceptable partition */
		if (part) {
3480fb44:	e35b0000 	cmp	fp, #0
3480fb48:	0a00000e 	beq	3480fb88 <get_device_and_partition+0x29c>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
3480fb4c:	e3a02050 	mov	r2, #80	; 0x50
3480fb50:	e28d1010 	add	r1, sp, #16
3480fb54:	e1a00004 	mov	r0, r4
3480fb58:	eb003027 	bl	3481bbfc <memcpy>
		} else {
			printf("** No valid partitions found **\n");
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480fb5c:	e284402c 	add	r4, r4, #44	; 0x2c
3480fb60:	e3a02020 	mov	r2, #32
3480fb64:	e59f105c 	ldr	r1, [pc, #92]	; 3480fbc8 <get_device_and_partition+0x2dc>
3480fb68:	e1a00004 	mov	r0, r4
3480fb6c:	eb002f35 	bl	3481b848 <strncmp>
3480fb70:	e3500000 	cmp	r0, #0
3480fb74:	0a000006 	beq	3480fb94 <get_device_and_partition+0x2a8>
		printf("** Invalid partition type \"%.32s\""
3480fb78:	e1a01004 	mov	r1, r4
3480fb7c:	e59f0048 	ldr	r0, [pc, #72]	; 3480fbcc <get_device_and_partition+0x2e0>
3480fb80:	ebffe705 	bl	3480979c <printf>
3480fb84:	eaffffa0 	b	3480fa0c <get_device_and_partition+0x120>
			printf("** No valid partitions found **\n");
3480fb88:	e59f0040 	ldr	r0, [pc, #64]	; 3480fbd0 <get_device_and_partition+0x2e4>
			ret = get_partition_info(*dev_desc, p, info);
3480fb8c:	e1a0b006 	mov	fp, r6
			printf("** No valid partitions found **\n");
3480fb90:	ebffe701 	bl	3480979c <printf>

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
3480fb94:	e1a00007 	mov	r0, r7
3480fb98:	ebffe844 	bl	34809cb0 <free>
	return ret;
}
3480fb9c:	e1a0000b 	mov	r0, fp
3480fba0:	e28dd060 	add	sp, sp, #96	; 0x60
3480fba4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480fba8:	34825979 	.word	0x34825979
3480fbac:	34825984 	.word	0x34825984
3480fbb0:	348261af 	.word	0x348261af
3480fbb4:	3482599f 	.word	0x3482599f
3480fbb8:	348259a4 	.word	0x348259a4
3480fbbc:	348259cd 	.word	0x348259cd
3480fbc0:	348259ec 	.word	0x348259ec
3480fbc4:	34825a0e 	.word	0x34825a0e
3480fbc8:	34825509 	.word	0x34825509
3480fbcc:	34825a4b 	.word	0x34825a4b
3480fbd0:	34825a2a 	.word	0x34825a2a

3480fbd4 <le32_to_int>:
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480fbd4:	e5d03002 	ldrb	r3, [r0, #2]
    return ((le32[3] << 24) +
3480fbd8:	e5d02003 	ldrb	r2, [r0, #3]
	    (le32[2] << 16) +
3480fbdc:	e1a03803 	lsl	r3, r3, #16
    return ((le32[3] << 24) +
3480fbe0:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[1] << 8) +
3480fbe4:	e5d02001 	ldrb	r2, [r0, #1]
3480fbe8:	e5d00000 	ldrb	r0, [r0]
	    (le32[2] << 16) +
3480fbec:	e0833402 	add	r3, r3, r2, lsl #8
	     le32[0]
	   );
}
3480fbf0:	e0830000 	add	r0, r3, r0
3480fbf4:	e12fff1e 	bx	lr

3480fbf8 <is_extended>:

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
3480fbf8:	e3c03080 	bic	r3, r0, #128	; 0x80
	    part_type == 0xf ||
	    part_type == 0x85);
}
3480fbfc:	e350000f 	cmp	r0, #15
3480fc00:	13530005 	cmpne	r3, #5
3480fc04:	03a00001 	moveq	r0, #1
3480fc08:	13a00000 	movne	r0, #0
3480fc0c:	e12fff1e 	bx	lr

3480fc10 <test_block_type>:
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480fc10:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
3480fc14:	e3530055 	cmp	r3, #85	; 0x55
3480fc18:	1a000011 	bne	3480fc64 <test_block_type+0x54>
3480fc1c:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
3480fc20:	e35300aa 	cmp	r3, #170	; 0xaa
3480fc24:	1a00000e 	bne	3480fc64 <test_block_type+0x54>
{
3480fc28:	e92d4010 	push	{r4, lr}
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
3480fc2c:	e3a02003 	mov	r2, #3
3480fc30:	e1a04000 	mov	r4, r0
3480fc34:	e59f1038 	ldr	r1, [pc, #56]	; 3480fc74 <test_block_type+0x64>
3480fc38:	e2800036 	add	r0, r0, #54	; 0x36
3480fc3c:	eb002f01 	bl	3481b848 <strncmp>
3480fc40:	e3500000 	cmp	r0, #0
3480fc44:	0a000008 	beq	3480fc6c <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
3480fc48:	e3a02005 	mov	r2, #5
3480fc4c:	e59f1024 	ldr	r1, [pc, #36]	; 3480fc78 <test_block_type+0x68>
3480fc50:	e2840052 	add	r0, r4, #82	; 0x52
3480fc54:	eb002efb 	bl	3481b848 <strncmp>
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
3480fc58:	e16f0f10 	clz	r0, r0
3480fc5c:	e1a002a0 	lsr	r0, r0, #5
3480fc60:	e8bd8010 	pop	{r4, pc}
		return (-1);
3480fc64:	e3e00000 	mvn	r0, #0
3480fc68:	e12fff1e 	bx	lr
		return DOS_PBR; /* is PBR */
3480fc6c:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
3480fc70:	e8bd8010 	pop	{r4, pc}
3480fc74:	34825a80 	.word	0x34825a80
3480fc78:	34825a84 	.word	0x34825a84

3480fc7c <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480fc7c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480fc80:	e1a09003 	mov	r9, r3
3480fc84:	e28db01c 	add	fp, sp, #28
3480fc88:	e24dd020 	sub	sp, sp, #32
3480fc8c:	e1a07000 	mov	r7, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fc90:	e5903014 	ldr	r3, [r0, #20]
{
3480fc94:	e1a06001 	mov	r6, r1
3480fc98:	e50b2024 	str	r2, [fp, #-36]	; 0xffffffdc
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fc9c:	e3a02001 	mov	r2, #1
3480fca0:	e5904060 	ldr	r4, [r0, #96]	; 0x60
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fca4:	e283303f 	add	r3, r3, #63	; 0x3f
	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fca8:	e5900004 	ldr	r0, [r0, #4]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fcac:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480fcb0:	e2833040 	add	r3, r3, #64	; 0x40
3480fcb4:	e04dd003 	sub	sp, sp, r3
3480fcb8:	e28d504f 	add	r5, sp, #79	; 0x4f
3480fcbc:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fcc0:	e1a03005 	mov	r3, r5
3480fcc4:	e12fff34 	blx	r4
3480fcc8:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480fccc:	11a02006 	movne	r2, r6
3480fcd0:	15971004 	ldrne	r1, [r7, #4]
3480fcd4:	159f0154 	ldrne	r0, [pc, #340]	; 3480fe30 <print_partition_extended+0x1b4>
3480fcd8:	1a000006 	bne	3480fcf8 <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
3480fcdc:	e1a00005 	mov	r0, r5
3480fce0:	ebffffca 	bl	3480fc10 <test_block_type>
	if (i != DOS_MBR) {
3480fce4:	e3500000 	cmp	r0, #0
3480fce8:	0a000004 	beq	3480fd00 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480fcec:	e5d521ff 	ldrb	r2, [r5, #511]	; 0x1ff
3480fcf0:	e5d511fe 	ldrb	r1, [r5, #510]	; 0x1fe
3480fcf4:	e59f0138 	ldr	r0, [pc, #312]	; 3480fe34 <print_partition_extended+0x1b8>
3480fcf8:	ebffe6a7 	bl	3480979c <printf>
			buffer[DOS_PART_MAGIC_OFFSET],
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
3480fcfc:	ea000049 	b	3480fe28 <print_partition_extended+0x1ac>
3480fd00:	e2854f71 	add	r4, r5, #452	; 0x1c4
3480fd04:	e2853f81 	add	r3, r5, #516	; 0x204
3480fd08:	e2844002 	add	r4, r4, #2
3480fd0c:	e2833002 	add	r3, r3, #2
	if (i != DOS_MBR) {
3480fd10:	e1a05004 	mov	r5, r4
3480fd14:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
3480fd18:	e555a004 	ldrb	sl, [r5, #-4]
3480fd1c:	e35a0000 	cmp	sl, #0
3480fd20:	0a000028 	beq	3480fdc8 <print_partition_extended+0x14c>
3480fd24:	e3560000 	cmp	r6, #0
3480fd28:	0a000009 	beq	3480fd54 <print_partition_extended+0xd8>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
3480fd2c:	e1a0000a 	mov	r0, sl
3480fd30:	ebffffb0 	bl	3480fbf8 <is_extended>
3480fd34:	e3500000 	cmp	r0, #0
3480fd38:	0a000005 	beq	3480fd54 <print_partition_extended+0xd8>
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fd3c:	e5550004 	ldrb	r0, [r5, #-4]
		if ((ext_part_sector == 0) ||
3480fd40:	e3500000 	cmp	r0, #0
3480fd44:	0a000021 	beq	3480fdd0 <print_partition_extended+0x154>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fd48:	ebffffaa 	bl	3480fbf8 <is_extended>
3480fd4c:	e3500000 	cmp	r0, #0
3480fd50:	ea00001d 	b	3480fdcc <print_partition_extended+0x150>
	int lba_start = ext_part_sector + le32_to_int (p->start4);
3480fd54:	e1a00005 	mov	r0, r5
3480fd58:	ebffff9d 	bl	3480fbd4 <le32_to_int>
3480fd5c:	e0862000 	add	r2, r6, r0
	int lba_size  = le32_to_int (p->size4);
3480fd60:	e2850004 	add	r0, r5, #4
	int lba_start = ext_part_sector + le32_to_int (p->start4);
3480fd64:	e50b202c 	str	r2, [fp, #-44]	; 0xffffffd4
	int lba_size  = le32_to_int (p->size4);
3480fd68:	ebffff99 	bl	3480fbd4 <le32_to_int>
3480fd6c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
		(is_extended(p->sys_ind) ? " Extd" : ""),
3480fd70:	e1a0000a 	mov	r0, sl
3480fd74:	ebffff9f 	bl	3480fbf8 <is_extended>
	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
3480fd78:	e555c008 	ldrb	ip, [r5, #-8]
3480fd7c:	e3500000 	cmp	r0, #0
3480fd80:	e59f20b0 	ldr	r2, [pc, #176]	; 3480fe38 <print_partition_extended+0x1bc>
3480fd84:	e59f30b0 	ldr	r3, [pc, #176]	; 3480fe3c <print_partition_extended+0x1c0>
3480fd88:	e59f10b0 	ldr	r1, [pc, #176]	; 3480fe40 <print_partition_extended+0x1c4>
3480fd8c:	01a03002 	moveq	r3, r2
3480fd90:	e35c0080 	cmp	ip, #128	; 0x80
3480fd94:	11a01002 	movne	r1, r2
3480fd98:	e1a00003 	mov	r0, r3
3480fd9c:	e98d0003 	stmib	sp, {r0, r1}
3480fda0:	e1a01009 	mov	r1, r9
3480fda4:	e58da000 	str	sl, [sp]
3480fda8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
3480fdac:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
3480fdb0:	e59f008c 	ldr	r0, [pc, #140]	; 3480fe44 <print_partition_extended+0x1c8>
3480fdb4:	ebffe678 	bl	3480979c <printf>
		if ((ext_part_sector == 0) ||
3480fdb8:	e3560000 	cmp	r6, #0
3480fdbc:	1affffde 	bne	3480fd3c <print_partition_extended+0xc0>
			part_num++;
3480fdc0:	e2899001 	add	r9, r9, #1
3480fdc4:	ea000001 	b	3480fdd0 <print_partition_extended+0x154>
		if ((ext_part_sector == 0) ||
3480fdc8:	e3560000 	cmp	r6, #0
3480fdcc:	0afffffb 	beq	3480fdc0 <print_partition_extended+0x144>
	for (i = 0; i < 4; i++, pt++) {
3480fdd0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
3480fdd4:	e2855010 	add	r5, r5, #16
3480fdd8:	e1550003 	cmp	r5, r3
3480fddc:	1affffcd 	bne	3480fd18 <print_partition_extended+0x9c>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3480fde0:	e5540004 	ldrb	r0, [r4, #-4]
3480fde4:	ebffff83 	bl	3480fbf8 <is_extended>
3480fde8:	e3500000 	cmp	r0, #0
3480fdec:	0a000009 	beq	3480fe18 <print_partition_extended+0x19c>
			int lba_start = le32_to_int (pt->start4) + relative;
3480fdf0:	e1a00004 	mov	r0, r4
3480fdf4:	ebffff76 	bl	3480fbd4 <le32_to_int>
3480fdf8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc

			print_partition_extended (dev_desc, lba_start,
3480fdfc:	e3560000 	cmp	r6, #0
3480fe00:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
			int lba_start = le32_to_int (pt->start4) + relative;
3480fe04:	e0801003 	add	r1, r0, r3
			print_partition_extended (dev_desc, lba_start,
3480fe08:	e1a03009 	mov	r3, r9
3480fe0c:	01a02001 	moveq	r2, r1
3480fe10:	e1a00007 	mov	r0, r7
3480fe14:	ebffff98 	bl	3480fc7c <print_partition_extended>
	for (i = 0; i < 4; i++, pt++) {
3480fe18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
3480fe1c:	e2844010 	add	r4, r4, #16
3480fe20:	e1540003 	cmp	r4, r3
3480fe24:	1affffed 	bne	3480fde0 <print_partition_extended+0x164>
						  part_num);
		}
	}

	return;
}
3480fe28:	e24bd01c 	sub	sp, fp, #28
3480fe2c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480fe30:	34825a96 	.word	0x34825a96
3480fe34:	34825ac1 	.word	0x34825ac1
3480fe38:	34822afd 	.word	0x34822afd
3480fe3c:	34825a8a 	.word	0x34825a8a
3480fe40:	34825a90 	.word	0x34825a90
3480fe44:	34825ae6 	.word	0x34825ae6

3480fe48 <get_partition_info_extended.constprop.2>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fe48:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480fe4c:	e1a05003 	mov	r5, r3
3480fe50:	e28db01c 	add	fp, sp, #28
3480fe54:	e24dd018 	sub	sp, sp, #24
3480fe58:	e1a07000 	mov	r7, r0
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fe5c:	e5903014 	ldr	r3, [r0, #20]
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fe60:	e50b2024 	str	r2, [fp, #-36]	; 0xffffffdc
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fe64:	e3a02001 	mov	r2, #1
3480fe68:	e5906060 	ldr	r6, [r0, #96]	; 0x60
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fe6c:	e283303f 	add	r3, r3, #63	; 0x3f
	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fe70:	e5900004 	ldr	r0, [r0, #4]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fe74:	e3c3303f 	bic	r3, r3, #63	; 0x3f
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fe78:	e50b1020 	str	r1, [fp, #-32]	; 0xffffffe0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fe7c:	e2833040 	add	r3, r3, #64	; 0x40
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fe80:	e59b9008 	ldr	r9, [fp, #8]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fe84:	e04dd003 	sub	sp, sp, r3
3480fe88:	e28d4047 	add	r4, sp, #71	; 0x47
3480fe8c:	e3c4403f 	bic	r4, r4, #63	; 0x3f
	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fe90:	e1a03004 	mov	r3, r4
3480fe94:	e12fff36 	blx	r6
3480fe98:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480fe9c:	151b2020 	ldrne	r2, [fp, #-32]	; 0xffffffe0
3480fea0:	15971004 	ldrne	r1, [r7, #4]
3480fea4:	159f0200 	ldrne	r0, [pc, #512]	; 348100ac <get_partition_info_extended.constprop.2+0x264>
3480fea8:	1a000006 	bne	3480fec8 <get_partition_info_extended.constprop.2+0x80>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
3480feac:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
3480feb0:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
3480feb4:	e3510055 	cmp	r1, #85	; 0x55
3480feb8:	1a000001 	bne	3480fec4 <get_partition_info_extended.constprop.2+0x7c>
3480febc:	e35200aa 	cmp	r2, #170	; 0xaa
3480fec0:	0a000002 	beq	3480fed0 <get_partition_info_extended.constprop.2+0x88>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480fec4:	e59f01e4 	ldr	r0, [pc, #484]	; 348100b0 <get_partition_info_extended.constprop.2+0x268>
3480fec8:	ebffe633 	bl	3480979c <printf>
3480fecc:	ea000072 	b	3481009c <get_partition_info_extended.constprop.2+0x254>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480fed0:	e2843f6f 	add	r3, r4, #444	; 0x1bc
3480fed4:	e2844f7f 	add	r4, r4, #508	; 0x1fc
3480fed8:	e2833002 	add	r3, r3, #2
3480fedc:	e2844002 	add	r4, r4, #2
3480fee0:	e1a06003 	mov	r6, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
3480fee4:	e5d62000 	ldrb	r2, [r6]
3480fee8:	e312007f 	tst	r2, #127	; 0x7f
3480feec:	1a000042 	bne	3480fffc <get_partition_info_extended.constprop.2+0x1b4>
		    (pt->sys_ind != 0) &&
3480fef0:	e5d60004 	ldrb	r0, [r6, #4]
3480fef4:	e59b1004 	ldr	r1, [fp, #4]
3480fef8:	e2902000 	adds	r2, r0, #0
3480fefc:	13a02001 	movne	r2, #1
3480ff00:	e1550001 	cmp	r5, r1
3480ff04:	13a02000 	movne	r2, #0
3480ff08:	e3520000 	cmp	r2, #0
3480ff0c:	0a00003a 	beq	3480fffc <get_partition_info_extended.constprop.2+0x1b4>
3480ff10:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
3480ff14:	ebffff37 	bl	3480fbf8 <is_extended>
		    (part_num == which_part) &&
3480ff18:	e250a000 	subs	sl, r0, #0
3480ff1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
3480ff20:	1a000035 	bne	3480fffc <get_partition_info_extended.constprop.2+0x1b4>
			info->blksz = 512;
3480ff24:	e3a03c02 	mov	r3, #512	; 0x200
			info->start = ext_part_sector + le32_to_int (pt->start4);
3480ff28:	e2860008 	add	r0, r6, #8
			info->blksz = 512;
3480ff2c:	e5893008 	str	r3, [r9, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
3480ff30:	ebffff27 	bl	3480fbd4 <le32_to_int>
3480ff34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
3480ff38:	e0830000 	add	r0, r3, r0
3480ff3c:	e5890000 	str	r0, [r9]
			info->size  = le32_to_int (pt->size4);
3480ff40:	e286000c 	add	r0, r6, #12
3480ff44:	ebffff22 	bl	3480fbd4 <le32_to_int>
			switch(dev_desc->if_type) {
3480ff48:	e5973000 	ldr	r3, [r7]
			info->size  = le32_to_int (pt->size4);
3480ff4c:	e5890004 	str	r0, [r9, #4]
3480ff50:	e289000c 	add	r0, r9, #12
3480ff54:	e5972004 	ldr	r2, [r7, #4]
			switch(dev_desc->if_type) {
3480ff58:	e2433001 	sub	r3, r3, #1
3480ff5c:	e3530007 	cmp	r3, #7
3480ff60:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480ff64:	ea000017 	b	3480ffc8 <get_partition_info_extended.constprop.2+0x180>
3480ff68:	3480ff88 	.word	0x3480ff88
3480ff6c:	3480ff98 	.word	0x3480ff98
3480ff70:	3480ff88 	.word	0x3480ff88
3480ff74:	3480ffa8 	.word	0x3480ffa8
3480ff78:	3480ffb8 	.word	0x3480ffb8
3480ff7c:	3480ffc8 	.word	0x3480ffc8
3480ff80:	3480ffc8 	.word	0x3480ffc8
3480ff84:	3480ff88 	.word	0x3480ff88
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
3480ff88:	e1a03005 	mov	r3, r5
3480ff8c:	e2822061 	add	r2, r2, #97	; 0x61
3480ff90:	e59f111c 	ldr	r1, [pc, #284]	; 348100b4 <get_partition_info_extended.constprop.2+0x26c>
3480ff94:	ea00000e 	b	3480ffd4 <get_partition_info_extended.constprop.2+0x18c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
3480ff98:	e1a03005 	mov	r3, r5
3480ff9c:	e2822061 	add	r2, r2, #97	; 0x61
3480ffa0:	e59f1110 	ldr	r1, [pc, #272]	; 348100b8 <get_partition_info_extended.constprop.2+0x270>
3480ffa4:	ea00000a 	b	3480ffd4 <get_partition_info_extended.constprop.2+0x18c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
3480ffa8:	e1a03005 	mov	r3, r5
3480ffac:	e2822061 	add	r2, r2, #97	; 0x61
3480ffb0:	e59f1104 	ldr	r1, [pc, #260]	; 348100bc <get_partition_info_extended.constprop.2+0x274>
3480ffb4:	ea000006 	b	3480ffd4 <get_partition_info_extended.constprop.2+0x18c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
3480ffb8:	e1a03005 	mov	r3, r5
3480ffbc:	e2822061 	add	r2, r2, #97	; 0x61
3480ffc0:	e59f10f8 	ldr	r1, [pc, #248]	; 348100c0 <get_partition_info_extended.constprop.2+0x278>
3480ffc4:	ea000002 	b	3480ffd4 <get_partition_info_extended.constprop.2+0x18c>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
3480ffc8:	e59f10f4 	ldr	r1, [pc, #244]	; 348100c4 <get_partition_info_extended.constprop.2+0x27c>
3480ffcc:	e1a03005 	mov	r3, r5
3480ffd0:	e2822061 	add	r2, r2, #97	; 0x61
3480ffd4:	eb00328b 	bl	3481ca08 <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
3480ffd8:	e59f10e8 	ldr	r1, [pc, #232]	; 348100c8 <get_partition_info_extended.constprop.2+0x280>
3480ffdc:	e289002c 	add	r0, r9, #44	; 0x2c
3480ffe0:	eb003288 	bl	3481ca08 <sprintf>
	return p->boot_ind == 0x80;
3480ffe4:	e5d63000 	ldrb	r3, [r6]
3480ffe8:	e2433080 	sub	r3, r3, #128	; 0x80
3480ffec:	e16f3f13 	clz	r3, r3
3480fff0:	e1a032a3 	lsr	r3, r3, #5
			info->bootable = is_bootable(pt);
3480fff4:	e589304c 	str	r3, [r9, #76]	; 0x4c
3480fff8:	ea000028 	b	348100a0 <get_partition_info_extended.constprop.2+0x258>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480fffc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
34810000:	e3520000 	cmp	r2, #0
34810004:	0a000007 	beq	34810028 <get_partition_info_extended.constprop.2+0x1e0>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
34810008:	e5d60004 	ldrb	r0, [r6, #4]
		if ((ext_part_sector == 0) ||
3481000c:	e3500000 	cmp	r0, #0
34810010:	0a000005 	beq	3481002c <get_partition_info_extended.constprop.2+0x1e4>
34810014:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
34810018:	ebfffef6 	bl	3480fbf8 <is_extended>
3481001c:	e3500000 	cmp	r0, #0
34810020:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
34810024:	1a000000 	bne	3481002c <get_partition_info_extended.constprop.2+0x1e4>
			part_num++;
34810028:	e2855001 	add	r5, r5, #1
	for (i = 0; i < 4; i++, pt++) {
3481002c:	e2866010 	add	r6, r6, #16
34810030:	e1560004 	cmp	r6, r4
34810034:	1affffaa 	bne	3480fee4 <get_partition_info_extended.constprop.2+0x9c>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
34810038:	e5d30004 	ldrb	r0, [r3, #4]
3481003c:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
34810040:	ebfffeec 	bl	3480fbf8 <is_extended>
34810044:	e3500000 	cmp	r0, #0
34810048:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
3481004c:	0a00000f 	beq	34810090 <get_partition_info_extended.constprop.2+0x248>
			int lba_start = le32_to_int (pt->start4) + relative;
34810050:	e2830008 	add	r0, r3, #8
34810054:	ebfffede 	bl	3480fbd4 <le32_to_int>
34810058:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc

			return get_partition_info_extended (dev_desc, lba_start,
3481005c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
34810060:	e58d9004 	str	r9, [sp, #4]
			int lba_start = le32_to_int (pt->start4) + relative;
34810064:	e0801003 	add	r1, r0, r3
			return get_partition_info_extended (dev_desc, lba_start,
34810068:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
3481006c:	e59b3004 	ldr	r3, [fp, #4]
34810070:	e3500000 	cmp	r0, #0
34810074:	e1a00007 	mov	r0, r7
34810078:	e58d3000 	str	r3, [sp]
3481007c:	01a02001 	moveq	r2, r1
34810080:	e1a03005 	mov	r3, r5
34810084:	ebffff6f 	bl	3480fe48 <get_partition_info_extended.constprop.2>
34810088:	e1a0a000 	mov	sl, r0
3481008c:	ea000003 	b	348100a0 <get_partition_info_extended.constprop.2+0x258>
	for (i = 0; i < 4; i++, pt++) {
34810090:	e2833010 	add	r3, r3, #16
34810094:	e1530004 	cmp	r3, r4
34810098:	1affffe6 	bne	34810038 <get_partition_info_extended.constprop.2+0x1f0>
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
3481009c:	e3e0a000 	mvn	sl, #0
}
348100a0:	e1a0000a 	mov	r0, sl
348100a4:	e24bd01c 	sub	sp, fp, #28
348100a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348100ac:	34825a96 	.word	0x34825a96
348100b0:	34825ac1 	.word	0x34825ac1
348100b4:	34825afe 	.word	0x34825afe
348100b8:	34825b05 	.word	0x34825b05
348100bc:	34825b0c 	.word	0x34825b0c
348100c0:	34825b15 	.word	0x34825b15
348100c4:	34825b1e 	.word	0x34825b1e
348100c8:	34825509 	.word	0x34825509

348100cc <test_part_dos>:
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
348100cc:	e5903014 	ldr	r3, [r0, #20]
	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348100d0:	e3a02001 	mov	r2, #1
{
348100d4:	e92d4830 	push	{r4, r5, fp, lr}
348100d8:	e28db00c 	add	fp, sp, #12
	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348100dc:	e5905060 	ldr	r5, [r0, #96]	; 0x60
348100e0:	e3a01000 	mov	r1, #0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
348100e4:	e283303f 	add	r3, r3, #63	; 0x3f
348100e8:	e3c3303f 	bic	r3, r3, #63	; 0x3f
	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348100ec:	e5900004 	ldr	r0, [r0, #4]
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
348100f0:	e2833040 	add	r3, r3, #64	; 0x40
348100f4:	e04dd003 	sub	sp, sp, r3
348100f8:	e28d403f 	add	r4, sp, #63	; 0x3f
348100fc:	e3c4403f 	bic	r4, r4, #63	; 0x3f
	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
34810100:	e1a03004 	mov	r3, r4
34810104:	e12fff35 	blx	r5
34810108:	e3500001 	cmp	r0, #1
		return -1;
3481010c:	13e00000 	mvnne	r0, #0
	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
34810110:	1a000004 	bne	34810128 <test_part_dos+0x5c>
	if (test_block_type(buffer) != DOS_MBR)
34810114:	e1a00004 	mov	r0, r4
34810118:	ebfffebc 	bl	3480fc10 <test_block_type>
3481011c:	e2900000 	adds	r0, r0, #0
34810120:	13a00001 	movne	r0, #1
34810124:	e2600000 	rsb	r0, r0, #0
}
34810128:	e24bd00c 	sub	sp, fp, #12
3481012c:	e8bd8830 	pop	{r4, r5, fp, pc}

34810130 <print_part_dos>:

void print_part_dos (block_dev_desc_t *dev_desc)
{
34810130:	e92d4010 	push	{r4, lr}
34810134:	e1a04000 	mov	r4, r0
	printf ("Partition     Start Sector     Num Sectors     Type\n");
34810138:	e59f0018 	ldr	r0, [pc, #24]	; 34810158 <print_part_dos+0x28>
3481013c:	ebffe596 	bl	3480979c <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
34810140:	e3a02000 	mov	r2, #0
34810144:	e1a00004 	mov	r0, r4
34810148:	e3a03001 	mov	r3, #1
3481014c:	e1a01002 	mov	r1, r2
}
34810150:	e8bd4010 	pop	{r4, lr}
	print_partition_extended (dev_desc, 0, 0, 1);
34810154:	eafffec8 	b	3480fc7c <print_partition_extended>
34810158:	34825b25 	.word	0x34825b25

3481015c <get_partition_info_dos>:

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
3481015c:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
34810160:	e3a03001 	mov	r3, #1
34810164:	e88d0006 	stm	sp, {r1, r2}
34810168:	e3a02000 	mov	r2, #0
3481016c:	e1a01002 	mov	r1, r2
34810170:	ebffff34 	bl	3480fe48 <get_partition_info_extended.constprop.2>
}
34810174:	e28dd00c 	add	sp, sp, #12
34810178:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

3481017c <s5p_gpio_cfg_pin>:

void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
{
	unsigned int value;

	value = readl(&bank->con);
3481017c:	e5903000 	ldr	r3, [r0]
	value &= ~CON_MASK(gpio);
34810180:	e1a01101 	lsl	r1, r1, #2
34810184:	e3a0c00f 	mov	ip, #15
34810188:	e1c3311c 	bic	r3, r3, ip, lsl r1
	value |= CON_SFR(gpio, cfg);
3481018c:	e1832112 	orr	r2, r3, r2, lsl r1
	writel(value, &bank->con);
34810190:	e5802000 	str	r2, [r0]
34810194:	e12fff1e 	bx	lr

34810198 <s5p_gpio_direction_output>:
}

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
34810198:	e92d4070 	push	{r4, r5, r6, lr}
3481019c:	e1a04000 	mov	r4, r0
348101a0:	e1a05002 	mov	r5, r2
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
348101a4:	e3a02001 	mov	r2, #1
{
348101a8:	e1a06001 	mov	r6, r1
	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
348101ac:	ebfffff2 	bl	3481017c <s5p_gpio_cfg_pin>

	value = readl(&bank->dat);
348101b0:	e5943004 	ldr	r3, [r4, #4]
	value &= ~DAT_MASK(gpio);
348101b4:	e3a01001 	mov	r1, #1
	if (en)
348101b8:	e3550000 	cmp	r5, #0
	value &= ~DAT_MASK(gpio);
348101bc:	e1a01611 	lsl	r1, r1, r6
348101c0:	e1c33001 	bic	r3, r3, r1
		value |= DAT_SET(gpio);
348101c4:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
348101c8:	e5843004 	str	r3, [r4, #4]
348101cc:	e8bd8070 	pop	{r4, r5, r6, pc}

348101d0 <s5p_gpio_direction_input>:
}

void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
{
	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
348101d0:	e3a02000 	mov	r2, #0
348101d4:	eaffffe8 	b	3481017c <s5p_gpio_cfg_pin>

348101d8 <s5p_gpio_set_value>:

void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
348101d8:	e5903004 	ldr	r3, [r0, #4]
	value &= ~DAT_MASK(gpio);
348101dc:	e3a0c001 	mov	ip, #1
	if (en)
348101e0:	e3520000 	cmp	r2, #0
	value &= ~DAT_MASK(gpio);
348101e4:	e1a0111c 	lsl	r1, ip, r1
348101e8:	e1c33001 	bic	r3, r3, r1
		value |= DAT_SET(gpio);
348101ec:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
348101f0:	e5803004 	str	r3, [r0, #4]
348101f4:	e12fff1e 	bx	lr

348101f8 <s5p_gpio_get_value>:

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
348101f8:	e5903004 	ldr	r3, [r0, #4]
	return !!(value & DAT_MASK(gpio));
348101fc:	e3a02001 	mov	r2, #1
34810200:	e0133112 	ands	r3, r3, r2, lsl r1
}
34810204:	11a00002 	movne	r0, r2
34810208:	03a00000 	moveq	r0, #0
3481020c:	e12fff1e 	bx	lr

34810210 <s5p_gpio_set_pull>:

void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->pull);
34810210:	e5903008 	ldr	r3, [r0, #8]
	value &= ~PULL_MASK(gpio);
34810214:	e1a01081 	lsl	r1, r1, #1
34810218:	e3a0c003 	mov	ip, #3
3481021c:	e1c3311c 	bic	r3, r3, ip, lsl r1

	switch (mode) {
34810220:	e242c001 	sub	ip, r2, #1
34810224:	e35c0001 	cmp	ip, #1
	case GPIO_PULL_DOWN:
	case GPIO_PULL_UP:
		value |= PULL_MODE(gpio, mode);
34810228:	91833112 	orrls	r3, r3, r2, lsl r1
		break;
	default:
		break;
	}

	writel(value, &bank->pull);
3481022c:	e5803008 	str	r3, [r0, #8]
34810230:	e12fff1e 	bx	lr

34810234 <s5p_gpio_set_drv>:

void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
34810234:	e590300c 	ldr	r3, [r0, #12]
	value &= ~DRV_MASK(gpio);

	switch (mode) {
34810238:	e3520003 	cmp	r2, #3
3481023c:	812fff1e 	bxhi	lr
	value &= ~DRV_MASK(gpio);
34810240:	e1a01081 	lsl	r1, r1, #1
34810244:	e3a0c003 	mov	ip, #3
34810248:	e1c3311c 	bic	r3, r3, ip, lsl r1
	case GPIO_DRV_1X:
	case GPIO_DRV_2X:
	case GPIO_DRV_3X:
	case GPIO_DRV_4X:
		value |= DRV_SET(gpio, mode);
3481024c:	e1832112 	orr	r2, r3, r2, lsl r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
34810250:	e580200c 	str	r2, [r0, #12]
34810254:	e12fff1e 	bx	lr

34810258 <s5p_gpio_set_rate>:

void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
34810258:	e590c00c 	ldr	ip, [r0, #12]
	value &= ~RATE_MASK(gpio);

	switch (mode) {
3481025c:	e3520001 	cmp	r2, #1
34810260:	812fff1e 	bxhi	lr
	value &= ~RATE_MASK(gpio);
34810264:	e3a03001 	mov	r3, #1
34810268:	e2811010 	add	r1, r1, #16
3481026c:	e1a01113 	lsl	r1, r3, r1
34810270:	e1cc3001 	bic	r3, ip, r1
	case GPIO_DRV_FAST:
	case GPIO_DRV_SLOW:
		value |= RATE_SET(gpio);
34810274:	e1831001 	orr	r1, r3, r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
34810278:	e580100c 	str	r1, [r0, #12]
3481027c:	e12fff1e 	bx	lr

34810280 <s5p_gpio_get_bank>:
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
34810280:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810284:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
}
34810288:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
3481028c:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810290:	e12fff1e 	bx	lr

34810294 <s5p_gpio_get_pin>:

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
}
34810294:	e2000007 	and	r0, r0, #7
34810298:	e12fff1e 	bx	lr

3481029c <gpio_request>:
/* Common GPIO API */

int gpio_request(unsigned gpio, const char *label)
{
	return 0;
}
3481029c:	e3a00000 	mov	r0, #0
348102a0:	e12fff1e 	bx	lr

348102a4 <gpio_free>:

int gpio_free(unsigned gpio)
{
	return 0;
}
348102a4:	e3a00000 	mov	r0, #0
348102a8:	e12fff1e 	bx	lr

348102ac <gpio_direction_input>:
	int bank = gpio / GPIO_PER_BANK;
348102ac:	e1a031a0 	lsr	r3, r0, #3

int gpio_direction_input(unsigned gpio)
{
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
348102b0:	e2001007 	and	r1, r0, #7
{
348102b4:	e92d4010 	push	{r4, lr}
	bank *= sizeof(struct s5p_gpio_bank);
348102b8:	e1a03283 	lsl	r3, r3, #5
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
348102bc:	e283020e 	add	r0, r3, #-536870912	; 0xe0000000
348102c0:	e2800602 	add	r0, r0, #2097152	; 0x200000
348102c4:	ebffffc1 	bl	348101d0 <s5p_gpio_direction_input>
				s5p_gpio_get_pin(gpio));
	return 0;
}
348102c8:	e3a00000 	mov	r0, #0
348102cc:	e8bd8010 	pop	{r4, pc}

348102d0 <gpio_direction_output>:
	int bank = gpio / GPIO_PER_BANK;
348102d0:	e1a031a0 	lsr	r3, r0, #3

int gpio_direction_output(unsigned gpio, int value)
{
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
348102d4:	e1a02001 	mov	r2, r1
348102d8:	e2001007 	and	r1, r0, #7
	bank *= sizeof(struct s5p_gpio_bank);
348102dc:	e1a03283 	lsl	r3, r3, #5
{
348102e0:	e92d4010 	push	{r4, lr}
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
348102e4:	e283020e 	add	r0, r3, #-536870912	; 0xe0000000
348102e8:	e2800602 	add	r0, r0, #2097152	; 0x200000
348102ec:	ebffffa9 	bl	34810198 <s5p_gpio_direction_output>
				 s5p_gpio_get_pin(gpio), value);
	return 0;
}
348102f0:	e3a00000 	mov	r0, #0
348102f4:	e8bd8010 	pop	{r4, pc}

348102f8 <gpio_get_value>:
	int bank = gpio / GPIO_PER_BANK;
348102f8:	e1a031a0 	lsr	r3, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
348102fc:	e1a03283 	lsl	r3, r3, #5
	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810300:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
34810304:	e2833602 	add	r3, r3, #2097152	; 0x200000
	value = readl(&bank->dat);
34810308:	e5933004 	ldr	r3, [r3, #4]
	return !!(value & DAT_MASK(gpio));
3481030c:	e3a02001 	mov	r2, #1
	return gpio % GPIO_PER_BANK;
34810310:	e2000007 	and	r0, r0, #7
	return !!(value & DAT_MASK(gpio));
34810314:	e0133012 	ands	r3, r3, r2, lsl r0

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
				       s5p_gpio_get_pin(gpio));
}
34810318:	11a00002 	movne	r0, r2
3481031c:	03a00000 	moveq	r0, #0
34810320:	e12fff1e 	bx	lr

34810324 <gpio_set_value>:
	int bank = gpio / GPIO_PER_BANK;
34810324:	e1a031a0 	lsr	r3, r0, #3

int gpio_set_value(unsigned gpio, int value)
{
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
34810328:	e1a02001 	mov	r2, r1
3481032c:	e2001007 	and	r1, r0, #7
	bank *= sizeof(struct s5p_gpio_bank);
34810330:	e1a03283 	lsl	r3, r3, #5
{
34810334:	e92d4010 	push	{r4, lr}
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
34810338:	e283020e 	add	r0, r3, #-536870912	; 0xe0000000
3481033c:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810340:	ebffffa4 	bl	348101d8 <s5p_gpio_set_value>
			  s5p_gpio_get_pin(gpio), value);

	return 0;
}
34810344:	e3a00000 	mov	r0, #0
34810348:	e8bd8010 	pop	{r4, pc}

3481034c <send_stop>:

/*-----------------------------------------------------------------------
 * STOP: Low -> High on SDA while SCL is High
 */
static void send_stop(void)
{
3481034c:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
34810350:	e3a01000 	mov	r1, #0
34810354:	e3a000b3 	mov	r0, #179	; 0xb3
34810358:	ebffffdc 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
3481035c:	e3a00005 	mov	r0, #5
34810360:	eb002ea9 	bl	3481be0c <udelay>
	I2C_SDA(0);
34810364:	e3a01000 	mov	r1, #0
34810368:	e3a000b0 	mov	r0, #176	; 0xb0
3481036c:	ebffffd7 	bl	348102d0 <gpio_direction_output>
	I2C_ACTIVE;
	I2C_DELAY;
34810370:	e3a00005 	mov	r0, #5
34810374:	eb002ea4 	bl	3481be0c <udelay>
	I2C_SCL(1);
34810378:	e3a01001 	mov	r1, #1
3481037c:	e3a000b3 	mov	r0, #179	; 0xb3
34810380:	ebffffd2 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
34810384:	e3a00005 	mov	r0, #5
34810388:	eb002e9f 	bl	3481be0c <udelay>
	I2C_SDA(1);
3481038c:	e3a000b0 	mov	r0, #176	; 0xb0
34810390:	ebffffc5 	bl	348102ac <gpio_direction_input>
	I2C_DELAY;
34810394:	e3a00005 	mov	r0, #5
	I2C_TRISTATE;
}
34810398:	e8bd4010 	pop	{r4, lr}
	I2C_DELAY;
3481039c:	ea002e9a 	b	3481be0c <udelay>

348103a0 <send_start>:
{
348103a0:	e92d4010 	push	{r4, lr}
	I2C_DELAY;
348103a4:	e3a00005 	mov	r0, #5
348103a8:	eb002e97 	bl	3481be0c <udelay>
	I2C_SDA(1);
348103ac:	e3a000b0 	mov	r0, #176	; 0xb0
348103b0:	ebffffbd 	bl	348102ac <gpio_direction_input>
	I2C_DELAY;
348103b4:	e3a00005 	mov	r0, #5
348103b8:	eb002e93 	bl	3481be0c <udelay>
	I2C_SCL(1);
348103bc:	e3a01001 	mov	r1, #1
348103c0:	e3a000b3 	mov	r0, #179	; 0xb3
348103c4:	ebffffc1 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348103c8:	e3a00005 	mov	r0, #5
348103cc:	eb002e8e 	bl	3481be0c <udelay>
	I2C_SDA(0);
348103d0:	e3a01000 	mov	r1, #0
348103d4:	e3a000b0 	mov	r0, #176	; 0xb0
348103d8:	ebffffbc 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348103dc:	e3a00005 	mov	r0, #5
}
348103e0:	e8bd4010 	pop	{r4, lr}
	I2C_DELAY;
348103e4:	ea002e88 	b	3481be0c <udelay>

348103e8 <write_byte>:

/*-----------------------------------------------------------------------
 * Send 8 bits and look for an acknowledgement.
 */
static int write_byte(uchar data)
{
348103e8:	e92d4070 	push	{r4, r5, r6, lr}
348103ec:	e1a05000 	mov	r5, r0
348103f0:	e3a04008 	mov	r4, #8
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
348103f4:	e3a01000 	mov	r1, #0
348103f8:	e3a000b3 	mov	r0, #179	; 0xb3
348103fc:	ebffffb3 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810400:	e3a00005 	mov	r0, #5
34810404:	eb002e80 	bl	3481be0c <udelay>
		I2C_SDA(data & 0x80);
34810408:	e3150080 	tst	r5, #128	; 0x80
3481040c:	0a000002 	beq	3481041c <write_byte+0x34>
34810410:	e3a000b0 	mov	r0, #176	; 0xb0
34810414:	ebffffa4 	bl	348102ac <gpio_direction_input>
34810418:	ea000002 	b	34810428 <write_byte+0x40>
3481041c:	e3a01000 	mov	r1, #0
34810420:	e3a000b0 	mov	r0, #176	; 0xb0
34810424:	ebffffa9 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810428:	e3a00005 	mov	r0, #5
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;

		data <<= 1;
3481042c:	e1a05085 	lsl	r5, r5, #1
		I2C_DELAY;
34810430:	eb002e75 	bl	3481be0c <udelay>
		I2C_SCL(1);
34810434:	e3a01001 	mov	r1, #1
34810438:	e3a000b3 	mov	r0, #179	; 0xb3
3481043c:	ebffffa3 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810440:	e3a00005 	mov	r0, #5
		data <<= 1;
34810444:	e6ef5075 	uxtb	r5, r5
		I2C_DELAY;
34810448:	eb002e6f 	bl	3481be0c <udelay>
		I2C_DELAY;
3481044c:	e3a00005 	mov	r0, #5
34810450:	eb002e6d 	bl	3481be0c <udelay>
	for(j = 0; j < 8; j++) {
34810454:	e2544001 	subs	r4, r4, #1
34810458:	1affffe5 	bne	348103f4 <write_byte+0xc>
	}

	/*
	 * Look for an <ACK>(negative logic) and return it.
	 */
	I2C_SCL(0);
3481045c:	e1a01004 	mov	r1, r4
34810460:	e3a000b3 	mov	r0, #179	; 0xb3
34810464:	ebffff99 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
34810468:	e3a00005 	mov	r0, #5
3481046c:	eb002e66 	bl	3481be0c <udelay>
	I2C_SDA(1);
34810470:	e3a000b0 	mov	r0, #176	; 0xb0
34810474:	ebffff8c 	bl	348102ac <gpio_direction_input>
	I2C_TRISTATE;
	I2C_DELAY;
34810478:	e3a00005 	mov	r0, #5
3481047c:	eb002e62 	bl	3481be0c <udelay>
	I2C_SCL(1);
34810480:	e3a01001 	mov	r1, #1
34810484:	e3a000b3 	mov	r0, #179	; 0xb3
34810488:	ebffff90 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
3481048c:	e3a00005 	mov	r0, #5
34810490:	eb002e5d 	bl	3481be0c <udelay>
	I2C_DELAY;
34810494:	e3a00005 	mov	r0, #5
34810498:	eb002e5b 	bl	3481be0c <udelay>
	nack = I2C_READ;
3481049c:	e3a000b0 	mov	r0, #176	; 0xb0
348104a0:	ebffff94 	bl	348102f8 <gpio_get_value>
	I2C_SCL(0);
348104a4:	e1a01004 	mov	r1, r4
	nack = I2C_READ;
348104a8:	e1a05000 	mov	r5, r0
	I2C_SCL(0);
348104ac:	e3a000b3 	mov	r0, #179	; 0xb3
348104b0:	ebffff86 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348104b4:	e3a00005 	mov	r0, #5
348104b8:	eb002e53 	bl	3481be0c <udelay>
	I2C_ACTIVE;

	return(nack);	/* not a nack is an ack */
}
348104bc:	e1a00005 	mov	r0, r5
348104c0:	e8bd8070 	pop	{r4, r5, r6, pc}

348104c4 <i2c_get_bus_num>:
 * Functions for multiple I2C bus handling
 */
unsigned int i2c_get_bus_num(void)
{
	return i2c_bus_num;
}
348104c4:	e59f3004 	ldr	r3, [pc, #4]	; 348104d0 <i2c_get_bus_num+0xc>
348104c8:	e5930000 	ldr	r0, [r3]
348104cc:	e12fff1e 	bx	lr
348104d0:	34827748 	.word	0x34827748

348104d4 <i2c_set_bus_num>:
			i2c_bus_num = bus;
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
348104d4:	e3500006 	cmp	r0, #6
		return -1;
	i2c_bus_num = bus;
348104d8:	959f300c 	ldrls	r3, [pc, #12]	; 348104ec <i2c_set_bus_num+0x18>
348104dc:	95830000 	strls	r0, [r3]
#endif
	return 0;
348104e0:	93a00000 	movls	r0, #0
		return -1;
348104e4:	83e00000 	mvnhi	r0, #0
}
348104e8:	e12fff1e 	bx	lr
348104ec:	34827748 	.word	0x34827748

348104f0 <i2c_init>:

/*-----------------------------------------------------------------------
 * Initialization
 */
void i2c_init (int speed, int slaveaddr)
{
348104f0:	e92d4010 	push	{r4, lr}
	I2C_SCL(1);
348104f4:	e3a01001 	mov	r1, #1
348104f8:	e3a000b3 	mov	r0, #179	; 0xb3
	I2C_INIT;
348104fc:	e3a04009 	mov	r4, #9
	I2C_SCL(1);
34810500:	ebffff72 	bl	348102d0 <gpio_direction_output>
	I2C_SDA(1);
34810504:	e3a000b0 	mov	r0, #176	; 0xb0
34810508:	ebffff67 	bl	348102ac <gpio_direction_input>
	I2C_INIT;
3481050c:	e59f1058 	ldr	r1, [pc, #88]	; 3481056c <i2c_init+0x7c>
34810510:	e3a000b3 	mov	r0, #179	; 0xb3
34810514:	ebffff60 	bl	3481029c <gpio_request>
34810518:	e59f104c 	ldr	r1, [pc, #76]	; 3481056c <i2c_init+0x7c>
3481051c:	e3a000b0 	mov	r0, #176	; 0xb0
34810520:	ebffff5d 	bl	3481029c <gpio_request>
		I2C_SCL(0);
34810524:	e3a01000 	mov	r1, #0
34810528:	e3a000b3 	mov	r0, #179	; 0xb3
3481052c:	ebffff67 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810530:	e3a00005 	mov	r0, #5
34810534:	eb002e34 	bl	3481be0c <udelay>
		I2C_DELAY;
34810538:	e3a00005 	mov	r0, #5
3481053c:	eb002e32 	bl	3481be0c <udelay>
		I2C_SCL(1);
34810540:	e3a01001 	mov	r1, #1
34810544:	e3a000b3 	mov	r0, #179	; 0xb3
34810548:	ebffff60 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
3481054c:	e3a00005 	mov	r0, #5
34810550:	eb002e2d 	bl	3481be0c <udelay>
		I2C_DELAY;
34810554:	e3a00005 	mov	r0, #5
34810558:	eb002e2b 	bl	3481be0c <udelay>
	for(j = 0; j < 9; j++) {
3481055c:	e2544001 	subs	r4, r4, #1
34810560:	1affffef 	bne	34810524 <i2c_init+0x34>
	 * the DIMM SPD, for instance), RAM won't be usable and your
	 * system will crash.
	 */
	send_reset ();
#endif
}
34810564:	e8bd4010 	pop	{r4, lr}
	send_stop();
34810568:	eaffff77 	b	3481034c <send_stop>
3481056c:	34825b5a 	.word	0x34825b5a

34810570 <i2c_probe>:
 * Probe to see if a chip is present.  Also good for checking for the
 * completion of EEPROM writes since the chip stops responding until
 * the write completes (typically 10mSec).
 */
int i2c_probe(uchar addr)
{
34810570:	e92d4010 	push	{r4, lr}
34810574:	e1a04000 	mov	r4, r0

	/*
	 * perform 1 byte write transaction with just address byte
	 * (fake write)
	 */
	send_start();
34810578:	ebffff88 	bl	348103a0 <send_start>
	rc = write_byte ((addr << 1) | 0);
3481057c:	e1a00084 	lsl	r0, r4, #1
34810580:	e20000fe 	and	r0, r0, #254	; 0xfe
34810584:	ebffff97 	bl	348103e8 <write_byte>
34810588:	e1a04000 	mov	r4, r0
	send_stop();
3481058c:	ebffff6e 	bl	3481034c <send_stop>

	return (rc ? 1 : 0);
}
34810590:	e2940000 	adds	r0, r4, #0
34810594:	13a00001 	movne	r0, #1
34810598:	e8bd8010 	pop	{r4, pc}

3481059c <i2c_read>:

/*-----------------------------------------------------------------------
 * Read bytes
 */
int  i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
3481059c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348105a0:	e1a05002 	mov	r5, r2
348105a4:	e1a04000 	mov	r4, r0
348105a8:	e1a0a001 	mov	sl, r1
348105ac:	e1a09003 	mov	r9, r3
348105b0:	e1a04084 	lsl	r4, r4, #1
348105b4:	e59d7020 	ldr	r7, [sp, #32]
	 * Do the addressing portion of a write cycle to set the
	 * chip's address pointer.  If the address length is zero,
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
348105b8:	ebffff78 	bl	348103a0 <send_start>
	if(alen > 0) {
348105bc:	e3550000 	cmp	r5, #0
348105c0:	da000011 	ble	3481060c <i2c_read+0x70>
		if(write_byte(chip << 1)) {	/* write cycle */
348105c4:	e20400fe 	and	r0, r4, #254	; 0xfe
348105c8:	ebffff86 	bl	348103e8 <write_byte>
348105cc:	e3500000 	cmp	r0, #0
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
348105d0:	02456001 	subeq	r6, r5, #1
348105d4:	01a06186 	lsleq	r6, r6, #3
		if(write_byte(chip << 1)) {	/* write cycle */
348105d8:	0a000007 	beq	348105fc <i2c_read+0x60>
			send_stop();
348105dc:	ebffff5a 	bl	3481034c <send_stop>
348105e0:	ea000047 	b	34810704 <i2c_read+0x168>
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
348105e4:	e1a0063a 	lsr	r0, sl, r6
348105e8:	e6ef0070 	uxtb	r0, r0
348105ec:	ebffff7d 	bl	348103e8 <write_byte>
348105f0:	e3500000 	cmp	r0, #0
348105f4:	1a000042 	bne	34810704 <i2c_read+0x168>
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
			}
			shift -= 8;
348105f8:	e2466008 	sub	r6, r6, #8
		while(alen-- > 0) {
348105fc:	e2555001 	subs	r5, r5, #1
34810600:	2afffff7 	bcs	348105e4 <i2c_read+0x48>
		 * stop/start sequence.
		 */
#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
		send_start();
#else
		send_stop();
34810604:	ebffff50 	bl	3481034c <send_stop>
		send_start();
34810608:	ebffff64 	bl	348103a0 <send_start>
	/*
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
3481060c:	e3840001 	orr	r0, r4, #1
34810610:	e2496001 	sub	r6, r9, #1
34810614:	e6ef0070 	uxtb	r0, r0
34810618:	ebffff72 	bl	348103e8 <write_byte>
	while(len-- > 0) {
3481061c:	e2477001 	sub	r7, r7, #1
34810620:	e2873001 	add	r3, r7, #1
34810624:	e3530000 	cmp	r3, #0
34810628:	da000032 	ble	348106f8 <i2c_read+0x15c>
	I2C_SDA(1);
3481062c:	e3a05008 	mov	r5, #8
	data = 0;
34810630:	e3a04000 	mov	r4, #0
	I2C_SDA(1);
34810634:	e3a000b0 	mov	r0, #176	; 0xb0
34810638:	ebffff1b 	bl	348102ac <gpio_direction_input>
		I2C_SCL(0);
3481063c:	e3a01000 	mov	r1, #0
34810640:	e3a000b3 	mov	r0, #179	; 0xb3
34810644:	ebffff21 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810648:	e3a00005 	mov	r0, #5
		data <<= 1;
3481064c:	e1a04084 	lsl	r4, r4, #1
		I2C_DELAY;
34810650:	eb002ded 	bl	3481be0c <udelay>
		I2C_SCL(1);
34810654:	e3a01001 	mov	r1, #1
34810658:	e3a000b3 	mov	r0, #179	; 0xb3
3481065c:	ebffff1b 	bl	348102d0 <gpio_direction_output>
		I2C_DELAY;
34810660:	e3a00005 	mov	r0, #5
34810664:	eb002de8 	bl	3481be0c <udelay>
		data |= I2C_READ;
34810668:	e3a000b0 	mov	r0, #176	; 0xb0
3481066c:	ebffff21 	bl	348102f8 <gpio_get_value>
34810670:	e1804004 	orr	r4, r0, r4
		I2C_DELAY;
34810674:	e3a00005 	mov	r0, #5
34810678:	eb002de3 	bl	3481be0c <udelay>
	for(j = 0; j < 8; j++) {
3481067c:	e2555001 	subs	r5, r5, #1
34810680:	1affffed 	bne	3481063c <i2c_read+0xa0>
	I2C_SCL(0);
34810684:	e1a01005 	mov	r1, r5
34810688:	e3a000b3 	mov	r0, #179	; 0xb3
3481068c:	ebffff0f 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
34810690:	e3a00005 	mov	r0, #5
34810694:	eb002ddc 	bl	3481be0c <udelay>
	I2C_SDA(ack);
34810698:	e3570000 	cmp	r7, #0
3481069c:	1a000002 	bne	348106ac <i2c_read+0x110>
348106a0:	e3a000b0 	mov	r0, #176	; 0xb0
348106a4:	ebffff00 	bl	348102ac <gpio_direction_input>
348106a8:	ea000002 	b	348106b8 <i2c_read+0x11c>
348106ac:	e1a01005 	mov	r1, r5
348106b0:	e3a000b0 	mov	r0, #176	; 0xb0
348106b4:	ebffff05 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348106b8:	e3a00005 	mov	r0, #5
348106bc:	eb002dd2 	bl	3481be0c <udelay>
	I2C_SCL(1);
348106c0:	e3a01001 	mov	r1, #1
348106c4:	e3a000b3 	mov	r0, #179	; 0xb3
348106c8:	ebffff00 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348106cc:	e3a00005 	mov	r0, #5
348106d0:	eb002dcd 	bl	3481be0c <udelay>
	I2C_DELAY;
348106d4:	e3a00005 	mov	r0, #5
348106d8:	eb002dcb 	bl	3481be0c <udelay>
	I2C_SCL(0);
348106dc:	e3a01000 	mov	r1, #0
348106e0:	e3a000b3 	mov	r0, #179	; 0xb3
348106e4:	ebfffef9 	bl	348102d0 <gpio_direction_output>
	I2C_DELAY;
348106e8:	e3a00005 	mov	r0, #5
348106ec:	eb002dc6 	bl	3481be0c <udelay>
		*buffer++ = read_byte(len == 0);
348106f0:	e5e64001 	strb	r4, [r6, #1]!
348106f4:	eaffffc8 	b	3481061c <i2c_read+0x80>
	}
	send_stop();
348106f8:	ebffff13 	bl	3481034c <send_stop>
	return(0);
348106fc:	e3a00000 	mov	r0, #0
34810700:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
				return(1);
34810704:	e3a00001 	mov	r0, #1
}
34810708:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481070c <i2c_write>:

/*-----------------------------------------------------------------------
 * Write bytes
 */
int  i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
3481070c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34810710:	e1a05000 	mov	r5, r0
34810714:	e1a04002 	mov	r4, r2
34810718:	e1a09001 	mov	r9, r1
3481071c:	e1a06003 	mov	r6, r3
34810720:	e59d7018 	ldr	r7, [sp, #24]
	int shift, failures = 0;

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
34810724:	ebffff1d 	bl	348103a0 <send_start>
	if(write_byte(chip << 1)) {	/* write cycle */
34810728:	e1a00085 	lsl	r0, r5, #1
3481072c:	e20000fe 	and	r0, r0, #254	; 0xfe
34810730:	ebffff2c 	bl	348103e8 <write_byte>
34810734:	e3500000 	cmp	r0, #0
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
34810738:	02445001 	subeq	r5, r4, #1
3481073c:	01a05185 	lsleq	r5, r5, #3
	if(write_byte(chip << 1)) {	/* write cycle */
34810740:	0a000008 	beq	34810768 <i2c_write+0x5c>
		send_stop();
34810744:	ebffff00 	bl	3481034c <send_stop>
34810748:	ea000016 	b	348107a8 <i2c_write+0x9c>
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
3481074c:	e1a00539 	lsr	r0, r9, r5
34810750:	e2444001 	sub	r4, r4, #1
34810754:	e6ef0070 	uxtb	r0, r0
34810758:	ebffff22 	bl	348103e8 <write_byte>
3481075c:	e3500000 	cmp	r0, #0
34810760:	1a000010 	bne	348107a8 <i2c_write+0x9c>
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
		}
		shift -= 8;
34810764:	e2455008 	sub	r5, r5, #8
	while(alen-- > 0) {
34810768:	e3540000 	cmp	r4, #0
3481076c:	cafffff6 	bgt	3481074c <i2c_write+0x40>
34810770:	e1a05006 	mov	r5, r6
34810774:	e3a04000 	mov	r4, #0
34810778:	e0653007 	rsb	r3, r5, r7
3481077c:	e0863003 	add	r3, r6, r3
	}

	while(len-- > 0) {
34810780:	e3530000 	cmp	r3, #0
34810784:	da000004 	ble	3481079c <i2c_write+0x90>
		if(write_byte(*buffer++)) {
34810788:	e4d50001 	ldrb	r0, [r5], #1
3481078c:	ebffff15 	bl	348103e8 <write_byte>
34810790:	e3500000 	cmp	r0, #0
			failures++;
34810794:	12844001 	addne	r4, r4, #1
34810798:	eafffff6 	b	34810778 <i2c_write+0x6c>
		}
	}
	send_stop();
3481079c:	ebfffeea 	bl	3481034c <send_stop>
	return(failures);
348107a0:	e1a00004 	mov	r0, r4
348107a4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			return(1);
348107a8:	e3a00001 	mov	r0, #1
}
348107ac:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

348107b0 <input_queue_ascii>:
};


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
348107b0:	e5903010 	ldr	r3, [r0, #16]
348107b4:	e5902014 	ldr	r2, [r0, #20]
348107b8:	e353000f 	cmp	r3, #15
348107bc:	1a000003 	bne	348107d0 <input_queue_ascii+0x20>
		if (!config->fifo_out)
348107c0:	e3520000 	cmp	r2, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
348107c4:	13a03000 	movne	r3, #0
		if (!config->fifo_out)
348107c8:	1a000003 	bne	348107dc <input_queue_ascii+0x2c>
348107cc:	ea000007 	b	348107f0 <input_queue_ascii+0x40>
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
348107d0:	e2833001 	add	r3, r3, #1
348107d4:	e1530002 	cmp	r3, r2
348107d8:	0a000004 	beq	348107f0 <input_queue_ascii+0x40>
			return -1; /* buffer full */
		config->fifo_in++;
348107dc:	e5803010 	str	r3, [r0, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
348107e0:	e5903010 	ldr	r3, [r0, #16]
348107e4:	e7c01003 	strb	r1, [r0, r3]

	return 0;
348107e8:	e3a00000 	mov	r0, #0
348107ec:	e12fff1e 	bx	lr
			return -1; /* buffer full */
348107f0:	e3e00000 	mvn	r0, #0
}
348107f4:	e12fff1e 	bx	lr

348107f8 <input_tstc>:

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
348107f8:	e5902010 	ldr	r2, [r0, #16]
348107fc:	e5903014 	ldr	r3, [r0, #20]
{
34810800:	e92d4010 	push	{r4, lr}
34810804:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810808:	e1520003 	cmp	r2, r3
3481080c:	0a000004 	beq	34810824 <input_tstc+0x2c>
		if (!(*config->read_keys)(config))
			return 0;
	}
	return config->fifo_in != config->fifo_out;
34810810:	e5943010 	ldr	r3, [r4, #16]
34810814:	e5940014 	ldr	r0, [r4, #20]
34810818:	e0530000 	subs	r0, r3, r0
3481081c:	13a00001 	movne	r0, #1
34810820:	e8bd8010 	pop	{r4, pc}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810824:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
34810828:	e3530000 	cmp	r3, #0
3481082c:	0afffff7 	beq	34810810 <input_tstc+0x18>
		if (!(*config->read_keys)(config))
34810830:	e12fff33 	blx	r3
34810834:	e3500000 	cmp	r0, #0
34810838:	1afffff4 	bne	34810810 <input_tstc+0x18>
}
3481083c:	e8bd8010 	pop	{r4, pc}

34810840 <input_getc>:

int input_getc(struct input_config *config)
{
34810840:	e92d4010 	push	{r4, lr}
34810844:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810848:	e5943014 	ldr	r3, [r4, #20]
3481084c:	e5942010 	ldr	r2, [r4, #16]
34810850:	e1520003 	cmp	r2, r3
34810854:	1a000008 	bne	3481087c <input_getc+0x3c>
		if (config->read_keys)
34810858:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
3481085c:	e3530000 	cmp	r3, #0
34810860:	0afffffc 	beq	34810858 <input_getc+0x18>
			err = (*config->read_keys)(config);
34810864:	e1a00004 	mov	r0, r4
34810868:	e12fff33 	blx	r3
		if (err)
3481086c:	e3500000 	cmp	r0, #0
34810870:	0afffff4 	beq	34810848 <input_getc+0x8>
			return -1;
34810874:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
34810878:	e8bd8010 	pop	{r4, pc}
	if (++config->fifo_out == INPUT_BUFFER_LEN)
3481087c:	e2833001 	add	r3, r3, #1
34810880:	e3530010 	cmp	r3, #16
		config->fifo_out = 0;
34810884:	03a03000 	moveq	r3, #0
34810888:	e5843014 	str	r3, [r4, #20]
	return config->fifo[config->fifo_out];
3481088c:	e5943014 	ldr	r3, [r4, #20]
34810890:	e7d40003 	ldrb	r0, [r4, r3]
34810894:	e8bd8010 	pop	{r4, pc}

34810898 <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34810898:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481089c:	e28db01c 	add	fp, sp, #28
348108a0:	e24dd010 	sub	sp, sp, #16
	char ch[num_keycodes];
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
348108a4:	e3a05000 	mov	r5, #0
	char ch[num_keycodes];
348108a8:	e2823007 	add	r3, r2, #7
	if (!config->num_tables) {
348108ac:	e5d0701b 	ldrb	r7, [r0, #27]
	char ch[num_keycodes];
348108b0:	e3c33007 	bic	r3, r3, #7
348108b4:	e04dd003 	sub	sp, sp, r3
{
348108b8:	e1a04000 	mov	r4, r0
348108bc:	e1a09001 	mov	r9, r1
348108c0:	e1a06002 	mov	r6, r2
	if (!config->num_tables) {
348108c4:	e1570005 	cmp	r7, r5
	char ch[num_keycodes];
348108c8:	e50bd020 	str	sp, [fp, #-32]	; 0xffffffe0
	config->modifiers = 0;
348108cc:	e5c05018 	strb	r5, [r0, #24]
	if (!config->num_tables) {
348108d0:	0a000043 	beq	348109e4 <input_send_keycodes+0x14c>
	*same = sort_array_by_ordering(keycode, num_keycodes,
348108d4:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
			config->prev_keycodes, config->num_prev_keycodes);
348108d8:	e280701c 	add	r7, r0, #28
348108dc:	e50bd028 	str	sp, [fp, #-40]	; 0xffffffd8
	*same = sort_array_by_ordering(keycode, num_keycodes,
348108e0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
	int temp[count];
348108e4:	e1a03102 	lsl	r3, r2, #2
348108e8:	e283200a 	add	r2, r3, #10
	memcpy(temp, dest, count * sizeof(*dest));
348108ec:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
	int temp[count];
348108f0:	e3c22007 	bic	r2, r2, #7
348108f4:	e04dd002 	sub	sp, sp, r2
	memcpy(temp, dest, count * sizeof(*dest));
348108f8:	e1a02003 	mov	r2, r3
348108fc:	e1a0000d 	mov	r0, sp
	int temp[count];
34810900:	e1a0a00d 	mov	sl, sp
	memcpy(temp, dest, count * sizeof(*dest));
34810904:	eb002cbc 	bl	3481bbfc <memcpy>
34810908:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
	for (i = 0; i < ocount; i++) {
3481090c:	e1a02005 	mov	r2, r5
34810910:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
34810914:	e1520001 	cmp	r2, r1
34810918:	aa00000e 	bge	34810958 <input_send_keycodes+0xc0>
		if (array_search(temp, count, order[i]) != -1)
3481091c:	e7970102 	ldr	r0, [r7, r2, lsl #2]
	for (i = 0; i < count; i++) {
34810920:	e3a01000 	mov	r1, #0
34810924:	e1510006 	cmp	r1, r6
34810928:	aa000008 	bge	34810950 <input_send_keycodes+0xb8>
		if (array[i] == key)
3481092c:	e79ac101 	ldr	ip, [sl, r1, lsl #2]
34810930:	e15c0000 	cmp	ip, r0
34810934:	1a000003 	bne	34810948 <input_send_keycodes+0xb0>
		if (array_search(temp, count, order[i]) != -1)
34810938:	e3710001 	cmn	r1, #1
			dest[dest_count++] = order[i];
3481093c:	17890105 	strne	r0, [r9, r5, lsl #2]
34810940:	12855001 	addne	r5, r5, #1
34810944:	ea000001 	b	34810950 <input_send_keycodes+0xb8>
	for (i = 0; i < count; i++) {
34810948:	e2811001 	add	r1, r1, #1
3481094c:	eafffff4 	b	34810924 <input_send_keycodes+0x8c>
	for (i = 0; i < ocount; i++) {
34810950:	e2822001 	add	r2, r2, #1
34810954:	eaffffed 	b	34810910 <input_send_keycodes+0x78>
34810958:	e1a00005 	mov	r0, r5
	for (i = 0; i < count; i++) {
3481095c:	e3a01000 	mov	r1, #0
34810960:	e1510006 	cmp	r1, r6
34810964:	aa000010 	bge	348109ac <input_send_keycodes+0x114>
		if (array_search(order, ocount, temp[i]) == -1)
34810968:	e79ac101 	ldr	ip, [sl, r1, lsl #2]
	for (i = 0; i < count; i++) {
3481096c:	e3a02000 	mov	r2, #0
34810970:	e51be024 	ldr	lr, [fp, #-36]	; 0xffffffdc
34810974:	e152000e 	cmp	r2, lr
34810978:	aa000007 	bge	3481099c <input_send_keycodes+0x104>
		if (array[i] == key)
3481097c:	e797e102 	ldr	lr, [r7, r2, lsl #2]
34810980:	e15e000c 	cmp	lr, ip
34810984:	1a000002 	bne	34810994 <input_send_keycodes+0xfc>
		if (array_search(order, ocount, temp[i]) == -1)
34810988:	e3720001 	cmn	r2, #1
3481098c:	1a000004 	bne	348109a4 <input_send_keycodes+0x10c>
34810990:	ea000001 	b	3481099c <input_send_keycodes+0x104>
	for (i = 0; i < count; i++) {
34810994:	e2822001 	add	r2, r2, #1
34810998:	eafffff4 	b	34810970 <input_send_keycodes+0xd8>
			dest[dest_count++] = temp[i];
3481099c:	e789c100 	str	ip, [r9, r0, lsl #2]
348109a0:	e2800001 	add	r0, r0, #1
	for (i = 0; i < count; i++) {
348109a4:	e2811001 	add	r1, r1, #1
348109a8:	eaffffec 	b	34810960 <input_send_keycodes+0xc8>
	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
348109ac:	e1a00007 	mov	r0, r7
348109b0:	e1a02003 	mov	r2, r3
348109b4:	e51bd028 	ldr	sp, [fp, #-40]	; 0xffffffd8
348109b8:	e1a01009 	mov	r1, r9
348109bc:	eb002c8e 	bl	3481bbfc <memcpy>
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
348109c0:	e1550006 	cmp	r5, r6
	config->num_prev_keycodes = num_keycodes;
348109c4:	e584605c 	str	r6, [r4, #92]	; 0x5c
	int is_repeat = 0;
348109c8:	13a07000 	movne	r7, #0
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
348109cc:	1a000005 	bne	348109e8 <input_send_keycodes+0x150>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
348109d0:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
348109d4:	ebffc1ca 	bl	34801104 <get_timer>
		if (!is_repeat)
348109d8:	e3500000 	cmp	r0, #0
348109dc:	ba00005f 	blt	34810b60 <input_send_keycodes+0x2c8>
348109e0:	e3a07001 	mov	r7, #1
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
348109e4:	e3a05000 	mov	r5, #0
	table = &config->table[0];
348109e8:	e284a060 	add	sl, r4, #96	; 0x60
	for (i = 0; i < num_keycodes; i++) {
348109ec:	e3a00000 	mov	r0, #0
	table = &config->table[0];
348109f0:	e1a0200a 	mov	r2, sl
	for (i = 0; i < num_keycodes; i++) {
348109f4:	e1500006 	cmp	r0, r6
348109f8:	aa000033 	bge	34810acc <input_send_keycodes+0x234>
		int key = keycode[i] & KEY_MASK;
348109fc:	e7991100 	ldr	r1, [r9, r0, lsl #2]
		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810a00:	e592c00c 	ldr	ip, [r2, #12]
		int key = keycode[i] & KEY_MASK;
34810a04:	e7eb3051 	ubfx	r3, r1, #0, #12
		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810a08:	e153000c 	cmp	r3, ip
34810a0c:	aa000003 	bge	34810a20 <input_send_keycodes+0x188>
34810a10:	e592c008 	ldr	ip, [r2, #8]
34810a14:	e7dcc003 	ldrb	ip, [ip, r3]
34810a18:	e35c00ff 	cmp	ip, #255	; 0xff
34810a1c:	1a000028 	bne	34810ac4 <input_send_keycodes+0x22c>
			table = process_modifier(config, key,
34810a20:	e2012902 	and	r2, r1, #32768	; 0x8000
	for (i = 1; i < config->num_tables; i++) {
34810a24:	e3a0e001 	mov	lr, #1
			table = process_modifier(config, key,
34810a28:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
34810a2c:	e2841070 	add	r1, r4, #112	; 0x70
	for (i = 1; i < config->num_tables; i++) {
34810a30:	e5d4201b 	ldrb	r2, [r4, #27]
34810a34:	e50b202c 	str	r2, [fp, #-44]	; 0xffffffd4
	table = &config->table[0];
34810a38:	e1a0200a 	mov	r2, sl
	for (i = 1; i < config->num_tables; i++) {
34810a3c:	e51bc02c 	ldr	ip, [fp, #-44]	; 0xffffffd4
34810a40:	e15e000c 	cmp	lr, ip
34810a44:	aa00000b 	bge	34810a78 <input_send_keycodes+0x1e0>
		if (key == tab->left_keycode || key == tab->right_keycode)
34810a48:	e591c000 	ldr	ip, [r1]
34810a4c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
34810a50:	e153000c 	cmp	r3, ip
34810a54:	0a000003 	beq	34810a68 <input_send_keycodes+0x1d0>
34810a58:	e591c004 	ldr	ip, [r1, #4]
34810a5c:	e153000c 	cmp	r3, ip
34810a60:	01a02001 	moveq	r2, r1
34810a64:	e50b2024 	str	r2, [fp, #-36]	; 0xffffffdc
	for (i = 1; i < config->num_tables; i++) {
34810a68:	e28ee001 	add	lr, lr, #1
34810a6c:	e2811010 	add	r1, r1, #16
34810a70:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
34810a74:	eafffff0 	b	34810a3c <input_send_keycodes+0x1a4>
	if (!release) {
34810a78:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
34810a7c:	e3510000 	cmp	r1, #0
34810a80:	1a00000f 	bne	34810ac4 <input_send_keycodes+0x22c>
34810a84:	e243303a 	sub	r3, r3, #58	; 0x3a
34810a88:	e353000c 	cmp	r3, #12
34810a8c:	8a00000c 	bhi	34810ac4 <input_send_keycodes+0x22c>
	if (flip != -1) {
34810a90:	e59f10d4 	ldr	r1, [pc, #212]	; 34810b6c <input_send_keycodes+0x2d4>
34810a94:	e19130d3 	ldrsb	r3, [r1, r3]
34810a98:	e3730001 	cmn	r3, #1
34810a9c:	0a000008 	beq	34810ac4 <input_send_keycodes+0x22c>
		if (config->flags & FLAG_NUM_LOCK)
34810aa0:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
34810aa4:	e3110001 	tst	r1, #1
34810aa8:	13a03004 	movne	r3, #4
34810aac:	03a03000 	moveq	r3, #0
		if (config->flags & FLAG_CAPS_LOCK)
34810ab0:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
34810ab4:	13833002 	orrne	r3, r3, #2
		if (config->flags & FLAG_SCROLL_LOCK)
34810ab8:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
34810abc:	13833001 	orrne	r3, r3, #1
		config->leds = leds;
34810ac0:	e5c4301a 	strb	r3, [r4, #26]
	for (i = 0; i < num_keycodes; i++) {
34810ac4:	e2800001 	add	r0, r0, #1
34810ac8:	eaffffc9 	b	348109f4 <input_send_keycodes+0x15c>
34810acc:	e3a01000 	mov	r1, #0
34810ad0:	e1a03001 	mov	r3, r1
	for (i = ch_count = 0; i < num_keycodes; i++) {
34810ad4:	e1510006 	cmp	r1, r6
34810ad8:	aa000010 	bge	34810b20 <input_send_keycodes+0x288>
		int key = keycode[i];
34810adc:	e799c101 	ldr	ip, [r9, r1, lsl #2]
		if (key < table->num_entries && i >= same) {
34810ae0:	e592e00c 	ldr	lr, [r2, #12]
34810ae4:	e15c000e 	cmp	ip, lr
34810ae8:	b3a00001 	movlt	r0, #1
34810aec:	a3a00000 	movge	r0, #0
34810af0:	e1510005 	cmp	r1, r5
34810af4:	b3a00000 	movlt	r0, #0
34810af8:	e3500000 	cmp	r0, #0
34810afc:	0a000005 	beq	34810b18 <input_send_keycodes+0x280>
			int ch = table->xlate[key];
34810b00:	e5920008 	ldr	r0, [r2, #8]
34810b04:	e7d0000c 	ldrb	r0, [r0, ip]
			if (ch != 0xff)
34810b08:	e35000ff 	cmp	r0, #255	; 0xff
				output_ch[ch_count++] = (uchar)ch;
34810b0c:	151bc020 	ldrne	ip, [fp, #-32]	; 0xffffffe0
34810b10:	17cc0003 	strbne	r0, [ip, r3]
34810b14:	12833001 	addne	r3, r3, #1
	for (i = ch_count = 0; i < num_keycodes; i++) {
34810b18:	e2811001 	add	r1, r1, #1
34810b1c:	eaffffec 	b	34810ad4 <input_send_keycodes+0x23c>
34810b20:	e51b5020 	ldr	r5, [fp, #-32]	; 0xffffffe0
34810b24:	e0856003 	add	r6, r5, r3
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
34810b28:	e1550006 	cmp	r5, r6
34810b2c:	0a000003 	beq	34810b40 <input_send_keycodes+0x2a8>
		input_queue_ascii(config, ch[i]);
34810b30:	e4d51001 	ldrb	r1, [r5], #1
34810b34:	e1a00004 	mov	r0, r4
34810b38:	ebffff1c 	bl	348107b0 <input_queue_ascii>
34810b3c:	eafffff9 	b	34810b28 <input_send_keycodes+0x290>
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
34810b40:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34810b44:	e3570000 	cmp	r7, #0
34810b48:	e59450ac 	ldr	r5, [r4, #172]	; 0xac
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
34810b4c:	e3a00000 	mov	r0, #0
			config->repeat_rate_ms :
34810b50:	01a05003 	moveq	r5, r3
	config->next_repeat_ms = get_timer(0) + delay_ms;
34810b54:	ebffc16a 	bl	34801104 <get_timer>
34810b58:	e0800005 	add	r0, r0, r5
34810b5c:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	return 0;
}
34810b60:	e3a00000 	mov	r0, #0
34810b64:	e24bd01c 	sub	sp, fp, #28
34810b68:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810b6c:	348214e0 	.word	0x348214e0

34810b70 <input_add_table>:
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810b70:	e5d0c01b 	ldrb	ip, [r0, #27]
34810b74:	e35c0004 	cmp	ip, #4
34810b78:	0a00000a 	beq	34810ba8 <input_add_table+0x38>
{
34810b7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810b80:	e28ce001 	add	lr, ip, #1
34810b84:	e5c0e01b 	strb	lr, [r0, #27]
34810b88:	e080e20c 	add	lr, r0, ip, lsl #4
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
34810b8c:	e3a00000 	mov	r0, #0
	table->xlate = xlate;
34810b90:	e58e3068 	str	r3, [lr, #104]	; 0x68
	table->num_entries = num_entries;
34810b94:	e59d3004 	ldr	r3, [sp, #4]
	table->left_keycode = left_keycode;
34810b98:	e58e1060 	str	r1, [lr, #96]	; 0x60
	table->right_keycode = right_keycode;
34810b9c:	e58e2064 	str	r2, [lr, #100]	; 0x64
	table->num_entries = num_entries;
34810ba0:	e58e306c 	str	r3, [lr, #108]	; 0x6c
	return 0;
34810ba4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
		return -1;
34810ba8:	e3e00000 	mvn	r0, #0
34810bac:	e12fff1e 	bx	lr

34810bb0 <input_init>:
}

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
34810bb0:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34810bb4:	e1a04000 	mov	r4, r0
34810bb8:	e1a07001 	mov	r7, r1
34810bbc:	e1a06002 	mov	r6, r2
	memset(config, '\0', sizeof(*config));
34810bc0:	e3a01000 	mov	r1, #0
34810bc4:	e3a020b0 	mov	r2, #176	; 0xb0
{
34810bc8:	e1a05003 	mov	r5, r3
	memset(config, '\0', sizeof(*config));
34810bcc:	eb002bea 	bl	3481bb7c <memset>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810bd0:	e5d4201b 	ldrb	r2, [r4, #27]
	config->leds = leds;
34810bd4:	e5c4701a 	strb	r7, [r4, #26]
	config->repeat_delay_ms = repeat_delay_ms;
34810bd8:	e58460a8 	str	r6, [r4, #168]	; 0xa8
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810bdc:	e3520004 	cmp	r2, #4
	config->repeat_rate_ms = repeat_rate_ms;
34810be0:	e58450ac 	str	r5, [r4, #172]	; 0xac
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810be4:	1a000001 	bne	34810bf0 <input_init+0x40>
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
34810be8:	e3e00000 	mvn	r0, #0
34810bec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	table = &config->table[config->num_tables++];
34810bf0:	e2823001 	add	r3, r2, #1
34810bf4:	e0841202 	add	r1, r4, r2, lsl #4
34810bf8:	e6ef3073 	uxtb	r3, r3
	table->left_keycode = left_keycode;
34810bfc:	e3e00000 	mvn	r0, #0
	table->num_entries = num_entries;
34810c00:	e3a0c063 	mov	ip, #99	; 0x63
	table = &config->table[config->num_tables++];
34810c04:	e5c4301b 	strb	r3, [r4, #27]
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810c08:	e3530004 	cmp	r3, #4
	table->left_keycode = left_keycode;
34810c0c:	e5810060 	str	r0, [r1, #96]	; 0x60
	table->right_keycode = right_keycode;
34810c10:	e5810064 	str	r0, [r1, #100]	; 0x64
	table->xlate = xlate;
34810c14:	e59f0074 	ldr	r0, [pc, #116]	; 34810c90 <input_init+0xe0>
	table->num_entries = num_entries;
34810c18:	e581c06c 	str	ip, [r1, #108]	; 0x6c
	table->xlate = xlate;
34810c1c:	e5810068 	str	r0, [r1, #104]	; 0x68
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810c20:	0afffff0 	beq	34810be8 <input_init+0x38>
	table = &config->table[config->num_tables++];
34810c24:	e2821002 	add	r1, r2, #2
34810c28:	e0840203 	add	r0, r4, r3, lsl #4
34810c2c:	e6ef1071 	uxtb	r1, r1
	table->left_keycode = left_keycode;
34810c30:	e3a0e02a 	mov	lr, #42	; 0x2a
	table->xlate = xlate;
34810c34:	e1a03000 	mov	r3, r0
	table = &config->table[config->num_tables++];
34810c38:	e5c4101b 	strb	r1, [r4, #27]
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810c3c:	e3510004 	cmp	r1, #4
	table->left_keycode = left_keycode;
34810c40:	e580e060 	str	lr, [r0, #96]	; 0x60
	table->right_keycode = right_keycode;
34810c44:	e3a0e036 	mov	lr, #54	; 0x36
34810c48:	e580e064 	str	lr, [r0, #100]	; 0x64
	table->xlate = xlate;
34810c4c:	e59f0040 	ldr	r0, [pc, #64]	; 34810c94 <input_init+0xe4>
	table->num_entries = num_entries;
34810c50:	e583c06c 	str	ip, [r3, #108]	; 0x6c
	table->xlate = xlate;
34810c54:	e5830068 	str	r0, [r3, #104]	; 0x68
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810c58:	0affffe2 	beq	34810be8 <input_init+0x38>
	table = &config->table[config->num_tables++];
34810c5c:	e2823003 	add	r3, r2, #3
	table->left_keycode = left_keycode;
34810c60:	e3a0201d 	mov	r2, #29
	table = &config->table[config->num_tables++];
34810c64:	e5c4301b 	strb	r3, [r4, #27]
34810c68:	e0843201 	add	r3, r4, r1, lsl #4
	table->xlate = xlate;
34810c6c:	e080000c 	add	r0, r0, ip
	table->left_keycode = left_keycode;
34810c70:	e5832060 	str	r2, [r3, #96]	; 0x60
	table->right_keycode = right_keycode;
34810c74:	e3a02061 	mov	r2, #97	; 0x61
	table->xlate = xlate;
34810c78:	e5830068 	str	r0, [r3, #104]	; 0x68
34810c7c:	e1a04003 	mov	r4, r3
	table->right_keycode = right_keycode;
34810c80:	e5832064 	str	r2, [r3, #100]	; 0x64
	}

	return 0;
34810c84:	e3a00000 	mov	r0, #0
	table->num_entries = num_entries;
34810c88:	e583c06c 	str	ip, [r3, #108]	; 0x6c
}
34810c8c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34810c90:	348214ed 	.word	0x348214ed
34810c94:	3482774c 	.word	0x3482774c

34810c98 <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
34810c98:	e92d4010 	push	{r4, lr}
34810c9c:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
34810ca0:	ebfff79b 	bl	3480eb14 <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810ca4:	e3500000 	cmp	r0, #0
34810ca8:	0a000001 	beq	34810cb4 <input_stdio_register+0x1c>
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
34810cac:	e3a00000 	mov	r0, #0
34810cb0:	e8bd8010 	pop	{r4, pc}
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810cb4:	e59f002c 	ldr	r0, [pc, #44]	; 34810ce8 <input_stdio_register+0x50>
34810cb8:	e2844008 	add	r4, r4, #8
34810cbc:	ebffdbb0 	bl	34807b84 <getenv>
34810cc0:	e1a01004 	mov	r1, r4
34810cc4:	eb002ad5 	bl	3481b820 <strcmp>
34810cc8:	e3500000 	cmp	r0, #0
34810ccc:	1afffff6 	bne	34810cac <input_stdio_register+0x14>
				console_assign(stdin, dev->name))
34810cd0:	e1a01004 	mov	r1, r4
34810cd4:	ebffe302 	bl	348098e4 <console_assign>
		if (OVERWRITE_CONSOLE ||
34810cd8:	e2900000 	adds	r0, r0, #0
34810cdc:	13a00001 	movne	r0, #1
34810ce0:	e2600000 	rsb	r0, r0, #0
}
34810ce4:	e8bd8010 	pop	{r4, pc}
34810ce8:	34823fd1 	.word	0x34823fd1

34810cec <do_pmic>:
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
34810cec:	e3520001 	cmp	r2, #1
{
34810cf0:	e92d42f3 	push	{r0, r1, r4, r5, r6, r7, r9, lr}
34810cf4:	e1a06002 	mov	r6, r2
	if (argc < 2)
34810cf8:	da000046 	ble	34810e18 <do_pmic+0x12c>
		return cmd_usage(cmdtp);

	cmd = argv[1];
34810cfc:	e5937004 	ldr	r7, [r3, #4]
34810d00:	e1a09000 	mov	r9, r0
	if (strcmp(cmd, "dump") == 0) {
34810d04:	e59f115c 	ldr	r1, [pc, #348]	; 34810e68 <do_pmic+0x17c>
34810d08:	e1a05003 	mov	r5, r3
34810d0c:	e1a00007 	mov	r0, r7
34810d10:	eb002ac2 	bl	3481b820 <strcmp>
34810d14:	e2504000 	subs	r4, r0, #0
34810d18:	1a00001c 	bne	34810d90 <do_pmic+0xa4>
34810d1c:	e59f6148 	ldr	r6, [pc, #328]	; 34810e6c <do_pmic+0x180>
	for (i = 0; i < p->number_of_regs; i++) {
34810d20:	e1a05004 	mov	r5, r4
	printf("PMIC: %s\n", p->name);
34810d24:	e59f0144 	ldr	r0, [pc, #324]	; 34810e70 <do_pmic+0x184>
34810d28:	e5961000 	ldr	r1, [r6]
34810d2c:	ebffe29a 	bl	3480979c <printf>
	for (i = 0; i < p->number_of_regs; i++) {
34810d30:	e5d63006 	ldrb	r3, [r6, #6]
34810d34:	e1550003 	cmp	r5, r3
34810d38:	aa000011 	bge	34810d84 <do_pmic+0x98>
		ret = pmic_reg_read(p, i, &val);
34810d3c:	e28d2004 	add	r2, sp, #4
34810d40:	e1a01005 	mov	r1, r5
34810d44:	e59f0120 	ldr	r0, [pc, #288]	; 34810e6c <do_pmic+0x180>
34810d48:	eb0000a5 	bl	34810fe4 <pmic_reg_read>
		if (ret)
34810d4c:	e3500000 	cmp	r0, #0
34810d50:	0a000001 	beq	34810d5c <do_pmic+0x70>
			puts("PMIC: Registers dump failed\n");
34810d54:	e59f0118 	ldr	r0, [pc, #280]	; 34810e74 <do_pmic+0x188>
34810d58:	ebffe283 	bl	3480976c <puts>
		if (!(i % 8))
34810d5c:	e3150007 	tst	r5, #7
34810d60:	1a000002 	bne	34810d70 <do_pmic+0x84>
			printf("\n0x%02x: ", i);
34810d64:	e1a01005 	mov	r1, r5
34810d68:	e59f0108 	ldr	r0, [pc, #264]	; 34810e78 <do_pmic+0x18c>
34810d6c:	ebffe28a 	bl	3480979c <printf>
		printf("%08x ", val);
34810d70:	e59d1004 	ldr	r1, [sp, #4]
	for (i = 0; i < p->number_of_regs; i++) {
34810d74:	e2855001 	add	r5, r5, #1
		printf("%08x ", val);
34810d78:	e59f00fc 	ldr	r0, [pc, #252]	; 34810e7c <do_pmic+0x190>
34810d7c:	ebffe286 	bl	3480979c <printf>
34810d80:	eaffffea 	b	34810d30 <do_pmic+0x44>
	puts("\n");
34810d84:	e59f00f4 	ldr	r0, [pc, #244]	; 34810e80 <do_pmic+0x194>
34810d88:	ebffe277 	bl	3480976c <puts>
34810d8c:	ea000032 	b	34810e5c <do_pmic+0x170>
		pmic_dump(p);
		return 0;
	}

	if (strcmp(cmd, "read") == 0) {
34810d90:	e59f10ec 	ldr	r1, [pc, #236]	; 34810e84 <do_pmic+0x198>
34810d94:	e1a00007 	mov	r0, r7
34810d98:	eb002aa0 	bl	3481b820 <strcmp>
34810d9c:	e2504000 	subs	r4, r0, #0
34810da0:	1a000013 	bne	34810df4 <do_pmic+0x108>
		if (argc < 3)
34810da4:	e3560002 	cmp	r6, #2
34810da8:	0a000019 	beq	34810e14 <do_pmic+0x128>
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
34810dac:	e3a02010 	mov	r2, #16
34810db0:	e1a01004 	mov	r1, r4
34810db4:	e5950008 	ldr	r0, [r5, #8]
34810db8:	eb002e69 	bl	3481c764 <simple_strtoul>

		ret = pmic_reg_read(p, reg, &val);
34810dbc:	e28d2004 	add	r2, sp, #4
34810dc0:	e1a01000 	mov	r1, r0
		reg = simple_strtoul(argv[2], NULL, 16);
34810dc4:	e1a05000 	mov	r5, r0
		ret = pmic_reg_read(p, reg, &val);
34810dc8:	e59f009c 	ldr	r0, [pc, #156]	; 34810e6c <do_pmic+0x180>
34810dcc:	eb000084 	bl	34810fe4 <pmic_reg_read>

		if (ret)
34810dd0:	e3500000 	cmp	r0, #0
34810dd4:	0a000001 	beq	34810de0 <do_pmic+0xf4>
			puts("PMIC: Register read failed\n");
34810dd8:	e59f00a8 	ldr	r0, [pc, #168]	; 34810e88 <do_pmic+0x19c>
34810ddc:	ebffe262 	bl	3480976c <puts>

		printf("\n0x%02x: 0x%08x\n", reg, val);
34810de0:	e59d2004 	ldr	r2, [sp, #4]
34810de4:	e1a01005 	mov	r1, r5
34810de8:	e59f009c 	ldr	r0, [pc, #156]	; 34810e8c <do_pmic+0x1a0>
34810dec:	ebffe26a 	bl	3480979c <printf>

		return 0;
34810df0:	ea000019 	b	34810e5c <do_pmic+0x170>
	}

	if (strcmp(cmd, "write") == 0) {
34810df4:	e59f1094 	ldr	r1, [pc, #148]	; 34810e90 <do_pmic+0x1a4>
34810df8:	e1a00007 	mov	r0, r7
34810dfc:	eb002a87 	bl	3481b820 <strcmp>
34810e00:	e2504000 	subs	r4, r0, #0

		return 0;
	}

	/* No subcommand found */
	return 1;
34810e04:	13a04001 	movne	r4, #1
	if (strcmp(cmd, "write") == 0) {
34810e08:	1a000013 	bne	34810e5c <do_pmic+0x170>
		if (argc < 4)
34810e0c:	e3560003 	cmp	r6, #3
34810e10:	ca000003 	bgt	34810e24 <do_pmic+0x138>
			return cmd_usage(cmdtp);
34810e14:	e1a00009 	mov	r0, r9
34810e18:	ebffe109 	bl	34809244 <cmd_usage>
34810e1c:	e1a04000 	mov	r4, r0
34810e20:	ea00000d 	b	34810e5c <do_pmic+0x170>
		reg = simple_strtoul(argv[2], NULL, 16);
34810e24:	e3a02010 	mov	r2, #16
34810e28:	e1a01004 	mov	r1, r4
34810e2c:	e5950008 	ldr	r0, [r5, #8]
34810e30:	eb002e4b 	bl	3481c764 <simple_strtoul>
		val = simple_strtoul(argv[3], NULL, 16);
34810e34:	e3a02010 	mov	r2, #16
		reg = simple_strtoul(argv[2], NULL, 16);
34810e38:	e1a06000 	mov	r6, r0
		val = simple_strtoul(argv[3], NULL, 16);
34810e3c:	e1a01004 	mov	r1, r4
34810e40:	e595000c 	ldr	r0, [r5, #12]
34810e44:	eb002e46 	bl	3481c764 <simple_strtoul>
		pmic_reg_write(p, reg, val);
34810e48:	e1a01006 	mov	r1, r6
		val = simple_strtoul(argv[3], NULL, 16);
34810e4c:	e1a02000 	mov	r2, r0
34810e50:	e58d0004 	str	r0, [sp, #4]
		pmic_reg_write(p, reg, val);
34810e54:	e59f0010 	ldr	r0, [pc, #16]	; 34810e6c <do_pmic+0x180>
34810e58:	eb000036 	bl	34810f38 <pmic_reg_write>
}
34810e5c:	e1a00004 	mov	r0, r4
34810e60:	e28dd008 	add	sp, sp, #8
34810e64:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34810e68:	34824a70 	.word	0x34824a70
34810e6c:	3482a6e4 	.word	0x3482a6e4
34810e70:	34825b63 	.word	0x34825b63
34810e74:	34825b6d 	.word	0x34825b6d
34810e78:	34825b8a 	.word	0x34825b8a
34810e7c:	34825b94 	.word	0x34825b94
34810e80:	34824f42 	.word	0x34824f42
34810e84:	34822f2a 	.word	0x34822f2a
34810e88:	34825b9a 	.word	0x34825b9a
34810e8c:	34825bb6 	.word	0x34825bb6
34810e90:	34822f2f 	.word	0x34822f2f

34810e94 <check_reg>:
	if (reg >= pmic.number_of_regs) {
34810e94:	e59f3028 	ldr	r3, [pc, #40]	; 34810ec4 <check_reg+0x30>
34810e98:	e5d32006 	ldrb	r2, [r3, #6]
34810e9c:	e1500002 	cmp	r0, r2
34810ea0:	3a000005 	bcc	34810ebc <check_reg+0x28>
34810ea4:	e1a01000 	mov	r1, r0
{
34810ea8:	e92d4010 	push	{r4, lr}
		printf("<reg num> = %d is invalid. Should be less than %d\n",
34810eac:	e59f0014 	ldr	r0, [pc, #20]	; 34810ec8 <check_reg+0x34>
34810eb0:	ebffe239 	bl	3480979c <printf>
		return -1;
34810eb4:	e3e00000 	mvn	r0, #0
34810eb8:	e8bd8010 	pop	{r4, pc}
	return 0;
34810ebc:	e3a00000 	mov	r0, #0
34810ec0:	e12fff1e 	bx	lr
34810ec4:	3482a6e4 	.word	0x3482a6e4
34810ec8:	34825bc7 	.word	0x34825bc7

34810ecc <pmic_set_output>:
{
34810ecc:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34810ed0:	e1a04002 	mov	r4, r2
	if (pmic_reg_read(p, reg, &val))
34810ed4:	e28d2004 	add	r2, sp, #4
{
34810ed8:	e1a05000 	mov	r5, r0
34810edc:	e1a06001 	mov	r6, r1
34810ee0:	e1a07003 	mov	r7, r3
	if (pmic_reg_read(p, reg, &val))
34810ee4:	eb00003e 	bl	34810fe4 <pmic_reg_read>
34810ee8:	e3500000 	cmp	r0, #0
		return -1;
34810eec:	13e00000 	mvnne	r0, #0
	if (pmic_reg_read(p, reg, &val))
34810ef0:	1a00000b 	bne	34810f24 <pmic_set_output+0x58>
34810ef4:	e59d2004 	ldr	r2, [sp, #4]
	if (on)
34810ef8:	e3570000 	cmp	r7, #0
	if (pmic_reg_write(p, reg, val))
34810efc:	e1a01006 	mov	r1, r6
34810f00:	e1a00005 	mov	r0, r5
		val |= out;
34810f04:	11822004 	orrne	r2, r2, r4
		val &= ~out;
34810f08:	01c22004 	biceq	r2, r2, r4
34810f0c:	e58d2004 	str	r2, [sp, #4]
	if (pmic_reg_write(p, reg, val))
34810f10:	e59d2004 	ldr	r2, [sp, #4]
34810f14:	eb000007 	bl	34810f38 <pmic_reg_write>
34810f18:	e2900000 	adds	r0, r0, #0
34810f1c:	13a00001 	movne	r0, #1
34810f20:	e2600000 	rsb	r0, r0, #0
}
34810f24:	e28dd00c 	add	sp, sp, #12
34810f28:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34810f2c <get_pmic>:
}
34810f2c:	e59f0000 	ldr	r0, [pc]	; 34810f34 <get_pmic+0x8>
34810f30:	e12fff1e 	bx	lr
34810f34:	3482a6e4 	.word	0x3482a6e4

34810f38 <pmic_reg_write>:
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34810f38:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34810f3c:	e3a03000 	mov	r3, #0
{
34810f40:	e1a06000 	mov	r6, r0

	if (check_reg(reg))
34810f44:	e1a00001 	mov	r0, r1
{
34810f48:	e1a05001 	mov	r5, r1
34810f4c:	e1a04002 	mov	r4, r2
	unsigned char buf[4] = { 0 };
34810f50:	e58d300c 	str	r3, [sp, #12]
	if (check_reg(reg))
34810f54:	ebffffce 	bl	34810e94 <check_reg>
34810f58:	e3500000 	cmp	r0, #0
34810f5c:	1a00001b 	bne	34810fd0 <pmic_reg_write+0x98>
		return -1;

	switch (pmic_i2c_tx_num) {
34810f60:	e5d63010 	ldrb	r3, [r6, #16]
34810f64:	e3530001 	cmp	r3, #1
34810f68:	0a000007 	beq	34810f8c <pmic_reg_write+0x54>
34810f6c:	e3530003 	cmp	r3, #3
34810f70:	1a000007 	bne	34810f94 <pmic_reg_write+0x5c>
	case 3:
		buf[0] = (val >> 16) & 0xff;
34810f74:	e1a02824 	lsr	r2, r4, #16
		buf[1] = (val >> 8) & 0xff;
		buf[2] = val & 0xff;
34810f78:	e5cd400e 	strb	r4, [sp, #14]
		buf[0] = (val >> 16) & 0xff;
34810f7c:	e5cd200c 	strb	r2, [sp, #12]
		buf[1] = (val >> 8) & 0xff;
34810f80:	e1a02424 	lsr	r2, r4, #8
34810f84:	e5cd200d 	strb	r2, [sp, #13]
		break;
34810f88:	ea000006 	b	34810fa8 <pmic_reg_write+0x70>
	case 1:
		buf[0] = val & 0xff;
34810f8c:	e5cd400c 	strb	r4, [sp, #12]
		break;
34810f90:	ea000004 	b	34810fa8 <pmic_reg_write+0x70>
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34810f94:	e1a02003 	mov	r2, r3
34810f98:	e59f103c 	ldr	r1, [pc, #60]	; 34810fdc <pmic_reg_write+0xa4>
34810f9c:	e59f003c 	ldr	r0, [pc, #60]	; 34810fe0 <pmic_reg_write+0xa8>
34810fa0:	ebffe1fd 	bl	3480979c <printf>
34810fa4:	ea000009 	b	34810fd0 <pmic_reg_write+0x98>
		return -1;
	}

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34810fa8:	e58d3000 	str	r3, [sp]
34810fac:	e3a02001 	mov	r2, #1
34810fb0:	e5d60008 	ldrb	r0, [r6, #8]
34810fb4:	e28d300c 	add	r3, sp, #12
34810fb8:	e1a01005 	mov	r1, r5
34810fbc:	ebfffdd2 	bl	3481070c <i2c_write>
34810fc0:	e2900000 	adds	r0, r0, #0
34810fc4:	13a00001 	movne	r0, #1
34810fc8:	e2600000 	rsb	r0, r0, #0
34810fcc:	ea000000 	b	34810fd4 <pmic_reg_write+0x9c>
		return -1;
34810fd0:	e3e00000 	mvn	r0, #0
		return -1;

	return 0;
}
34810fd4:	e28dd010 	add	sp, sp, #16
34810fd8:	e8bd8070 	pop	{r4, r5, r6, pc}
34810fdc:	34821550 	.word	0x34821550
34810fe0:	34825c69 	.word	0x34825c69

34810fe4 <pmic_reg_read>:

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810fe4:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34810fe8:	e3a03000 	mov	r3, #0
{
34810fec:	e1a06000 	mov	r6, r0
	u32 ret_val = 0;

	if (check_reg(reg))
34810ff0:	e1a00001 	mov	r0, r1
{
34810ff4:	e1a04001 	mov	r4, r1
34810ff8:	e1a05002 	mov	r5, r2
	unsigned char buf[4] = { 0 };
34810ffc:	e58d3008 	str	r3, [sp, #8]
	u32 ret_val = 0;
34811000:	e58d300c 	str	r3, [sp, #12]
	if (check_reg(reg))
34811004:	ebffffa2 	bl	34810e94 <check_reg>
34811008:	e3500000 	cmp	r0, #0
3481100c:	1a00001e 	bne	3481108c <pmic_reg_read+0xa8>
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34811010:	e5d63010 	ldrb	r3, [r6, #16]
34811014:	e1a01004 	mov	r1, r4
34811018:	e5d60008 	ldrb	r0, [r6, #8]
3481101c:	e3a02001 	mov	r2, #1
34811020:	e58d3000 	str	r3, [sp]
34811024:	e28d3008 	add	r3, sp, #8
34811028:	ebfffd5b 	bl	3481059c <i2c_read>
3481102c:	e2504000 	subs	r4, r0, #0
34811030:	1a000015 	bne	3481108c <pmic_reg_read+0xa8>
		return -1;

	switch (pmic_i2c_tx_num) {
34811034:	e5d62010 	ldrb	r2, [r6, #16]
34811038:	e3520001 	cmp	r2, #1
3481103c:	0a000008 	beq	34811064 <pmic_reg_read+0x80>
34811040:	e3520003 	cmp	r2, #3
34811044:	1a00000d 	bne	34811080 <pmic_reg_read+0x9c>
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
34811048:	e5dd3009 	ldrb	r3, [sp, #9]
3481104c:	e5dd2008 	ldrb	r2, [sp, #8]
34811050:	e1a03403 	lsl	r3, r3, #8
34811054:	e1833802 	orr	r3, r3, r2, lsl #16
34811058:	e5dd200a 	ldrb	r2, [sp, #10]
3481105c:	e1833002 	orr	r3, r3, r2
34811060:	ea000000 	b	34811068 <pmic_reg_read+0x84>
		break;
	case 1:
		ret_val = buf[0];
34811064:	e5dd3008 	ldrb	r3, [sp, #8]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34811068:	e3a02004 	mov	r2, #4
3481106c:	e28d100c 	add	r1, sp, #12
34811070:	e1a00005 	mov	r0, r5
		ret_val = buf[0];
34811074:	e58d300c 	str	r3, [sp, #12]
	memcpy(val, &ret_val, sizeof(ret_val));
34811078:	eb002adf 	bl	3481bbfc <memcpy>

	return 0;
3481107c:	ea000003 	b	34811090 <pmic_reg_read+0xac>
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34811080:	e59f1014 	ldr	r1, [pc, #20]	; 3481109c <pmic_reg_read+0xb8>
34811084:	e59f0014 	ldr	r0, [pc, #20]	; 348110a0 <pmic_reg_read+0xbc>
34811088:	ebffe1c3 	bl	3480979c <printf>
		return -1;
3481108c:	e3e04000 	mvn	r4, #0
}
34811090:	e1a00004 	mov	r0, r4
34811094:	e28dd010 	add	sp, sp, #16
34811098:	e8bd8070 	pop	{r4, r5, r6, pc}
3481109c:	3482155f 	.word	0x3482155f
348110a0:	34825c69 	.word	0x34825c69

348110a4 <pmic_probe>:

int pmic_probe(struct pmic *p)
{
348110a4:	e92d4010 	push	{r4, lr}
348110a8:	e1a04000 	mov	r4, r0

static inline void I2C_SET_BUS(unsigned int bus) __attribute__((always_inline));
static inline void I2C_SET_BUS(unsigned int bus)
{
	if (I2C_MULTI_BUS)
		i2c_set_bus_num(bus);
348110ac:	e5d00004 	ldrb	r0, [r0, #4]
348110b0:	ebfffd07 	bl	348104d4 <i2c_set_bus_num>
	I2C_SET_BUS(p->bus);
	debug("PMIC:%s probed!\n", p->name);
	if (i2c_probe(pmic_i2c_addr)) {
348110b4:	e5d40008 	ldrb	r0, [r4, #8]
348110b8:	ebfffd2c 	bl	34810570 <i2c_probe>
348110bc:	e3500000 	cmp	r0, #0
348110c0:	08bd8010 	popeq	{r4, pc}
		printf("Can't find PMIC:%s\n", p->name);
348110c4:	e5941000 	ldr	r1, [r4]
348110c8:	e59f0008 	ldr	r0, [pc, #8]	; 348110d8 <pmic_probe+0x34>
348110cc:	ebffe1b2 	bl	3480979c <printf>
		return -1;
348110d0:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
348110d4:	e8bd8010 	pop	{r4, pc}
348110d8:	34825c80 	.word	0x34825c80

348110dc <pmic_init>:
#include <common.h>
#include <pmic.h>
#include <max8998_pmic.h>

int pmic_init(void)
{
348110dc:	e92d4010 	push	{r4, lr}
	struct pmic *p = get_pmic();
348110e0:	ebffff91 	bl	34810f2c <get_pmic>
348110e4:	e1a04000 	mov	r4, r0
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");
348110e8:	e59f0030 	ldr	r0, [pc, #48]	; 34811120 <pmic_init+0x44>
348110ec:	ebffe19e 	bl	3480976c <puts>

	p->name = name;
348110f0:	e59f302c 	ldr	r3, [pc, #44]	; 34811124 <pmic_init+0x48>
	p->interface = PMIC_I2C;
348110f4:	e3a00000 	mov	r0, #0
348110f8:	e5c40005 	strb	r0, [r4, #5]
	p->number_of_regs = PMIC_NUM_OF_REGS;
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
	p->hw.i2c.tx_num = 1;
	p->bus = I2C_PMIC;
348110fc:	e5c40004 	strb	r0, [r4, #4]
	p->name = name;
34811100:	e5843000 	str	r3, [r4]
	p->number_of_regs = PMIC_NUM_OF_REGS;
34811104:	e3a0302d 	mov	r3, #45	; 0x2d
34811108:	e5c43006 	strb	r3, [r4, #6]
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
3481110c:	e3a03066 	mov	r3, #102	; 0x66
34811110:	e5c43008 	strb	r3, [r4, #8]
	p->hw.i2c.tx_num = 1;
34811114:	e3a03001 	mov	r3, #1
34811118:	e5c43010 	strb	r3, [r4, #16]

	return 0;
}
3481111c:	e8bd8010 	pop	{r4, pc}
34811120:	34825c94 	.word	0x34825c94
34811124:	3482156d 	.word	0x3482156d

34811128 <__fswab32>:
34811128:	e6bf0f30 	rev	r0, r0
3481112c:	e12fff1e 	bx	lr

34811130 <__board_mmc_getcd>:
static struct list_head mmc_devices;
static int cur_dev_num = -1;

int __board_mmc_getcd(struct mmc *mmc) {
	return -1;
}
34811130:	e3e00000 	mvn	r0, #0
34811134:	e12fff1e 	bx	lr

34811138 <mmc_send_cmd>:
static inline void mmc_bounce_buffer_stop(struct mmc_data *backup,
					struct mmc_data *orig) { }
#endif

int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
34811138:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
3481113c:	e1a04000 	mov	r4, r0
34811140:	e1a05001 	mov	r5, r1
34811144:	e1a06002 	mov	r6, r2
	struct mmc_data backup;
	int ret;

	memset(&backup, 0, sizeof(backup));
34811148:	e3a01000 	mov	r1, #0
3481114c:	e3a02010 	mov	r2, #16
34811150:	e1a0000d 	mov	r0, sp
34811154:	eb002a88 	bl	3481bb7c <memset>
		default:
			printf("\t\tERROR MMC rsp not supported\n");
			break;
	}
#else
	ret = mmc->send_cmd(mmc, cmd, data);
34811158:	e5943110 	ldr	r3, [r4, #272]	; 0x110
3481115c:	e1a02006 	mov	r2, r6
34811160:	e1a01005 	mov	r1, r5
34811164:	e1a00004 	mov	r0, r4
34811168:	e12fff33 	blx	r3
#endif
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}
3481116c:	e28dd010 	add	sp, sp, #16
34811170:	e8bd8070 	pop	{r4, r5, r6, pc}

34811174 <mmc_send_status>:

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811174:	e92d4070 	push	{r4, r5, r6, lr}
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34811178:	e3a0300d 	mov	r3, #13
{
3481117c:	e24dd020 	sub	sp, sp, #32
34811180:	e1a06000 	mov	r6, r0
34811184:	e1a04001 	mov	r4, r1
34811188:	e3a05005 	mov	r5, #5
	cmd.cmdidx = MMC_CMD_SEND_STATUS;
3481118c:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811190:	e3a03015 	mov	r3, #21
34811194:	e58d3008 	str	r3, [sp, #8]
	if (!mmc_host_is_spi(mmc))
34811198:	e5903050 	ldr	r3, [r0, #80]	; 0x50
3481119c:	e3130b01 	tst	r3, #1024	; 0x400
		cmd.cmdarg = mmc->rca << 16;
348111a0:	01d038b0 	ldrheq	r3, [r0, #128]	; 0x80
348111a4:	01a03803 	lsleq	r3, r3, #16
348111a8:	058d300c 	streq	r3, [sp, #12]

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
348111ac:	e3a02000 	mov	r2, #0
348111b0:	e28d1004 	add	r1, sp, #4
348111b4:	e1a00006 	mov	r0, r6
348111b8:	ebffffde 	bl	34811138 <mmc_send_cmd>
		if (!err) {
348111bc:	e3500000 	cmp	r0, #0
348111c0:	1a00000d 	bne	348111fc <mmc_send_status+0x88>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348111c4:	e59d1010 	ldr	r1, [sp, #16]
348111c8:	e3110c01 	tst	r1, #256	; 0x100
348111cc:	0a000002 	beq	348111dc <mmc_send_status+0x68>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
348111d0:	e2013c1e 	and	r3, r1, #7680	; 0x1e00
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348111d4:	e3530c0e 	cmp	r3, #3584	; 0xe00
348111d8:	1a000011 	bne	34811224 <mmc_send_status+0xb0>
			     MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
348111dc:	e59f3050 	ldr	r3, [pc, #80]	; 34811234 <mmc_send_status+0xc0>
348111e0:	e0033001 	and	r3, r3, r1
348111e4:	e3530000 	cmp	r3, #0
348111e8:	0a000005 	beq	34811204 <mmc_send_status+0x90>
				printf("Status Error: 0x%08X\n",
348111ec:	e59f0044 	ldr	r0, [pc, #68]	; 34811238 <mmc_send_status+0xc4>
348111f0:	ebffe169 	bl	3480979c <printf>
					cmd.response[0]);
				return COMM_ERR;
348111f4:	e3e00011 	mvn	r0, #17
348111f8:	ea00000b 	b	3481122c <mmc_send_status+0xb8>
			}
		} else if (--retries < 0)
348111fc:	e2555001 	subs	r5, r5, #1
34811200:	4a000009 	bmi	3481122c <mmc_send_status+0xb8>
			return err;

		udelay(1000);
34811204:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811208:	eb002aff 	bl	3481be0c <udelay>

	} while (timeout--);
3481120c:	e2544001 	subs	r4, r4, #1
34811210:	2affffe5 	bcs	348111ac <mmc_send_status+0x38>
#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
		printf("Timeout waiting card ready\n");
34811214:	e59f0020 	ldr	r0, [pc, #32]	; 3481123c <mmc_send_status+0xc8>
34811218:	ebffe15f 	bl	3480979c <printf>
		return TIMEOUT;
3481121c:	e3e00012 	mvn	r0, #18
34811220:	ea000001 	b	3481122c <mmc_send_status+0xb8>
	if (timeout <= 0) {
34811224:	e3540000 	cmp	r4, #0
34811228:	dafffff9 	ble	34811214 <mmc_send_status+0xa0>
	}

	return 0;
}
3481122c:	e28dd020 	add	sp, sp, #32
34811230:	e8bd8070 	pop	{r4, r5, r6, pc}
34811234:	fdf94080 	.word	0xfdf94080
34811238:	34825ca5 	.word	0x34825ca5
3481123c:	34825cbb 	.word	0x34825cbb

34811240 <mmc_set_blocklen>:

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34811240:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34811244:	e3a03010 	mov	r3, #16
{
34811248:	e24dd024 	sub	sp, sp, #36	; 0x24
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
3481124c:	e3a02000 	mov	r2, #0
	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34811250:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811254:	e3a03015 	mov	r3, #21
	cmd.cmdarg = len;
34811258:	e58d100c 	str	r1, [sp, #12]
	return mmc_send_cmd(mmc, &cmd, NULL);
3481125c:	e28d1004 	add	r1, sp, #4
	cmd.resp_type = MMC_RSP_R1;
34811260:	e58d3008 	str	r3, [sp, #8]
	return mmc_send_cmd(mmc, &cmd, NULL);
34811264:	ebffffb3 	bl	34811138 <mmc_send_cmd>
}
34811268:	e28dd024 	add	sp, sp, #36	; 0x24
3481126c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34811270 <find_mmc_device>:
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811270:	e59f203c 	ldr	r2, [pc, #60]	; 348112b4 <find_mmc_device+0x44>
34811274:	e5923000 	ldr	r3, [r2]
34811278:	e1530002 	cmp	r3, r2
3481127c:	0a000004 	beq	34811294 <find_mmc_device+0x24>
		m = list_entry(entry, struct mmc, link);

		if (m->block_dev.dev == dev_num)
34811280:	e59310a4 	ldr	r1, [r3, #164]	; 0xa4
34811284:	e1510000 	cmp	r1, r0
34811288:	0a000007 	beq	348112ac <find_mmc_device+0x3c>
	list_for_each(entry, &mmc_devices) {
3481128c:	e5933000 	ldr	r3, [r3]
34811290:	eafffff8 	b	34811278 <find_mmc_device+0x8>
34811294:	e1a01000 	mov	r1, r0
{
34811298:	e92d4010 	push	{r4, lr}
			return m;
	}

	printf("MMC Device %d not found\n", dev_num);
3481129c:	e59f0014 	ldr	r0, [pc, #20]	; 348112b8 <find_mmc_device+0x48>
348112a0:	ebffe13d 	bl	3480979c <printf>

	return NULL;
348112a4:	e3a00000 	mov	r0, #0
348112a8:	e8bd8010 	pop	{r4, pc}
348112ac:	e1a00003 	mov	r0, r3
348112b0:	e12fff1e 	bx	lr
348112b4:	3482a704 	.word	0x3482a704
348112b8:	34825cd7 	.word	0x34825cd7

348112bc <mmc_berase>:
	return err;
}

static unsigned long
mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
{
348112bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348112c0:	e24dd028 	sub	sp, sp, #40	; 0x28
348112c4:	e1a0a001 	mov	sl, r1
348112c8:	e1a09002 	mov	r9, r2
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
348112cc:	ebffffe7 	bl	34811270 <find_mmc_device>
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
348112d0:	e2504000 	subs	r4, r0, #0
		return -1;
348112d4:	03e06000 	mvneq	r6, #0
	if (!mmc)
348112d8:	0a000059 	beq	34811444 <mmc_berase+0x188>

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
348112dc:	e5945090 	ldr	r5, [r4, #144]	; 0x90
348112e0:	e1a0000a 	mov	r0, sl
348112e4:	e1a01005 	mov	r1, r5
348112e8:	fa0037e3 	blx	3481f27c <__aeabi_uidivmod>
348112ec:	e3510000 	cmp	r1, #0
348112f0:	1a000004 	bne	34811308 <mmc_berase+0x4c>
348112f4:	e1a01005 	mov	r1, r5
348112f8:	e1a00009 	mov	r0, r9
348112fc:	fa0037de 	blx	3481f27c <__aeabi_uidivmod>
34811300:	e3510000 	cmp	r1, #0
34811304:	0a000008 	beq	3481132c <mmc_berase+0x70>
34811308:	e0893005 	add	r3, r9, r5
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
3481130c:	e2652000 	rsb	r2, r5, #0
		       ((start + blkcnt + mmc->erase_grp_size)
34811310:	e083300a 	add	r3, r3, sl
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
34811314:	e1a01005 	mov	r1, r5
		       & ~(mmc->erase_grp_size - 1)) - 1);
34811318:	e0033002 	and	r3, r3, r2
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
3481131c:	e59f012c 	ldr	r0, [pc, #300]	; 34811450 <mmc_berase+0x194>
34811320:	e2433001 	sub	r3, r3, #1
34811324:	e002200a 	and	r2, r2, sl
34811328:	ebffe11b 	bl	3480979c <printf>
	return 0;
3481132c:	e3a07000 	mov	r7, #0
	cmd.resp_type = MMC_RSP_R1;
34811330:	e3a0b015 	mov	fp, #21

	while (blk < blkcnt) {
34811334:	e1570009 	cmp	r7, r9
34811338:	2a000039 	bcs	34811424 <mmc_berase+0x168>
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
3481133c:	e5943090 	ldr	r3, [r4, #144]	; 0x90
			mmc->erase_grp_size : (blkcnt - blk);
34811340:	e0675009 	rsb	r5, r7, r9
		err = mmc_erase_t(mmc, start + blk, blk_r);
34811344:	e087200a 	add	r2, r7, sl
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811348:	e1a00004 	mov	r0, r4
3481134c:	e2426001 	sub	r6, r2, #1
	cmd.resp_type = MMC_RSP_R1;
34811350:	e58db010 	str	fp, [sp, #16]
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34811354:	e1550003 	cmp	r5, r3
34811358:	21a05003 	movcs	r5, r3
	if (mmc->high_capacity)
3481135c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
34811360:	e3530000 	cmp	r3, #0
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811364:	0594308c 	ldreq	r3, [r4, #140]	; 0x8c
34811368:	00866005 	addeq	r6, r6, r5
		end = start + blkcnt - 1;
3481136c:	10866005 	addne	r6, r6, r5
		start *= mmc->write_bl_len;
34811370:	00020293 	muleq	r2, r3, r2
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811374:	00060693 	muleq	r6, r3, r6
	if (IS_SD(mmc)) {
34811378:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	cmd.cmdarg = start;
3481137c:	e58d2014 	str	r2, [sp, #20]
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811380:	e3a02000 	mov	r2, #0
	if (IS_SD(mmc)) {
34811384:	e2033802 	and	r3, r3, #131072	; 0x20000
		end_cmd = MMC_CMD_ERASE_GROUP_END;
34811388:	e3530000 	cmp	r3, #0
3481138c:	13a01020 	movne	r1, #32
34811390:	03a01023 	moveq	r1, #35	; 0x23
34811394:	13a03021 	movne	r3, #33	; 0x21
34811398:	03a03024 	moveq	r3, #36	; 0x24
	cmd.cmdidx = start_cmd;
3481139c:	e1cd10bc 	strh	r1, [sp, #12]
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113a0:	e28d100c 	add	r1, sp, #12
		end_cmd = MMC_CMD_ERASE_GROUP_END;
348113a4:	e58d3004 	str	r3, [sp, #4]
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113a8:	ebffff62 	bl	34811138 <mmc_send_cmd>
	if (err)
348113ac:	e2502000 	subs	r2, r0, #0
348113b0:	e59d3004 	ldr	r3, [sp, #4]
348113b4:	1a000011 	bne	34811400 <mmc_berase+0x144>
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113b8:	e28d100c 	add	r1, sp, #12
348113bc:	e1a00004 	mov	r0, r4
	cmd.cmdidx = end_cmd;
348113c0:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = end;
348113c4:	e58d6014 	str	r6, [sp, #20]
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113c8:	ebffff5a 	bl	34811138 <mmc_send_cmd>
	if (err)
348113cc:	e2502000 	subs	r2, r0, #0
348113d0:	1a00000a 	bne	34811400 <mmc_berase+0x144>
	cmd.cmdidx = MMC_CMD_ERASE;
348113d4:	e3a03026 	mov	r3, #38	; 0x26
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113d8:	e28d100c 	add	r1, sp, #12
	cmd.cmdidx = MMC_CMD_ERASE;
348113dc:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = SECURE_ERASE;
348113e0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
348113e4:	e58d3014 	str	r3, [sp, #20]
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113e8:	e1a00004 	mov	r0, r4
	cmd.resp_type = MMC_RSP_R1b;
348113ec:	e3a0301d 	mov	r3, #29
348113f0:	e58d3010 	str	r3, [sp, #16]
	err = mmc_send_cmd(mmc, &cmd, NULL);
348113f4:	ebffff4f 	bl	34811138 <mmc_send_cmd>
	if (err)
348113f8:	e2502000 	subs	r2, r0, #0
348113fc:	0a000006 	beq	3481141c <mmc_berase+0x160>
	puts("mmc erase failed\n");
34811400:	e59f004c 	ldr	r0, [pc, #76]	; 34811454 <mmc_berase+0x198>
34811404:	e58d2004 	str	r2, [sp, #4]
34811408:	ebffe0d7 	bl	3480976c <puts>
		if (err)
3481140c:	e59d2004 	ldr	r2, [sp, #4]
34811410:	e2526000 	subs	r6, r2, #0
34811414:	0a000004 	beq	3481142c <mmc_berase+0x170>
34811418:	ea000001 	b	34811424 <mmc_berase+0x168>
	return 0;
3481141c:	e1a06002 	mov	r6, r2
34811420:	ea000001 	b	3481142c <mmc_berase+0x170>
		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
			return 0;
	}

	return blk;
34811424:	e1a06007 	mov	r6, r7
34811428:	ea000005 	b	34811444 <mmc_berase+0x188>
		if (mmc_send_status(mmc, timeout))
3481142c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811430:	e1a00004 	mov	r0, r4
34811434:	ebffff4e 	bl	34811174 <mmc_send_status>
34811438:	e3500000 	cmp	r0, #0
		blk += blk_r;
3481143c:	e0877005 	add	r7, r7, r5
		if (mmc_send_status(mmc, timeout))
34811440:	0affffbb 	beq	34811334 <mmc_berase+0x78>
}
34811444:	e1a00006 	mov	r0, r6
34811448:	e28dd028 	add	sp, sp, #40	; 0x28
3481144c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811450:	34825cf0 	.word	0x34825cf0
34811454:	34825d4d 	.word	0x34825d4d

34811458 <mmc_bwrite>:
	return blkcnt;
}

static ulong
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
34811458:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481145c:	e24dd030 	sub	sp, sp, #48	; 0x30
34811460:	e1a04001 	mov	r4, r1
34811464:	e1a06002 	mov	r6, r2
34811468:	e1a0a003 	mov	sl, r3
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
3481146c:	ebffff7f 	bl	34811270 <find_mmc_device>
	if (!mmc)
34811470:	e250b000 	subs	fp, r0, #0
34811474:	1a000001 	bne	34811480 <mmc_bwrite+0x28>
		return 0;
34811478:	e3a00000 	mov	r0, #0
3481147c:	ea00004c 	b	348115b4 <mmc_bwrite+0x15c>

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
34811480:	e59b108c 	ldr	r1, [fp, #140]	; 0x8c
34811484:	ebffff6d 	bl	34811240 <mmc_set_blocklen>
34811488:	e3500000 	cmp	r0, #0
3481148c:	1afffff9 	bne	34811478 <mmc_bwrite+0x20>
34811490:	e1a07006 	mov	r7, r6
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811494:	e59b3120 	ldr	r3, [fp, #288]	; 0x120
	if ((start + blkcnt) > mmc->block_dev.lba) {
34811498:	e59b20b0 	ldr	r2, [fp, #176]	; 0xb0
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
3481149c:	e1570003 	cmp	r7, r3
348114a0:	31a05007 	movcc	r5, r7
348114a4:	21a05003 	movcs	r5, r3
	if ((start + blkcnt) > mmc->block_dev.lba) {
348114a8:	e0859004 	add	r9, r5, r4
348114ac:	e1590002 	cmp	r9, r2
348114b0:	9a000003 	bls	348114c4 <mmc_bwrite+0x6c>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
348114b4:	e1a01009 	mov	r1, r9
348114b8:	e59f00fc 	ldr	r0, [pc, #252]	; 348115bc <mmc_bwrite+0x164>
348114bc:	ebffe0b6 	bl	3480979c <printf>
348114c0:	ea000017 	b	34811524 <mmc_bwrite+0xcc>
	if (blkcnt > 1)
348114c4:	e3550001 	cmp	r5, #1
	cmd.resp_type = MMC_RSP_R1;
348114c8:	e3a02015 	mov	r2, #21
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
348114cc:	83a03019 	movhi	r3, #25
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
348114d0:	93a03018 	movls	r3, #24
348114d4:	e1cd31b4 	strh	r3, [sp, #20]
	if (mmc_send_cmd(mmc, &cmd, &data)) {
348114d8:	e28d1014 	add	r1, sp, #20
	if (mmc->high_capacity)
348114dc:	e59b3040 	ldr	r3, [fp, #64]	; 0x40
	if (mmc_send_cmd(mmc, &cmd, &data)) {
348114e0:	e1a0000b 	mov	r0, fp
	cmd.resp_type = MMC_RSP_R1;
348114e4:	e58d2018 	str	r2, [sp, #24]
	if (mmc_send_cmd(mmc, &cmd, &data)) {
348114e8:	e28d2004 	add	r2, sp, #4
	data.src = src;
348114ec:	e58da004 	str	sl, [sp, #4]
	if (mmc->high_capacity)
348114f0:	e3530000 	cmp	r3, #0
348114f4:	e59b308c 	ldr	r3, [fp, #140]	; 0x8c
	data.blocks = blkcnt;
348114f8:	e58d500c 	str	r5, [sp, #12]
	data.blocksize = mmc->write_bl_len;
348114fc:	e58d3010 	str	r3, [sp, #16]
		cmd.cmdarg = start * mmc->write_bl_len;
34811500:	00040493 	muleq	r4, r3, r4
	data.flags = MMC_DATA_WRITE;
34811504:	e3a03002 	mov	r3, #2
34811508:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = start * mmc->write_bl_len;
3481150c:	e58d401c 	str	r4, [sp, #28]
	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811510:	ebffff08 	bl	34811138 <mmc_send_cmd>
34811514:	e2504000 	subs	r4, r0, #0
34811518:	0a000003 	beq	3481152c <mmc_bwrite+0xd4>
		printf("mmc write failed\n");
3481151c:	e59f009c 	ldr	r0, [pc, #156]	; 348115c0 <mmc_bwrite+0x168>
34811520:	ebffe09d 	bl	3480979c <printf>
		return 0;
34811524:	e3a02000 	mov	r2, #0
34811528:	ea000019 	b	34811594 <mmc_bwrite+0x13c>
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
3481152c:	e59b3050 	ldr	r3, [fp, #80]	; 0x50
34811530:	e2233b01 	eor	r3, r3, #1024	; 0x400
34811534:	e7e03553 	ubfx	r3, r3, #10, #1
34811538:	e3550001 	cmp	r5, #1
3481153c:	93a03000 	movls	r3, #0
34811540:	82033001 	andhi	r3, r3, #1
34811544:	e3530000 	cmp	r3, #0
34811548:	0a00000b 	beq	3481157c <mmc_bwrite+0x124>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
3481154c:	e3a0300c 	mov	r3, #12
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811550:	e1a02004 	mov	r2, r4
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811554:	e1cd31b4 	strh	r3, [sp, #20]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811558:	e28d1014 	add	r1, sp, #20
		cmd.resp_type = MMC_RSP_R1b;
3481155c:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811560:	e1a0000b 	mov	r0, fp
		cmd.cmdarg = 0;
34811564:	e58d401c 	str	r4, [sp, #28]
		cmd.resp_type = MMC_RSP_R1b;
34811568:	e58d3018 	str	r3, [sp, #24]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
3481156c:	ebfffef1 	bl	34811138 <mmc_send_cmd>
34811570:	e3500000 	cmp	r0, #0
			printf("mmc fail to send stop cmd\n");
34811574:	159f0048 	ldrne	r0, [pc, #72]	; 348115c4 <mmc_bwrite+0x16c>
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811578:	1affffe8 	bne	34811520 <mmc_bwrite+0xc8>
	if (mmc_send_status(mmc, timeout))
3481157c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811580:	e1a0000b 	mov	r0, fp
34811584:	ebfffefa 	bl	34811174 <mmc_send_status>
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811588:	e3500000 	cmp	r0, #0
3481158c:	01a02005 	moveq	r2, r5
34811590:	13a02000 	movne	r2, #0
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
34811594:	e1520005 	cmp	r2, r5
34811598:	1affffb6 	bne	34811478 <mmc_bwrite+0x20>
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
3481159c:	e59b308c 	ldr	r3, [fp, #140]	; 0x8c
	} while (blocks_todo > 0);
348115a0:	e0577002 	subs	r7, r7, r2
	if ((start + blkcnt) > mmc->block_dev.lba) {
348115a4:	e1a04009 	mov	r4, r9
		src += cur * mmc->write_bl_len;
348115a8:	e02aa293 	mla	sl, r3, r2, sl
	} while (blocks_todo > 0);
348115ac:	1affffb8 	bne	34811494 <mmc_bwrite+0x3c>

	return blkcnt;
348115b0:	e1a00006 	mov	r0, r6
}
348115b4:	e28dd030 	add	sp, sp, #48	; 0x30
348115b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348115bc:	34825d5f 	.word	0x34825d5f
348115c0:	34825d8b 	.word	0x34825d8b
348115c4:	34825d9d 	.word	0x34825d9d

348115c8 <mmc_read_blocks>:
int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
348115c8:	e3530001 	cmp	r3, #1
{
348115cc:	e92d4070 	push	{r4, r5, r6, lr}
348115d0:	e1a05003 	mov	r5, r3
348115d4:	e24dd030 	sub	sp, sp, #48	; 0x30
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
348115d8:	83a03012 	movhi	r3, #18
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
348115dc:	93a03011 	movls	r3, #17
348115e0:	e1cd31b4 	strh	r3, [sp, #20]
{
348115e4:	e1a06000 	mov	r6, r0

	if (mmc->high_capacity)
348115e8:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	else
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
348115ec:	e58d1004 	str	r1, [sp, #4]
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
348115f0:	e28d1014 	add	r1, sp, #20
	data.blocks = blkcnt;
348115f4:	e58d500c 	str	r5, [sp, #12]
	if (mmc->high_capacity)
348115f8:	e3530000 	cmp	r3, #0
348115fc:	e5903088 	ldr	r3, [r0, #136]	; 0x88
	data.blocksize = mmc->read_bl_len;
34811600:	e58d3010 	str	r3, [sp, #16]
		cmd.cmdarg = start * mmc->read_bl_len;
34811604:	00020293 	muleq	r2, r3, r2
	data.flags = MMC_DATA_READ;
34811608:	e3a03001 	mov	r3, #1
3481160c:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = start * mmc->read_bl_len;
34811610:	e58d201c 	str	r2, [sp, #28]
	cmd.resp_type = MMC_RSP_R1;
34811614:	e3a02015 	mov	r2, #21
34811618:	e58d2018 	str	r2, [sp, #24]
	if (mmc_send_cmd(mmc, &cmd, &data))
3481161c:	e28d2004 	add	r2, sp, #4
34811620:	ebfffec4 	bl	34811138 <mmc_send_cmd>
34811624:	e2504000 	subs	r4, r0, #0
		return 0;
34811628:	13a04000 	movne	r4, #0
	if (mmc_send_cmd(mmc, &cmd, &data))
3481162c:	1a000010 	bne	34811674 <mmc_read_blocks+0xac>

	if (blkcnt > 1) {
34811630:	e3550001 	cmp	r5, #1
34811634:	9a00000d 	bls	34811670 <mmc_read_blocks+0xa8>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811638:	e3a0300c 	mov	r3, #12
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
3481163c:	e1a02004 	mov	r2, r4
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811640:	e1cd31b4 	strh	r3, [sp, #20]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811644:	e28d1014 	add	r1, sp, #20
		cmd.resp_type = MMC_RSP_R1b;
34811648:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
3481164c:	e1a00006 	mov	r0, r6
		cmd.cmdarg = 0;
34811650:	e58d401c 	str	r4, [sp, #28]
		cmd.resp_type = MMC_RSP_R1b;
34811654:	e58d3018 	str	r3, [sp, #24]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811658:	ebfffeb6 	bl	34811138 <mmc_send_cmd>
3481165c:	e3500000 	cmp	r0, #0
34811660:	0a000002 	beq	34811670 <mmc_read_blocks+0xa8>
			printf("mmc fail to send stop cmd\n");
34811664:	e59f0014 	ldr	r0, [pc, #20]	; 34811680 <mmc_read_blocks+0xb8>
34811668:	ebffe04b 	bl	3480979c <printf>
			return 0;
3481166c:	ea000000 	b	34811674 <mmc_read_blocks+0xac>
		}
	}

	return blkcnt;
34811670:	e1a04005 	mov	r4, r5
}
34811674:	e1a00004 	mov	r0, r4
34811678:	e28dd030 	add	sp, sp, #48	; 0x30
3481167c:	e8bd8070 	pop	{r4, r5, r6, pc}
34811680:	34825d9d 	.word	0x34825d9d

34811684 <mmc_bread>:

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811684:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811688:	e2524000 	subs	r4, r2, #0
3481168c:	0a00000a 	beq	348116bc <mmc_bread+0x38>
34811690:	e1a07001 	mov	r7, r1
34811694:	e1a09003 	mov	r9, r3
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
34811698:	ebfffef4 	bl	34811270 <find_mmc_device>
	if (!mmc)
3481169c:	e2506000 	subs	r6, r0, #0
348116a0:	0a000005 	beq	348116bc <mmc_bread+0x38>
		return 0;

	if ((start + blkcnt) > mmc->block_dev.lba) {
348116a4:	e59620b0 	ldr	r2, [r6, #176]	; 0xb0
348116a8:	e0841007 	add	r1, r4, r7
348116ac:	e1510002 	cmp	r1, r2
348116b0:	9a000003 	bls	348116c4 <mmc_bread+0x40>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
348116b4:	e59f0064 	ldr	r0, [pc, #100]	; 34811720 <mmc_bread+0x9c>
348116b8:	ebffe037 	bl	3480979c <printf>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
348116bc:	e3a00000 	mov	r0, #0
348116c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
348116c4:	e5961088 	ldr	r1, [r6, #136]	; 0x88
348116c8:	ebfffedc 	bl	34811240 <mmc_set_blocklen>
348116cc:	e3500000 	cmp	r0, #0
348116d0:	1afffff9 	bne	348116bc <mmc_bread+0x38>
348116d4:	e1a05004 	mov	r5, r4
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
348116d8:	e5963120 	ldr	r3, [r6, #288]	; 0x120
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
348116dc:	e1a02007 	mov	r2, r7
348116e0:	e1a01009 	mov	r1, r9
348116e4:	e1a00006 	mov	r0, r6
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
348116e8:	e1550003 	cmp	r5, r3
348116ec:	31a0a005 	movcc	sl, r5
348116f0:	21a0a003 	movcs	sl, r3
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
348116f4:	e1a0300a 	mov	r3, sl
348116f8:	ebffffb2 	bl	348115c8 <mmc_read_blocks>
348116fc:	e150000a 	cmp	r0, sl
34811700:	1affffed 	bne	348116bc <mmc_bread+0x38>
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
34811704:	e5963088 	ldr	r3, [r6, #136]	; 0x88
	} while (blocks_todo > 0);
34811708:	e0555000 	subs	r5, r5, r0
		start += cur;
3481170c:	e0877000 	add	r7, r7, r0
		dst += cur * mmc->read_bl_len;
34811710:	e0299093 	mla	r9, r3, r0, r9
	} while (blocks_todo > 0);
34811714:	1affffef 	bne	348116d8 <mmc_bread+0x54>
34811718:	e1a00004 	mov	r0, r4

	return blkcnt;
}
3481171c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811720:	34825d5f 	.word	0x34825d5f

34811724 <mmc_go_idle>:

int mmc_go_idle(struct mmc* mmc)
{
34811724:	e92d4010 	push	{r4, lr}
34811728:	e1a04000 	mov	r4, r0
3481172c:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	udelay(1000);
34811730:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811734:	eb0029b4 	bl	3481be0c <udelay>

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811738:	e3a02000 	mov	r2, #0
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481173c:	e1a00004 	mov	r0, r4
34811740:	e28d1004 	add	r1, sp, #4
	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811744:	e1cd20b4 	strh	r2, [sp, #4]
	cmd.cmdarg = 0;
34811748:	e58d200c 	str	r2, [sp, #12]
	cmd.resp_type = MMC_RSP_NONE;
3481174c:	e58d2008 	str	r2, [sp, #8]
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811750:	ebfffe78 	bl	34811138 <mmc_send_cmd>

	if (err)
34811754:	e2504000 	subs	r4, r0, #0
34811758:	1a000001 	bne	34811764 <mmc_go_idle+0x40>
		return err;

	udelay(2000);
3481175c:	e3a00e7d 	mov	r0, #2000	; 0x7d0
34811760:	eb0029a9 	bl	3481be0c <udelay>

	return 0;
}
34811764:	e1a00004 	mov	r0, r4
34811768:	e28dd020 	add	sp, sp, #32
3481176c:	e8bd8010 	pop	{r4, pc}

34811770 <sd_send_op_cond>:

int
sd_send_op_cond(struct mmc *mmc)
{
34811770:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34811774:	e1a04000 	mov	r4, r0
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811778:	e59f7120 	ldr	r7, [pc, #288]	; 348118a0 <sd_send_op_cond+0x130>
{
3481177c:	e24dd024 	sub	sp, sp, #36	; 0x24
	int timeout = 1000;
34811780:	e3a05ffa 	mov	r5, #1000	; 0x3e8
		cmd.cmdidx = MMC_CMD_APP_CMD;
34811784:	e3a06037 	mov	r6, #55	; 0x37
		cmd.resp_type = MMC_RSP_R1;
34811788:	e3a03015 	mov	r3, #21
		cmd.cmdarg = 0;
3481178c:	e3a02000 	mov	r2, #0
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811790:	e28d1004 	add	r1, sp, #4
34811794:	e1a00004 	mov	r0, r4
		cmd.cmdidx = MMC_CMD_APP_CMD;
34811798:	e1cd60b4 	strh	r6, [sp, #4]
		cmd.resp_type = MMC_RSP_R1;
3481179c:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
348117a0:	e58d200c 	str	r2, [sp, #12]
		err = mmc_send_cmd(mmc, &cmd, NULL);
348117a4:	ebfffe63 	bl	34811138 <mmc_send_cmd>
		if (err)
348117a8:	e3500000 	cmp	r0, #0
348117ac:	1a000039 	bne	34811898 <sd_send_op_cond+0x128>
		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
348117b0:	e3a03029 	mov	r3, #41	; 0x29
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348117b4:	e3a02000 	mov	r2, #0
		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
348117b8:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
348117bc:	e3a03001 	mov	r3, #1
348117c0:	e58d3008 	str	r3, [sp, #8]
		err = mmc_send_cmd(mmc, &cmd, NULL);
348117c4:	e28d1004 	add	r1, sp, #4
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
348117c8:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348117cc:	e3130b01 	tst	r3, #1024	; 0x400
348117d0:	059f00cc 	ldreq	r0, [pc, #204]	; 348118a4 <sd_send_op_cond+0x134>
348117d4:	0594302c 	ldreq	r3, [r4, #44]	; 0x2c
348117d8:	00000003 	andeq	r0, r0, r3
		if (mmc->version == SD_VERSION_2)
348117dc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
348117e0:	e58d000c 	str	r0, [sp, #12]
		if (mmc->version == SD_VERSION_2)
348117e4:	e1530007 	cmp	r3, r7
			cmd.cmdarg |= OCR_HCS;
348117e8:	03800101 	orreq	r0, r0, #1073741824	; 0x40000000
348117ec:	058d000c 	streq	r0, [sp, #12]
		err = mmc_send_cmd(mmc, &cmd, NULL);
348117f0:	e1a00004 	mov	r0, r4
348117f4:	ebfffe4f 	bl	34811138 <mmc_send_cmd>

		if (err)
348117f8:	e3500000 	cmp	r0, #0
348117fc:	1a000025 	bne	34811898 <sd_send_op_cond+0x128>
			return err;

		udelay(1000);
34811800:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811804:	eb002980 	bl	3481be0c <udelay>
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
34811808:	e59d3010 	ldr	r3, [sp, #16]
3481180c:	e3530000 	cmp	r3, #0
34811810:	ba000002 	blt	34811820 <sd_send_op_cond+0xb0>
34811814:	e2555001 	subs	r5, r5, #1
34811818:	2affffda 	bcs	34811788 <sd_send_op_cond+0x18>
3481181c:	ea00001c 	b	34811894 <sd_send_op_cond+0x124>

	if (timeout <= 0)
34811820:	e3550000 	cmp	r5, #0
34811824:	0a00001a 	beq	34811894 <sd_send_op_cond+0x124>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
34811828:	e59f3070 	ldr	r3, [pc, #112]	; 348118a0 <sd_send_op_cond+0x130>
3481182c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34811830:	e1520003 	cmp	r2, r3
		mmc->version = SD_VERSION_1_0;
34811834:	12433010 	subne	r3, r3, #16
34811838:	15843030 	strne	r3, [r4, #48]	; 0x30

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
3481183c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811840:	e3130b01 	tst	r3, #1024	; 0x400
34811844:	1a000006 	bne	34811864 <sd_send_op_cond+0xf4>

		if (err)
			return err;
	}

	mmc->ocr = cmd.response[0];
34811848:	e59d3010 	ldr	r3, [sp, #16]

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
3481184c:	e3a00000 	mov	r0, #0
34811850:	e1c408b0 	strh	r0, [r4, #128]	; 0x80
	mmc->ocr = cmd.response[0];
34811854:	e5843054 	str	r3, [r4, #84]	; 0x54
	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811858:	e7e03f53 	ubfx	r3, r3, #30, #1
3481185c:	e5843040 	str	r3, [r4, #64]	; 0x40

	return 0;
34811860:	ea00000c 	b	34811898 <sd_send_op_cond+0x128>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811864:	e3a0303a 	mov	r3, #58	; 0x3a
		cmd.cmdarg = 0;
34811868:	e3a02000 	mov	r2, #0
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
3481186c:	e1cd30b4 	strh	r3, [sp, #4]
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811870:	e28d1004 	add	r1, sp, #4
		cmd.resp_type = MMC_RSP_R3;
34811874:	e3a03001 	mov	r3, #1
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811878:	e1a00004 	mov	r0, r4
		cmd.resp_type = MMC_RSP_R3;
3481187c:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
34811880:	e58d200c 	str	r2, [sp, #12]
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811884:	ebfffe2b 	bl	34811138 <mmc_send_cmd>
		if (err)
34811888:	e3500000 	cmp	r0, #0
3481188c:	0affffed 	beq	34811848 <sd_send_op_cond+0xd8>
34811890:	ea000000 	b	34811898 <sd_send_op_cond+0x128>
		return UNUSABLE_ERR;
34811894:	e3e00010 	mvn	r0, #16
}
34811898:	e28dd024 	add	sp, sp, #36	; 0x24
3481189c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
348118a0:	00020020 	.word	0x00020020
348118a4:	00ff8000 	.word	0x00ff8000

348118a8 <mmc_send_op_cond>:

int mmc_send_op_cond(struct mmc *mmc)
{
348118a8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
348118ac:	e1a05000 	mov	r5, r0
348118b0:	e24dd024 	sub	sp, sp, #36	; 0x24

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348118b4:	e3a06001 	mov	r6, #1
	mmc_go_idle(mmc);
348118b8:	ebffff99 	bl	34811724 <mmc_go_idle>
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;
348118bc:	e3a02000 	mov	r2, #0

 	err = mmc_send_cmd(mmc, &cmd, NULL);
348118c0:	e28d1004 	add	r1, sp, #4
348118c4:	e1a00005 	mov	r0, r5
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348118c8:	e1cd60b4 	strh	r6, [sp, #4]
 	cmd.resp_type = MMC_RSP_R3;
348118cc:	e58d6008 	str	r6, [sp, #8]
 	cmd.cmdarg = 0;
348118d0:	e58d200c 	str	r2, [sp, #12]
 	err = mmc_send_cmd(mmc, &cmd, NULL);
348118d4:	ebfffe17 	bl	34811138 <mmc_send_cmd>

 	if (err)
348118d8:	e3500000 	cmp	r0, #0
348118dc:	1a00003c 	bne	348119d4 <mmc_send_op_cond+0x12c>
	int timeout = 10000;
348118e0:	e3027710 	movw	r7, #10000	; 0x2710
 		return err;

 	udelay(1000);
348118e4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348118e8:	eb002947 	bl	3481be0c <udelay>

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348118ec:	e5950050 	ldr	r0, [r5, #80]	; 0x50
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348118f0:	e1cd60b4 	strh	r6, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
348118f4:	e58d6008 	str	r6, [sp, #8]
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348118f8:	e3100b01 	tst	r0, #1024	; 0x400
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
348118fc:	059d2010 	ldreq	r2, [sp, #16]
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811900:	13a03000 	movne	r3, #0
				(mmc->voltages &
34811904:	0595102c 	ldreq	r1, [r5, #44]	; 0x2c
34811908:	059f30cc 	ldreq	r3, [pc, #204]	; 348119dc <mmc_send_op_cond+0x134>
3481190c:	00011002 	andeq	r1, r1, r2
				(cmd.response[0] & OCR_ACCESS_MODE));
34811910:	02022206 	andeq	r2, r2, #1610612736	; 0x60000000
				(mmc->voltages &
34811914:	00033001 	andeq	r3, r3, r1

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811918:	e28d1004 	add	r1, sp, #4
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
3481191c:	01833002 	orreq	r3, r3, r2
		if (mmc->host_caps & MMC_MODE_HC)
34811920:	e3100b02 	tst	r0, #2048	; 0x800
			cmd.cmdarg |= OCR_HCS;
34811924:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811928:	e3a02000 	mov	r2, #0
3481192c:	e1a00005 	mov	r0, r5
			cmd.cmdarg |= OCR_HCS;
34811930:	e58d300c 	str	r3, [sp, #12]
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811934:	ebfffdff 	bl	34811138 <mmc_send_cmd>

		if (err)
34811938:	e2504000 	subs	r4, r0, #0
3481193c:	1a000021 	bne	348119c8 <mmc_send_op_cond+0x120>
			return err;

		udelay(1000);
34811940:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811944:	eb002930 	bl	3481be0c <udelay>
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811948:	e59d3010 	ldr	r3, [sp, #16]
3481194c:	e3530000 	cmp	r3, #0
34811950:	ba000002 	blt	34811960 <mmc_send_op_cond+0xb8>
34811954:	e2577001 	subs	r7, r7, #1
34811958:	2affffe3 	bcs	348118ec <mmc_send_op_cond+0x44>
3481195c:	ea00001b 	b	348119d0 <mmc_send_op_cond+0x128>

	if (timeout <= 0)
34811960:	e3570000 	cmp	r7, #0
34811964:	0a000019 	beq	348119d0 <mmc_send_op_cond+0x128>
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811968:	e5953050 	ldr	r3, [r5, #80]	; 0x50
3481196c:	e3130b01 	tst	r3, #1024	; 0x400
34811970:	1a000008 	bne	34811998 <mmc_send_op_cond+0xf0>

		if (err)
			return err;
	}

	mmc->version = MMC_VERSION_UNKNOWN;
34811974:	e3a03801 	mov	r3, #65536	; 0x10000
	mmc->ocr = cmd.response[0];

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
34811978:	e3a00000 	mov	r0, #0
	mmc->version = MMC_VERSION_UNKNOWN;
3481197c:	e5853030 	str	r3, [r5, #48]	; 0x30
	mmc->ocr = cmd.response[0];
34811980:	e59d3010 	ldr	r3, [sp, #16]
	mmc->rca = 0;
34811984:	e1c508b0 	strh	r0, [r5, #128]	; 0x80
	mmc->ocr = cmd.response[0];
34811988:	e5853054 	str	r3, [r5, #84]	; 0x54
	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
3481198c:	e7e03f53 	ubfx	r3, r3, #30, #1
34811990:	e5853040 	str	r3, [r5, #64]	; 0x40

	return 0;
34811994:	ea00000e 	b	348119d4 <mmc_send_op_cond+0x12c>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811998:	e3a0303a 	mov	r3, #58	; 0x3a
		err = mmc_send_cmd(mmc, &cmd, NULL);
3481199c:	e1a02004 	mov	r2, r4
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
348119a0:	e1cd30b4 	strh	r3, [sp, #4]
		err = mmc_send_cmd(mmc, &cmd, NULL);
348119a4:	e28d1004 	add	r1, sp, #4
		cmd.resp_type = MMC_RSP_R3;
348119a8:	e3a03001 	mov	r3, #1
		err = mmc_send_cmd(mmc, &cmd, NULL);
348119ac:	e1a00005 	mov	r0, r5
		cmd.resp_type = MMC_RSP_R3;
348119b0:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
348119b4:	e58d400c 	str	r4, [sp, #12]
		err = mmc_send_cmd(mmc, &cmd, NULL);
348119b8:	ebfffdde 	bl	34811138 <mmc_send_cmd>
		if (err)
348119bc:	e3500000 	cmp	r0, #0
348119c0:	0affffeb 	beq	34811974 <mmc_send_op_cond+0xcc>
348119c4:	ea000002 	b	348119d4 <mmc_send_op_cond+0x12c>
348119c8:	e1a00004 	mov	r0, r4
348119cc:	ea000000 	b	348119d4 <mmc_send_op_cond+0x12c>
		return UNUSABLE_ERR;
348119d0:	e3e00010 	mvn	r0, #16
}
348119d4:	e28dd024 	add	sp, sp, #36	; 0x24
348119d8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
348119dc:	007fff80 	.word	0x007fff80

348119e0 <mmc_send_ext_csd>:


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
348119e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348119e4:	e3a03008 	mov	r3, #8
{
348119e8:	e24dd034 	sub	sp, sp, #52	; 0x34
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
348119ec:	e3a02c02 	mov	r2, #512	; 0x200
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348119f0:	e1cd31b4 	strh	r3, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
348119f4:	e3a03015 	mov	r3, #21
348119f8:	e58d3018 	str	r3, [sp, #24]
	cmd.cmdarg = 0;
348119fc:	e3a03000 	mov	r3, #0
34811a00:	e58d301c 	str	r3, [sp, #28]
	data.blocks = 1;
34811a04:	e3a03001 	mov	r3, #1
	data.dest = (char *)ext_csd;
34811a08:	e58d1004 	str	r1, [sp, #4]
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811a0c:	e28d1014 	add	r1, sp, #20
	data.blocksize = 512;
34811a10:	e58d2010 	str	r2, [sp, #16]
	err = mmc_send_cmd(mmc, &cmd, &data);
34811a14:	e28d2004 	add	r2, sp, #4
	data.blocks = 1;
34811a18:	e58d300c 	str	r3, [sp, #12]
	data.flags = MMC_DATA_READ;
34811a1c:	e58d3008 	str	r3, [sp, #8]
	err = mmc_send_cmd(mmc, &cmd, &data);
34811a20:	ebfffdc4 	bl	34811138 <mmc_send_cmd>

	return err;
}
34811a24:	e28dd034 	add	sp, sp, #52	; 0x34
34811a28:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34811a2c <mmc_switch>:

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
				 (value << 8);
34811a2c:	e1a03403 	lsl	r3, r3, #8
{
34811a30:	e92d4010 	push	{r4, lr}
	cmd.cmdidx = MMC_CMD_SWITCH;
34811a34:	e3a01006 	mov	r1, #6
34811a38:	e3833403 	orr	r3, r3, #50331648	; 0x3000000
{
34811a3c:	e24dd020 	sub	sp, sp, #32
				 (index << 16) |
34811a40:	e1832802 	orr	r2, r3, r2, lsl #16
	cmd.cmdidx = MMC_CMD_SWITCH;
34811a44:	e1cd10b4 	strh	r1, [sp, #4]
	cmd.resp_type = MMC_RSP_R1b;
34811a48:	e3a0101d 	mov	r1, #29
34811a4c:	e58d1008 	str	r1, [sp, #8]

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811a50:	e28d1004 	add	r1, sp, #4
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34811a54:	e58d200c 	str	r2, [sp, #12]
	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811a58:	e3a02000 	mov	r2, #0
{
34811a5c:	e1a04000 	mov	r4, r0
	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811a60:	ebfffdb4 	bl	34811138 <mmc_send_cmd>

	/* Waiting for the ready status */
	if (!ret)
34811a64:	e3500000 	cmp	r0, #0
34811a68:	1a000002 	bne	34811a78 <mmc_switch+0x4c>
		ret = mmc_send_status(mmc, timeout);
34811a6c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811a70:	e1a00004 	mov	r0, r4
34811a74:	ebfffdbe 	bl	34811174 <mmc_send_status>

	return ret;

}
34811a78:	e28dd020 	add	sp, sp, #32
34811a7c:	e8bd8010 	pop	{r4, pc}

34811a80 <mmc_change_freq>:
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811a80:	e3a03000 	mov	r3, #0
{
34811a84:	e92d4070 	push	{r4, r5, r6, lr}
	mmc->card_caps = 0;
34811a88:	e580304c 	str	r3, [r0, #76]	; 0x4c
{
34811a8c:	e24ddd09 	sub	sp, sp, #576	; 0x240
34811a90:	e1a04000 	mov	r4, r0

	if (mmc_host_is_spi(mmc))
34811a94:	e5903050 	ldr	r3, [r0, #80]	; 0x50
34811a98:	e3130b01 	tst	r3, #1024	; 0x400
34811a9c:	0a000001 	beq	34811aa8 <mmc_change_freq+0x28>
		return 0;
34811aa0:	e3a00000 	mov	r0, #0
34811aa4:	ea000021 	b	34811b30 <mmc_change_freq+0xb0>

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
34811aa8:	e5902030 	ldr	r2, [r0, #48]	; 0x30
34811aac:	e59f3084 	ldr	r3, [pc, #132]	; 34811b38 <mmc_change_freq+0xb8>
34811ab0:	e1520003 	cmp	r2, r3
34811ab4:	9afffff9 	bls	34811aa0 <mmc_change_freq+0x20>
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811ab8:	e28d603f 	add	r6, sp, #63	; 0x3f
34811abc:	e3c6603f 	bic	r6, r6, #63	; 0x3f
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);
34811ac0:	e1a01006 	mov	r1, r6
34811ac4:	ebffffc5 	bl	348119e0 <mmc_send_ext_csd>

	if (err)
34811ac8:	e3500000 	cmp	r0, #0
34811acc:	1a000017 	bne	34811b30 <mmc_change_freq+0xb0>
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811ad0:	e3a03001 	mov	r3, #1
34811ad4:	e3a020b9 	mov	r2, #185	; 0xb9
34811ad8:	e1a01003 	mov	r1, r3
34811adc:	e1a00004 	mov	r0, r4
	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
34811ae0:	e5d650c4 	ldrb	r5, [r6, #196]	; 0xc4
	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811ae4:	ebffffd0 	bl	34811a2c <mmc_switch>

	if (err)
34811ae8:	e3500000 	cmp	r0, #0
34811aec:	1a00000f 	bne	34811b30 <mmc_change_freq+0xb0>
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);
34811af0:	e1a01006 	mov	r1, r6
34811af4:	e1a00004 	mov	r0, r4
34811af8:	ebffffb8 	bl	348119e0 <mmc_send_ext_csd>

	if (err)
34811afc:	e3500000 	cmp	r0, #0
34811b00:	1a00000a 	bne	34811b30 <mmc_change_freq+0xb0>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
34811b04:	e5d630b9 	ldrb	r3, [r6, #185]	; 0xb9
34811b08:	e3530000 	cmp	r3, #0
34811b0c:	0affffe3 	beq	34811aa0 <mmc_change_freq+0x20>
34811b10:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
34811b14:	e2053002 	and	r3, r5, #2
34811b18:	e21330ff 	ands	r3, r3, #255	; 0xff
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
	else
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
34811b1c:	01a00003 	moveq	r0, r3
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
34811b20:	13822011 	orrne	r2, r2, #17
		mmc->card_caps |= MMC_MODE_HS;
34811b24:	03822001 	orreq	r2, r2, #1
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
34811b28:	1584204c 	strne	r2, [r4, #76]	; 0x4c
		mmc->card_caps |= MMC_MODE_HS;
34811b2c:	0584204c 	streq	r2, [r4, #76]	; 0x4c
}
34811b30:	e28ddd09 	add	sp, sp, #576	; 0x240
34811b34:	e8bd8070 	pop	{r4, r5, r6, pc}
34811b38:	0001003f 	.word	0x0001003f

34811b3c <mmc_switch_part>:

int mmc_switch_part(int dev_num, unsigned int part_num)
{
34811b3c:	e92d4010 	push	{r4, lr}
34811b40:	e1a04001 	mov	r4, r1
	struct mmc *mmc = find_mmc_device(dev_num);
34811b44:	ebfffdc9 	bl	34811270 <find_mmc_device>

	if (!mmc)
34811b48:	e2503000 	subs	r3, r0, #0
34811b4c:	0a000007 	beq	34811b70 <mmc_switch_part+0x34>
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811b50:	e5d33082 	ldrb	r3, [r3, #130]	; 0x82
34811b54:	e2044007 	and	r4, r4, #7
34811b58:	e3a020b3 	mov	r2, #179	; 0xb3
34811b5c:	e3a01001 	mov	r1, #1
34811b60:	e3c33007 	bic	r3, r3, #7
34811b64:	e1843003 	orr	r3, r4, r3
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34811b68:	e8bd4010 	pop	{r4, lr}
	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811b6c:	eaffffae 	b	34811a2c <mmc_switch>
}
34811b70:	e3e00000 	mvn	r0, #0
34811b74:	e8bd8010 	pop	{r4, pc}

34811b78 <mmc_getcd>:

int mmc_getcd(struct mmc *mmc)
{
34811b78:	e92d4010 	push	{r4, lr}
34811b7c:	e1a04000 	mov	r4, r0
	int cd;

	cd = board_mmc_getcd(mmc);
34811b80:	ebfffd6a 	bl	34811130 <__board_mmc_getcd>

	if ((cd < 0) && mmc->getcd)
34811b84:	e3500000 	cmp	r0, #0
34811b88:	a8bd8010 	popge	{r4, pc}
34811b8c:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
34811b90:	e3530000 	cmp	r3, #0
34811b94:	08bd8010 	popeq	{r4, pc}
		cd = mmc->getcd(mmc);
34811b98:	e1a00004 	mov	r0, r4

	return cd;
}
34811b9c:	e8bd4010 	pop	{r4, lr}
		cd = mmc->getcd(mmc);
34811ba0:	e12fff13 	bx	r3

34811ba4 <sd_switch>:

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811ba4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811ba8:	e3a0c006 	mov	ip, #6
{
34811bac:	e24dd034 	sub	sp, sp, #52	; 0x34
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
34811bb0:	e1a02102 	lsl	r2, r2, #2
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811bb4:	e1cdc1b4 	strh	ip, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
34811bb8:	e3a0c015 	mov	ip, #21
34811bbc:	e58dc018 	str	ip, [sp, #24]
	cmd.cmdarg = (mode << 31) | 0xffffff;
34811bc0:	e3e0c4ff 	mvn	ip, #-16777216	; 0xff000000
34811bc4:	e18c1f81 	orr	r1, ip, r1, lsl #31
	cmd.cmdarg &= ~(0xf << (group * 4));
34811bc8:	e3a0c00f 	mov	ip, #15
34811bcc:	e1c1121c 	bic	r1, r1, ip, lsl r2
	cmd.cmdarg |= value << (group * 4);
34811bd0:	e1813213 	orr	r3, r1, r3, lsl r2
	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
34811bd4:	e28d2004 	add	r2, sp, #4
34811bd8:	e28d1014 	add	r1, sp, #20
	cmd.cmdarg |= value << (group * 4);
34811bdc:	e58d301c 	str	r3, [sp, #28]
	data.dest = (char *)resp;
34811be0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34811be4:	e58d3004 	str	r3, [sp, #4]
	data.blocksize = 64;
34811be8:	e3a03040 	mov	r3, #64	; 0x40
34811bec:	e58d3010 	str	r3, [sp, #16]
	data.blocks = 1;
34811bf0:	e3a03001 	mov	r3, #1
34811bf4:	e58d300c 	str	r3, [sp, #12]
	data.flags = MMC_DATA_READ;
34811bf8:	e58d3008 	str	r3, [sp, #8]
	return mmc_send_cmd(mmc, &cmd, &data);
34811bfc:	ebfffd4d 	bl	34811138 <mmc_send_cmd>
}
34811c00:	e28dd034 	add	sp, sp, #52	; 0x34
34811c04:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34811c08 <sd_change_freq>:
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811c08:	e5902050 	ldr	r2, [r0, #80]	; 0x50
	mmc->card_caps = 0;
34811c0c:	e3a03000 	mov	r3, #0
{
34811c10:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34811c14:	e1a04000 	mov	r4, r0
34811c18:	e24ddf4e 	sub	sp, sp, #312	; 0x138
	mmc->card_caps = 0;
34811c1c:	e580304c 	str	r3, [r0, #76]	; 0x4c
	if (mmc_host_is_spi(mmc))
34811c20:	e2122b01 	ands	r2, r2, #1024	; 0x400
34811c24:	0a000001 	beq	34811c30 <sd_change_freq+0x28>
		return 0;
34811c28:	e3a00000 	mov	r0, #0
34811c2c:	ea000065 	b	34811dc8 <sd_change_freq+0x1c0>

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
34811c30:	e3a03037 	mov	r3, #55	; 0x37
	cmd.resp_type = MMC_RSP_R1;
34811c34:	e3a06015 	mov	r6, #21
	cmd.cmdidx = MMC_CMD_APP_CMD;
34811c38:	e1cd31bc 	strh	r3, [sp, #28]
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811c3c:	e28d101c 	add	r1, sp, #28
	cmd.cmdarg = mmc->rca << 16;
34811c40:	e1d038b0 	ldrh	r3, [r0, #128]	; 0x80
	cmd.resp_type = MMC_RSP_R1;
34811c44:	e58d6020 	str	r6, [sp, #32]
	cmd.cmdarg = mmc->rca << 16;
34811c48:	e1a03803 	lsl	r3, r3, #16
34811c4c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811c50:	ebfffd38 	bl	34811138 <mmc_send_cmd>

	if (err)
34811c54:	e3500000 	cmp	r0, #0
34811c58:	1a00005a 	bne	34811dc8 <sd_change_freq+0x1c0>
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
34811c5c:	e28d5077 	add	r5, sp, #119	; 0x77
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
	cmd.resp_type = MMC_RSP_R1;
34811c60:	e58d6020 	str	r6, [sp, #32]
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
34811c64:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	cmd.cmdarg = 0;
34811c68:	e3a06004 	mov	r6, #4

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34811c6c:	e3a09008 	mov	r9, #8
	data.blocks = 1;
34811c70:	e3a07001 	mov	r7, #1
	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34811c74:	e3a03033 	mov	r3, #51	; 0x33
	cmd.cmdarg = 0;
34811c78:	e58d0024 	str	r0, [sp, #36]	; 0x24
	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34811c7c:	e1cd31bc 	strh	r3, [sp, #28]
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811c80:	e28d200c 	add	r2, sp, #12
34811c84:	e28d101c 	add	r1, sp, #28
34811c88:	e1a00004 	mov	r0, r4
	data.dest = (char *)scr;
34811c8c:	e58d500c 	str	r5, [sp, #12]
	data.blocksize = 8;
34811c90:	e58d9018 	str	r9, [sp, #24]
	data.blocks = 1;
34811c94:	e58d7014 	str	r7, [sp, #20]
	data.flags = MMC_DATA_READ;
34811c98:	e58d7010 	str	r7, [sp, #16]
	err = mmc_send_cmd(mmc, &cmd, &data);
34811c9c:	ebfffd25 	bl	34811138 <mmc_send_cmd>

	if (err) {
34811ca0:	e3500000 	cmp	r0, #0
34811ca4:	0a000002 	beq	34811cb4 <sd_change_freq+0xac>
		if (timeout--)
34811ca8:	e2566001 	subs	r6, r6, #1
34811cac:	1afffff3 	bne	34811c80 <sd_change_freq+0x78>
34811cb0:	ea000044 	b	34811dc8 <sd_change_freq+0x1c0>
			goto retry_scr;

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
34811cb4:	e5950000 	ldr	r0, [r5]
34811cb8:	ebfffd1a 	bl	34811128 <__fswab32>
34811cbc:	e1a06000 	mov	r6, r0
34811cc0:	e5840058 	str	r0, [r4, #88]	; 0x58
	mmc->scr[1] = __be32_to_cpu(scr[1]);
34811cc4:	e5950004 	ldr	r0, [r5, #4]
34811cc8:	ebfffd16 	bl	34811128 <__fswab32>

	switch ((mmc->scr[0] >> 24) & 0xf) {
34811ccc:	e7e32c56 	ubfx	r2, r6, #24, #4
	mmc->scr[1] = __be32_to_cpu(scr[1]);
34811cd0:	e584005c 	str	r0, [r4, #92]	; 0x5c
	switch ((mmc->scr[0] >> 24) & 0xf) {
34811cd4:	e3520001 	cmp	r2, #1
34811cd8:	e59f30f0 	ldr	r3, [pc, #240]	; 34811dd0 <sd_change_freq+0x1c8>
34811cdc:	0a000004 	beq	34811cf4 <sd_change_freq+0xec>
34811ce0:	3a000006 	bcc	34811d00 <sd_change_freq+0xf8>
34811ce4:	e3520002 	cmp	r2, #2
34811ce8:	1a000004 	bne	34811d00 <sd_change_freq+0xf8>
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
			break;
		case 2:
			mmc->version = SD_VERSION_2;
34811cec:	e59f20e0 	ldr	r2, [pc, #224]	; 34811dd4 <sd_change_freq+0x1cc>
34811cf0:	ea000000 	b	34811cf8 <sd_change_freq+0xf0>
			mmc->version = SD_VERSION_1_10;
34811cf4:	e59f20dc 	ldr	r2, [pc, #220]	; 34811dd8 <sd_change_freq+0x1d0>
			mmc->version = SD_VERSION_2;
34811cf8:	e5842030 	str	r2, [r4, #48]	; 0x30
			break;
34811cfc:	ea000000 	b	34811d04 <sd_change_freq+0xfc>
		default:
			mmc->version = SD_VERSION_1_0;
34811d00:	e5843030 	str	r3, [r4, #48]	; 0x30
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
34811d04:	e3160701 	tst	r6, #262144	; 0x40000
		mmc->card_caps |= MMC_MODE_4BIT;
34811d08:	1594204c 	ldrne	r2, [r4, #76]	; 0x4c
34811d0c:	13822c01 	orrne	r2, r2, #256	; 0x100
34811d10:	1584204c 	strne	r2, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
34811d14:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34811d18:	e1520003 	cmp	r2, r3
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
34811d1c:	128d60f7 	addne	r6, sp, #247	; 0xf7
34811d20:	13a05005 	movne	r5, #5
34811d24:	13c6603f 	bicne	r6, r6, #63	; 0x3f
	if (mmc->version == SD_VERSION_1_0)
34811d28:	0affffbe 	beq	34811c28 <sd_change_freq+0x20>
		return 0;

	timeout = 4;
	while (timeout--) {
34811d2c:	e2555001 	subs	r5, r5, #1
34811d30:	0a00000b 	beq	34811d64 <sd_change_freq+0x15c>
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34811d34:	e3a02000 	mov	r2, #0
34811d38:	e58d6000 	str	r6, [sp]
34811d3c:	e3a03001 	mov	r3, #1
34811d40:	e1a01002 	mov	r1, r2
34811d44:	e1a00004 	mov	r0, r4
34811d48:	ebffff95 	bl	34811ba4 <sd_switch>
				(u8 *)switch_status);

		if (err)
34811d4c:	e3500000 	cmp	r0, #0
34811d50:	1a00001c 	bne	34811dc8 <sd_change_freq+0x1c0>
			return err;

		/* The high-speed function is busy.  Try again */
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
34811d54:	e596001c 	ldr	r0, [r6, #28]
34811d58:	ebfffcf2 	bl	34811128 <__fswab32>
34811d5c:	e3100802 	tst	r0, #131072	; 0x20000
34811d60:	1afffff1 	bne	34811d2c <sd_change_freq+0x124>
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
34811d64:	e596000c 	ldr	r0, [r6, #12]
34811d68:	ebfffcee 	bl	34811128 <__fswab32>
34811d6c:	e3100802 	tst	r0, #131072	; 0x20000
34811d70:	0affffac 	beq	34811c28 <sd_change_freq+0x20>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
34811d74:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811d78:	e2033011 	and	r3, r3, #17
34811d7c:	e3530011 	cmp	r3, #17
34811d80:	1affffa8 	bne	34811c28 <sd_change_freq+0x20>
		(mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
34811d84:	e3a03001 	mov	r3, #1
34811d88:	e58d6000 	str	r6, [sp]
34811d8c:	e3a02000 	mov	r2, #0
34811d90:	e1a01003 	mov	r1, r3
34811d94:	e1a00004 	mov	r0, r4
34811d98:	ebffff81 	bl	34811ba4 <sd_switch>

	if (err)
34811d9c:	e2505000 	subs	r5, r0, #0
34811da0:	11a00005 	movne	r0, r5
34811da4:	1a000007 	bne	34811dc8 <sd_change_freq+0x1c0>
		return err;

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
34811da8:	e5960010 	ldr	r0, [r6, #16]
34811dac:	ebfffcdd 	bl	34811128 <__fswab32>
34811db0:	e200040f 	and	r0, r0, #251658240	; 0xf000000
34811db4:	e3500401 	cmp	r0, #16777216	; 0x1000000
		mmc->card_caps |= MMC_MODE_HS;
34811db8:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34811dbc:	03833001 	orreq	r3, r3, #1
34811dc0:	0584304c 	streq	r3, [r4, #76]	; 0x4c
34811dc4:	eaffff97 	b	34811c28 <sd_change_freq+0x20>

	return 0;
}
34811dc8:	e28ddf4e 	add	sp, sp, #312	; 0x138
34811dcc:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34811dd0:	00020010 	.word	0x00020010
34811dd4:	00020020 	.word	0x00020020
34811dd8:	0002001a 	.word	0x0002001a

34811ddc <mmc_set_ios>:
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811ddc:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34811de0:	e12fff13 	bx	r3

34811de4 <mmc_set_clock>:
}

void mmc_set_clock(struct mmc *mmc, uint clock)
{
	if (clock > mmc->f_max)
34811de4:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
34811de8:	e1510002 	cmp	r1, r2
34811dec:	21a01002 	movcs	r1, r2
		clock = mmc->f_max;

	if (clock < mmc->f_min)
34811df0:	e5902038 	ldr	r2, [r0, #56]	; 0x38
		clock = mmc->f_min;

	mmc->clock = clock;
34811df4:	e1510002 	cmp	r1, r2
34811df8:	25801048 	strcs	r1, [r0, #72]	; 0x48
34811dfc:	35802048 	strcc	r2, [r0, #72]	; 0x48

	mmc_set_ios(mmc);
34811e00:	eafffff5 	b	34811ddc <mmc_set_ios>

34811e04 <mmc_set_bus_width>:
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811e04:	e5801044 	str	r1, [r0, #68]	; 0x44

	mmc_set_ios(mmc);
34811e08:	eafffff3 	b	34811ddc <mmc_set_ios>

34811e0c <mmc_startup>:
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811e0c:	e5903050 	ldr	r3, [r0, #80]	; 0x50
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;
34811e10:	e3a02000 	mov	r2, #0
{
34811e14:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34811e18:	e24dde4b 	sub	sp, sp, #1200	; 0x4b0
34811e1c:	e24dd008 	sub	sp, sp, #8
34811e20:	e1a04000 	mov	r4, r0
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811e24:	e3130b01 	tst	r3, #1024	; 0x400
34811e28:	e28d501c 	add	r5, sp, #28
34811e2c:	13a0300a 	movne	r3, #10
34811e30:	03a03002 	moveq	r3, #2
34811e34:	e1cd31bc 	strh	r3, [sp, #28]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811e38:	e1a01005 	mov	r1, r5
	cmd.resp_type = MMC_RSP_R2;
34811e3c:	e3a03007 	mov	r3, #7
	cmd.cmdarg = 0;
34811e40:	e58d2024 	str	r2, [sp, #36]	; 0x24
	cmd.resp_type = MMC_RSP_R2;
34811e44:	e58d3020 	str	r3, [sp, #32]
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811e48:	ebfffcba 	bl	34811138 <mmc_send_cmd>

	if (err)
34811e4c:	e3500000 	cmp	r0, #0
34811e50:	1a00016d 	bne	3481240c <mmc_startup+0x600>
		return err;

	memcpy(mmc->cid, cmd.response, 16);
34811e54:	e3a02010 	mov	r2, #16
34811e58:	e28d1028 	add	r1, sp, #40	; 0x28
34811e5c:	e2840070 	add	r0, r4, #112	; 0x70
34811e60:	eb002765 	bl	3481bbfc <memcpy>
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34811e64:	e5942050 	ldr	r2, [r4, #80]	; 0x50
34811e68:	e2122b01 	ands	r2, r2, #1024	; 0x400
34811e6c:	1a000010 	bne	34811eb4 <mmc_startup+0xa8>
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
34811e70:	e3a03003 	mov	r3, #3
		cmd.cmdarg = mmc->rca << 16;
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811e74:	e1a01005 	mov	r1, r5
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
34811e78:	e1cd31bc 	strh	r3, [sp, #28]
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811e7c:	e1a00004 	mov	r0, r4
		cmd.cmdarg = mmc->rca << 16;
34811e80:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
34811e84:	e1a03803 	lsl	r3, r3, #16
34811e88:	e58d3024 	str	r3, [sp, #36]	; 0x24
		cmd.resp_type = MMC_RSP_R6;
34811e8c:	e3a03015 	mov	r3, #21
34811e90:	e58d3020 	str	r3, [sp, #32]
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811e94:	ebfffca7 	bl	34811138 <mmc_send_cmd>

		if (err)
34811e98:	e3500000 	cmp	r0, #0
34811e9c:	1a00015a 	bne	3481240c <mmc_startup+0x600>
			return err;

		if (IS_SD(mmc))
34811ea0:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34811ea4:	e3130802 	tst	r3, #131072	; 0x20000
			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
34811ea8:	159d3028 	ldrne	r3, [sp, #40]	; 0x28
34811eac:	11a03823 	lsrne	r3, r3, #16
34811eb0:	11c438b0 	strhne	r3, [r4, #128]	; 0x80
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
34811eb4:	e3a03009 	mov	r3, #9
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811eb8:	e3a02000 	mov	r2, #0
	cmd.cmdidx = MMC_CMD_SEND_CSD;
34811ebc:	e1cd31bc 	strh	r3, [sp, #28]
	cmd.resp_type = MMC_RSP_R2;
34811ec0:	e3a03007 	mov	r3, #7
34811ec4:	e58d3020 	str	r3, [sp, #32]
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ec8:	e28d101c 	add	r1, sp, #28
	cmd.cmdarg = mmc->rca << 16;
34811ecc:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ed0:	e1a00004 	mov	r0, r4
	cmd.cmdarg = mmc->rca << 16;
34811ed4:	e1a03803 	lsl	r3, r3, #16
34811ed8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811edc:	ebfffc95 	bl	34811138 <mmc_send_cmd>

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34811ee0:	e3a01ffa 	mov	r1, #1000	; 0x3e8
	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ee4:	e1a05000 	mov	r5, r0
	mmc_send_status(mmc, timeout);
34811ee8:	e1a00004 	mov	r0, r4
34811eec:	ebfffca0 	bl	34811174 <mmc_send_status>

	if (err)
34811ef0:	e3550000 	cmp	r5, #0
34811ef4:	11a00005 	movne	r0, r5
34811ef8:	1a000143 	bne	3481240c <mmc_startup+0x600>
	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811efc:	e594c030 	ldr	ip, [r4, #48]	; 0x30
	mmc->csd[0] = cmd.response[0];
34811f00:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
	mmc->csd[1] = cmd.response[1];
34811f04:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
	mmc->csd[2] = cmd.response[2];
34811f08:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811f0c:	e35c0801 	cmp	ip, #65536	; 0x10000
	mmc->csd[3] = cmd.response[3];
34811f10:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
	mmc->csd[0] = cmd.response[0];
34811f14:	e5843060 	str	r3, [r4, #96]	; 0x60
	mmc->csd[1] = cmd.response[1];
34811f18:	e5840064 	str	r0, [r4, #100]	; 0x64
	mmc->csd[2] = cmd.response[2];
34811f1c:	e5842068 	str	r2, [r4, #104]	; 0x68
	mmc->csd[3] = cmd.response[3];
34811f20:	e584106c 	str	r1, [r4, #108]	; 0x6c
	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811f24:	1a000012 	bne	34811f74 <mmc_startup+0x168>
		int version = (cmd.response[0] >> 26) & 0xf;
34811f28:	e7e3cd53 	ubfx	ip, r3, #26, #4

		switch (version) {
34811f2c:	e35c0004 	cmp	ip, #4
34811f30:	979ff10c 	ldrls	pc, [pc, ip, lsl #2]
34811f34:	ea00000c 	b	34811f6c <mmc_startup+0x160>
34811f38:	34811f6c 	.word	0x34811f6c
34811f3c:	34811f4c 	.word	0x34811f4c
34811f40:	34811f54 	.word	0x34811f54
34811f44:	34811f5c 	.word	0x34811f5c
34811f48:	34811f64 	.word	0x34811f64
			case 0:
				mmc->version = MMC_VERSION_1_2;
				break;
			case 1:
				mmc->version = MMC_VERSION_1_4;
34811f4c:	e59fc4c4 	ldr	ip, [pc, #1220]	; 34812418 <mmc_startup+0x60c>
34811f50:	ea000006 	b	34811f70 <mmc_startup+0x164>
				break;
			case 2:
				mmc->version = MMC_VERSION_2_2;
34811f54:	e59fc4c0 	ldr	ip, [pc, #1216]	; 3481241c <mmc_startup+0x610>
34811f58:	ea000004 	b	34811f70 <mmc_startup+0x164>
				break;
			case 3:
				mmc->version = MMC_VERSION_3;
34811f5c:	e59fc4bc 	ldr	ip, [pc, #1212]	; 34812420 <mmc_startup+0x614>
34811f60:	ea000002 	b	34811f70 <mmc_startup+0x164>
				break;
			case 4:
				mmc->version = MMC_VERSION_4;
34811f64:	e59fc4b8 	ldr	ip, [pc, #1208]	; 34812424 <mmc_startup+0x618>
34811f68:	ea000000 	b	34811f70 <mmc_startup+0x164>
				break;
			default:
				mmc->version = MMC_VERSION_1_2;
34811f6c:	e59fc4b4 	ldr	ip, [pc, #1204]	; 34812428 <mmc_startup+0x61c>
34811f70:	e584c030 	str	ip, [r4, #48]	; 0x30
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
34811f74:	e59fc4b0 	ldr	ip, [pc, #1200]	; 3481242c <mmc_startup+0x620>
34811f78:	e7e3e1d3 	ubfx	lr, r3, #3, #4
	freq = fbase[(cmd.response[0] & 0x7)];
34811f7c:	e2033007 	and	r3, r3, #7

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811f80:	e7e35850 	ubfx	r5, r0, #16, #4
	freq = fbase[(cmd.response[0] & 0x7)];
34811f84:	e08c3103 	add	r3, ip, r3, lsl #2
	mmc->tran_speed = freq * mult;
34811f88:	e79cc10e 	ldr	ip, [ip, lr, lsl #2]
34811f8c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
34811f90:	e0030c93 	mul	r3, r3, ip

	if (IS_SD(mmc))
34811f94:	e594c030 	ldr	ip, [r4, #48]	; 0x30
34811f98:	e31c0802 	tst	ip, #131072	; 0x20000
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811f9c:	07e31b51 	ubfxeq	r1, r1, #22, #4
	mmc->tran_speed = freq * mult;
34811fa0:	e5843084 	str	r3, [r4, #132]	; 0x84
	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811fa4:	e3a03001 	mov	r3, #1
34811fa8:	e1a05513 	lsl	r5, r3, r5
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811fac:	01a03113 	lsleq	r3, r3, r1
34811fb0:	0584308c 	streq	r3, [r4, #140]	; 0x8c

	if (mmc->high_capacity) {
34811fb4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		mmc->write_bl_len = mmc->read_bl_len;
34811fb8:	1584508c 	strne	r5, [r4, #140]	; 0x8c
	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811fbc:	e5845088 	str	r5, [r4, #136]	; 0x88
	if (mmc->high_capacity) {
34811fc0:	e3530000 	cmp	r3, #0
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
			| (mmc->csd[2] & 0xc0000000) >> 30;
34811fc4:	01a03f22 	lsreq	r3, r2, #30
			| (mmc->csd[2] & 0xffff0000) >> 16;
34811fc8:	11a02822 	lsrne	r2, r2, #16
		csize = (mmc->csd[1] & 0x3f) << 16
34811fcc:	1200003f 	andne	r0, r0, #63	; 0x3f
		csize = (mmc->csd[1] & 0x3ff) << 2
34811fd0:	07e90050 	ubfxeq	r0, r0, #0, #10
			| (mmc->csd[2] & 0xffff0000) >> 16;
34811fd4:	11820800 	orrne	r0, r2, r0, lsl #16
			| (mmc->csd[2] & 0xc0000000) >> 30;
34811fd8:	01830100 	orreq	r0, r3, r0, lsl #2
		csize = (mmc->csd[1] & 0x3f) << 16
34811fdc:	13a01000 	movne	r1, #0
		cmult = 8;
34811fe0:	13a02008 	movne	r2, #8
		csize = (mmc->csd[1] & 0x3ff) << 2
34811fe4:	03a01000 	moveq	r1, #0
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34811fe8:	07e227d2 	ubfxeq	r2, r2, #15, #3
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
34811fec:	e2900001 	adds	r0, r0, #1
34811ff0:	e2822002 	add	r2, r2, #2
34811ff4:	e2a11000 	adc	r1, r1, #0
34811ff8:	fa00355f 	blx	3481f57c <__ashldi3>
	mmc->capacity *= mmc->read_bl_len;
34811ffc:	e1a03fc5 	asr	r3, r5, #31

	if (mmc->read_bl_len > 512)
34812000:	e3550c02 	cmp	r5, #512	; 0x200

	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34812004:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc->capacity *= mmc->read_bl_len;
34812008:	e0030390 	mul	r3, r0, r3
3481200c:	e0233195 	mla	r3, r5, r1, r3
34812010:	e0810590 	umull	r0, r1, r0, r5
34812014:	e0831001 	add	r1, r3, r1
		mmc->read_bl_len = 512;
34812018:	c3a03c02 	movgt	r3, #512	; 0x200
3481201c:	c5843088 	strgt	r3, [r4, #136]	; 0x88
	if (mmc->write_bl_len > 512)
34812020:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
	mmc->capacity *= mmc->read_bl_len;
34812024:	e1c409f8 	strd	r0, [r4, #152]	; 0x98
	if (mmc->write_bl_len > 512)
34812028:	e3530c02 	cmp	r3, #512	; 0x200
		mmc->write_bl_len = 512;
3481202c:	83a03c02 	movhi	r3, #512	; 0x200
34812030:	8584308c 	strhi	r3, [r4, #140]	; 0x8c
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34812034:	e2122b01 	ands	r2, r2, #1024	; 0x400
34812038:	0a00000e 	beq	34812078 <mmc_startup+0x26c>
	}

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
3481203c:	e3a03001 	mov	r3, #1
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34812040:	e59f13e8 	ldr	r1, [pc, #1000]	; 34812430 <mmc_startup+0x624>
	mmc->erase_grp_size = 1;
34812044:	e5843090 	str	r3, [r4, #144]	; 0x90
	mmc->part_config = MMCPART_NOAVAILABLE;
34812048:	e3e03000 	mvn	r3, #0
3481204c:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34812050:	e28d5077 	add	r5, sp, #119	; 0x77
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34812054:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34812058:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
3481205c:	e1530001 	cmp	r3, r1
34812060:	e2232802 	eor	r2, r3, #131072	; 0x20000
34812064:	93a03000 	movls	r3, #0
34812068:	83a03001 	movhi	r3, #1
3481206c:	e01338a2 	ands	r3, r3, r2, lsr #17
34812070:	0a00003c 	beq	34812168 <mmc_startup+0x35c>
34812074:	ea00000c 	b	348120ac <mmc_startup+0x2a0>
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34812078:	e3a03007 	mov	r3, #7
		err = mmc_send_cmd(mmc, &cmd, NULL);
3481207c:	e28d101c 	add	r1, sp, #28
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34812080:	e1cd31bc 	strh	r3, [sp, #28]
		cmd.resp_type = MMC_RSP_R1;
34812084:	e3a03015 	mov	r3, #21
34812088:	e58d3020 	str	r3, [sp, #32]
		err = mmc_send_cmd(mmc, &cmd, NULL);
3481208c:	e1a00004 	mov	r0, r4
		cmd.cmdarg = mmc->rca << 16;
34812090:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
34812094:	e1a03803 	lsl	r3, r3, #16
34812098:	e58d3024 	str	r3, [sp, #36]	; 0x24
		err = mmc_send_cmd(mmc, &cmd, NULL);
3481209c:	ebfffc25 	bl	34811138 <mmc_send_cmd>
		if (err)
348120a0:	e3500000 	cmp	r0, #0
348120a4:	0affffe4 	beq	3481203c <mmc_startup+0x230>
348120a8:	ea0000d7 	b	3481240c <mmc_startup+0x600>
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
348120ac:	e1a01005 	mov	r1, r5
348120b0:	e1a00004 	mov	r0, r4
348120b4:	ebfffe49 	bl	348119e0 <mmc_send_ext_csd>
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
348120b8:	e5d530c0 	ldrb	r3, [r5, #192]	; 0xc0
348120bc:	e16f0f10 	clz	r0, r0
348120c0:	e1a002a0 	lsr	r0, r0, #5
348120c4:	e3530001 	cmp	r3, #1
348120c8:	93a00000 	movls	r0, #0
348120cc:	e3500000 	cmp	r0, #0
348120d0:	0a000012 	beq	34812120 <mmc_startup+0x314>
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348120d4:	e5d530d6 	ldrb	r3, [r5, #214]	; 0xd6
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
348120d8:	e5d520d5 	ldrb	r2, [r5, #213]	; 0xd5
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348120dc:	e1a03803 	lsl	r3, r3, #16
348120e0:	e1833402 	orr	r3, r3, r2, lsl #8
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
348120e4:	e5d520d4 	ldrb	r2, [r5, #212]	; 0xd4
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348120e8:	e1833002 	orr	r3, r3, r2
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
348120ec:	e5d520d7 	ldrb	r2, [r5, #215]	; 0xd7
348120f0:	e1833c02 	orr	r3, r3, r2, lsl #24
			capacity *= 512;
348120f4:	e1a01fc3 	asr	r1, r3, #31
348120f8:	e1a02481 	lsl	r2, r1, #9
348120fc:	e1822ba3 	orr	r2, r2, r3, lsr #23
34812100:	e1a03483 	lsl	r3, r3, #9
			if ((capacity >> 20) > 2 * 1024)
34812104:	e1a00a23 	lsr	r0, r3, #20
34812108:	e1a01a22 	lsr	r1, r2, #20
3481210c:	e1800602 	orr	r0, r0, r2, lsl #12
34812110:	e3510000 	cmp	r1, #0
34812114:	03500b02 	cmpeq	r0, #2048	; 0x800
				mmc->capacity = capacity;
34812118:	85843098 	strhi	r3, [r4, #152]	; 0x98
3481211c:	8584209c 	strhi	r2, [r4, #156]	; 0x9c
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
34812120:	e5d530af 	ldrb	r3, [r5, #175]	; 0xaf
34812124:	e3530000 	cmp	r3, #0
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34812128:	05942068 	ldreq	r2, [r4, #104]	; 0x68
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
3481212c:	15d530e0 	ldrbne	r3, [r5, #224]	; 0xe0
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34812130:	07e41552 	ubfxeq	r1, r2, #10, #5
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
34812134:	07e422d2 	ubfxeq	r2, r2, #5, #5
			mmc->erase_grp_size = (erase_gsz + 1)
				* (erase_gmul + 1);
34812138:	02823001 	addeq	r3, r2, #1
3481213c:	00233391 	mlaeq	r3, r1, r3, r3
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34812140:	11a03983 	lslne	r3, r3, #19
			mmc->erase_grp_size = (erase_gsz + 1)
34812144:	e5843090 	str	r3, [r4, #144]	; 0x90
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
34812148:	e5d530a0 	ldrb	r3, [r5, #160]	; 0xa0
3481214c:	e3130001 	tst	r3, #1
34812150:	1a000002 	bne	34812160 <mmc_startup+0x354>
34812154:	e5d530e2 	ldrb	r3, [r5, #226]	; 0xe2
34812158:	e3530000 	cmp	r3, #0
3481215c:	0a000001 	beq	34812168 <mmc_startup+0x35c>
		    ext_csd[EXT_CSD_BOOT_MULT])
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
34812160:	e5d530b3 	ldrb	r3, [r5, #179]	; 0xb3
34812164:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	}

	if (IS_SD(mmc))
34812168:	e5943030 	ldr	r3, [r4, #48]	; 0x30
		err = sd_change_freq(mmc);
3481216c:	e1a00004 	mov	r0, r4
	if (IS_SD(mmc))
34812170:	e3130802 	tst	r3, #131072	; 0x20000
34812174:	0a000001 	beq	34812180 <mmc_startup+0x374>
		err = sd_change_freq(mmc);
34812178:	ebfffea2 	bl	34811c08 <sd_change_freq>
3481217c:	ea000000 	b	34812184 <mmc_startup+0x378>
	else
		err = mmc_change_freq(mmc);
34812180:	ebfffe3e 	bl	34811a80 <mmc_change_freq>

	if (err)
34812184:	e3500000 	cmp	r0, #0
		err = mmc_change_freq(mmc);
34812188:	e1a07000 	mov	r7, r0
	if (err)
3481218c:	1a00009e 	bne	3481240c <mmc_startup+0x600>
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
34812190:	e5942030 	ldr	r2, [r4, #48]	; 0x30
	mmc->card_caps &= mmc->host_caps;
34812194:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812198:	e5946050 	ldr	r6, [r4, #80]	; 0x50
	if (IS_SD(mmc)) {
3481219c:	e3120802 	tst	r2, #131072	; 0x20000
	mmc->card_caps &= mmc->host_caps;
348121a0:	e0033006 	and	r3, r3, r6
348121a4:	e584304c 	str	r3, [r4, #76]	; 0x4c
	if (IS_SD(mmc)) {
348121a8:	0a000023 	beq	3481223c <mmc_startup+0x430>
		if (mmc->card_caps & MMC_MODE_4BIT) {
348121ac:	e3130c01 	tst	r3, #256	; 0x100
348121b0:	0a00001c 	beq	34812228 <mmc_startup+0x41c>
			cmd.cmdidx = MMC_CMD_APP_CMD;
348121b4:	e3a03037 	mov	r3, #55	; 0x37
348121b8:	e28d501c 	add	r5, sp, #28
348121bc:	e1cd31bc 	strh	r3, [sp, #28]
			cmd.resp_type = MMC_RSP_R1;
348121c0:	e3a06015 	mov	r6, #21
			cmd.cmdarg = mmc->rca << 16;
348121c4:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

			err = mmc_send_cmd(mmc, &cmd, NULL);
348121c8:	e1a02007 	mov	r2, r7
348121cc:	e1a01005 	mov	r1, r5
348121d0:	e1a00004 	mov	r0, r4
			cmd.resp_type = MMC_RSP_R1;
348121d4:	e58d6020 	str	r6, [sp, #32]
			cmd.cmdarg = mmc->rca << 16;
348121d8:	e1a03803 	lsl	r3, r3, #16
348121dc:	e58d3024 	str	r3, [sp, #36]	; 0x24
			err = mmc_send_cmd(mmc, &cmd, NULL);
348121e0:	ebfffbd4 	bl	34811138 <mmc_send_cmd>
			if (err)
348121e4:	e3500000 	cmp	r0, #0
348121e8:	1a000087 	bne	3481240c <mmc_startup+0x600>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
348121ec:	e3a03006 	mov	r3, #6
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
348121f0:	e1a02007 	mov	r2, r7
			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
348121f4:	e1cd31bc 	strh	r3, [sp, #28]
			err = mmc_send_cmd(mmc, &cmd, NULL);
348121f8:	e1a01005 	mov	r1, r5
			cmd.cmdarg = 2;
348121fc:	e3a03002 	mov	r3, #2
			err = mmc_send_cmd(mmc, &cmd, NULL);
34812200:	e1a00004 	mov	r0, r4
			cmd.resp_type = MMC_RSP_R1;
34812204:	e58d6020 	str	r6, [sp, #32]
			cmd.cmdarg = 2;
34812208:	e58d3024 	str	r3, [sp, #36]	; 0x24
			err = mmc_send_cmd(mmc, &cmd, NULL);
3481220c:	ebfffbc9 	bl	34811138 <mmc_send_cmd>
			if (err)
34812210:	e3500000 	cmp	r0, #0
34812214:	1a00007c 	bne	3481240c <mmc_startup+0x600>
	mmc->bus_width = width;
34812218:	e3a03004 	mov	r3, #4
	mmc_set_ios(mmc);
3481221c:	e1a00004 	mov	r0, r4
	mmc->bus_width = width;
34812220:	e5843044 	str	r3, [r4, #68]	; 0x44
	mmc_set_ios(mmc);
34812224:	ebfffeec 	bl	34811ddc <mmc_set_ios>
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
34812228:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
3481222c:	e3130001 	tst	r3, #1
			mmc->tran_speed = 50000000;
34812230:	159f31fc 	ldrne	r3, [pc, #508]	; 34812434 <mmc_startup+0x628>
		else
			mmc->tran_speed = 25000000;
34812234:	059f31fc 	ldreq	r3, [pc, #508]	; 34812438 <mmc_startup+0x62c>
34812238:	ea00003d 	b	34812334 <mmc_startup+0x528>
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
3481223c:	e28d9fad 	add	r9, sp, #692	; 0x2b4
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
34812240:	e7e16456 	ubfx	r6, r6, #8, #2
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
34812244:	e2899003 	add	r9, r9, #3
34812248:	e1a07106 	lsl	r7, r6, #2
3481224c:	e3c9903f 	bic	r9, r9, #63	; 0x3f
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
34812250:	e6ef3076 	uxtb	r3, r6
34812254:	e3a020b7 	mov	r2, #183	; 0xb7
34812258:	e3a01001 	mov	r1, #1
3481225c:	e1a00004 	mov	r0, r4
34812260:	ebfffdf1 	bl	34811a2c <mmc_switch>
					EXT_CSD_BUS_WIDTH, width);

			if (err)
34812264:	e3500000 	cmp	r0, #0
34812268:	1a000027 	bne	3481230c <mmc_startup+0x500>
				continue;

			if (!width) {
3481226c:	e3560000 	cmp	r6, #0
34812270:	1a000004 	bne	34812288 <mmc_startup+0x47c>
	mmc->bus_width = width;
34812274:	e3a03001 	mov	r3, #1
	mmc_set_ios(mmc);
34812278:	e1a00004 	mov	r0, r4
	mmc->bus_width = width;
3481227c:	e5843044 	str	r3, [r4, #68]	; 0x44
	mmc_set_ios(mmc);
34812280:	ebfffed5 	bl	34811ddc <mmc_set_ios>
34812284:	ea000024 	b	3481231c <mmc_startup+0x510>
34812288:	e1a00004 	mov	r0, r4
	mmc->bus_width = width;
3481228c:	e5847044 	str	r7, [r4, #68]	; 0x44
	mmc_set_ios(mmc);
34812290:	ebfffed1 	bl	34811ddc <mmc_set_ios>
				mmc_set_bus_width(mmc, 1);
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
34812294:	e1a01009 	mov	r1, r9
34812298:	e1a00004 	mov	r0, r4
3481229c:	ebfffdcf 	bl	348119e0 <mmc_send_ext_csd>
			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
348122a0:	e3500000 	cmp	r0, #0
348122a4:	1a000018 	bne	3481230c <mmc_startup+0x500>
348122a8:	e5d520a0 	ldrb	r2, [r5, #160]	; 0xa0
348122ac:	e5d930a0 	ldrb	r3, [r9, #160]	; 0xa0
348122b0:	e1520003 	cmp	r2, r3
348122b4:	1a000014 	bne	3481230c <mmc_startup+0x500>
				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
348122b8:	e5d520af 	ldrb	r2, [r5, #175]	; 0xaf
348122bc:	e5d930af 	ldrb	r3, [r9, #175]	; 0xaf
348122c0:	e1520003 	cmp	r2, r3
348122c4:	1a000010 	bne	3481230c <mmc_startup+0x500>
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
348122c8:	e5d520c0 	ldrb	r2, [r5, #192]	; 0xc0
348122cc:	e5d930c0 	ldrb	r3, [r9, #192]	; 0xc0
348122d0:	e1520003 	cmp	r2, r3
348122d4:	1a00000c 	bne	3481230c <mmc_startup+0x500>
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
348122d8:	e5d520e0 	ldrb	r2, [r5, #224]	; 0xe0
348122dc:	e5d930e0 	ldrb	r3, [r9, #224]	; 0xe0
348122e0:	e1520003 	cmp	r2, r3
348122e4:	1a000008 	bne	3481230c <mmc_startup+0x500>
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
348122e8:	e3a02004 	mov	r2, #4
348122ec:	e28910d4 	add	r1, r9, #212	; 0xd4
348122f0:	e28500d4 	add	r0, r5, #212	; 0xd4
348122f4:	eb00266d 	bl	3481bcb0 <memcmp>
348122f8:	e3500000 	cmp	r0, #0
					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
348122fc:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34812300:	01836006 	orreq	r6, r3, r6
34812304:	0584604c 	streq	r6, [r4, #76]	; 0x4c
				break;
34812308:	0a000003 	beq	3481231c <mmc_startup+0x510>
		for (; width >= 0; width--) {
3481230c:	e2466001 	sub	r6, r6, #1
34812310:	e2477004 	sub	r7, r7, #4
34812314:	e3760001 	cmn	r6, #1
34812318:	1affffcc 	bne	34812250 <mmc_startup+0x444>
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
3481231c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812320:	e3130001 	tst	r3, #1
34812324:	0a000003 	beq	34812338 <mmc_startup+0x52c>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
34812328:	e3130010 	tst	r3, #16
				mmc->tran_speed = 52000000;
3481232c:	159f3108 	ldrne	r3, [pc, #264]	; 3481243c <mmc_startup+0x630>
			else
				mmc->tran_speed = 26000000;
34812330:	059f3108 	ldreq	r3, [pc, #264]	; 34812440 <mmc_startup+0x634>
34812334:	e5843084 	str	r3, [r4, #132]	; 0x84
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);
34812338:	e5941084 	ldr	r1, [r4, #132]	; 0x84
3481233c:	e1a00004 	mov	r0, r4
34812340:	ebfffea7 	bl	34811de4 <mmc_set_clock>

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812344:	e594c09c 	ldr	ip, [r4, #156]	; 0x9c
	mmc->block_dev.lun = 0;
34812348:	e3a05000 	mov	r5, #0
	mmc->block_dev.blksz = mmc->read_bl_len;
3481234c:	e5941088 	ldr	r1, [r4, #136]	; 0x88
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
34812350:	e1a03005 	mov	r3, r5
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812354:	e5940098 	ldr	r0, [r4, #152]	; 0x98
34812358:	e1a0200c 	mov	r2, ip
	mmc->block_dev.lun = 0;
3481235c:	e5c450aa 	strb	r5, [r4, #170]	; 0xaa
34812360:	e1923003 	orrs	r3, r2, r3
	mmc->block_dev.type = 0;
34812364:	e5c450ab 	strb	r5, [r4, #171]	; 0xab
	mmc->block_dev.blksz = mmc->read_bl_len;
34812368:	e58410b4 	str	r1, [r4, #180]	; 0xb4
	uint64_t __res = dividend;
3481236c:	e58d0010 	str	r0, [sp, #16]
34812370:	e58dc014 	str	ip, [sp, #20]
	do_div(__res, divisor);
34812374:	1a000003 	bne	34812388 <mmc_startup+0x57c>
34812378:	fa003328 	blx	3481f020 <__udivsi3>
3481237c:	e58d5014 	str	r5, [sp, #20]
34812380:	e58d0010 	str	r0, [sp, #16]
34812384:	ea000001 	b	34812390 <mmc_startup+0x584>
34812388:	e28d0010 	add	r0, sp, #16
3481238c:	eb001f72 	bl	3481a15c <__div64_32>
	return(__res);
34812390:	e59d3010 	ldr	r3, [sp, #16]
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34812394:	e28400b8 	add	r0, r4, #184	; 0xb8
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34812398:	e5941078 	ldr	r1, [r4, #120]	; 0x78
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
3481239c:	e5942070 	ldr	r2, [r4, #112]	; 0x70
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348123a0:	e58430b0 	str	r3, [r4, #176]	; 0xb0
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
348123a4:	e5d4307f 	ldrb	r3, [r4, #127]	; 0x7f
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
348123a8:	e1a02422 	lsr	r2, r2, #8
348123ac:	e1833401 	orr	r3, r3, r1, lsl #8
348123b0:	e59f108c 	ldr	r1, [pc, #140]	; 34812444 <mmc_startup+0x638>
348123b4:	eb002993 	bl	3481ca08 <sprintf>
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
348123b8:	e5943074 	ldr	r3, [r4, #116]	; 0x74
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
348123bc:	e28400e1 	add	r0, r4, #225	; 0xe1
348123c0:	e5d42070 	ldrb	r2, [r4, #112]	; 0x70
348123c4:	e6ef1073 	uxtb	r1, r3
348123c8:	e58d1008 	str	r1, [sp, #8]
348123cc:	e7e71453 	ubfx	r1, r3, #8, #8
348123d0:	e58d1004 	str	r1, [sp, #4]
348123d4:	e7e71853 	ubfx	r1, r3, #16, #8
348123d8:	e58d1000 	str	r1, [sp]
348123dc:	e1a03c23 	lsr	r3, r3, #24
348123e0:	e59f1060 	ldr	r1, [pc, #96]	; 34812448 <mmc_startup+0x63c>
348123e4:	eb002987 	bl	3481ca08 <sprintf>
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
348123e8:	e5942078 	ldr	r2, [r4, #120]	; 0x78
348123ec:	e28400f6 	add	r0, r4, #246	; 0xf6
348123f0:	e59f1054 	ldr	r1, [pc, #84]	; 3481244c <mmc_startup+0x640>
348123f4:	e7e33c52 	ubfx	r3, r2, #24, #4
348123f8:	e1a02e22 	lsr	r2, r2, #28
348123fc:	eb002981 	bl	3481ca08 <sprintf>
			(mmc->cid[2] >> 24) & 0xf);
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
34812400:	e28400a0 	add	r0, r4, #160	; 0xa0
34812404:	ebfff4c9 	bl	3480f730 <init_part>
#endif

	return 0;
34812408:	e3a00000 	mov	r0, #0
}
3481240c:	e28dde4b 	add	sp, sp, #1200	; 0x4b0
34812410:	e28dd008 	add	sp, sp, #8
34812414:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34812418:	00010014 	.word	0x00010014
3481241c:	00010022 	.word	0x00010022
34812420:	00010030 	.word	0x00010030
34812424:	00010040 	.word	0x00010040
34812428:	00010012 	.word	0x00010012
3481242c:	34820164 	.word	0x34820164
34812430:	0001003f 	.word	0x0001003f
34812434:	02faf080 	.word	0x02faf080
34812438:	017d7840 	.word	0x017d7840
3481243c:	03197500 	.word	0x03197500
34812440:	018cba80 	.word	0x018cba80
34812444:	34825db8 	.word	0x34825db8
34812448:	34825dca 	.word	0x34825dca
3481244c:	34825dd5 	.word	0x34825dd5

34812450 <mmc_send_if_cond>:

int mmc_send_if_cond(struct mmc *mmc)
{
34812450:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34812454:	e3a03008 	mov	r3, #8
{
34812458:	e24dd020 	sub	sp, sp, #32
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
3481245c:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812460:	e28d1004 	add	r1, sp, #4
{
34812464:	e1a04000 	mov	r4, r0
	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34812468:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
3481246c:	e59f3044 	ldr	r3, [pc, #68]	; 348124b8 <mmc_send_if_cond+0x68>
34812470:	e0033002 	and	r3, r3, r2
	err = mmc_send_cmd(mmc, &cmd, NULL);
34812474:	e3a02000 	mov	r2, #0
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812478:	e3530000 	cmp	r3, #0
3481247c:	e30031aa 	movw	r3, #426	; 0x1aa
34812480:	03a030aa 	moveq	r3, #170	; 0xaa
34812484:	e58d300c 	str	r3, [sp, #12]
	cmd.resp_type = MMC_RSP_R7;
34812488:	e3a03015 	mov	r3, #21
3481248c:	e58d3008 	str	r3, [sp, #8]
	err = mmc_send_cmd(mmc, &cmd, NULL);
34812490:	ebfffb28 	bl	34811138 <mmc_send_cmd>

	if (err)
34812494:	e3500000 	cmp	r0, #0
34812498:	1a000004 	bne	348124b0 <mmc_send_if_cond+0x60>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
3481249c:	e5dd3010 	ldrb	r3, [sp, #16]
348124a0:	e35300aa 	cmp	r3, #170	; 0xaa
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
348124a4:	059f3010 	ldreq	r3, [pc, #16]	; 348124bc <mmc_send_if_cond+0x6c>
		return UNUSABLE_ERR;
348124a8:	13e00010 	mvnne	r0, #16
		mmc->version = SD_VERSION_2;
348124ac:	05843030 	streq	r3, [r4, #48]	; 0x30

	return 0;
}
348124b0:	e28dd020 	add	sp, sp, #32
348124b4:	e8bd8010 	pop	{r4, pc}
348124b8:	00ff8000 	.word	0x00ff8000
348124bc:	00020020 	.word	0x00020020

348124c0 <mmc_register>:

int mmc_register(struct mmc *mmc)
{
	/* Setup the universal parts of the block interface just once */
	mmc->block_dev.if_type = IF_TYPE_MMC;
	mmc->block_dev.dev = cur_dev_num++;
348124c0:	e59f2068 	ldr	r2, [pc, #104]	; 34812530 <mmc_register+0x70>
	mmc->block_dev.if_type = IF_TYPE_MMC;
348124c4:	e3a03006 	mov	r3, #6
348124c8:	e58030a0 	str	r3, [r0, #160]	; 0xa0
348124cc:	e5800004 	str	r0, [r0, #4]
	mmc->block_dev.dev = cur_dev_num++;
348124d0:	e5923000 	ldr	r3, [r2]
348124d4:	e58030a4 	str	r3, [r0, #164]	; 0xa4
348124d8:	e2831001 	add	r1, r3, #1
	mmc->block_dev.removable = 1;
348124dc:	e3a03001 	mov	r3, #1
	mmc->block_dev.dev = cur_dev_num++;
348124e0:	e5821000 	str	r1, [r2]
	mmc->block_dev.removable = 1;
348124e4:	e5c030ac 	strb	r3, [r0, #172]	; 0xac
	mmc->block_dev.block_read = mmc_bread;
348124e8:	e59f3044 	ldr	r3, [pc, #68]	; 34812534 <mmc_register+0x74>
348124ec:	e5803100 	str	r3, [r0, #256]	; 0x100
	mmc->block_dev.block_write = mmc_bwrite;
348124f0:	e59f3040 	ldr	r3, [pc, #64]	; 34812538 <mmc_register+0x78>
348124f4:	e5803104 	str	r3, [r0, #260]	; 0x104
	mmc->block_dev.block_erase = mmc_berase;
348124f8:	e59f303c 	ldr	r3, [pc, #60]	; 3481253c <mmc_register+0x7c>
348124fc:	e5803108 	str	r3, [r0, #264]	; 0x108
	if (!mmc->b_max)
34812500:	e5903120 	ldr	r3, [r0, #288]	; 0x120
34812504:	e3530000 	cmp	r3, #0
		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
34812508:	030f3fff 	movweq	r3, #65535	; 0xffff
3481250c:	05803120 	streq	r3, [r0, #288]	; 0x120
	__list_add(new, head->prev, head);
34812510:	e59f3028 	ldr	r3, [pc, #40]	; 34812540 <mmc_register+0x80>
34812514:	e5932004 	ldr	r2, [r3, #4]
	next->prev = new;
34812518:	e5830004 	str	r0, [r3, #4]
	new->next = next;
3481251c:	e5803000 	str	r3, [r0]
	new->prev = prev;
34812520:	e5802004 	str	r2, [r0, #4]
	prev->next = new;
34812524:	e5820000 	str	r0, [r2]
	INIT_LIST_HEAD (&mmc->link);

	list_add_tail (&mmc->link, &mmc_devices);

	return 0;
}
34812528:	e3a00000 	mov	r0, #0
3481252c:	e12fff1e 	bx	lr
34812530:	34827814 	.word	0x34827814
34812534:	34811684 	.word	0x34811684
34812538:	34811458 	.word	0x34811458
3481253c:	348112bc 	.word	0x348112bc
34812540:	3482a704 	.word	0x3482a704

34812544 <mmc_init>:
	return &mmc->block_dev;
}
#endif

int mmc_init(struct mmc *mmc)
{
34812544:	e92d4070 	push	{r4, r5, r6, lr}
34812548:	e1a04000 	mov	r4, r0
	int err;

	if (mmc_getcd(mmc) == 0) {
3481254c:	ebfffd89 	bl	34811b78 <mmc_getcd>
34812550:	e3500000 	cmp	r0, #0
34812554:	1a000004 	bne	3481256c <mmc_init+0x28>
		mmc->has_init = 0;
34812558:	e5840034 	str	r0, [r4, #52]	; 0x34
		printf("MMC: no card present\n");
3481255c:	e59f00b4 	ldr	r0, [pc, #180]	; 34812618 <mmc_init+0xd4>
34812560:	ebffdc8d 	bl	3480979c <printf>
		return NO_CARD_ERR;
34812564:	e3e0000f 	mvn	r0, #15
34812568:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	if (mmc->has_init)
3481256c:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34812570:	e3530000 	cmp	r3, #0
34812574:	1a000025 	bne	34812610 <mmc_init+0xcc>
		return 0;

	err = mmc->init(mmc);
34812578:	e5943118 	ldr	r3, [r4, #280]	; 0x118
3481257c:	e1a00004 	mov	r0, r4
34812580:	e12fff33 	blx	r3

	if (err)
34812584:	e3500000 	cmp	r0, #0
34812588:	18bd8070 	popne	{r4, r5, r6, pc}
	mmc->bus_width = width;
3481258c:	e3a05001 	mov	r5, #1
	mmc_set_ios(mmc);
34812590:	e1a00004 	mov	r0, r4
	mmc->bus_width = width;
34812594:	e5845044 	str	r5, [r4, #68]	; 0x44
	mmc_set_ios(mmc);
34812598:	ebfffe0f 	bl	34811ddc <mmc_set_ios>
		return err;

	mmc_set_bus_width(mmc, 1);
	mmc_set_clock(mmc, 1);
3481259c:	e1a01005 	mov	r1, r5
348125a0:	e1a00004 	mov	r0, r4
348125a4:	ebfffe0e 	bl	34811de4 <mmc_set_clock>

	/* Reset the Card */
	err = mmc_go_idle(mmc);
348125a8:	e1a00004 	mov	r0, r4
348125ac:	ebfffc5c 	bl	34811724 <mmc_go_idle>

	if (err)
348125b0:	e3500000 	cmp	r0, #0
348125b4:	18bd8070 	popne	{r4, r5, r6, pc}
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
348125b8:	e5c40083 	strb	r0, [r4, #131]	; 0x83

	/* Test for SD version 2 */
	err = mmc_send_if_cond(mmc);
348125bc:	e1a00004 	mov	r0, r4
348125c0:	ebffffa2 	bl	34812450 <mmc_send_if_cond>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);
348125c4:	e1a00004 	mov	r0, r4
348125c8:	ebfffc68 	bl	34811770 <sd_send_op_cond>

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
348125cc:	e3700013 	cmn	r0, #19
348125d0:	1a000007 	bne	348125f4 <mmc_init+0xb0>
		err = mmc_send_op_cond(mmc);
348125d4:	e1a00004 	mov	r0, r4
348125d8:	ebfffcb2 	bl	348118a8 <mmc_send_op_cond>

		if (err) {
348125dc:	e3500000 	cmp	r0, #0
348125e0:	0a000003 	beq	348125f4 <mmc_init+0xb0>
			printf("Card did not respond to voltage select!\n");
348125e4:	e59f0030 	ldr	r0, [pc, #48]	; 3481261c <mmc_init+0xd8>
348125e8:	ebffdc6b 	bl	3480979c <printf>
			return UNUSABLE_ERR;
348125ec:	e3e00010 	mvn	r0, #16
348125f0:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	err = mmc_startup(mmc);
348125f4:	e1a00004 	mov	r0, r4
348125f8:	ebfffe03 	bl	34811e0c <mmc_startup>
	if (err)
348125fc:	e3500000 	cmp	r0, #0
		mmc->has_init = 0;
34812600:	13a03000 	movne	r3, #0
	else
		mmc->has_init = 1;
34812604:	03a03001 	moveq	r3, #1
34812608:	e5843034 	str	r3, [r4, #52]	; 0x34
3481260c:	e8bd8070 	pop	{r4, r5, r6, pc}
		return 0;
34812610:	e3a00000 	mov	r0, #0
	return err;
}
34812614:	e8bd8070 	pop	{r4, r5, r6, pc}
34812618:	34825ddb 	.word	0x34825ddb
3481261c:	34825df1 	.word	0x34825df1

34812620 <mmc_get_dev>:
{
34812620:	e92d4010 	push	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev);
34812624:	ebfffb11 	bl	34811270 <find_mmc_device>
	if (!mmc || mmc_init(mmc))
34812628:	e2504000 	subs	r4, r0, #0
3481262c:	1a000001 	bne	34812638 <mmc_get_dev+0x18>
		return NULL;
34812630:	e3a00000 	mov	r0, #0
34812634:	e8bd8010 	pop	{r4, pc}
	if (!mmc || mmc_init(mmc))
34812638:	ebffffc1 	bl	34812544 <mmc_init>
3481263c:	e3500000 	cmp	r0, #0
34812640:	1afffffa 	bne	34812630 <mmc_get_dev+0x10>
	return &mmc->block_dev;
34812644:	e28400a0 	add	r0, r4, #160	; 0xa0
}
34812648:	e8bd8010 	pop	{r4, pc}

3481264c <cpu_mmc_init>:
 * signals caller to move on
 */
static int __def_mmc_init(bd_t *bis)
{
	return -1;
}
3481264c:	e3e00000 	mvn	r0, #0
34812650:	e12fff1e 	bx	lr

34812654 <print_mmc_devices>:

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34812654:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34812658:	e1a06000 	mov	r6, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
3481265c:	e59f5048 	ldr	r5, [pc, #72]	; 348126ac <print_mmc_devices+0x58>
34812660:	e5954000 	ldr	r4, [r5]
34812664:	e1a07005 	mov	r7, r5
34812668:	e1540005 	cmp	r4, r5
3481266c:	0a00000b 	beq	348126a0 <print_mmc_devices+0x4c>
		m = list_entry(entry, struct mmc, link);

		printf("%s: %d", m->name, m->block_dev.dev);
34812670:	e59420a4 	ldr	r2, [r4, #164]	; 0xa4
34812674:	e2841008 	add	r1, r4, #8
34812678:	e59f0030 	ldr	r0, [pc, #48]	; 348126b0 <print_mmc_devices+0x5c>
3481267c:	ebffdc46 	bl	3480979c <printf>

		if (entry->next != &mmc_devices)
34812680:	e5943000 	ldr	r3, [r4]
34812684:	e1530007 	cmp	r3, r7
34812688:	0a000002 	beq	34812698 <print_mmc_devices+0x44>
			printf("%c ", separator);
3481268c:	e1a01006 	mov	r1, r6
34812690:	e59f001c 	ldr	r0, [pc, #28]	; 348126b4 <print_mmc_devices+0x60>
34812694:	ebffdc40 	bl	3480979c <printf>
	list_for_each(entry, &mmc_devices) {
34812698:	e5944000 	ldr	r4, [r4]
3481269c:	eafffff1 	b	34812668 <print_mmc_devices+0x14>
	}

	printf("\n");
348126a0:	e59f0010 	ldr	r0, [pc, #16]	; 348126b8 <print_mmc_devices+0x64>
}
348126a4:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	printf("\n");
348126a8:	eaffdc3b 	b	3480979c <printf>
348126ac:	3482a704 	.word	0x3482a704
348126b0:	34825e1a 	.word	0x34825e1a
348126b4:	34822506 	.word	0x34822506
348126b8:	34824f42 	.word	0x34824f42

348126bc <get_mmc_num>:

int get_mmc_num(void)
{
	return cur_dev_num;
}
348126bc:	e59f3004 	ldr	r3, [pc, #4]	; 348126c8 <get_mmc_num+0xc>
348126c0:	e5930000 	ldr	r0, [r3]
348126c4:	e12fff1e 	bx	lr
348126c8:	34827814 	.word	0x34827814

348126cc <mmc_initialize>:
	list->next = list;
348126cc:	e59f303c 	ldr	r3, [pc, #60]	; 34812710 <mmc_initialize+0x44>

int mmc_initialize(bd_t *bis)
{
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;
348126d0:	e3a02000 	mov	r2, #0
{
348126d4:	e92d4010 	push	{r4, lr}
348126d8:	e1a04000 	mov	r4, r0
348126dc:	e5833000 	str	r3, [r3]
	list->prev = list;
348126e0:	e5833004 	str	r3, [r3, #4]
	cur_dev_num = 0;
348126e4:	e59f3028 	ldr	r3, [pc, #40]	; 34812714 <mmc_initialize+0x48>
348126e8:	e5832000 	str	r2, [r3]

	if (board_mmc_init(bis) < 0)
348126ec:	ebffb903 	bl	34800b00 <board_mmc_init>
348126f0:	e3500000 	cmp	r0, #0
348126f4:	aa000001 	bge	34812700 <mmc_initialize+0x34>
		cpu_mmc_init(bis);
348126f8:	e1a00004 	mov	r0, r4
348126fc:	ebffffd2 	bl	3481264c <cpu_mmc_init>

	print_mmc_devices(',');
34812700:	e3a0002c 	mov	r0, #44	; 0x2c
34812704:	ebffffd2 	bl	34812654 <print_mmc_devices>

	return 0;
}
34812708:	e3a00000 	mov	r0, #0
3481270c:	e8bd8010 	pop	{r4, pc}
34812710:	3482a704 	.word	0x3482a704
34812714:	34827814 	.word	0x34827814

34812718 <sdhci_reset>:
#include <sdhci.h>

void *aligned_buffer;

static void sdhci_reset(struct sdhci_host *host, u8 mask)
{
34812718:	e92d4070 	push	{r4, r5, r6, lr}
3481271c:	e1a06000 	mov	r6, r0
34812720:	e1a04001 	mov	r4, r1
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812724:	e5903004 	ldr	r3, [r0, #4]
34812728:	e3a05065 	mov	r5, #101	; 0x65
3481272c:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f
34812730:	e5963004 	ldr	r3, [r6, #4]
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812734:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
34812738:	e6ef3073 	uxtb	r3, r3
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
3481273c:	e1130004 	tst	r3, r4
34812740:	0a000008 	beq	34812768 <sdhci_reset+0x50>
		if (timeout == 0) {
34812744:	e2555001 	subs	r5, r5, #1
34812748:	1a000003 	bne	3481275c <sdhci_reset+0x44>
			printf("Reset 0x%x never completed.\n", (int)mask);
3481274c:	e1a01004 	mov	r1, r4
34812750:	e59f0014 	ldr	r0, [pc, #20]	; 3481276c <sdhci_reset+0x54>
			return;
		}
		timeout--;
		udelay(1000);
	}
}
34812754:	e8bd4070 	pop	{r4, r5, r6, lr}
			printf("Reset 0x%x never completed.\n", (int)mask);
34812758:	eaffdc0f 	b	3480979c <printf>
		udelay(1000);
3481275c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34812760:	eb0025a9 	bl	3481be0c <udelay>
34812764:	eafffff1 	b	34812730 <sdhci_reset+0x18>
}
34812768:	e8bd8070 	pop	{r4, r5, r6, pc}
3481276c:	34825e21 	.word	0x34825e21

34812770 <sdhci_set_ios>:

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812770:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34812774:	e1a06000 	mov	r6, r0
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812778:	e5905028 	ldr	r5, [r0, #40]	; 0x28

	if (host->set_control_reg)
3481277c:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34812780:	e3530000 	cmp	r3, #0
34812784:	0a000001 	beq	34812790 <sdhci_set_ios+0x20>
		host->set_control_reg(host);
34812788:	e1a00005 	mov	r0, r5
3481278c:	e12fff33 	blx	r3

	if (mmc->clock != host->clock)
34812790:	e5969048 	ldr	r9, [r6, #72]	; 0x48
34812794:	e5953014 	ldr	r3, [r5, #20]
34812798:	e1590003 	cmp	r9, r3
3481279c:	0a000040 	beq	348128a4 <sdhci_set_ios+0x134>
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
348127a0:	e5967028 	ldr	r7, [r6, #40]	; 0x28
	writew(val, host->ioaddr + reg);
348127a4:	e3a02000 	mov	r2, #0
348127a8:	e5973004 	ldr	r3, [r7, #4]
	if (clock == 0)
348127ac:	e1590002 	cmp	r9, r2
348127b0:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
348127b4:	0a00003a 	beq	348128a4 <sdhci_set_ios+0x134>
	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
348127b8:	e5d73010 	ldrb	r3, [r7, #16]
348127bc:	e596b03c 	ldr	fp, [r6, #60]	; 0x3c
348127c0:	e3530001 	cmp	r3, #1
348127c4:	9a00000d 	bls	34812800 <sdhci_set_ios+0x90>
		if (mmc->f_max <= clock)
348127c8:	e15b0009 	cmp	fp, r9
			div = 1;
348127cc:	93a04001 	movls	r4, #1
		if (mmc->f_max <= clock)
348127d0:	9a000014 	bls	34812828 <sdhci_set_ios+0xb8>
348127d4:	e3a04002 	mov	r4, #2
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348127d8:	e300a7fe 	movw	sl, #2046	; 0x7fe
				if ((mmc->f_max / div) <= clock)
348127dc:	e1a01004 	mov	r1, r4
348127e0:	e1a0000b 	mov	r0, fp
348127e4:	fa00320d 	blx	3481f020 <__udivsi3>
348127e8:	e1500009 	cmp	r0, r9
348127ec:	9a00000d 	bls	34812828 <sdhci_set_ios+0xb8>
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348127f0:	e2844002 	add	r4, r4, #2
348127f4:	e154000a 	cmp	r4, sl
348127f8:	1afffff7 	bne	348127dc <sdhci_set_ios+0x6c>
348127fc:	ea000009 	b	34812828 <sdhci_set_ios+0xb8>
			if ((mmc->f_max / div) <= clock)
34812800:	e3a0a008 	mov	sl, #8
34812804:	e3a04001 	mov	r4, #1
34812808:	e1a01004 	mov	r1, r4
3481280c:	e1a0000b 	mov	r0, fp
34812810:	fa003202 	blx	3481f020 <__udivsi3>
34812814:	e1500009 	cmp	r0, r9
34812818:	9a000002 	bls	34812828 <sdhci_set_ios+0xb8>
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
3481281c:	e25aa001 	subs	sl, sl, #1
34812820:	e1a04084 	lsl	r4, r4, #1
34812824:	1afffff7 	bne	34812808 <sdhci_set_ios+0x98>
	if (host->set_clock)
34812828:	e5973028 	ldr	r3, [r7, #40]	; 0x28
	div >>= 1;
3481282c:	e1a040a4 	lsr	r4, r4, #1
	if (host->set_clock)
34812830:	e3530000 	cmp	r3, #0
34812834:	0a000002 	beq	34812844 <sdhci_set_ios+0xd4>
		host->set_clock(host->index, div);
34812838:	e1a01004 	mov	r1, r4
3481283c:	e5970020 	ldr	r0, [r7, #32]
34812840:	e12fff33 	blx	r3
	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
34812844:	e1a03404 	lsl	r3, r4, #8
	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
34812848:	e7e14454 	ubfx	r4, r4, #8, #2
	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
3481284c:	e6ff3073 	uxth	r3, r3
34812850:	e3833001 	orr	r3, r3, #1
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812854:	e1834304 	orr	r4, r3, r4, lsl #6
34812858:	e5973004 	ldr	r3, [r7, #4]
3481285c:	e1c342bc 	strh	r4, [r3, #44]	; 0x2c
34812860:	e3a04015 	mov	r4, #21
34812864:	e5973004 	ldr	r3, [r7, #4]
	return readw(host->ioaddr + reg);
34812868:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
3481286c:	e6ff3073 	uxth	r3, r3
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
34812870:	e3130002 	tst	r3, #2
34812874:	1a000007 	bne	34812898 <sdhci_set_ios+0x128>
		if (timeout == 0) {
34812878:	e2544001 	subs	r4, r4, #1
3481287c:	1a000002 	bne	3481288c <sdhci_set_ios+0x11c>
			printf("Internal clock never stabilised.\n");
34812880:	e59f0098 	ldr	r0, [pc, #152]	; 34812920 <sdhci_set_ios+0x1b0>
34812884:	ebffdbc4 	bl	3480979c <printf>
34812888:	ea000005 	b	348128a4 <sdhci_set_ios+0x134>
		udelay(1000);
3481288c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34812890:	eb00255d 	bl	3481be0c <udelay>
34812894:	eafffff2 	b	34812864 <sdhci_set_ios+0xf4>
	clk |= SDHCI_CLOCK_CARD_EN;
34812898:	e3833004 	orr	r3, r3, #4
	writew(val, host->ioaddr + reg);
3481289c:	e5972004 	ldr	r2, [r7, #4]
348128a0:	e1c232bc 	strh	r3, [r2, #44]	; 0x2c
348128a4:	e5953004 	ldr	r3, [r5, #4]
	return readb(host->ioaddr + reg);
348128a8:	e5d33028 	ldrb	r3, [r3, #40]	; 0x28
348128ac:	e6ef1073 	uxtb	r1, r3
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
348128b0:	e5960044 	ldr	r0, [r6, #68]	; 0x44
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
348128b4:	e1a03001 	mov	r3, r1
348128b8:	e5952010 	ldr	r2, [r5, #16]
	if (mmc->bus_width == 8) {
348128bc:	e3500008 	cmp	r0, #8
348128c0:	1a000004 	bne	348128d8 <sdhci_set_ios+0x168>
		ctrl &= ~SDHCI_CTRL_4BITBUS;
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348128c4:	e6ef2072 	uxtb	r2, r2
		ctrl &= ~SDHCI_CTRL_4BITBUS;
348128c8:	e3c13002 	bic	r3, r1, #2
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348128cc:	e3520001 	cmp	r2, #1
			ctrl |= SDHCI_CTRL_8BITBUS;
348128d0:	83833020 	orrhi	r3, r3, #32
348128d4:	ea000005 	b	348128f0 <sdhci_set_ios+0x180>
	} else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348128d8:	e6ef2072 	uxtb	r2, r2
348128dc:	e3520001 	cmp	r2, #1
			ctrl &= ~SDHCI_CTRL_8BITBUS;
348128e0:	83c13020 	bichi	r3, r1, #32
		if (mmc->bus_width == 4)
348128e4:	e3500004 	cmp	r0, #4
			ctrl |= SDHCI_CTRL_4BITBUS;
348128e8:	03833002 	orreq	r3, r3, #2
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
348128ec:	13c33002 	bicne	r3, r3, #2
	}

	if (mmc->clock > 26000000)
348128f0:	e5961048 	ldr	r1, [r6, #72]	; 0x48
348128f4:	e59f2028 	ldr	r2, [pc, #40]	; 34812924 <sdhci_set_ios+0x1b4>
348128f8:	e1510002 	cmp	r1, r2
		ctrl |= SDHCI_CTRL_HISPD;
	else
		ctrl &= ~SDHCI_CTRL_HISPD;

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
348128fc:	e5952008 	ldr	r2, [r5, #8]
		ctrl |= SDHCI_CTRL_HISPD;
34812900:	83833004 	orrhi	r3, r3, #4
		ctrl &= ~SDHCI_CTRL_HISPD;
34812904:	93c33004 	bicls	r3, r3, #4
	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
34812908:	e3120008 	tst	r2, #8
		ctrl &= ~SDHCI_CTRL_HISPD;
3481290c:	13c33004 	bicne	r3, r3, #4

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
34812910:	e6ef3073 	uxtb	r3, r3
	writeb(val, host->ioaddr + reg);
34812914:	e5952004 	ldr	r2, [r5, #4]
34812918:	e5c23028 	strb	r3, [r2, #40]	; 0x28
3481291c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812920:	34825e3e 	.word	0x34825e3e
34812924:	018cba80 	.word	0x018cba80

34812928 <sdhci_init>:
}

int sdhci_init(struct mmc *mmc)
{
34812928:	e92d4070 	push	{r4, r5, r6, lr}
3481292c:	e1a05000 	mov	r5, r0
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812930:	e5904028 	ldr	r4, [r0, #40]	; 0x28

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
34812934:	e5943008 	ldr	r3, [r4, #8]
34812938:	e3130001 	tst	r3, #1
3481293c:	0a00000d 	beq	34812978 <sdhci_init+0x50>
34812940:	e59f6150 	ldr	r6, [pc, #336]	; 34812a98 <sdhci_init+0x170>
34812944:	e5963000 	ldr	r3, [r6]
34812948:	e3530000 	cmp	r3, #0
3481294c:	1a000009 	bne	34812978 <sdhci_init+0x50>
		aligned_buffer = memalign(8, 512*1024);
34812950:	e3a01702 	mov	r1, #524288	; 0x80000
34812954:	e3a00008 	mov	r0, #8
34812958:	ebffe037 	bl	3480aa3c <memalign>
		if (!aligned_buffer) {
3481295c:	e3500000 	cmp	r0, #0
		aligned_buffer = memalign(8, 512*1024);
34812960:	e5860000 	str	r0, [r6]
		if (!aligned_buffer) {
34812964:	1a000003 	bne	34812978 <sdhci_init+0x50>
			printf("Aligned buffer alloc failed!!!");
34812968:	e59f012c 	ldr	r0, [pc, #300]	; 34812a9c <sdhci_init+0x174>
3481296c:	ebffdb8a 	bl	3480979c <printf>
			return -1;
34812970:	e3e00000 	mvn	r0, #0
34812974:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);
34812978:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
3481297c:	e3520000 	cmp	r2, #0
		return 0;
34812980:	01a03002 	moveq	r3, r2
	if (!x)
34812984:	0a000010 	beq	348129cc <sdhci_init+0xa4>
	if (!(x & 0xffff0000u)) {
34812988:	e1a03822 	lsr	r3, r2, #16
3481298c:	e1a03803 	lsl	r3, r3, #16
34812990:	e3530000 	cmp	r3, #0
		x <<= 16;
34812994:	01a02802 	lsleq	r2, r2, #16
		r -= 16;
34812998:	03a03010 	moveq	r3, #16
	int r = 32;
3481299c:	13a03020 	movne	r3, #32
	}
	if (!(x & 0xff000000u)) {
348129a0:	e31204ff 	tst	r2, #-16777216	; 0xff000000
		x <<= 8;
348129a4:	01a02402 	lsleq	r2, r2, #8
		r -= 8;
348129a8:	02433008 	subeq	r3, r3, #8
	}
	if (!(x & 0xf0000000u)) {
348129ac:	e312020f 	tst	r2, #-268435456	; 0xf0000000
		x <<= 4;
348129b0:	01a02202 	lsleq	r2, r2, #4
		r -= 4;
348129b4:	02433004 	subeq	r3, r3, #4
	}
	if (!(x & 0xc0000000u)) {
348129b8:	e3120103 	tst	r2, #-1073741824	; 0xc0000000
		x <<= 2;
348129bc:	01a02102 	lsleq	r2, r2, #2
		r -= 2;
348129c0:	02433002 	subeq	r3, r3, #2
	}
	if (!(x & 0x80000000u)) {
348129c4:	e3520000 	cmp	r2, #0
		x <<= 1;
		r -= 1;
348129c8:	a2433001 	subge	r3, r3, #1
348129cc:	e2433001 	sub	r3, r3, #1
	if (power != (unsigned short)-1) {
348129d0:	e30f2fff 	movw	r2, #65535	; 0xffff
	sdhci_set_power(host, fls(mmc->voltages) - 1);
348129d4:	e6ff3073 	uxth	r3, r3
	if (power != (unsigned short)-1) {
348129d8:	e1530002 	cmp	r3, r2
348129dc:	0a000010 	beq	34812a24 <sdhci_init+0xfc>
		switch (1 << power) {
348129e0:	e3a02001 	mov	r2, #1
348129e4:	e1a03312 	lsl	r3, r2, r3
348129e8:	e3530701 	cmp	r3, #262144	; 0x40000
348129ec:	0a00000a 	beq	34812a1c <sdhci_init+0xf4>
348129f0:	ca000004 	bgt	34812a08 <sdhci_init+0xe0>
348129f4:	e3530080 	cmp	r3, #128	; 0x80
348129f8:	0a00001f 	beq	34812a7c <sdhci_init+0x154>
348129fc:	e3530802 	cmp	r3, #131072	; 0x20000
34812a00:	0a000005 	beq	34812a1c <sdhci_init+0xf4>
34812a04:	ea000006 	b	34812a24 <sdhci_init+0xfc>
34812a08:	e3530601 	cmp	r3, #1048576	; 0x100000
34812a0c:	0a00001c 	beq	34812a84 <sdhci_init+0x15c>
34812a10:	e3530602 	cmp	r3, #2097152	; 0x200000
34812a14:	0a00001a 	beq	34812a84 <sdhci_init+0x15c>
34812a18:	ea000001 	b	34812a24 <sdhci_init+0xfc>
			pwr = SDHCI_POWER_300;
34812a1c:	e3a0300c 	mov	r3, #12
34812a20:	ea000018 	b	34812a88 <sdhci_init+0x160>
34812a24:	e5943004 	ldr	r3, [r4, #4]
34812a28:	e3a02000 	mov	r2, #0
34812a2c:	e5c32029 	strb	r2, [r3, #41]	; 0x29

	if (host->quirks & SDHCI_QUIRK_NO_CD) {
34812a30:	e5943008 	ldr	r3, [r4, #8]
34812a34:	e3130020 	tst	r3, #32
34812a38:	1a000006 	bne	34812a58 <sdhci_init+0x130>
	writel(val, host->ioaddr + reg);
34812a3c:	e5942004 	ldr	r2, [r4, #4]
34812a40:	e3e03000 	mvn	r3, #0
34812a44:	e5823034 	str	r3, [r2, #52]	; 0x34
34812a48:	e5942004 	ldr	r2, [r4, #4]

	/* Eable all state */
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);

	return 0;
34812a4c:	e3a00000 	mov	r0, #0
34812a50:	e5823038 	str	r3, [r2, #56]	; 0x38
34812a54:	e8bd8070 	pop	{r4, r5, r6, pc}
34812a58:	e5943004 	ldr	r3, [r4, #4]
34812a5c:	e3a020c0 	mov	r2, #192	; 0xc0
34812a60:	e5832028 	str	r2, [r3, #40]	; 0x28
	return readl(host->ioaddr + reg);
34812a64:	e5933024 	ldr	r3, [r3, #36]	; 0x24
		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
34812a68:	e2033807 	and	r3, r3, #458752	; 0x70000
		while ((!(status & SDHCI_CARD_PRESENT)) ||
34812a6c:	e3530807 	cmp	r3, #458752	; 0x70000
34812a70:	0afffff1 	beq	34812a3c <sdhci_init+0x114>
34812a74:	e5943004 	ldr	r3, [r4, #4]
34812a78:	eafffff9 	b	34812a64 <sdhci_init+0x13c>
			pwr = SDHCI_POWER_180;
34812a7c:	e3a0300a 	mov	r3, #10
34812a80:	ea000000 	b	34812a88 <sdhci_init+0x160>
			pwr = SDHCI_POWER_330;
34812a84:	e3a0300e 	mov	r3, #14
	pwr |= SDHCI_POWER_ON;
34812a88:	e3833001 	orr	r3, r3, #1
	writeb(val, host->ioaddr + reg);
34812a8c:	e5942004 	ldr	r2, [r4, #4]
34812a90:	e5c23029 	strb	r3, [r2, #41]	; 0x29
34812a94:	eaffffe5 	b	34812a30 <sdhci_init+0x108>
34812a98:	3482a70c 	.word	0x3482a70c
34812a9c:	34825e60 	.word	0x34825e60

34812aa0 <sdhci_send_command>:
{
34812aa0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34812aa4:	e1a05001 	mov	r5, r1
34812aa8:	e1a06002 	mov	r6, r2
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812aac:	e5904028 	ldr	r4, [r0, #40]	; 0x28
	writel(val, host->ioaddr + reg);
34812ab0:	e5943004 	ldr	r3, [r4, #4]
34812ab4:	e3e02000 	mvn	r2, #0
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
34812ab8:	e3a0700b 	mov	r7, #11
34812abc:	e5832030 	str	r2, [r3, #48]	; 0x30
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
34812ac0:	e1d130b0 	ldrh	r3, [r1]
		mask &= ~SDHCI_DATA_INHIBIT;
34812ac4:	e353000c 	cmp	r3, #12
34812ac8:	13a09003 	movne	r9, #3
34812acc:	03a09001 	moveq	r9, #1
34812ad0:	e5943004 	ldr	r3, [r4, #4]
	return readl(host->ioaddr + reg);
34812ad4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
34812ad8:	e1190003 	tst	r9, r3
34812adc:	0a000008 	beq	34812b04 <sdhci_send_command+0x64>
		if (timeout == 0) {
34812ae0:	e2577001 	subs	r7, r7, #1
34812ae4:	1a000003 	bne	34812af8 <sdhci_send_command+0x58>
			printf("Controller never released inhibit bit(s).\n");
34812ae8:	e59f02fc 	ldr	r0, [pc, #764]	; 34812dec <sdhci_send_command+0x34c>
34812aec:	ebffdb2a 	bl	3480979c <printf>
			return COMM_ERR;
34812af0:	e3e00011 	mvn	r0, #17
34812af4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		udelay(1000);
34812af8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34812afc:	eb0024c2 	bl	3481be0c <udelay>
34812b00:	eafffff2 	b	34812ad0 <sdhci_send_command+0x30>
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
34812b04:	e5951004 	ldr	r1, [r5, #4]
34812b08:	e2113001 	ands	r3, r1, #1
34812b0c:	0a000006 	beq	34812b2c <sdhci_send_command+0x8c>
	else if (cmd->resp_type & MMC_RSP_136)
34812b10:	e3110002 	tst	r1, #2
34812b14:	1a000006 	bne	34812b34 <sdhci_send_command+0x94>
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812b18:	e3110008 	tst	r1, #8
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
34812b1c:	13a03003 	movne	r3, #3
		mask |= SDHCI_INT_DATA_END;
34812b20:	11a02003 	movne	r2, r3
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812b24:	1a000004 	bne	34812b3c <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_SHORT;
34812b28:	e3a03002 	mov	r3, #2
	mask = SDHCI_INT_RESPONSE;
34812b2c:	e3a02001 	mov	r2, #1
34812b30:	ea000001 	b	34812b3c <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_LONG;
34812b34:	e3a03001 	mov	r3, #1
34812b38:	eafffffb 	b	34812b2c <sdhci_send_command+0x8c>
	if (cmd->resp_type & MMC_RSP_CRC)
34812b3c:	e3110004 	tst	r1, #4
		flags |= SDHCI_CMD_CRC;
34812b40:	13833008 	orrne	r3, r3, #8
	if (cmd->resp_type & MMC_RSP_OPCODE)
34812b44:	e3110010 	tst	r1, #16
		flags |= SDHCI_CMD_INDEX;
34812b48:	13833010 	orrne	r3, r3, #16
	if (data)
34812b4c:	e3560000 	cmp	r6, #0
34812b50:	0a000015 	beq	34812bac <sdhci_send_command+0x10c>
		flags |= SDHCI_CMD_DATA;
34812b54:	e3833020 	orr	r3, r3, #32
	writeb(val, host->ioaddr + reg);
34812b58:	e5941004 	ldr	r1, [r4, #4]
34812b5c:	e3a0000e 	mov	r0, #14
34812b60:	e5c1002e 	strb	r0, [r1, #46]	; 0x2e
		if (data->blocks > 1)
34812b64:	e5961008 	ldr	r1, [r6, #8]
		trans_bytes = data->blocks * data->blocksize;
34812b68:	e596000c 	ldr	r0, [r6, #12]
		if (data->flags == MMC_DATA_READ)
34812b6c:	e596c004 	ldr	ip, [r6, #4]
			mode |= SDHCI_TRNS_MULTI;
34812b70:	e3510002 	cmp	r1, #2
34812b74:	33a01002 	movcc	r1, #2
34812b78:	23a01022 	movcs	r1, #34	; 0x22
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34812b7c:	e7eb0050 	ubfx	r0, r0, #0, #12
		if (data->flags == MMC_DATA_READ)
34812b80:	e35c0001 	cmp	ip, #1
			mode |= SDHCI_TRNS_READ;
34812b84:	03811010 	orreq	r1, r1, #16
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34812b88:	e3800a07 	orr	r0, r0, #28672	; 0x7000
	writew(val, host->ioaddr + reg);
34812b8c:	e594c004 	ldr	ip, [r4, #4]
34812b90:	e1cc00b4 	strh	r0, [ip, #4]
		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
34812b94:	e1d6c0b8 	ldrh	ip, [r6, #8]
34812b98:	e5940004 	ldr	r0, [r4, #4]
		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
34812b9c:	e6ff1071 	uxth	r1, r1
34812ba0:	e1c0c0b6 	strh	ip, [r0, #6]
34812ba4:	e5940004 	ldr	r0, [r4, #4]
34812ba8:	e1c010bc 	strh	r1, [r0, #12]
	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
34812bac:	e5950008 	ldr	r0, [r5, #8]
	writel(val, host->ioaddr + reg);
34812bb0:	e5941004 	ldr	r1, [r4, #4]
34812bb4:	e5810008 	str	r0, [r1, #8]
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
34812bb8:	e1d510b0 	ldrh	r1, [r5]
34812bbc:	e1833401 	orr	r3, r3, r1, lsl #8
34812bc0:	e6ff3073 	uxth	r3, r3
	writew(val, host->ioaddr + reg);
34812bc4:	e5941004 	ldr	r1, [r4, #4]
34812bc8:	e1c130be 	strh	r3, [r1, #14]
	unsigned int retry = 10000;
34812bcc:	e3023710 	movw	r3, #10000	; 0x2710
34812bd0:	e5941004 	ldr	r1, [r4, #4]
	return readl(host->ioaddr + reg);
34812bd4:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & SDHCI_INT_ERROR)
34812bd8:	e3110902 	tst	r1, #32768	; 0x8000
34812bdc:	1a000004 	bne	34812bf4 <sdhci_send_command+0x154>
		if (--retry == 0)
34812be0:	e2533001 	subs	r3, r3, #1
34812be4:	0a000004 	beq	34812bfc <sdhci_send_command+0x15c>
	} while ((stat & mask) != mask);
34812be8:	e1d20001 	bics	r0, r2, r1
34812bec:	1afffff7 	bne	34812bd0 <sdhci_send_command+0x130>
34812bf0:	ea00000a 	b	34812c20 <sdhci_send_command+0x180>
	if (retry == 0) {
34812bf4:	e3530000 	cmp	r3, #0
34812bf8:	1a000008 	bne	34812c20 <sdhci_send_command+0x180>
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
34812bfc:	e5943008 	ldr	r3, [r4, #8]
34812c00:	e3130004 	tst	r3, #4
34812c04:	0a000001 	beq	34812c10 <sdhci_send_command+0x170>
			return 0;
34812c08:	e3a00000 	mov	r0, #0
34812c0c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			printf("Timeout for status update!\n");
34812c10:	e59f01d8 	ldr	r0, [pc, #472]	; 34812df0 <sdhci_send_command+0x350>
34812c14:	ebffdae0 	bl	3480979c <printf>
			return TIMEOUT;
34812c18:	e3e00012 	mvn	r0, #18
34812c1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812c20:	e3820902 	orr	r0, r2, #32768	; 0x8000
34812c24:	e0000001 	and	r0, r0, r1
34812c28:	e1500002 	cmp	r0, r2
		ret = -1;
34812c2c:	13e03000 	mvnne	r3, #0
	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812c30:	1a00001d 	bne	34812cac <sdhci_send_command+0x20c>
	if (cmd->resp_type & MMC_RSP_136) {
34812c34:	e5953004 	ldr	r3, [r5, #4]
34812c38:	e3130002 	tst	r3, #2
34812c3c:	0a000014 	beq	34812c94 <sdhci_send_command+0x1f4>
34812c40:	e2855008 	add	r5, r5, #8
34812c44:	e3a0c01c 	mov	ip, #28
34812c48:	e3a02000 	mov	r2, #0
34812c4c:	e5943004 	ldr	r3, [r4, #4]
34812c50:	e793300c 	ldr	r3, [r3, ip]
					SDHCI_RESPONSE + (3-i)*4) << 8;
34812c54:	e1a03403 	lsl	r3, r3, #8
			if (i != 3)
34812c58:	e3520003 	cmp	r2, #3
			cmd->response[i] = sdhci_readl(host,
34812c5c:	e5a53004 	str	r3, [r5, #4]!
			if (i != 3)
34812c60:	0a000006 	beq	34812c80 <sdhci_send_command+0x1e0>
	return readb(host->ioaddr + reg);
34812c64:	e5941004 	ldr	r1, [r4, #4]
34812c68:	e24c3001 	sub	r3, ip, #1
34812c6c:	e7d13003 	ldrb	r3, [r1, r3]
34812c70:	e6ef3073 	uxtb	r3, r3
				cmd->response[i] |= sdhci_readb(host,
34812c74:	e5951000 	ldr	r1, [r5]
34812c78:	e1813003 	orr	r3, r1, r3
34812c7c:	e5853000 	str	r3, [r5]
		for (i = 0; i < 4; i++) {
34812c80:	e2822001 	add	r2, r2, #1
34812c84:	e24cc004 	sub	ip, ip, #4
34812c88:	e3520004 	cmp	r2, #4
34812c8c:	1affffee 	bne	34812c4c <sdhci_send_command+0x1ac>
34812c90:	ea000002 	b	34812ca0 <sdhci_send_command+0x200>
34812c94:	e5943004 	ldr	r3, [r4, #4]
	return readl(host->ioaddr + reg);
34812c98:	e5933010 	ldr	r3, [r3, #16]
		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
34812c9c:	e585300c 	str	r3, [r5, #12]
	writel(val, host->ioaddr + reg);
34812ca0:	e5943004 	ldr	r3, [r4, #4]
34812ca4:	e5830030 	str	r0, [r3, #48]	; 0x30
	int ret = 0;
34812ca8:	e3a03000 	mov	r3, #0
	if (!ret && data)
34812cac:	e2832001 	add	r2, r3, #1
34812cb0:	e3560000 	cmp	r6, #0
34812cb4:	03a02000 	moveq	r2, #0
34812cb8:	12022001 	andne	r2, r2, #1
34812cbc:	e3520000 	cmp	r2, #0
34812cc0:	0a000038 	beq	34812da8 <sdhci_send_command+0x308>
34812cc4:	e3a07000 	mov	r7, #0
34812cc8:	e3021710 	movw	r1, #10000	; 0x2710
34812ccc:	e3a09030 	mov	r9, #48	; 0x30
34812cd0:	e5943004 	ldr	r3, [r4, #4]
	return readl(host->ioaddr + reg);
34812cd4:	e5935030 	ldr	r5, [r3, #48]	; 0x30
		if (stat & SDHCI_INT_ERROR) {
34812cd8:	e2153902 	ands	r3, r5, #32768	; 0x8000
34812cdc:	0a000003 	beq	34812cf0 <sdhci_send_command+0x250>
			printf("Error detected in status(0x%X)!\n", stat);
34812ce0:	e1a01005 	mov	r1, r5
34812ce4:	e59f0108 	ldr	r0, [pc, #264]	; 34812df4 <sdhci_send_command+0x354>
34812ce8:	ebffdaab 	bl	3480979c <printf>
34812cec:	ea000028 	b	34812d94 <sdhci_send_command+0x2f4>
		if (stat & rdy) {
34812cf0:	e3150030 	tst	r5, #48	; 0x30
34812cf4:	0a00001d 	beq	34812d70 <sdhci_send_command+0x2d0>
34812cf8:	e5942004 	ldr	r2, [r4, #4]
34812cfc:	e5922024 	ldr	r2, [r2, #36]	; 0x24
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
34812d00:	e3120b03 	tst	r2, #3072	; 0xc00
34812d04:	0a000024 	beq	34812d9c <sdhci_send_command+0x2fc>
	writel(val, host->ioaddr + reg);
34812d08:	e5942004 	ldr	r2, [r4, #4]
34812d0c:	e5829030 	str	r9, [r2, #48]	; 0x30
	for (i = 0; i < data->blocksize; i += 4) {
34812d10:	e596000c 	ldr	r0, [r6, #12]
34812d14:	e5962000 	ldr	r2, [r6]
34812d18:	e1530000 	cmp	r3, r0
34812d1c:	2a00000b 	bcs	34812d50 <sdhci_send_command+0x2b0>
		if (data->flags == MMC_DATA_READ)
34812d20:	e5960004 	ldr	r0, [r6, #4]
34812d24:	e3500001 	cmp	r0, #1
34812d28:	1a000003 	bne	34812d3c <sdhci_send_command+0x29c>
34812d2c:	e5940004 	ldr	r0, [r4, #4]
	return readl(host->ioaddr + reg);
34812d30:	e5900020 	ldr	r0, [r0, #32]
			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
34812d34:	e7820003 	str	r0, [r2, r3]
34812d38:	ea000002 	b	34812d48 <sdhci_send_command+0x2a8>
			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
34812d3c:	e7920003 	ldr	r0, [r2, r3]
	writel(val, host->ioaddr + reg);
34812d40:	e5942004 	ldr	r2, [r4, #4]
34812d44:	e5820020 	str	r0, [r2, #32]
	for (i = 0; i < data->blocksize; i += 4) {
34812d48:	e2833004 	add	r3, r3, #4
34812d4c:	eaffffef 	b	34812d10 <sdhci_send_command+0x270>
			if (++block >= data->blocks)
34812d50:	e5963008 	ldr	r3, [r6, #8]
34812d54:	e2877001 	add	r7, r7, #1
			data->dest += data->blocksize;
34812d58:	e0822000 	add	r2, r2, r0
34812d5c:	e5862000 	str	r2, [r6]
			if (++block >= data->blocks)
34812d60:	e1570003 	cmp	r7, r3
34812d64:	3a000001 	bcc	34812d70 <sdhci_send_command+0x2d0>
	return 0;
34812d68:	e3a03000 	mov	r3, #0
34812d6c:	ea00000d 	b	34812da8 <sdhci_send_command+0x308>
		if (timeout-- > 0)
34812d70:	e3510000 	cmp	r1, #0
34812d74:	e241a001 	sub	sl, r1, #1
34812d78:	0a000003 	beq	34812d8c <sdhci_send_command+0x2ec>
			udelay(10);
34812d7c:	e3a0000a 	mov	r0, #10
34812d80:	eb002421 	bl	3481be0c <udelay>
34812d84:	e1a0100a 	mov	r1, sl
34812d88:	ea000003 	b	34812d9c <sdhci_send_command+0x2fc>
			printf("Transfer data timeout\n");
34812d8c:	e59f0064 	ldr	r0, [pc, #100]	; 34812df8 <sdhci_send_command+0x358>
34812d90:	ebffda81 	bl	3480979c <printf>
			return -1;
34812d94:	e3e03000 	mvn	r3, #0
34812d98:	ea000002 	b	34812da8 <sdhci_send_command+0x308>
	} while (!(stat & SDHCI_INT_DATA_END));
34812d9c:	e3150002 	tst	r5, #2
34812da0:	0affffca 	beq	34812cd0 <sdhci_send_command+0x230>
34812da4:	eaffffef 	b	34812d68 <sdhci_send_command+0x2c8>
34812da8:	e5942004 	ldr	r2, [r4, #4]
	return readl(host->ioaddr + reg);
34812dac:	e5925030 	ldr	r5, [r2, #48]	; 0x30
	writel(val, host->ioaddr + reg);
34812db0:	e5942004 	ldr	r2, [r4, #4]
	if (!ret) {
34812db4:	e3530000 	cmp	r3, #0
34812db8:	e3e01000 	mvn	r1, #0
34812dbc:	e5821030 	str	r1, [r2, #48]	; 0x30
34812dc0:	0affff90 	beq	34812c08 <sdhci_send_command+0x168>
	sdhci_reset(host, SDHCI_RESET_CMD);
34812dc4:	e1a00004 	mov	r0, r4
34812dc8:	e3a01002 	mov	r1, #2
34812dcc:	ebfffe51 	bl	34812718 <sdhci_reset>
	sdhci_reset(host, SDHCI_RESET_DATA);
34812dd0:	e1a00004 	mov	r0, r4
34812dd4:	e3a01004 	mov	r1, #4
34812dd8:	ebfffe4e 	bl	34812718 <sdhci_reset>
		return COMM_ERR;
34812ddc:	e3150801 	tst	r5, #65536	; 0x10000
34812de0:	13e00012 	mvnne	r0, #18
34812de4:	03e00011 	mvneq	r0, #17
}
34812de8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812dec:	34825e7f 	.word	0x34825e7f
34812df0:	34825eaa 	.word	0x34825eaa
34812df4:	34825ec6 	.word	0x34825ec6
34812df8:	34825ee7 	.word	0x34825ee7

34812dfc <add_sdhci>:
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34812dfc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34812e00:	e1a05000 	mov	r5, r0
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34812e04:	e3a00f4a 	mov	r0, #296	; 0x128
{
34812e08:	e1a07001 	mov	r7, r1
34812e0c:	e1a06002 	mov	r6, r2
	mmc = malloc(sizeof(struct mmc));
34812e10:	ebffdc30 	bl	34809ed8 <malloc>
	if (!mmc) {
34812e14:	e2504000 	subs	r4, r0, #0
		printf("mmc malloc fail!\n");
34812e18:	059f0140 	ldreq	r0, [pc, #320]	; 34812f60 <add_sdhci+0x164>
	if (!mmc) {
34812e1c:	0a00001f 	beq	34812ea0 <add_sdhci+0xa4>
		return -1;
	}

	mmc->priv = host;
34812e20:	e5845028 	str	r5, [r4, #40]	; 0x28
	host->mmc = mmc;

	sprintf(mmc->name, "%s", host->name);
34812e24:	e2840008 	add	r0, r4, #8
	host->mmc = mmc;
34812e28:	e5854018 	str	r4, [r5, #24]
	sprintf(mmc->name, "%s", host->name);
34812e2c:	e5952000 	ldr	r2, [r5]
34812e30:	e59f112c 	ldr	r1, [pc, #300]	; 34812f64 <add_sdhci+0x168>
34812e34:	eb0026f3 	bl	3481ca08 <sprintf>
	mmc->send_cmd = sdhci_send_command;
34812e38:	e59f3128 	ldr	r3, [pc, #296]	; 34812f68 <add_sdhci+0x16c>
34812e3c:	e5843110 	str	r3, [r4, #272]	; 0x110
	mmc->set_ios = sdhci_set_ios;
34812e40:	e59f3124 	ldr	r3, [pc, #292]	; 34812f6c <add_sdhci+0x170>
34812e44:	e5843114 	str	r3, [r4, #276]	; 0x114
	mmc->init = sdhci_init;
34812e48:	e59f3120 	ldr	r3, [pc, #288]	; 34812f70 <add_sdhci+0x174>
34812e4c:	e5843118 	str	r3, [r4, #280]	; 0x118
	mmc->getcd = NULL;
34812e50:	e3a03000 	mov	r3, #0
34812e54:	e584311c 	str	r3, [r4, #284]	; 0x11c
34812e58:	e5953004 	ldr	r3, [r5, #4]
	return readl(host->ioaddr + reg);
34812e5c:	e5931040 	ldr	r1, [r3, #64]	; 0x40
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
34812e60:	e3570000 	cmp	r7, #0
		mmc->f_max = max_clk;
34812e64:	1584703c 	strne	r7, [r4, #60]	; 0x3c
	if (max_clk)
34812e68:	1a000008 	bne	34812e90 <add_sdhci+0x94>
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812e6c:	e5d53010 	ldrb	r3, [r5, #16]
34812e70:	e3530001 	cmp	r3, #1
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34812e74:	87e73451 	ubfxhi	r3, r1, #8, #8
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34812e78:	97e53451 	ubfxls	r3, r1, #8, #6
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
34812e7c:	e584303c 	str	r3, [r4, #60]	; 0x3c
		mmc->f_max *= 1000000;
34812e80:	e59f30ec 	ldr	r3, [pc, #236]	; 34812f74 <add_sdhci+0x178>
34812e84:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
34812e88:	e0030293 	mul	r3, r3, r2
34812e8c:	e584303c 	str	r3, [r4, #60]	; 0x3c
	}
	if (mmc->f_max == 0) {
34812e90:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
34812e94:	e3520000 	cmp	r2, #0
34812e98:	1a000003 	bne	34812eac <add_sdhci+0xb0>
		printf("Hardware doesn't specify base clock frequency\n");
34812e9c:	e59f00d4 	ldr	r0, [pc, #212]	; 34812f78 <add_sdhci+0x17c>
34812ea0:	ebffda3d 	bl	3480979c <printf>
		return -1;
34812ea4:	e3e00000 	mvn	r0, #0
34812ea8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	}
	if (min_clk)
34812eac:	e3560000 	cmp	r6, #0
		mmc->f_min = min_clk;
34812eb0:	15846038 	strne	r6, [r4, #56]	; 0x38
	if (min_clk)
34812eb4:	1a000008 	bne	34812edc <add_sdhci+0xe0>
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812eb8:	e5d53010 	ldrb	r3, [r5, #16]
34812ebc:	e3530001 	cmp	r3, #1
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
34812ec0:	859f30b4 	ldrhi	r3, [pc, #180]	; 34812f7c <add_sdhci+0x180>
34812ec4:	81a020a2 	lsrhi	r2, r2, #1
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34812ec8:	91a02422 	lsrls	r2, r2, #8
34812ecc:	95842038 	strls	r2, [r4, #56]	; 0x38
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
34812ed0:	80832392 	umullhi	r2, r3, r2, r3
34812ed4:	81a034a3 	lsrhi	r3, r3, #9
34812ed8:	85843038 	strhi	r3, [r4, #56]	; 0x38
	}

	mmc->voltages = 0;
	if (caps & SDHCI_CAN_VDD_330)
34812edc:	e2113401 	ands	r3, r1, #16777216	; 0x1000000
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34812ee0:	e1a00005 	mov	r0, r5
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
34812ee4:	13a03603 	movne	r3, #3145728	; 0x300000
	if (caps & SDHCI_CAN_VDD_300)
34812ee8:	e3110402 	tst	r1, #33554432	; 0x2000000
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
34812eec:	e584302c 	str	r3, [r4, #44]	; 0x2c
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34812ef0:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
34812ef4:	13833806 	orrne	r3, r3, #393216	; 0x60000
34812ef8:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_180)
34812efc:	e3110301 	tst	r1, #67108864	; 0x4000000
		mmc->voltages |= MMC_VDD_165_195;
34812f00:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
34812f04:	13833080 	orrne	r3, r3, #128	; 0x80
34812f08:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
34812f0c:	e5953008 	ldr	r3, [r5, #8]
34812f10:	e3130010 	tst	r3, #16
		mmc->voltages |= host->voltages;
34812f14:	1595302c 	ldrne	r3, [r5, #44]	; 0x2c
34812f18:	1594202c 	ldrne	r2, [r4, #44]	; 0x2c
34812f1c:	11823003 	orrne	r3, r2, r3
34812f20:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
34812f24:	e3110701 	tst	r1, #262144	; 0x40000
	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
34812f28:	03003111 	movweq	r3, #273	; 0x111
		mmc->host_caps |= MMC_MODE_8BIT;
34812f2c:	13003311 	movwne	r3, #785	; 0x311
34812f30:	e5843050 	str	r3, [r4, #80]	; 0x50
	sdhci_reset(host, SDHCI_RESET_ALL);
34812f34:	e3a01001 	mov	r1, #1
	if (host->host_caps)
34812f38:	e595300c 	ldr	r3, [r5, #12]
34812f3c:	e3530000 	cmp	r3, #0
		mmc->host_caps |= host->host_caps;
34812f40:	15942050 	ldrne	r2, [r4, #80]	; 0x50
34812f44:	11823003 	orrne	r3, r2, r3
34812f48:	15843050 	strne	r3, [r4, #80]	; 0x50
	sdhci_reset(host, SDHCI_RESET_ALL);
34812f4c:	ebfffdf1 	bl	34812718 <sdhci_reset>
	mmc_register(mmc);
34812f50:	e1a00004 	mov	r0, r4
34812f54:	ebfffd59 	bl	348124c0 <mmc_register>

	return 0;
34812f58:	e3a00000 	mov	r0, #0
}
34812f5c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34812f60:	34825efe 	.word	0x34825efe
34812f64:	34823837 	.word	0x34823837
34812f68:	34812aa0 	.word	0x34812aa0
34812f6c:	34812770 	.word	0x34812770
34812f70:	34812928 	.word	0x34812928
34812f74:	000f4240 	.word	0x000f4240
34812f78:	34825f10 	.word	0x34825f10
34812f7c:	80200803 	.word	0x80200803

34812f80 <s5p_sdhci_set_control_reg>:
	writel(val, host->ioaddr + reg);
34812f80:	e5903004 	ldr	r3, [r0, #4]
34812f84:	e3a02803 	mov	r2, #196608	; 0x30000
34812f88:	e583208c 	str	r2, [r3, #140]	; 0x8c
	return readl(host->ioaddr + reg);
34812f8c:	e5933080 	ldr	r3, [r3, #128]	; 0x80
	 * 11 = 9mA
	 */
	sdhci_writel(host, SDHCI_CTRL4_DRIVE_MASK(0x3), SDHCI_CONTROL4);

	val = sdhci_readl(host, SDHCI_CONTROL2);
	val &= SDHCI_CTRL2_SELBASECLK_SHIFT;
34812f90:	e2033004 	and	r3, r3, #4

	val |=	SDHCI_CTRL2_ENSTAASYNCCLR |
34812f94:	e3833103 	orr	r3, r3, #-1073741824	; 0xc0000000
34812f98:	e3833c41 	orr	r3, r3, #16640	; 0x4100
	writel(val, host->ioaddr + reg);
34812f9c:	e5902004 	ldr	r2, [r0, #4]
34812fa0:	e5823080 	str	r3, [r2, #128]	; 0x80
34812fa4:	e5903004 	ldr	r3, [r0, #4]
34812fa8:	e3082080 	movw	r2, #32896	; 0x8080
34812fac:	e5832084 	str	r2, [r3, #132]	; 0x84
	return readl(host->ioaddr + reg);
34812fb0:	e5933080 	ldr	r3, [r3, #128]	; 0x80
	 * 00/01 = HCLK
	 * 10 = EPLL
	 * 11 = XTI or XEXTCLK
	 */
	ctrl = sdhci_readl(host, SDHCI_CONTROL2);
	ctrl &= ~SDHCI_CTRL2_SELBASECLK_MASK(0x3);
34812fb4:	e3c33030 	bic	r3, r3, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
34812fb8:	e3833020 	orr	r3, r3, #32
	writel(val, host->ioaddr + reg);
34812fbc:	e5902004 	ldr	r2, [r0, #4]
34812fc0:	e5823080 	str	r3, [r2, #128]	; 0x80
34812fc4:	e12fff1e 	bx	lr

34812fc8 <s5p_sdhci_init>:
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34812fc8:	e92d4070 	push	{r4, r5, r6, lr}
34812fcc:	e1a04000 	mov	r4, r0
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34812fd0:	e3a00030 	mov	r0, #48	; 0x30
{
34812fd4:	e1a05001 	mov	r5, r1
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34812fd8:	ebffdbbe 	bl	34809ed8 <malloc>
	if (!host) {
34812fdc:	e2503000 	subs	r3, r0, #0
34812fe0:	1a000003 	bne	34812ff4 <s5p_sdhci_init+0x2c>
		printf("sdhci__host malloc fail!\n");
34812fe4:	e59f005c 	ldr	r0, [pc, #92]	; 34813048 <s5p_sdhci_init+0x80>
34812fe8:	ebffd9eb 	bl	3480979c <printf>
		return 1;
34812fec:	e3a00001 	mov	r0, #1
34812ff0:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	host->name = S5P_NAME;
34812ff4:	e59f2050 	ldr	r2, [pc, #80]	; 3481304c <s5p_sdhci_init+0x84>
	host->ioaddr = (void *)regbase;
34812ff8:	e8830014 	stm	r3, {r2, r4}

	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
34812ffc:	e3a0201d 	mov	r2, #29
34813000:	e5832008 	str	r2, [r3, #8]
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
34813004:	e59f2044 	ldr	r2, [pc, #68]	; 34813050 <s5p_sdhci_init+0x88>
34813008:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return readw(host->ioaddr + reg);
3481300c:	e1d42fbe 	ldrh	r2, [r4, #254]	; 0xfe
34813010:	e6ff2072 	uxth	r2, r2
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
34813014:	e5832010 	str	r2, [r3, #16]

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34813018:	e59f2034 	ldr	r2, [pc, #52]	; 34813054 <s5p_sdhci_init+0x8c>
	host->set_clock = set_mmc_clk;
	host->index = index;
3481301c:	e5835020 	str	r5, [r3, #32]

	host->host_caps = MMC_MODE_HC;

	add_sdhci(host, 52000000, 400000);
34813020:	e59f1030 	ldr	r1, [pc, #48]	; 34813058 <s5p_sdhci_init+0x90>
	host->set_control_reg = &s5p_sdhci_set_control_reg;
34813024:	e5832024 	str	r2, [r3, #36]	; 0x24
	host->set_clock = set_mmc_clk;
34813028:	e59f202c 	ldr	r2, [pc, #44]	; 3481305c <s5p_sdhci_init+0x94>
3481302c:	e5832028 	str	r2, [r3, #40]	; 0x28
	host->host_caps = MMC_MODE_HC;
34813030:	e3a02b02 	mov	r2, #2048	; 0x800
34813034:	e583200c 	str	r2, [r3, #12]
	add_sdhci(host, 52000000, 400000);
34813038:	e59f2020 	ldr	r2, [pc, #32]	; 34813060 <s5p_sdhci_init+0x98>
3481303c:	ebffff6e 	bl	34812dfc <add_sdhci>
	return 0;
34813040:	e3a00000 	mov	r0, #0
}
34813044:	e8bd8070 	pop	{r4, r5, r6, pc}
34813048:	34825f3f 	.word	0x34825f3f
3481304c:	34825f59 	.word	0x34825f59
34813050:	00300080 	.word	0x00300080
34813054:	34812f80 	.word	0x34812f80
34813058:	03197500 	.word	0x03197500
3481305c:	34801714 	.word	0x34801714
34813060:	00061a80 	.word	0x00061a80

34813064 <add_mtd_device>:

int add_mtd_device(struct mtd_info *mtd)
{
	int i;

	BUG_ON(mtd->writesize == 0);
34813064:	e5903014 	ldr	r3, [r0, #20]
{
34813068:	e92d4010 	push	{r4, lr}
3481306c:	e1a04000 	mov	r4, r0
	BUG_ON(mtd->writesize == 0);
34813070:	e3530000 	cmp	r3, #0
34813074:	1a000003 	bne	34813088 <add_mtd_device+0x24>
34813078:	e3a02014 	mov	r2, #20
3481307c:	e59f1040 	ldr	r1, [pc, #64]	; 348130c4 <add_mtd_device+0x60>
34813080:	e59f0040 	ldr	r0, [pc, #64]	; 348130c8 <add_mtd_device+0x64>
34813084:	ebffd9c4 	bl	3480979c <printf>

	for (i = 0; i < MAX_MTD_DEVICES; i++)
		if (!mtd_table[i]) {
34813088:	e59f203c 	ldr	r2, [pc, #60]	; 348130cc <add_mtd_device+0x68>
	for (i = 0; i < MAX_MTD_DEVICES; i++)
3481308c:	e3a03000 	mov	r3, #0
		if (!mtd_table[i]) {
34813090:	e7920103 	ldr	r0, [r2, r3, lsl #2]
34813094:	e3500000 	cmp	r0, #0
34813098:	1a000004 	bne	348130b0 <add_mtd_device+0x4c>
			mtd_table[i] = mtd;
3481309c:	e59f2028 	ldr	r2, [pc, #40]	; 348130cc <add_mtd_device+0x68>
			mtd->index = i;
			mtd->usecount = 0;
348130a0:	e584009c 	str	r0, [r4, #156]	; 0x9c
			mtd_table[i] = mtd;
348130a4:	e7824103 	str	r4, [r2, r3, lsl #2]
			mtd->index = i;
348130a8:	e5843024 	str	r3, [r4, #36]	; 0x24

			/* We _know_ we aren't being removed, because
			   our caller is still holding us here. So none
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
348130ac:	e8bd8010 	pop	{r4, pc}
	for (i = 0; i < MAX_MTD_DEVICES; i++)
348130b0:	e2833001 	add	r3, r3, #1
348130b4:	e3530020 	cmp	r3, #32
348130b8:	1afffff4 	bne	34813090 <add_mtd_device+0x2c>
		}

	return 1;
348130bc:	e3a00001 	mov	r0, #1
}
348130c0:	e8bd8010 	pop	{r4, pc}
348130c4:	34825f67 	.word	0x34825f67
348130c8:	34825f71 	.word	0x34825f71
348130cc:	3482a710 	.word	0x3482a710

348130d0 <del_mtd_device>:
 */
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
348130d0:	e5901024 	ldr	r1, [r0, #36]	; 0x24
348130d4:	e59fc040 	ldr	ip, [pc, #64]	; 3481311c <del_mtd_device+0x4c>
348130d8:	e79c2101 	ldr	r2, [ip, r1, lsl #2]
348130dc:	e1520000 	cmp	r2, r0
348130e0:	1a00000b 	bne	34813114 <del_mtd_device+0x44>
		ret = -ENODEV;
	} else if (mtd->usecount) {
348130e4:	e592309c 	ldr	r3, [r2, #156]	; 0x9c
348130e8:	e3530000 	cmp	r3, #0
348130ec:	0a000005 	beq	34813108 <del_mtd_device+0x38>
{
348130f0:	e92d4010 	push	{r4, lr}
		printk(KERN_NOTICE "Removing MTD device #%d (%s)"
348130f4:	e5922020 	ldr	r2, [r2, #32]
348130f8:	e59f0020 	ldr	r0, [pc, #32]	; 34813120 <del_mtd_device+0x50>
348130fc:	ebffd9a6 	bl	3480979c <printf>
				" with use count %d\n",
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
34813100:	e3e0000f 	mvn	r0, #15
34813104:	e8bd8010 	pop	{r4, pc}
	} else {
		/* No need to get a refcount on the module containing
		 * the notifier, since we hold the mtd_table_mutex */
		mtd_table[mtd->index] = NULL;
34813108:	e78c3101 	str	r3, [ip, r1, lsl #2]

		ret = 0;
3481310c:	e1a00003 	mov	r0, r3
34813110:	e12fff1e 	bx	lr
		ret = -ENODEV;
34813114:	e3e00012 	mvn	r0, #18
34813118:	e12fff1e 	bx	lr
3481311c:	3482a710 	.word	0x3482a710
34813120:	34825f87 	.word	0x34825f87

34813124 <get_mtd_device>:
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34813124:	e3710001 	cmn	r1, #1
34813128:	1a000009 	bne	34813154 <get_mtd_device+0x30>
		for (i = 0; i < MAX_MTD_DEVICES; i++)
			if (mtd_table[i] == mtd)
3481312c:	e59fc060 	ldr	ip, [pc, #96]	; 34813194 <get_mtd_device+0x70>
34813130:	e3a02000 	mov	r2, #0
34813134:	e1a03002 	mov	r3, r2
34813138:	e79c1102 	ldr	r1, [ip, r2, lsl #2]
		for (i = 0; i < MAX_MTD_DEVICES; i++)
3481313c:	e2822001 	add	r2, r2, #1
			if (mtd_table[i] == mtd)
34813140:	e1510000 	cmp	r1, r0
34813144:	01a03000 	moveq	r3, r0
		for (i = 0; i < MAX_MTD_DEVICES; i++)
34813148:	e3520020 	cmp	r2, #32
3481314c:	1afffff9 	bne	34813138 <get_mtd_device+0x14>
34813150:	ea000006 	b	34813170 <get_mtd_device+0x4c>
				ret = mtd_table[i];
	} else if (num < MAX_MTD_DEVICES) {
34813154:	e351001f 	cmp	r1, #31
34813158:	ca00000b 	bgt	3481318c <get_mtd_device+0x68>
		ret = mtd_table[num];
3481315c:	e59f3030 	ldr	r3, [pc, #48]	; 34813194 <get_mtd_device+0x70>
34813160:	e7933101 	ldr	r3, [r3, r1, lsl #2]
		if (mtd && mtd != ret)
34813164:	e1500003 	cmp	r0, r3
34813168:	13500000 	cmpne	r0, #0
3481316c:	1a000006 	bne	3481318c <get_mtd_device+0x68>
			ret = NULL;
	}

	if (!ret)
34813170:	e3530000 	cmp	r3, #0
34813174:	0a000004 	beq	3481318c <get_mtd_device+0x68>
		goto out_unlock;

	ret->usecount++;
34813178:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
	return ret;
3481317c:	e1a00003 	mov	r0, r3
	ret->usecount++;
34813180:	e2822001 	add	r2, r2, #1
34813184:	e583209c 	str	r2, [r3, #156]	; 0x9c
	return ret;
34813188:	e12fff1e 	bx	lr

out_unlock:
	return ERR_PTR(err);
3481318c:	e3e00012 	mvn	r0, #18
}
34813190:	e12fff1e 	bx	lr
34813194:	3482a710 	.word	0x3482a710

34813198 <get_mtd_device_nm>:
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34813198:	e92d4070 	push	{r4, r5, r6, lr}
3481319c:	e1a05000 	mov	r5, r0
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
348131a0:	e59f6058 	ldr	r6, [pc, #88]	; 34813200 <get_mtd_device_nm+0x68>
	for (i = 0; i < MAX_MTD_DEVICES; i++) {
348131a4:	e3a04000 	mov	r4, #0
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
348131a8:	e7963104 	ldr	r3, [r6, r4, lsl #2]
348131ac:	e3530000 	cmp	r3, #0
348131b0:	0a00000a 	beq	348131e0 <get_mtd_device_nm+0x48>
348131b4:	e5931020 	ldr	r1, [r3, #32]
348131b8:	e1a00005 	mov	r0, r5
348131bc:	eb002197 	bl	3481b820 <strcmp>
348131c0:	e3500000 	cmp	r0, #0
348131c4:	1a000005 	bne	348131e0 <get_mtd_device_nm+0x48>
			mtd = mtd_table[i];
348131c8:	e59f3030 	ldr	r3, [pc, #48]	; 34813200 <get_mtd_device_nm+0x68>
348131cc:	e7930104 	ldr	r0, [r3, r4, lsl #2]
			break;
		}
	}

	if (!mtd)
348131d0:	e3500000 	cmp	r0, #0
348131d4:	1a000005 	bne	348131f0 <get_mtd_device_nm+0x58>

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
348131d8:	e3e00012 	mvn	r0, #18
348131dc:	e8bd8070 	pop	{r4, r5, r6, pc}
	for (i = 0; i < MAX_MTD_DEVICES; i++) {
348131e0:	e2844001 	add	r4, r4, #1
348131e4:	e3540020 	cmp	r4, #32
348131e8:	1affffee 	bne	348131a8 <get_mtd_device_nm+0x10>
348131ec:	eafffff9 	b	348131d8 <get_mtd_device_nm+0x40>
	mtd->usecount++;
348131f0:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
348131f4:	e2833001 	add	r3, r3, #1
348131f8:	e580309c 	str	r3, [r0, #156]	; 0x9c
}
348131fc:	e8bd8070 	pop	{r4, r5, r6, pc}
34813200:	3482a710 	.word	0x3482a710

34813204 <put_mtd_device>:

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34813204:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
34813208:	e2433001 	sub	r3, r3, #1
	BUG_ON(c < 0);
3481320c:	e3530000 	cmp	r3, #0
	c = --mtd->usecount;
34813210:	e580309c 	str	r3, [r0, #156]	; 0x9c
	BUG_ON(c < 0);
34813214:	a12fff1e 	bxge	lr
34813218:	e3a0208f 	mov	r2, #143	; 0x8f
3481321c:	e59f1004 	ldr	r1, [pc, #4]	; 34813228 <put_mtd_device+0x24>
34813220:	e59f0004 	ldr	r0, [pc, #4]	; 3481322c <put_mtd_device+0x28>
34813224:	eaffd95c 	b	3480979c <printf>
34813228:	34825f67 	.word	0x34825f67
3481322c:	34825f71 	.word	0x34825f71

34813230 <part_read_user_prot_reg>:

static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	return part->master->read_user_prot_reg(part->master, from,
34813230:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813234:	e5901060 	ldr	r1, [r0, #96]	; 0x60
34813238:	e12fff11 	bx	r1

3481323c <part_get_user_prot_info>:

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
3481323c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813240:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
34813244:	e12fff13 	bx	r3

34813248 <part_read_fact_prot_reg>:

static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	return part->master->read_fact_prot_reg(part->master, from,
34813248:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
3481324c:	e5901058 	ldr	r1, [r0, #88]	; 0x58
34813250:	e12fff11 	bx	r1

34813254 <part_get_fact_prot_info>:

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34813254:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813258:	e5903054 	ldr	r3, [r0, #84]	; 0x54
3481325c:	e12fff13 	bx	r3

34813260 <part_write>:

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813260:	e590c004 	ldr	ip, [r0, #4]
{
34813264:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34813268:	e59d1018 	ldr	r1, [sp, #24]
	if (!(mtd->flags & MTD_WRITEABLE))
3481326c:	e31c0b01 	tst	ip, #1024	; 0x400
{
34813270:	e59de01c 	ldr	lr, [sp, #28]
34813274:	e59d9020 	ldr	r9, [sp, #32]
	if (!(mtd->flags & MTD_WRITEABLE))
34813278:	0a000014 	beq	348132d0 <part_write+0x70>
		return -EROFS;
	if (to >= mtd->size)
3481327c:	e1c040d8 	ldrd	r4, [r0, #8]
34813280:	e1530005 	cmp	r3, r5
34813284:	01520004 	cmpeq	r2, r4
		len = 0;
34813288:	23a01000 	movcs	r1, #0
	if (to >= mtd->size)
3481328c:	2a000004 	bcs	348132a4 <part_write+0x44>
	else if (to + len > mtd->size)
34813290:	e0926001 	adds	r6, r2, r1
34813294:	e2a37000 	adc	r7, r3, #0
34813298:	e1570005 	cmp	r7, r5
3481329c:	01560004 	cmpeq	r6, r4
		len = mtd->size - to;
348132a0:	80621004 	rsbhi	r1, r2, r4
	return part->master->write(part->master, to + part->offset,
348132a4:	e1c04bd0 	ldrd	r4, [r0, #176]	; 0xb0
348132a8:	e590c0a8 	ldr	ip, [r0, #168]	; 0xa8
348132ac:	e58d9020 	str	r9, [sp, #32]
348132b0:	e0922004 	adds	r2, r2, r4
348132b4:	e58de01c 	str	lr, [sp, #28]
348132b8:	e58d1018 	str	r1, [sp, #24]
348132bc:	e0a33005 	adc	r3, r3, r5
348132c0:	e59c1044 	ldr	r1, [ip, #68]	; 0x44
348132c4:	e1a0000c 	mov	r0, ip
				    len, retlen, buf);
}
348132c8:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	return part->master->write(part->master, to + part->offset,
348132cc:	e12fff11 	bx	r1
}
348132d0:	e3e0001d 	mvn	r0, #29
348132d4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

348132d8 <part_panic_write>:

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348132d8:	e590c004 	ldr	ip, [r0, #4]
{
348132dc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
348132e0:	e59d1018 	ldr	r1, [sp, #24]
	if (!(mtd->flags & MTD_WRITEABLE))
348132e4:	e31c0b01 	tst	ip, #1024	; 0x400
{
348132e8:	e59de01c 	ldr	lr, [sp, #28]
348132ec:	e59d9020 	ldr	r9, [sp, #32]
	if (!(mtd->flags & MTD_WRITEABLE))
348132f0:	0a000014 	beq	34813348 <part_panic_write+0x70>
		return -EROFS;
	if (to >= mtd->size)
348132f4:	e1c040d8 	ldrd	r4, [r0, #8]
348132f8:	e1530005 	cmp	r3, r5
348132fc:	01520004 	cmpeq	r2, r4
		len = 0;
34813300:	23a01000 	movcs	r1, #0
	if (to >= mtd->size)
34813304:	2a000004 	bcs	3481331c <part_panic_write+0x44>
	else if (to + len > mtd->size)
34813308:	e0926001 	adds	r6, r2, r1
3481330c:	e2a37000 	adc	r7, r3, #0
34813310:	e1570005 	cmp	r7, r5
34813314:	01560004 	cmpeq	r6, r4
		len = mtd->size - to;
34813318:	80621004 	rsbhi	r1, r2, r4
	return part->master->panic_write(part->master, to + part->offset,
3481331c:	e1c04bd0 	ldrd	r4, [r0, #176]	; 0xb0
34813320:	e590c0a8 	ldr	ip, [r0, #168]	; 0xa8
34813324:	e58d9020 	str	r9, [sp, #32]
34813328:	e0922004 	adds	r2, r2, r4
3481332c:	e58de01c 	str	lr, [sp, #28]
34813330:	e58d1018 	str	r1, [sp, #24]
34813334:	e0a33005 	adc	r3, r3, r5
34813338:	e59c1048 	ldr	r1, [ip, #72]	; 0x48
3481333c:	e1a0000c 	mov	r0, ip
				    len, retlen, buf);
}
34813340:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	return part->master->panic_write(part->master, to + part->offset,
34813344:	e12fff11 	bx	r1
}
34813348:	e3e0001d 	mvn	r0, #29
3481334c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

34813350 <part_write_oob>:

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813350:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813354:	e5900004 	ldr	r0, [r0, #4]
{
34813358:	e92d00f0 	push	{r4, r5, r6, r7}
3481335c:	e59dc010 	ldr	ip, [sp, #16]
	if (!(mtd->flags & MTD_WRITEABLE))
34813360:	e3100b01 	tst	r0, #1024	; 0x400
34813364:	0a000014 	beq	348133bc <part_write_oob+0x6c>
		return -EROFS;

	if (to >= mtd->size)
34813368:	e1c140d8 	ldrd	r4, [r1, #8]
3481336c:	e1530005 	cmp	r3, r5
34813370:	01520004 	cmpeq	r2, r4
34813374:	2a000012 	bcs	348133c4 <part_write_oob+0x74>
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
34813378:	e59c0018 	ldr	r0, [ip, #24]
3481337c:	e3500000 	cmp	r0, #0
34813380:	0a000005 	beq	3481339c <part_write_oob+0x4c>
34813384:	e59c0004 	ldr	r0, [ip, #4]
34813388:	e0926000 	adds	r6, r2, r0
3481338c:	e2a37000 	adc	r7, r3, #0
34813390:	e1570005 	cmp	r7, r5
34813394:	01560004 	cmpeq	r6, r4
34813398:	8a000009 	bhi	348133c4 <part_write_oob+0x74>
		return -EINVAL;
	return part->master->write_oob(part->master, to + part->offset, ops);
3481339c:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348133a0:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
348133a4:	e58dc010 	str	ip, [sp, #16]
348133a8:	e0922004 	adds	r2, r2, r4
348133ac:	e0a33005 	adc	r3, r3, r5
348133b0:	e5901050 	ldr	r1, [r0, #80]	; 0x50
}
348133b4:	e8bd00f0 	pop	{r4, r5, r6, r7}
	return part->master->write_oob(part->master, to + part->offset, ops);
348133b8:	e12fff11 	bx	r1
		return -EROFS;
348133bc:	e3e0001d 	mvn	r0, #29
348133c0:	ea000000 	b	348133c8 <part_write_oob+0x78>
		return -EINVAL;
348133c4:	e3e00015 	mvn	r0, #21
}
348133c8:	e8bd00f0 	pop	{r4, r5, r6, r7}
348133cc:	e12fff1e 	bx	lr

348133d0 <part_write_user_prot_reg>:

static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	return part->master->write_user_prot_reg(part->master, from,
348133d0:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348133d4:	e5901064 	ldr	r1, [r0, #100]	; 0x64
348133d8:	e12fff11 	bx	r1

348133dc <part_lock_user_prot_reg>:

static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
348133dc:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348133e0:	e5901068 	ldr	r1, [r0, #104]	; 0x68
348133e4:	e12fff11 	bx	r1

348133e8 <part_erase>:

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
348133e8:	e5903004 	ldr	r3, [r0, #4]
348133ec:	e3130b01 	tst	r3, #1024	; 0x400
348133f0:	0a00001f 	beq	34813474 <part_erase+0x8c>
{
348133f4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
348133f8:	e1a04001 	mov	r4, r1
		return -EROFS;
	if (instr->addr >= mtd->size)
348133fc:	e1c160d8 	ldrd	r6, [r1, #8]
34813400:	e1c020d8 	ldrd	r2, [r0, #8]
34813404:	e1570003 	cmp	r7, r3
34813408:	01560002 	cmpeq	r6, r2
3481340c:	2a00001a 	bcs	3481347c <part_erase+0x94>
		return -EINVAL;
	instr->addr += part->offset;
34813410:	e1c02bd0 	ldrd	r2, [r0, #176]	; 0xb0
34813414:	e1a05000 	mov	r5, r0
	ret = part->master->erase(part->master, instr);
34813418:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
	instr->addr += part->offset;
3481341c:	e0922006 	adds	r2, r2, r6
34813420:	e0a33007 	adc	r3, r3, r7
34813424:	e1c120f8 	strd	r2, [r1, #8]
	ret = part->master->erase(part->master, instr);
34813428:	e5903034 	ldr	r3, [r0, #52]	; 0x34
3481342c:	e12fff33 	blx	r3
	if (ret) {
34813430:	e3500000 	cmp	r0, #0
34813434:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
34813438:	e1c421d8 	ldrd	r2, [r4, #24]
3481343c:	e3e07000 	mvn	r7, #0
34813440:	e3e06000 	mvn	r6, #0
34813444:	e1530007 	cmp	r3, r7
34813448:	01520006 	cmpeq	r2, r6
3481344c:	e1c56bd0 	ldrd	r6, [r5, #176]	; 0xb0
34813450:	0a000002 	beq	34813460 <part_erase+0x78>
			instr->fail_addr -= part->offset;
34813454:	e0522006 	subs	r2, r2, r6
34813458:	e0c33007 	sbc	r3, r3, r7
3481345c:	e1c421f8 	strd	r2, [r4, #24]
		instr->addr -= part->offset;
34813460:	e1c420d8 	ldrd	r2, [r4, #8]
34813464:	e0522006 	subs	r2, r2, r6
34813468:	e0c33007 	sbc	r3, r3, r7
3481346c:	e1c420f8 	strd	r2, [r4, #8]
34813470:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return -EROFS;
34813474:	e3e0001d 	mvn	r0, #29
	}
	return ret;
}
34813478:	e12fff1e 	bx	lr
		return -EINVAL;
3481347c:	e3e00015 	mvn	r0, #21
}
34813480:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

34813484 <part_lock>:
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813484:	e92d0cf0 	push	{r4, r5, r6, r7, sl, fp}
34813488:	e1a01000 	mov	r1, r0
3481348c:	e1cd61d8 	ldrd	r6, [sp, #24]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813490:	e1c040d8 	ldrd	r4, [r0, #8]
34813494:	e092a006 	adds	sl, r2, r6
34813498:	e0a3b007 	adc	fp, r3, r7
3481349c:	e15b0005 	cmp	fp, r5
348134a0:	015a0004 	cmpeq	sl, r4
348134a4:	8a000006 	bhi	348134c4 <part_lock+0x40>
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
348134a8:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348134ac:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348134b0:	e0922004 	adds	r2, r2, r4
348134b4:	e0a33005 	adc	r3, r3, r5
348134b8:	e5901070 	ldr	r1, [r0, #112]	; 0x70
}
348134bc:	e8bd0cf0 	pop	{r4, r5, r6, r7, sl, fp}
	return part->master->lock(part->master, ofs + part->offset, len);
348134c0:	e12fff11 	bx	r1
}
348134c4:	e3e00015 	mvn	r0, #21
348134c8:	e8bd0cf0 	pop	{r4, r5, r6, r7, sl, fp}
348134cc:	e12fff1e 	bx	lr

348134d0 <part_unlock>:

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
348134d0:	e92d0cf0 	push	{r4, r5, r6, r7, sl, fp}
348134d4:	e1a01000 	mov	r1, r0
348134d8:	e1cd61d8 	ldrd	r6, [sp, #24]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
348134dc:	e1c040d8 	ldrd	r4, [r0, #8]
348134e0:	e092a006 	adds	sl, r2, r6
348134e4:	e0a3b007 	adc	fp, r3, r7
348134e8:	e15b0005 	cmp	fp, r5
348134ec:	015a0004 	cmpeq	sl, r4
348134f0:	8a000006 	bhi	34813510 <part_unlock+0x40>
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
348134f4:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348134f8:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348134fc:	e0922004 	adds	r2, r2, r4
34813500:	e0a33005 	adc	r3, r3, r5
34813504:	e5901074 	ldr	r1, [r0, #116]	; 0x74
}
34813508:	e8bd0cf0 	pop	{r4, r5, r6, r7, sl, fp}
	return part->master->unlock(part->master, ofs + part->offset, len);
3481350c:	e12fff11 	bx	r1
}
34813510:	e3e00015 	mvn	r0, #21
34813514:	e8bd0cf0 	pop	{r4, r5, r6, r7, sl, fp}
34813518:	e12fff1e 	bx	lr

3481351c <part_sync>:

static void part_sync(struct mtd_info *mtd)
{
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
3481351c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813520:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
34813524:	e12fff13 	bx	r3

34813528 <part_block_isbad>:
}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813528:	e92d0030 	push	{r4, r5}
3481352c:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813530:	e1c040d8 	ldrd	r4, [r0, #8]
34813534:	e1530005 	cmp	r3, r5
34813538:	01520004 	cmpeq	r2, r4
3481353c:	2a000006 	bcs	3481355c <part_block_isbad+0x34>
		return -EINVAL;
	ofs += part->offset;
34813540:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
	return part->master->block_isbad(part->master, ofs);
34813544:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813548:	e0922004 	adds	r2, r2, r4
3481354c:	e0a33005 	adc	r3, r3, r5
34813550:	e5901078 	ldr	r1, [r0, #120]	; 0x78
}
34813554:	e8bd0030 	pop	{r4, r5}
	return part->master->block_isbad(part->master, ofs);
34813558:	e12fff11 	bx	r1
}
3481355c:	e3e00015 	mvn	r0, #21
34813560:	e8bd0030 	pop	{r4, r5}
34813564:	e12fff1e 	bx	lr

34813568 <part_block_markbad>:
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813568:	e5901004 	ldr	r1, [r0, #4]
3481356c:	e3110b01 	tst	r1, #1024	; 0x400
34813570:	0a000010 	beq	348135b8 <part_block_markbad+0x50>
{
34813574:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
		return -EROFS;
	if (ofs >= mtd->size)
34813578:	e1c040d8 	ldrd	r4, [r0, #8]
3481357c:	e1530005 	cmp	r3, r5
34813580:	01520004 	cmpeq	r2, r4
34813584:	2a00000d 	bcs	348135c0 <part_block_markbad+0x58>
34813588:	e1a04000 	mov	r4, r0
		return -EINVAL;
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
3481358c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
	ofs += part->offset;
34813590:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
	res = part->master->block_markbad(part->master, ofs);
34813594:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34813598:	e0922006 	adds	r2, r2, r6
3481359c:	e0a33007 	adc	r3, r3, r7
348135a0:	e12fff31 	blx	r1
	if (!res)
348135a4:	e3500000 	cmp	r0, #0
		mtd->ecc_stats.badblocks++;
348135a8:	05943088 	ldreq	r3, [r4, #136]	; 0x88
348135ac:	02833001 	addeq	r3, r3, #1
348135b0:	05843088 	streq	r3, [r4, #136]	; 0x88
348135b4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return -EROFS;
348135b8:	e3e0001d 	mvn	r0, #29
	return res;
}
348135bc:	e12fff1e 	bx	lr
		return -EINVAL;
348135c0:	e3e00015 	mvn	r0, #21
}
348135c4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

348135c8 <part_read_oob>:
{
348135c8:	e92d4cd3 	push	{r0, r1, r4, r6, r7, sl, fp, lr}
	if (from >= mtd->size)
348135cc:	e1c060d8 	ldrd	r6, [r0, #8]
{
348135d0:	e59d1020 	ldr	r1, [sp, #32]
	if (from >= mtd->size)
348135d4:	e1530007 	cmp	r3, r7
348135d8:	01520006 	cmpeq	r2, r6
348135dc:	2a00001c 	bcs	34813654 <part_read_oob+0x8c>
	if (ops->datbuf && from + ops->len > mtd->size)
348135e0:	e591c018 	ldr	ip, [r1, #24]
348135e4:	e35c0000 	cmp	ip, #0
348135e8:	0a000005 	beq	34813604 <part_read_oob+0x3c>
348135ec:	e591c004 	ldr	ip, [r1, #4]
348135f0:	e092a00c 	adds	sl, r2, ip
348135f4:	e2a3b000 	adc	fp, r3, #0
348135f8:	e15b0007 	cmp	fp, r7
348135fc:	015a0006 	cmpeq	sl, r6
34813600:	8a000013 	bhi	34813654 <part_read_oob+0x8c>
34813604:	e1a04000 	mov	r4, r0
	res = part->master->read_oob(part->master, from + part->offset, ops);
34813608:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
3481360c:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
34813610:	e58d1000 	str	r1, [sp]
34813614:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34813618:	e0922006 	adds	r2, r2, r6
3481361c:	e0a33007 	adc	r3, r3, r7
34813620:	e12fff31 	blx	r1
	if (unlikely(res)) {
34813624:	e3500000 	cmp	r0, #0
34813628:	0a00000a 	beq	34813658 <part_read_oob+0x90>
		if (res == -EUCLEAN)
3481362c:	e3700075 	cmn	r0, #117	; 0x75
			mtd->ecc_stats.corrected++;
34813630:	05943080 	ldreq	r3, [r4, #128]	; 0x80
34813634:	02833001 	addeq	r3, r3, #1
34813638:	05843080 	streq	r3, [r4, #128]	; 0x80
		if (res == -EUCLEAN)
3481363c:	0a000005 	beq	34813658 <part_read_oob+0x90>
		if (res == -EBADMSG)
34813640:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed++;
34813644:	05943084 	ldreq	r3, [r4, #132]	; 0x84
34813648:	02833001 	addeq	r3, r3, #1
3481364c:	05843084 	streq	r3, [r4, #132]	; 0x84
34813650:	ea000000 	b	34813658 <part_read_oob+0x90>
		return -EINVAL;
34813654:	e3e00015 	mvn	r0, #21
}
34813658:	e28dd008 	add	sp, sp, #8
3481365c:	e8bd8cd0 	pop	{r4, r6, r7, sl, fp, pc}

34813660 <part_read>:
{
34813660:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34813664:	e1a04000 	mov	r4, r0
	if (from >= mtd->size)
34813668:	e1c460d8 	ldrd	r6, [r4, #8]
	stats = part->master->ecc_stats;
3481366c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
	if (from >= mtd->size)
34813670:	e1530007 	cmp	r3, r7
{
34813674:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
	if (from >= mtd->size)
34813678:	01520006 	cmpeq	r2, r6
	stats = part->master->ecc_stats;
3481367c:	e5905080 	ldr	r5, [r0, #128]	; 0x80
		len = 0;
34813680:	23a01000 	movcs	r1, #0
	stats = part->master->ecc_stats;
34813684:	e5909084 	ldr	r9, [r0, #132]	; 0x84
	if (from >= mtd->size)
34813688:	2a000004 	bcs	348136a0 <part_read+0x40>
	else if (from + len > mtd->size)
3481368c:	e092a001 	adds	sl, r2, r1
34813690:	e2a3b000 	adc	fp, r3, #0
34813694:	e15b0007 	cmp	fp, r7
34813698:	015a0006 	cmpeq	sl, r6
		len = mtd->size - from;
3481369c:	80621006 	rsbhi	r1, r2, r6
	res = part->master->read(part->master, from + part->offset,
348136a0:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
348136a4:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
348136a8:	e58dc008 	str	ip, [sp, #8]
348136ac:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
348136b0:	e0922006 	adds	r2, r2, r6
348136b4:	e0a33007 	adc	r3, r3, r7
348136b8:	e88d1002 	stm	sp, {r1, ip}
348136bc:	e5901040 	ldr	r1, [r0, #64]	; 0x40
348136c0:	e12fff31 	blx	r1
	if (unlikely(res)) {
348136c4:	e3500000 	cmp	r0, #0
348136c8:	0a00000f 	beq	3481370c <part_read+0xac>
		if (res == -EUCLEAN)
348136cc:	e3700075 	cmn	r0, #117	; 0x75
348136d0:	1a000006 	bne	348136f0 <part_read+0x90>
			mtd->ecc_stats.corrected += part->master->ecc_stats.corrected - stats.corrected;
348136d4:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
348136d8:	e5942080 	ldr	r2, [r4, #128]	; 0x80
348136dc:	e5933080 	ldr	r3, [r3, #128]	; 0x80
348136e0:	e0833002 	add	r3, r3, r2
348136e4:	e0655003 	rsb	r5, r5, r3
348136e8:	e5845080 	str	r5, [r4, #128]	; 0x80
348136ec:	ea000006 	b	3481370c <part_read+0xac>
		if (res == -EBADMSG)
348136f0:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed += part->master->ecc_stats.failed - stats.failed;
348136f4:	059430a8 	ldreq	r3, [r4, #168]	; 0xa8
348136f8:	05942084 	ldreq	r2, [r4, #132]	; 0x84
348136fc:	05933084 	ldreq	r3, [r3, #132]	; 0x84
34813700:	00833002 	addeq	r3, r3, r2
34813704:	00699003 	rsbeq	r9, r9, r3
34813708:	05849084 	streq	r9, [r4, #132]	; 0x84
}
3481370c:	e28dd010 	add	sp, sp, #16
34813710:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

34813714 <mtd_erase_callback>:
	if (instr->mtd->erase == part_erase) {
34813714:	e5901000 	ldr	r1, [r0]
34813718:	e59f3060 	ldr	r3, [pc, #96]	; 34813780 <mtd_erase_callback+0x6c>
{
3481371c:	e92d0030 	push	{r4, r5}
	if (instr->mtd->erase == part_erase) {
34813720:	e5912034 	ldr	r2, [r1, #52]	; 0x34
34813724:	e1520003 	cmp	r2, r3
34813728:	1a00000d 	bne	34813764 <mtd_erase_callback+0x50>
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
3481372c:	e1c021d8 	ldrd	r2, [r0, #24]
34813730:	e3e05000 	mvn	r5, #0
34813734:	e3e04000 	mvn	r4, #0
34813738:	e1530005 	cmp	r3, r5
3481373c:	01520004 	cmpeq	r2, r4
34813740:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813744:	0a000002 	beq	34813754 <mtd_erase_callback+0x40>
			instr->fail_addr -= part->offset;
34813748:	e0522004 	subs	r2, r2, r4
3481374c:	e0c33005 	sbc	r3, r3, r5
34813750:	e1c021f8 	strd	r2, [r0, #24]
		instr->addr -= part->offset;
34813754:	e1c020d8 	ldrd	r2, [r0, #8]
34813758:	e0522004 	subs	r2, r2, r4
3481375c:	e0c33005 	sbc	r3, r3, r5
34813760:	e1c020f8 	strd	r2, [r0, #8]
	if (instr->callback)
34813764:	e5903030 	ldr	r3, [r0, #48]	; 0x30
34813768:	e3530000 	cmp	r3, #0
3481376c:	0a000001 	beq	34813778 <mtd_erase_callback+0x64>
}
34813770:	e8bd0030 	pop	{r4, r5}
		instr->callback(instr);
34813774:	e12fff13 	bx	r3
}
34813778:	e8bd0030 	pop	{r4, r5}
3481377c:	e12fff1e 	bx	lr
34813780:	348133e8 	.word	0x348133e8

34813784 <del_mtd_partitions>:

int del_mtd_partitions(struct mtd_info *master)
{
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813784:	e59f3080 	ldr	r3, [pc, #128]	; 3481380c <del_mtd_partitions+0x88>
{
34813788:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3481378c:	e1a07000 	mov	r7, r0
	entry->next = LIST_POISON1;
34813790:	e3a09000 	mov	r9, #0
34813794:	e1a06003 	mov	r6, r3
	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813798:	e5932000 	ldr	r2, [r3]
3481379c:	e5925000 	ldr	r5, [r2]
348137a0:	e24240bc 	sub	r4, r2, #188	; 0xbc
348137a4:	e24550bc 	sub	r5, r5, #188	; 0xbc
348137a8:	e28430bc 	add	r3, r4, #188	; 0xbc
348137ac:	e1560003 	cmp	r6, r3
348137b0:	0a000013 	beq	34813804 <del_mtd_partitions+0x80>
		if (slave->master == master) {
348137b4:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
348137b8:	e1530007 	cmp	r3, r7
348137bc:	1a00000c 	bne	348137f4 <del_mtd_partitions+0x70>
	__list_del(entry->prev, entry->next);
348137c0:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
348137c4:	e59420bc 	ldr	r2, [r4, #188]	; 0xbc
	next->prev = prev;
348137c8:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348137cc:	e5832000 	str	r2, [r3]
			list_del(&slave->list);
			if (slave->registered)
348137d0:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
	entry->next = LIST_POISON1;
348137d4:	e58490bc 	str	r9, [r4, #188]	; 0xbc
	entry->prev = LIST_POISON2;
348137d8:	e58490c0 	str	r9, [r4, #192]	; 0xc0
348137dc:	e3530000 	cmp	r3, #0
348137e0:	0a000001 	beq	348137ec <del_mtd_partitions+0x68>
				del_mtd_device(&slave->mtd);
348137e4:	e1a00004 	mov	r0, r4
348137e8:	ebfffe38 	bl	348130d0 <del_mtd_device>
			kfree(slave);
348137ec:	e1a00004 	mov	r0, r4
348137f0:	ebffd92e 	bl	34809cb0 <free>
	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
348137f4:	e59530bc 	ldr	r3, [r5, #188]	; 0xbc
348137f8:	e1a04005 	mov	r4, r5
348137fc:	e24350bc 	sub	r5, r3, #188	; 0xbc
34813800:	eaffffe8 	b	348137a8 <del_mtd_partitions+0x24>
		}

	return 0;
}
34813804:	e3a00000 	mov	r0, #0
34813808:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3481380c:	3482a790 	.word	0x3482a790

34813810 <add_mtd_partitions>:
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34813810:	e59f3608 	ldr	r3, [pc, #1544]	; 34813e20 <add_mtd_partitions+0x610>
{
34813814:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34813818:	e24dd058 	sub	sp, sp, #88	; 0x58
3481381c:	e58d2024 	str	r2, [sp, #36]	; 0x24
34813820:	e1a06001 	mov	r6, r1
34813824:	e1a05000 	mov	r5, r0
34813828:	e2866020 	add	r6, r6, #32
	if (mtd_partitions.next == NULL)
3481382c:	e5932000 	ldr	r2, [r3]
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34813830:	e3a07000 	mov	r7, #0
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
34813834:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
	if (mtd_partitions.next == NULL)
34813838:	e3520000 	cmp	r2, #0
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
3481383c:	e5902020 	ldr	r2, [r0, #32]
34813840:	e59f05dc 	ldr	r0, [pc, #1500]	; 34813e24 <add_mtd_partitions+0x614>
	list->next = list;
34813844:	05833000 	streq	r3, [r3]
	list->prev = list;
34813848:	05833004 	streq	r3, [r3, #4]
3481384c:	ebffd7d2 	bl	3480979c <printf>
	uint64_t cur_offset = 0;
34813850:	e3a02000 	mov	r2, #0
34813854:	e3a03000 	mov	r3, #0
34813858:	e1a0a002 	mov	sl, r2
3481385c:	e1a0b003 	mov	fp, r3
	for (i = 0; i < nbparts; i++) {
34813860:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34813864:	e1570003 	cmp	r7, r3
34813868:	aa000161 	bge	34813df4 <add_mtd_partitions+0x5e4>
	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
3481386c:	e3a01001 	mov	r1, #1
34813870:	e3a000c8 	mov	r0, #200	; 0xc8
34813874:	ebffdb0d 	bl	3480a4b0 <calloc>
	if (!slave) {
34813878:	e2504000 	subs	r4, r0, #0
3481387c:	1a000006 	bne	3481389c <add_mtd_partitions+0x8c>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
34813880:	e5951020 	ldr	r1, [r5, #32]
34813884:	e59f059c 	ldr	r0, [pc, #1436]	; 34813e28 <add_mtd_partitions+0x618>
34813888:	ebffd7c3 	bl	3480979c <printf>
		del_mtd_partitions(master);
3481388c:	e1a00005 	mov	r0, r5
34813890:	ebffffbb 	bl	34813784 <del_mtd_partitions>
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
34813894:	e3e0000b 	mvn	r0, #11
34813898:	ea00015e 	b	34813e18 <add_mtd_partitions+0x608>
	__list_add(new, head, head->next);
3481389c:	e59f257c 	ldr	r2, [pc, #1404]	; 34813e20 <add_mtd_partitions+0x610>
	list_add(&slave->list, &mtd_partitions);
348138a0:	e28430bc 	add	r3, r4, #188	; 0xbc
	if (slave->offset == MTDPART_OFS_APPEND)
348138a4:	e3e01000 	mvn	r1, #0
348138a8:	e3e00000 	mvn	r0, #0
348138ac:	e5922000 	ldr	r2, [r2]
	next->prev = new;
348138b0:	e5823004 	str	r3, [r2, #4]
	new->next = next;
348138b4:	e58420bc 	str	r2, [r4, #188]	; 0xbc
	new->prev = prev;
348138b8:	e59f2560 	ldr	r2, [pc, #1376]	; 34813e20 <add_mtd_partitions+0x610>
	prev->next = new;
348138bc:	e5823000 	str	r3, [r2]
	new->prev = prev;
348138c0:	e58420c0 	str	r2, [r4, #192]	; 0xc0
	slave->mtd.type = master->type;
348138c4:	e5d53000 	ldrb	r3, [r5]
348138c8:	e5c43000 	strb	r3, [r4]
	slave->mtd.flags = master->flags & ~part->mask_flags;
348138cc:	e5953004 	ldr	r3, [r5, #4]
348138d0:	e5162008 	ldr	r2, [r6, #-8]
348138d4:	e1c33002 	bic	r3, r3, r2
348138d8:	e5843004 	str	r3, [r4, #4]
	slave->mtd.size = part->size;
348138dc:	e14621d8 	ldrd	r2, [r6, #-24]	; 0xffffffe8
348138e0:	e1c420f8 	strd	r2, [r4, #8]
	slave->mtd.writesize = master->writesize;
348138e4:	e5953014 	ldr	r3, [r5, #20]
348138e8:	e5843014 	str	r3, [r4, #20]
	slave->mtd.oobsize = master->oobsize;
348138ec:	e5953018 	ldr	r3, [r5, #24]
348138f0:	e5843018 	str	r3, [r4, #24]
	slave->mtd.oobavail = master->oobavail;
348138f4:	e595301c 	ldr	r3, [r5, #28]
348138f8:	e584301c 	str	r3, [r4, #28]
	slave->mtd.subpage_sft = master->subpage_sft;
348138fc:	e5953090 	ldr	r3, [r5, #144]	; 0x90
34813900:	e5843090 	str	r3, [r4, #144]	; 0x90
	slave->mtd.name = part->name;
34813904:	e5163020 	ldr	r3, [r6, #-32]	; 0xffffffe0
34813908:	e5843020 	str	r3, [r4, #32]
	slave->mtd.owner = master->owner;
3481390c:	e5953098 	ldr	r3, [r5, #152]	; 0x98
34813910:	e5843098 	str	r3, [r4, #152]	; 0x98
	slave->mtd.read = part_read;
34813914:	e59f3510 	ldr	r3, [pc, #1296]	; 34813e2c <add_mtd_partitions+0x61c>
34813918:	e5843040 	str	r3, [r4, #64]	; 0x40
	slave->mtd.write = part_write;
3481391c:	e59f350c 	ldr	r3, [pc, #1292]	; 34813e30 <add_mtd_partitions+0x620>
34813920:	e5843044 	str	r3, [r4, #68]	; 0x44
	if (master->panic_write)
34813924:	e5953048 	ldr	r3, [r5, #72]	; 0x48
34813928:	e3530000 	cmp	r3, #0
		slave->mtd.panic_write = part_panic_write;
3481392c:	159f3500 	ldrne	r3, [pc, #1280]	; 34813e34 <add_mtd_partitions+0x624>
34813930:	15843048 	strne	r3, [r4, #72]	; 0x48
	if (master->read_oob)
34813934:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
34813938:	e3530000 	cmp	r3, #0
		slave->mtd.read_oob = part_read_oob;
3481393c:	159f34f4 	ldrne	r3, [pc, #1268]	; 34813e38 <add_mtd_partitions+0x628>
34813940:	1584304c 	strne	r3, [r4, #76]	; 0x4c
	if (master->write_oob)
34813944:	e5953050 	ldr	r3, [r5, #80]	; 0x50
34813948:	e3530000 	cmp	r3, #0
		slave->mtd.write_oob = part_write_oob;
3481394c:	159f34e8 	ldrne	r3, [pc, #1256]	; 34813e3c <add_mtd_partitions+0x62c>
34813950:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (master->read_user_prot_reg)
34813954:	e5953060 	ldr	r3, [r5, #96]	; 0x60
34813958:	e3530000 	cmp	r3, #0
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
3481395c:	159f34dc 	ldrne	r3, [pc, #1244]	; 34813e40 <add_mtd_partitions+0x630>
34813960:	15843060 	strne	r3, [r4, #96]	; 0x60
	if (master->read_fact_prot_reg)
34813964:	e5953058 	ldr	r3, [r5, #88]	; 0x58
34813968:	e3530000 	cmp	r3, #0
		slave->mtd.read_fact_prot_reg = part_read_fact_prot_reg;
3481396c:	159f34d0 	ldrne	r3, [pc, #1232]	; 34813e44 <add_mtd_partitions+0x634>
34813970:	15843058 	strne	r3, [r4, #88]	; 0x58
	if (master->write_user_prot_reg)
34813974:	e5953064 	ldr	r3, [r5, #100]	; 0x64
34813978:	e3530000 	cmp	r3, #0
		slave->mtd.write_user_prot_reg = part_write_user_prot_reg;
3481397c:	159f34c4 	ldrne	r3, [pc, #1220]	; 34813e48 <add_mtd_partitions+0x638>
34813980:	15843064 	strne	r3, [r4, #100]	; 0x64
	if (master->lock_user_prot_reg)
34813984:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34813988:	e3530000 	cmp	r3, #0
		slave->mtd.lock_user_prot_reg = part_lock_user_prot_reg;
3481398c:	159f34b8 	ldrne	r3, [pc, #1208]	; 34813e4c <add_mtd_partitions+0x63c>
34813990:	15843068 	strne	r3, [r4, #104]	; 0x68
	if (master->get_user_prot_info)
34813994:	e595305c 	ldr	r3, [r5, #92]	; 0x5c
34813998:	e3530000 	cmp	r3, #0
		slave->mtd.get_user_prot_info = part_get_user_prot_info;
3481399c:	159f34ac 	ldrne	r3, [pc, #1196]	; 34813e50 <add_mtd_partitions+0x640>
348139a0:	1584305c 	strne	r3, [r4, #92]	; 0x5c
	if (master->get_fact_prot_info)
348139a4:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348139a8:	e3530000 	cmp	r3, #0
		slave->mtd.get_fact_prot_info = part_get_fact_prot_info;
348139ac:	159f34a0 	ldrne	r3, [pc, #1184]	; 34813e54 <add_mtd_partitions+0x644>
348139b0:	15843054 	strne	r3, [r4, #84]	; 0x54
	if (master->sync)
348139b4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348139b8:	e3530000 	cmp	r3, #0
		slave->mtd.sync = part_sync;
348139bc:	159f3494 	ldrne	r3, [pc, #1172]	; 34813e58 <add_mtd_partitions+0x648>
348139c0:	1584306c 	strne	r3, [r4, #108]	; 0x6c
	if (master->lock)
348139c4:	e5953070 	ldr	r3, [r5, #112]	; 0x70
348139c8:	e3530000 	cmp	r3, #0
		slave->mtd.lock = part_lock;
348139cc:	159f3488 	ldrne	r3, [pc, #1160]	; 34813e5c <add_mtd_partitions+0x64c>
348139d0:	15843070 	strne	r3, [r4, #112]	; 0x70
	if (master->unlock)
348139d4:	e5953074 	ldr	r3, [r5, #116]	; 0x74
348139d8:	e3530000 	cmp	r3, #0
		slave->mtd.unlock = part_unlock;
348139dc:	159f347c 	ldrne	r3, [pc, #1148]	; 34813e60 <add_mtd_partitions+0x650>
348139e0:	15843074 	strne	r3, [r4, #116]	; 0x74
	if (master->block_isbad)
348139e4:	e5953078 	ldr	r3, [r5, #120]	; 0x78
348139e8:	e3530000 	cmp	r3, #0
		slave->mtd.block_isbad = part_block_isbad;
348139ec:	159f3470 	ldrne	r3, [pc, #1136]	; 34813e64 <add_mtd_partitions+0x654>
348139f0:	15843078 	strne	r3, [r4, #120]	; 0x78
	if (master->block_markbad)
348139f4:	e595307c 	ldr	r3, [r5, #124]	; 0x7c
	slave->master = master;
348139f8:	e58450a8 	str	r5, [r4, #168]	; 0xa8
	if (master->block_markbad)
348139fc:	e3530000 	cmp	r3, #0
		slave->mtd.block_markbad = part_block_markbad;
34813a00:	159f3460 	ldrne	r3, [pc, #1120]	; 34813e68 <add_mtd_partitions+0x658>
34813a04:	1584307c 	strne	r3, [r4, #124]	; 0x7c
	slave->mtd.erase = part_erase;
34813a08:	e59f345c 	ldr	r3, [pc, #1116]	; 34813e6c <add_mtd_partitions+0x65c>
34813a0c:	e5843034 	str	r3, [r4, #52]	; 0x34
	slave->offset = part->offset;
34813a10:	e14621d0 	ldrd	r2, [r6, #-16]
	slave->index = partno;
34813a14:	e58470b8 	str	r7, [r4, #184]	; 0xb8
	if (slave->offset == MTDPART_OFS_APPEND)
34813a18:	e1530001 	cmp	r3, r1
	slave->offset = part->offset;
34813a1c:	e1c42bf0 	strd	r2, [r4, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_APPEND)
34813a20:	01520000 	cmpeq	r2, r0
		slave->offset = cur_offset;
34813a24:	01a0200a 	moveq	r2, sl
34813a28:	01a0300b 	moveq	r3, fp
34813a2c:	01c42bf0 	strdeq	r2, [r4, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_NXTBLK) {
34813a30:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0
34813a34:	e3e01000 	mvn	r1, #0
34813a38:	e3e00001 	mvn	r0, #1
34813a3c:	e1530001 	cmp	r3, r1
34813a40:	01520000 	cmpeq	r2, r0
34813a44:	1a000028 	bne	34813aec <add_mtd_partitions+0x2dc>
		slave->offset = cur_offset;
34813a48:	e1a0200a 	mov	r2, sl
34813a4c:	e1a0300b 	mov	r3, fp
34813a50:	e1c42bf0 	strd	r2, [r4, #176]	; 0xb0
34813a54:	e1cd23f8 	strd	r2, [sp, #56]	; 0x38
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34813a58:	e3a03000 	mov	r3, #0
34813a5c:	e58db018 	str	fp, [sp, #24]
34813a60:	e58d301c 	str	r3, [sp, #28]
34813a64:	e1cd21d8 	ldrd	r2, [sp, #24]
34813a68:	e5959010 	ldr	r9, [r5, #16]
34813a6c:	e1923003 	orrs	r3, r2, r3
34813a70:	e1a01009 	mov	r1, r9
34813a74:	1a000004 	bne	34813a8c <add_mtd_partitions+0x27c>
34813a78:	e1a0000a 	mov	r0, sl
34813a7c:	fa002dfe 	blx	3481f27c <__aeabi_uidivmod>
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
34813a80:	e3510000 	cmp	r1, #0
34813a84:	0a000018 	beq	34813aec <add_mtd_partitions+0x2dc>
34813a88:	ea000004 	b	34813aa0 <add_mtd_partitions+0x290>
34813a8c:	e28d0038 	add	r0, sp, #56	; 0x38
34813a90:	eb0019b1 	bl	3481a15c <__div64_32>
34813a94:	e3500000 	cmp	r0, #0
34813a98:	0a000013 	beq	34813aec <add_mtd_partitions+0x2dc>
34813a9c:	ea0000d6 	b	34813dfc <add_mtd_partitions+0x5ec>
	do_div(sz, mtd->erasesize);
34813aa0:	e1a01009 	mov	r1, r9
34813aa4:	e1a0000a 	mov	r0, sl
34813aa8:	fa002d5c 	blx	3481f020 <__udivsi3>
34813aac:	e59d301c 	ldr	r3, [sp, #28]
34813ab0:	e58d0040 	str	r0, [sp, #64]	; 0x40
34813ab4:	e58d3044 	str	r3, [sp, #68]	; 0x44
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34813ab8:	e5953010 	ldr	r3, [r5, #16]
			printk(KERN_NOTICE "Moving partition %d: "
34813abc:	e1a01007 	mov	r1, r7
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34813ac0:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
			printk(KERN_NOTICE "Moving partition %d: "
34813ac4:	e59f03a4 	ldr	r0, [pc, #932]	; 34813e70 <add_mtd_partitions+0x660>
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34813ac8:	e0233392 	mla	r3, r2, r3, r3
34813acc:	e3a02000 	mov	r2, #0
34813ad0:	e58420b4 	str	r2, [r4, #180]	; 0xb4
34813ad4:	e58430b0 	str	r3, [r4, #176]	; 0xb0
			printk(KERN_NOTICE "Moving partition %d: "
34813ad8:	e58d3000 	str	r3, [sp]
34813adc:	e1a0300b 	mov	r3, fp
34813ae0:	e58d2004 	str	r2, [sp, #4]
34813ae4:	e1a0200a 	mov	r2, sl
34813ae8:	ebffd72b 	bl	3480979c <printf>
	if (slave->mtd.size == MTDPART_SIZ_FULL)
34813aec:	e1c420d8 	ldrd	r2, [r4, #8]
34813af0:	e1c40bd0 	ldrd	r0, [r4, #176]	; 0xb0
34813af4:	e1923003 	orrs	r3, r2, r3
34813af8:	1a000005 	bne	34813b14 <add_mtd_partitions+0x304>
		slave->mtd.size = master->size - slave->offset;
34813afc:	e1c520d8 	ldrd	r2, [r5, #8]
34813b00:	e0522000 	subs	r2, r2, r0
34813b04:	e0c33001 	sbc	r3, r3, r1
34813b08:	e1a0a002 	mov	sl, r2
34813b0c:	e1a0b003 	mov	fp, r3
34813b10:	e1c4a0f8 	strd	sl, [r4, #8]
	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
34813b14:	e5943020 	ldr	r3, [r4, #32]
34813b18:	e58d3008 	str	r3, [sp, #8]
34813b1c:	e1c420d8 	ldrd	r2, [r4, #8]
34813b20:	e092a000 	adds	sl, r2, r0
34813b24:	e1a02000 	mov	r2, r0
34813b28:	e0a3b001 	adc	fp, r3, r1
34813b2c:	e59f0340 	ldr	r0, [pc, #832]	; 34813e74 <add_mtd_partitions+0x664>
34813b30:	e1cda0f0 	strd	sl, [sp]
34813b34:	e1a03001 	mov	r3, r1
34813b38:	ebffd717 	bl	3480979c <printf>
	if (slave->offset >= master->size) {
34813b3c:	e1c520d8 	ldrd	r2, [r5, #8]
34813b40:	e1c4abd0 	ldrd	sl, [r4, #176]	; 0xb0
34813b44:	e1cd21f0 	strd	r2, [sp, #16]
34813b48:	e15b0003 	cmp	fp, r3
34813b4c:	015a0002 	cmpeq	sl, r2
34813b50:	3a000007 	bcc	34813b74 <add_mtd_partitions+0x364>
		slave->offset = 0;
34813b54:	e3a02000 	mov	r2, #0
34813b58:	e3a03000 	mov	r3, #0
34813b5c:	e1c42bf0 	strd	r2, [r4, #176]	; 0xb0
		slave->mtd.size = 0;
34813b60:	e1c420f8 	strd	r2, [r4, #8]
		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
34813b64:	e5161020 	ldr	r1, [r6, #-32]	; 0xffffffe0
34813b68:	e59f0308 	ldr	r0, [pc, #776]	; 34813e78 <add_mtd_partitions+0x668>
34813b6c:	ebffd70a 	bl	3480979c <printf>
34813b70:	ea00008d 	b	34813dac <add_mtd_partitions+0x59c>
	if (slave->offset + slave->mtd.size > master->size) {
34813b74:	e1c420d8 	ldrd	r2, [r4, #8]
34813b78:	e092000a 	adds	r0, r2, sl
34813b7c:	e0a3100b 	adc	r1, r3, fp
34813b80:	e1cd21d0 	ldrd	r2, [sp, #16]
34813b84:	e1510003 	cmp	r1, r3
34813b88:	01500002 	cmpeq	r0, r2
34813b8c:	9a000007 	bls	34813bb0 <add_mtd_partitions+0x3a0>
		slave->mtd.size = master->size - slave->offset;
34813b90:	e052000a 	subs	r0, r2, sl
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
34813b94:	e5952020 	ldr	r2, [r5, #32]
		slave->mtd.size = master->size - slave->offset;
34813b98:	e0c3100b 	sbc	r1, r3, fp
34813b9c:	e1c400f8 	strd	r0, [r4, #8]
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
34813ba0:	e1cd00f0 	strd	r0, [sp]
34813ba4:	e59f02d0 	ldr	r0, [pc, #720]	; 34813e7c <add_mtd_partitions+0x66c>
34813ba8:	e5161020 	ldr	r1, [r6, #-32]	; 0xffffffe0
34813bac:	ebffd6fa 	bl	3480979c <printf>
	if (master->numeraseregions > 1) {
34813bb0:	e595c02c 	ldr	ip, [r5, #44]	; 0x2c
34813bb4:	e35c0001 	cmp	ip, #1
34813bb8:	da00002a 	ble	34813c68 <add_mtd_partitions+0x458>
		u64 end = slave->offset + slave->mtd.size;
34813bbc:	e1c40bd0 	ldrd	r0, [r4, #176]	; 0xb0
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
34813bc0:	e3a0e000 	mov	lr, #0
		u64 end = slave->offset + slave->mtd.size;
34813bc4:	e1c420d8 	ldrd	r2, [r4, #8]
		struct mtd_erase_region_info *regions = master->eraseregions;
34813bc8:	e5959030 	ldr	r9, [r5, #48]	; 0x30
		u64 end = slave->offset + slave->mtd.size;
34813bcc:	e090a002 	adds	sl, r0, r2
34813bd0:	e0a1b003 	adc	fp, r1, r3
34813bd4:	e1cda1f0 	strd	sl, [sp, #16]
34813bd8:	e3a0a018 	mov	sl, #24
34813bdc:	e0030e9a 	mul	r3, sl, lr
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
34813be0:	e18320d9 	ldrd	r2, [r3, r9]
34813be4:	e1530001 	cmp	r3, r1
34813be8:	01520000 	cmpeq	r2, r0
34813bec:	8a000002 	bhi	34813bfc <add_mtd_partitions+0x3ec>
34813bf0:	e28ee001 	add	lr, lr, #1
34813bf4:	e15e000c 	cmp	lr, ip
34813bf8:	1afffff7 	bne	34813bdc <add_mtd_partitions+0x3cc>
34813bfc:	e3a03018 	mov	r3, #24
		i--;
34813c00:	e24e1001 	sub	r1, lr, #1
34813c04:	e02e9e93 	mla	lr, r3, lr, r9
		for (; i < max && regions[i].offset < end; i++) {
34813c08:	e151000c 	cmp	r1, ip
34813c0c:	aa00000b 	bge	34813c40 <add_mtd_partitions+0x430>
34813c10:	e14e21d8 	ldrd	r2, [lr, #-24]	; 0xffffffe8
34813c14:	e1cda1d0 	ldrd	sl, [sp, #16]
34813c18:	e153000b 	cmp	r3, fp
34813c1c:	0152000a 	cmpeq	r2, sl
34813c20:	2a000006 	bcs	34813c40 <add_mtd_partitions+0x430>
			if (slave->mtd.erasesize < regions[i].erasesize) {
34813c24:	e51e3010 	ldr	r3, [lr, #-16]
		for (; i < max && regions[i].offset < end; i++) {
34813c28:	e2811001 	add	r1, r1, #1
			if (slave->mtd.erasesize < regions[i].erasesize) {
34813c2c:	e5942010 	ldr	r2, [r4, #16]
34813c30:	e28ee018 	add	lr, lr, #24
34813c34:	e1520003 	cmp	r2, r3
				slave->mtd.erasesize = regions[i].erasesize;
34813c38:	35843010 	strcc	r3, [r4, #16]
34813c3c:	eafffff1 	b	34813c08 <add_mtd_partitions+0x3f8>
		BUG_ON(slave->mtd.erasesize == 0);
34813c40:	e5943010 	ldr	r3, [r4, #16]
34813c44:	e3530000 	cmp	r3, #0
34813c48:	1a000008 	bne	34813c70 <add_mtd_partitions+0x460>
34813c4c:	e59f322c 	ldr	r3, [pc, #556]	; 34813e80 <add_mtd_partitions+0x670>
34813c50:	e300218a 	movw	r2, #394	; 0x18a
34813c54:	e59f1228 	ldr	r1, [pc, #552]	; 34813e84 <add_mtd_partitions+0x674>
34813c58:	e59f0228 	ldr	r0, [pc, #552]	; 34813e88 <add_mtd_partitions+0x678>
34813c5c:	ebffd6ce 	bl	3480979c <printf>
34813c60:	e59f0224 	ldr	r0, [pc, #548]	; 34813e8c <add_mtd_partitions+0x67c>
34813c64:	eb002371 	bl	3481ca30 <panic>
		slave->mtd.erasesize = master->erasesize;
34813c68:	e5953010 	ldr	r3, [r5, #16]
34813c6c:	e5843010 	str	r3, [r4, #16]
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813c70:	e5943004 	ldr	r3, [r4, #4]
34813c74:	e3130b01 	tst	r3, #1024	; 0x400
34813c78:	0a000017 	beq	34813cdc <add_mtd_partitions+0x4cc>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
34813c7c:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
34813c80:	e59400b0 	ldr	r0, [r4, #176]	; 0xb0
34813c84:	e5941010 	ldr	r1, [r4, #16]
	return do_div(sz, mtd->erasesize);
34813c88:	e58d3028 	str	r3, [sp, #40]	; 0x28
34813c8c:	e58d304c 	str	r3, [sp, #76]	; 0x4c
34813c90:	e3a03000 	mov	r3, #0
34813c94:	e58d302c 	str	r3, [sp, #44]	; 0x2c
34813c98:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
34813c9c:	e58d0048 	str	r0, [sp, #72]	; 0x48
34813ca0:	e1923003 	orrs	r3, r2, r3
34813ca4:	1a000001 	bne	34813cb0 <add_mtd_partitions+0x4a0>
34813ca8:	fa002d73 	blx	3481f27c <__aeabi_uidivmod>
34813cac:	ea000002 	b	34813cbc <add_mtd_partitions+0x4ac>
34813cb0:	e28d0048 	add	r0, sp, #72	; 0x48
34813cb4:	eb001928 	bl	3481a15c <__div64_32>
34813cb8:	e1a01000 	mov	r1, r0
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813cbc:	e3510000 	cmp	r1, #0
34813cc0:	0a000005 	beq	34813cdc <add_mtd_partitions+0x4cc>
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813cc4:	e5943004 	ldr	r3, [r4, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813cc8:	e5161020 	ldr	r1, [r6, #-32]	; 0xffffffe0
34813ccc:	e59f01bc 	ldr	r0, [pc, #444]	; 34813e90 <add_mtd_partitions+0x680>
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813cd0:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34813cd4:	e5843004 	str	r3, [r4, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813cd8:	ebffd6af 	bl	3480979c <printf>
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813cdc:	e5943004 	ldr	r3, [r4, #4]
34813ce0:	e3130b01 	tst	r3, #1024	; 0x400
34813ce4:	0a000017 	beq	34813d48 <add_mtd_partitions+0x538>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
34813ce8:	e594300c 	ldr	r3, [r4, #12]
34813cec:	e5940008 	ldr	r0, [r4, #8]
34813cf0:	e5941010 	ldr	r1, [r4, #16]
34813cf4:	e58d3030 	str	r3, [sp, #48]	; 0x30
34813cf8:	e58d3054 	str	r3, [sp, #84]	; 0x54
34813cfc:	e3a03000 	mov	r3, #0
34813d00:	e58d3034 	str	r3, [sp, #52]	; 0x34
34813d04:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
34813d08:	e58d0050 	str	r0, [sp, #80]	; 0x50
34813d0c:	e1923003 	orrs	r3, r2, r3
34813d10:	1a000001 	bne	34813d1c <add_mtd_partitions+0x50c>
34813d14:	fa002d58 	blx	3481f27c <__aeabi_uidivmod>
34813d18:	ea000002 	b	34813d28 <add_mtd_partitions+0x518>
34813d1c:	e28d0050 	add	r0, sp, #80	; 0x50
34813d20:	eb00190d 	bl	3481a15c <__div64_32>
34813d24:	e1a01000 	mov	r1, r0
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813d28:	e3510000 	cmp	r1, #0
34813d2c:	0a000005 	beq	34813d48 <add_mtd_partitions+0x538>
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813d30:	e5943004 	ldr	r3, [r4, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34813d34:	e5161020 	ldr	r1, [r6, #-32]	; 0xffffffe0
34813d38:	e59f0154 	ldr	r0, [pc, #340]	; 34813e94 <add_mtd_partitions+0x684>
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813d3c:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34813d40:	e5843004 	str	r3, [r4, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34813d44:	ebffd694 	bl	3480979c <printf>
	slave->mtd.ecclayout = master->ecclayout;
34813d48:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34813d4c:	e5843028 	str	r3, [r4, #40]	; 0x28
	if (master->block_isbad) {
34813d50:	e5953078 	ldr	r3, [r5, #120]	; 0x78
34813d54:	e3530000 	cmp	r3, #0
34813d58:	13a0a000 	movne	sl, #0
34813d5c:	13a0b000 	movne	fp, #0
34813d60:	0a000011 	beq	34813dac <add_mtd_partitions+0x59c>
		while (offs < slave->mtd.size) {
34813d64:	e1c420d8 	ldrd	r2, [r4, #8]
34813d68:	e15b0003 	cmp	fp, r3
34813d6c:	015a0002 	cmpeq	sl, r2
34813d70:	2a00000d 	bcs	34813dac <add_mtd_partitions+0x59c>
						offs + slave->offset))
34813d74:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0
			if (master->block_isbad(master,
34813d78:	e1a00005 	mov	r0, r5
34813d7c:	e5951078 	ldr	r1, [r5, #120]	; 0x78
34813d80:	e092200a 	adds	r2, r2, sl
34813d84:	e0a3300b 	adc	r3, r3, fp
34813d88:	e12fff31 	blx	r1
34813d8c:	e3500000 	cmp	r0, #0
				slave->mtd.ecc_stats.badblocks++;
34813d90:	15943088 	ldrne	r3, [r4, #136]	; 0x88
34813d94:	12833001 	addne	r3, r3, #1
34813d98:	15843088 	strne	r3, [r4, #136]	; 0x88
			offs += slave->mtd.erasesize;
34813d9c:	e5943010 	ldr	r3, [r4, #16]
34813da0:	e09aa003 	adds	sl, sl, r3
34813da4:	e2abb000 	adc	fp, fp, #0
34813da8:	eaffffed 	b	34813d64 <add_mtd_partitions+0x554>
	if (part->mtdp) {
34813dac:	e5963000 	ldr	r3, [r6]
34813db0:	e3530000 	cmp	r3, #0
		*part->mtdp = &slave->mtd;
34813db4:	15834000 	strne	r4, [r3]
		slave->registered = 0;
34813db8:	13a03000 	movne	r3, #0
	if (part->mtdp) {
34813dbc:	1a000002 	bne	34813dcc <add_mtd_partitions+0x5bc>
		add_mtd_device(&slave->mtd);
34813dc0:	e1a00004 	mov	r0, r4
34813dc4:	ebfffca6 	bl	34813064 <add_mtd_device>
		slave->registered = 1;
34813dc8:	e3a03001 	mov	r3, #1
		cur_offset = slave->offset + slave->mtd.size;
34813dcc:	e1c4a0d8 	ldrd	sl, [r4, #8]
	for (i = 0; i < nbparts; i++) {
34813dd0:	e2877001 	add	r7, r7, #1
		slave->registered = 1;
34813dd4:	e58430c4 	str	r3, [r4, #196]	; 0xc4
34813dd8:	e2866028 	add	r6, r6, #40	; 0x28
		cur_offset = slave->offset + slave->mtd.size;
34813ddc:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0
34813de0:	e09a0002 	adds	r0, sl, r2
34813de4:	e0ab1003 	adc	r1, fp, r3
34813de8:	e1a0a000 	mov	sl, r0
34813dec:	e1a0b001 	mov	fp, r1
34813df0:	eafffe9a 	b	34813860 <add_mtd_partitions+0x50>
	}

	return 0;
34813df4:	e3a00000 	mov	r0, #0
34813df8:	ea000006 	b	34813e18 <add_mtd_partitions+0x608>
34813dfc:	e28d0058 	add	r0, sp, #88	; 0x58
34813e00:	e1a0200a 	mov	r2, sl
34813e04:	e1a0300b 	mov	r3, fp
	do_div(sz, mtd->erasesize);
34813e08:	e5951010 	ldr	r1, [r5, #16]
34813e0c:	e16021f8 	strd	r2, [r0, #-24]!	; 0xffffffe8
34813e10:	eb0018d1 	bl	3481a15c <__div64_32>
34813e14:	eaffff27 	b	34813ab8 <add_mtd_partitions+0x2a8>
}
34813e18:	e28dd058 	add	sp, sp, #88	; 0x58
34813e1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34813e20:	3482a790 	.word	0x3482a790
34813e24:	34825fb7 	.word	0x34825fb7
34813e28:	34825fdc 	.word	0x34825fdc
34813e2c:	34813660 	.word	0x34813660
34813e30:	34813260 	.word	0x34813260
34813e34:	348132d8 	.word	0x348132d8
34813e38:	348135c8 	.word	0x348135c8
34813e3c:	34813350 	.word	0x34813350
34813e40:	34813230 	.word	0x34813230
34813e44:	34813248 	.word	0x34813248
34813e48:	348133d0 	.word	0x348133d0
34813e4c:	348133dc 	.word	0x348133dc
34813e50:	3481323c 	.word	0x3481323c
34813e54:	34813254 	.word	0x34813254
34813e58:	3481351c 	.word	0x3481351c
34813e5c:	34813484 	.word	0x34813484
34813e60:	348134d0 	.word	0x348134d0
34813e64:	34813528 	.word	0x34813528
34813e68:	34813568 	.word	0x34813568
34813e6c:	348133e8 	.word	0x348133e8
34813e70:	34826018 	.word	0x34826018
34813e74:	34826045 	.word	0x34826045
34813e78:	34826061 	.word	0x34826061
34813e7c:	34826092 	.word	0x34826092
34813e80:	3482157a 	.word	0x3482157a
34813e84:	348260e8 	.word	0x348260e8
34813e88:	348260f2 	.word	0x348260f2
34813e8c:	3482610f 	.word	0x3482610f
34813e90:	34826114 	.word	0x34826114
34813e94:	34826165 	.word	0x34826165

34813e98 <onenand_init>:
struct mtd_info onenand_mtd;
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
34813e98:	e92d4070 	push	{r4, r5, r6, lr}
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34813e9c:	e3a020a8 	mov	r2, #168	; 0xa8
34813ea0:	e59f4074 	ldr	r4, [pc, #116]	; 34813f1c <onenand_init+0x84>
34813ea4:	e3a01000 	mov	r1, #0
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34813ea8:	e28450a8 	add	r5, r4, #168	; 0xa8
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34813eac:	e1a00004 	mov	r0, r4
34813eb0:	eb001f31 	bl	3481bb7c <memset>
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34813eb4:	e3a020a8 	mov	r2, #168	; 0xa8
34813eb8:	e3a01000 	mov	r1, #0
34813ebc:	e1a00005 	mov	r0, r5
34813ec0:	eb001f2d 	bl	3481bb7c <memset>

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34813ec4:	e1a00004 	mov	r0, r4
	onenand_mtd.priv = &onenand_chip;
34813ec8:	e5845094 	str	r5, [r4, #148]	; 0x94
	onenand_board_init(&onenand_mtd);
34813ecc:	ebffb337 	bl	34800bb0 <onenand_board_init>
#else
	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
#endif

	onenand_scan(&onenand_mtd, 1);
34813ed0:	e3a01001 	mov	r1, #1
34813ed4:	e1a00004 	mov	r0, r4
34813ed8:	eb000ac1 	bl	348169e4 <onenand_scan>

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
34813edc:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
34813ee0:	e3130c02 	tst	r3, #512	; 0x200
34813ee4:	0a000001 	beq	34813ef0 <onenand_init+0x58>
		puts("Flex-");
34813ee8:	e59f0030 	ldr	r0, [pc, #48]	; 34813f20 <onenand_init+0x88>
34813eec:	ebffd61e 	bl	3480976c <puts>
	puts("OneNAND: ");
34813ef0:	e59f002c 	ldr	r0, [pc, #44]	; 34813f24 <onenand_init+0x8c>
34813ef4:	ebffd61c 	bl	3480976c <puts>
	print_size(onenand_chip.chipsize, "\n");
34813ef8:	e59400c0 	ldr	r0, [r4, #192]	; 0xc0
34813efc:	e3a01000 	mov	r1, #0
34813f00:	e59f2020 	ldr	r2, [pc, #32]	; 34813f28 <onenand_init+0x90>
34813f04:	eb0017ee 	bl	34819ec4 <print_size>
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
34813f08:	e59f301c 	ldr	r3, [pc, #28]	; 34813f2c <onenand_init+0x94>
	add_mtd_device(&onenand_mtd);
34813f0c:	e59f0008 	ldr	r0, [pc, #8]	; 34813f1c <onenand_init+0x84>
	onenand_mtd.name = dev_name;
34813f10:	e5843020 	str	r3, [r4, #32]
#endif
}
34813f14:	e8bd4070 	pop	{r4, r5, r6, lr}
	add_mtd_device(&onenand_mtd);
34813f18:	eafffc51 	b	34813064 <add_mtd_device>
34813f1c:	3482a798 	.word	0x3482a798
34813f20:	348261ab 	.word	0x348261ab
34813f24:	348261b1 	.word	0x348261b1
34813f28:	34824f42 	.word	0x34824f42
34813f2c:	34827818 	.word	0x34827818

34813f30 <memcpy_16>:
{
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
34813f30:	e1a020a2 	lsr	r2, r2, #1
34813f34:	e2403002 	sub	r3, r0, #2
	while (len-- > 0)
34813f38:	e2522001 	subs	r2, r2, #1
		*d++ = *s++;
34813f3c:	20d1c0b2 	ldrhcs	ip, [r1], #2
34813f40:	21e3c0b2 	strhcs	ip, [r3, #2]!
34813f44:	2afffffb 	bcs	34813f38 <memcpy_16+0x8>
	return ret;
}
34813f48:	e12fff1e 	bx	lr

34813f4c <onenand_readw>:
 *
 * Read OneNAND register
 */
static unsigned short onenand_readw(void __iomem * addr)
{
	return readw(addr);
34813f4c:	e1d000b0 	ldrh	r0, [r0]
34813f50:	e6ff0070 	uxth	r0, r0
}
34813f54:	e12fff1e 	bx	lr

34813f58 <onenand_writew>:
 *
 * Write OneNAND register with value
 */
static void onenand_writew(unsigned short value, void __iomem * addr)
{
	writew(value, addr);
34813f58:	e1c100b0 	strh	r0, [r1]
34813f5c:	e12fff1e 	bx	lr

34813f60 <flexonenand_addr>:
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34813f60:	e590301c 	ldr	r3, [r0, #28]
{
34813f64:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34813f68:	e1a04001 	mov	r4, r1
	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34813f6c:	e2133008 	ands	r3, r3, #8
34813f70:	0a000007 	beq	34813f94 <flexonenand_addr+0x34>
34813f74:	e5903028 	ldr	r3, [r0, #40]	; 0x28
34813f78:	e1510003 	cmp	r1, r3
		block -= this->density_mask;
34813f7c:	20634001 	rsbcs	r4, r3, r1
		die = 1;
		ofs = this->diesize[0];
34813f80:	25906010 	ldrcs	r6, [r0, #16]
34813f84:	23a07000 	movcs	r7, #0
		die = 1;
34813f88:	23a03001 	movcs	r3, #1
34813f8c:	2a000002 	bcs	34813f9c <flexonenand_addr+0x3c>
	int die = 0, boundary;
34813f90:	e3a03000 	mov	r3, #0
	loff_t ofs = 0;
34813f94:	e3a06000 	mov	r6, #0
34813f98:	e3a07000 	mov	r7, #0
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
34813f9c:	e5905030 	ldr	r5, [r0, #48]	; 0x30
	boundary = this->boundary[die];
34813fa0:	e2833002 	add	r3, r3, #2
34813fa4:	e7909103 	ldr	r9, [r0, r3, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
34813fa8:	e1a01fc4 	asr	r1, r4, #31
34813fac:	e1a00004 	mov	r0, r4
34813fb0:	e2455001 	sub	r5, r5, #1
34813fb4:	e1a02005 	mov	r2, r5
34813fb8:	fa002d6f 	blx	3481f57c <__ashldi3>
	if (block > (boundary + 1))
34813fbc:	e2893001 	add	r3, r9, #1
	ofs += (loff_t) block << (this->erase_shift - 1);
34813fc0:	e0966000 	adds	r6, r6, r0
34813fc4:	e0a77001 	adc	r7, r7, r1
	if (block > (boundary + 1))
34813fc8:	e1540003 	cmp	r4, r3
34813fcc:	da000006 	ble	34813fec <flexonenand_addr+0x8c>
		ofs += (loff_t) (block - boundary - 1)
34813fd0:	e0690004 	rsb	r0, r9, r4
			<< (this->erase_shift - 1);
34813fd4:	e1a02005 	mov	r2, r5
		ofs += (loff_t) (block - boundary - 1)
34813fd8:	e2400001 	sub	r0, r0, #1
			<< (this->erase_shift - 1);
34813fdc:	e1a01fc0 	asr	r1, r0, #31
34813fe0:	fa002d65 	blx	3481f57c <__ashldi3>
		ofs += (loff_t) (block - boundary - 1)
34813fe4:	e0966000 	adds	r6, r6, r0
34813fe8:	e0a77001 	adc	r7, r7, r1
	return ofs;
}
34813fec:	e1a00006 	mov	r0, r6
34813ff0:	e1a01007 	mov	r1, r7
34813ff4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

34813ff8 <onenand_sync>:
 * @param mtd		MTD device structure
 *
 * Sync is actually a wait for chip ready function
 */
void onenand_sync(struct mtd_info *mtd)
{
34813ff8:	e12fff1e 	bx	lr

34813ffc <onenand_chip_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34813ffc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34814000:	e1a09000 	mov	r9, r0
	struct onenand_chip *this = mtd->priv;
34814004:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814008:	e5940000 	ldr	r0, [r4]
3481400c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814010:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814014:	e2800042 	add	r0, r0, #66	; 0x42
34814018:	e12fff33 	blx	r3

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
3481401c:	e5941000 	ldr	r1, [r4]
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814020:	e1a05000 	mov	r5, r0
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814024:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814028:	e7ee0050 	ubfx	r0, r0, #0, #15
3481402c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814030:	e2811042 	add	r1, r1, #66	; 0x42
34814034:	e12fff33 	blx	r3
			 this->base + ONENAND_REG_SYS_CFG1);

	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
34814038:	e5941000 	ldr	r1, [r4]
3481403c:	e3a00090 	mov	r0, #144	; 0x90
34814040:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814044:	e12fff33 	blx	r3

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
34814048:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481404c:	e5940000 	ldr	r0, [r4]
34814050:	e12fff33 	blx	r3
34814054:	e1a06000 	mov	r6, r0
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
34814058:	e5940000 	ldr	r0, [r4]
3481405c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814060:	e2800002 	add	r0, r0, #2
34814064:	e12fff33 	blx	r3

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814068:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
3481406c:	e1a07000 	mov	r7, r0
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814070:	e5941000 	ldr	r1, [r4]
34814074:	e3a000f0 	mov	r0, #240	; 0xf0
34814078:	e12fff33 	blx	r3

	/* Wait reset */
	this->wait(mtd, FL_RESETING);
3481407c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814080:	e3a01006 	mov	r1, #6
34814084:	e1a00009 	mov	r0, r9
34814088:	e12fff33 	blx	r3

	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
3481408c:	e5941000 	ldr	r1, [r4]
34814090:	e1a00005 	mov	r0, r5
34814094:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814098:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481409c:	e2811042 	add	r1, r1, #66	; 0x42
348140a0:	e12fff33 	blx	r3
		if (manuf == onenand_manuf_ids[i].id)
348140a4:	e35600ec 	cmp	r6, #236	; 0xec
348140a8:	13560020 	cmpne	r6, #32
348140ac:	0a000001 	beq	348140b8 <onenand_chip_probe+0xbc>

	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;
348140b0:	e3e00005 	mvn	r0, #5
348140b4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

	/* Read manufacturer and device IDs from Register */
	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
348140b8:	e5940000 	ldr	r0, [r4]
348140bc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348140c0:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348140c4:	e12fff33 	blx	r3
348140c8:	e1a05000 	mov	r5, r0
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
348140cc:	e5940000 	ldr	r0, [r4]
348140d0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348140d4:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348140d8:	e2800002 	add	r0, r0, #2
348140dc:	e12fff33 	blx	r3

	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
348140e0:	e1500007 	cmp	r0, r7
348140e4:	01550006 	cmpeq	r5, r6
348140e8:	13a00001 	movne	r0, #1
348140ec:	03a00000 	moveq	r0, #0
348140f0:	1affffee 	bne	348140b0 <onenand_chip_probe+0xb4>
		return -ENXIO;

	return 0;
}
348140f4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

348140f8 <flexonenand_get_size>:
{
348140f8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
348140fc:	e3a03010 	mov	r3, #16
	struct onenand_chip *this = mtd->priv;
34814100:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
34814104:	e24dd020 	sub	sp, sp, #32
34814108:	e1a05000 	mov	r5, r0
	density = onenand_get_density(this->device_id);
3481410c:	e594701c 	ldr	r7, [r4, #28]
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814110:	e5946030 	ldr	r6, [r4, #48]	; 0x30
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34814114:	e7e31257 	ubfx	r1, r7, #4, #4
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814118:	e7e071d7 	ubfx	r7, r7, #3, #1
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
3481411c:	e1a03113 	lsl	r3, r3, r1
34814120:	e1a02006 	mov	r2, r6
34814124:	e1a01fc3 	asr	r1, r3, #31
34814128:	e1a00a03 	lsl	r0, r3, #20
3481412c:	e1a01a01 	lsl	r1, r1, #20
34814130:	e1811623 	orr	r1, r1, r3, lsr #12
34814134:	fa002d09 	blx	3481f560 <__ashrdi3>
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814138:	e1a03750 	asr	r3, r0, r7
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
3481413c:	e5940000 	ldr	r0, [r4]
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814140:	e58d301c 	str	r3, [sp, #28]
	maxbdry = blksperdie - 1;
34814144:	e2433001 	sub	r3, r3, #1
34814148:	e58d3018 	str	r3, [sp, #24]
	eraseshift = this->erase_shift - 1;
3481414c:	e2463001 	sub	r3, r6, #1
34814150:	e58d3010 	str	r3, [sp, #16]
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814154:	e2800b79 	add	r0, r0, #123904	; 0x1e400
	mtd->numeraseregions = this->dies << 1;
34814158:	e5943004 	ldr	r3, [r4, #4]
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
3481415c:	e2800042 	add	r0, r0, #66	; 0x42
	mtd->numeraseregions = this->dies << 1;
34814160:	e1a03083 	lsl	r3, r3, #1
34814164:	e585302c 	str	r3, [r5, #44]	; 0x2c
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814168:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481416c:	e12fff33 	blx	r3
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814170:	e5941000 	ldr	r1, [r4]
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814174:	e1a0b000 	mov	fp, r0
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814178:	e3800c01 	orr	r0, r0, #256	; 0x100
3481417c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814180:	e6ff0070 	uxth	r0, r0
34814184:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814188:	e2811042 	add	r1, r1, #66	; 0x42
3481418c:	e12fff33 	blx	r3
34814190:	e2843004 	add	r3, r4, #4
34814194:	e3a02000 	mov	r2, #0
34814198:	e58d3014 	str	r3, [sp, #20]
3481419c:	e1a09003 	mov	r9, r3
348141a0:	e3a03000 	mov	r3, #0
348141a4:	e1cd20f8 	strd	r2, [sp, #8]
	for (die = 0; die < this->dies; die++) {
348141a8:	e59d2008 	ldr	r2, [sp, #8]
348141ac:	e5943004 	ldr	r3, [r4, #4]
348141b0:	e1520003 	cmp	r2, r3
348141b4:	2a000034 	bcs	3481428c <flexonenand_get_size+0x194>
		this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
348141b8:	e3a07000 	mov	r7, #0
348141bc:	e1cd20d8 	ldrd	r2, [sp, #8]
348141c0:	e58d7000 	str	r7, [sp]
348141c4:	e3a01066 	mov	r1, #102	; 0x66
348141c8:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348141cc:	e1a00005 	mov	r0, r5
348141d0:	e12fff3c 	blx	ip
		this->wait(mtd, FL_SYNCING);
348141d4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348141d8:	e3a01004 	mov	r1, #4
348141dc:	e1a00005 	mov	r0, r5
348141e0:	e12fff33 	blx	r3
		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
348141e4:	e1cd20d8 	ldrd	r2, [sp, #8]
348141e8:	e3011985 	movw	r1, #6533	; 0x1985
348141ec:	e58d7000 	str	r7, [sp]
348141f0:	e1a00005 	mov	r0, r5
348141f4:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348141f8:	e12fff3c 	blx	ip
		this->wait(mtd, FL_READING);
348141fc:	e3a01001 	mov	r1, #1
34814200:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814204:	e1a00005 	mov	r0, r5
34814208:	e12fff33 	blx	r3
		bdry = this->read_word(this->base + ONENAND_DATARAM);
3481420c:	e5940000 	ldr	r0, [r4]
34814210:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814214:	e2800b01 	add	r0, r0, #1024	; 0x400
34814218:	e12fff33 	blx	r3
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;
3481421c:	e7e93050 	ubfx	r3, r0, #0, #10
		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814220:	e3a02000 	mov	r2, #0
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;
34814224:	e5a93004 	str	r3, [r9, #4]!
		bdry = this->read_word(this->base + ONENAND_DATARAM);
34814228:	e1a06000 	mov	r6, r0
		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
3481422c:	e58d7000 	str	r7, [sp]
34814230:	e3a03000 	mov	r3, #0
34814234:	e3a010f0 	mov	r1, #240	; 0xf0
34814238:	e5947050 	ldr	r7, [r4, #80]	; 0x50
3481423c:	e1a00005 	mov	r0, r5
34814240:	e12fff37 	blx	r7
		this->wait(mtd, FL_RESETING);
34814244:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814248:	e3a01006 	mov	r1, #6
3481424c:	e1a00005 	mov	r0, r5
34814250:	e12fff33 	blx	r3
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
34814254:	e1a03726 	lsr	r3, r6, #14
		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
34814258:	e59f1278 	ldr	r1, [pc, #632]	; 348144d8 <flexonenand_get_size+0x3e0>
3481425c:	e59f2278 	ldr	r2, [pc, #632]	; 348144dc <flexonenand_get_size+0x3e4>
34814260:	e3530003 	cmp	r3, #3
34814264:	e59f0274 	ldr	r0, [pc, #628]	; 348144e0 <flexonenand_get_size+0x3e8>
34814268:	01a02001 	moveq	r2, r1
3481426c:	e59d1008 	ldr	r1, [sp, #8]
34814270:	e1a03002 	mov	r3, r2
34814274:	e5992000 	ldr	r2, [r9]
34814278:	ebffd547 	bl	3480979c <printf>
3481427c:	e1cd20d8 	ldrd	r2, [sp, #8]
34814280:	e2922001 	adds	r2, r2, #1
34814284:	e2a33000 	adc	r3, r3, #0
34814288:	eaffffc5 	b	348141a4 <flexonenand_get_size+0xac>
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
3481428c:	e5941000 	ldr	r1, [r4]
34814290:	e1a0000b 	mov	r0, fp
34814294:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814298:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481429c:	e2811042 	add	r1, r1, #66	; 0x42
348142a0:	e12fff33 	blx	r3
348142a4:	e5943004 	ldr	r3, [r4, #4]
	ofs = 0;
348142a8:	e3a02000 	mov	r2, #0
	for (; die < this->dies; die++) {
348142ac:	e59d1014 	ldr	r1, [sp, #20]
	ofs = 0;
348142b0:	e1a0a002 	mov	sl, r2
	die = 0;
348142b4:	e3a00000 	mov	r0, #0
			mtd->eraseregions[i].offset = ofs;
348142b8:	e3a0c018 	mov	ip, #24
348142bc:	e58d3008 	str	r3, [sp, #8]
	ofs = 0;
348142c0:	e3a03000 	mov	r3, #0
348142c4:	e1a0b003 	mov	fp, r3
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
348142c8:	e3a0e001 	mov	lr, #1
	i = -1;
348142cc:	e3e03000 	mvn	r3, #0
	for (; die < this->dies; die++) {
348142d0:	e59d2008 	ldr	r2, [sp, #8]
348142d4:	e1500002 	cmp	r0, r2
348142d8:	0a000045 	beq	348143f4 <flexonenand_get_size+0x2fc>
		if (!die || this->boundary[die-1] != maxbdry) {
348142dc:	e3500000 	cmp	r0, #0
348142e0:	0a000003 	beq	348142f4 <flexonenand_get_size+0x1fc>
348142e4:	e5912000 	ldr	r2, [r1]
348142e8:	e59d6018 	ldr	r6, [sp, #24]
348142ec:	e1520006 	cmp	r2, r6
348142f0:	0a000012 	beq	34814340 <flexonenand_get_size+0x248>
			i++;
348142f4:	e2833001 	add	r3, r3, #1
			mtd->eraseregions[i].offset = ofs;
348142f8:	e5959030 	ldr	r9, [r5, #48]	; 0x30
348142fc:	e002039c 	mul	r2, ip, r3
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814300:	e59d6010 	ldr	r6, [sp, #16]
			mtd->eraseregions[i].offset = ofs;
34814304:	e189a0f2 	strd	sl, [r9, r2]
34814308:	e0897002 	add	r7, r9, r2
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
3481430c:	e59d2010 	ldr	r2, [sp, #16]
34814310:	e1a0221e 	lsl	r2, lr, r2
34814314:	e5872008 	str	r2, [r7, #8]
							this->boundary[die] + 1;
34814318:	e5912004 	ldr	r2, [r1, #4]
3481431c:	e2822001 	add	r2, r2, #1
			mtd->eraseregions[i].numblocks =
34814320:	e587200c 	str	r2, [r7, #12]
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814324:	e1a02612 	lsl	r2, r2, r6
34814328:	e09aa002 	adds	sl, sl, r2
			eraseshift++;
3481432c:	e59d2010 	ldr	r2, [sp, #16]
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814330:	e2abb000 	adc	fp, fp, #0
			eraseshift++;
34814334:	e2822001 	add	r2, r2, #1
34814338:	e58d2010 	str	r2, [sp, #16]
3481433c:	ea00000f 	b	34814380 <flexonenand_get_size+0x288>
			mtd->eraseregions[i].numblocks +=
34814340:	e5959030 	ldr	r9, [r5, #48]	; 0x30
			mtd->numeraseregions -= 1;
34814344:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814348:	e59d6010 	ldr	r6, [sp, #16]
			mtd->eraseregions[i].numblocks +=
3481434c:	e029939c 	mla	r9, ip, r3, r9
			mtd->numeraseregions -= 1;
34814350:	e2422001 	sub	r2, r2, #1
34814354:	e585202c 	str	r2, [r5, #44]	; 0x2c
34814358:	e599700c 	ldr	r7, [r9, #12]
							this->boundary[die] + 1;
3481435c:	e5912004 	ldr	r2, [r1, #4]
34814360:	e2877001 	add	r7, r7, #1
			mtd->eraseregions[i].numblocks +=
34814364:	e0877002 	add	r7, r7, r2
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814368:	e2822001 	add	r2, r2, #1
			mtd->eraseregions[i].numblocks +=
3481436c:	e589700c 	str	r7, [r9, #12]
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814370:	e2467001 	sub	r7, r6, #1
34814374:	e1a02712 	lsl	r2, r2, r7
34814378:	e09aa002 	adds	sl, sl, r2
3481437c:	e2abb000 	adc	fp, fp, #0
		if (this->boundary[die] != maxbdry) {
34814380:	e5b12004 	ldr	r2, [r1, #4]!
34814384:	e59d6018 	ldr	r6, [sp, #24]
34814388:	e1520006 	cmp	r2, r6
			mtd->numeraseregions -= 1;
3481438c:	0595202c 	ldreq	r2, [r5, #44]	; 0x2c
34814390:	02422001 	subeq	r2, r2, #1
34814394:	0585202c 	streq	r2, [r5, #44]	; 0x2c
		if (this->boundary[die] != maxbdry) {
34814398:	0a000013 	beq	348143ec <flexonenand_get_size+0x2f4>
			i++;
3481439c:	e2833001 	add	r3, r3, #1
			mtd->eraseregions[i].offset = ofs;
348143a0:	e5956030 	ldr	r6, [r5, #48]	; 0x30
348143a4:	e009039c 	mul	r9, ip, r3
348143a8:	e186a0f9 	strd	sl, [r6, r9]
348143ac:	e0867009 	add	r7, r6, r9
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
348143b0:	e59d6010 	ldr	r6, [sp, #16]
348143b4:	e1a0961e 	lsl	r9, lr, r6
			mtd->eraseregions[i].numblocks = maxbdry ^
348143b8:	e59d6018 	ldr	r6, [sp, #24]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
348143bc:	e5879008 	str	r9, [r7, #8]
			mtd->eraseregions[i].numblocks = maxbdry ^
348143c0:	e0222006 	eor	r2, r2, r6
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
348143c4:	e59d6010 	ldr	r6, [sp, #16]
			mtd->eraseregions[i].numblocks = maxbdry ^
348143c8:	e587200c 	str	r2, [r7, #12]
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
348143cc:	e1a02612 	lsl	r2, r2, r6
348143d0:	e09a6002 	adds	r6, sl, r2
			eraseshift--;
348143d4:	e59d2010 	ldr	r2, [sp, #16]
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
348143d8:	e2ab7000 	adc	r7, fp, #0
348143dc:	e1a0a006 	mov	sl, r6
348143e0:	e1a0b007 	mov	fp, r7
			eraseshift--;
348143e4:	e2422001 	sub	r2, r2, #1
348143e8:	e58d2010 	str	r2, [sp, #16]
	for (; die < this->dies; die++) {
348143ec:	e2800001 	add	r0, r0, #1
348143f0:	eaffffb6 	b	348142d0 <flexonenand_get_size+0x1d8>
	mtd->erasesize = 1 << this->erase_shift;
348143f4:	e5942030 	ldr	r2, [r4, #48]	; 0x30
348143f8:	e3a03001 	mov	r3, #1
	if (mtd->numeraseregions == 1)
348143fc:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
	for (i = 0; i < mtd->numeraseregions; i++)
34814400:	e3a06000 	mov	r6, #0
34814404:	e3a07018 	mov	r7, #24
	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814408:	e59f00d4 	ldr	r0, [pc, #212]	; 348144e4 <flexonenand_get_size+0x3ec>
	mtd->erasesize = 1 << this->erase_shift;
3481440c:	e1a03213 	lsl	r3, r3, r2
	if (mtd->numeraseregions == 1)
34814410:	e3510001 	cmp	r1, #1
	mtd->erasesize = 1 << this->erase_shift;
34814414:	e5853010 	str	r3, [r5, #16]
		mtd->erasesize >>= 1;
34814418:	01a030a3 	lsreq	r3, r3, #1
3481441c:	05853010 	streq	r3, [r5, #16]
	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814420:	ebffd4dd 	bl	3480979c <printf>
	for (i = 0; i < mtd->numeraseregions; i++)
34814424:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
34814428:	e1560003 	cmp	r6, r3
3481442c:	aa00000c 	bge	34814464 <flexonenand_get_size+0x36c>
34814430:	e0030697 	mul	r3, r7, r6
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814434:	e5952030 	ldr	r2, [r5, #48]	; 0x30
	for (i = 0; i < mtd->numeraseregions; i++)
34814438:	e2866001 	add	r6, r6, #1
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
3481443c:	e0821003 	add	r1, r2, r3
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814440:	e0822003 	add	r2, r2, r3
34814444:	e591000c 	ldr	r0, [r1, #12]
34814448:	e58d0004 	str	r0, [sp, #4]
3481444c:	e5911008 	ldr	r1, [r1, #8]
34814450:	e59f0090 	ldr	r0, [pc, #144]	; 348144e8 <flexonenand_get_size+0x3f0>
34814454:	e58d1000 	str	r1, [sp]
34814458:	e1c220d0 	ldrd	r2, [r2]
3481445c:	ebffd4ce 	bl	3480979c <printf>
34814460:	eaffffef 	b	34814424 <flexonenand_get_size+0x32c>
34814464:	e5946004 	ldr	r6, [r4, #4]
	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814468:	e3a02000 	mov	r2, #0
3481446c:	e3a03000 	mov	r3, #0
34814470:	e1c520f8 	strd	r2, [r5, #8]
34814474:	e2866001 	add	r6, r6, #1
34814478:	e0846106 	add	r6, r4, r6, lsl #2
3481447c:	e59d3014 	ldr	r3, [sp, #20]
34814480:	e1530006 	cmp	r3, r6
34814484:	0a000011 	beq	348144d0 <flexonenand_get_size+0x3d8>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814488:	e5942030 	ldr	r2, [r4, #48]	; 0x30
						 << (this->erase_shift - 1);
3481448c:	e3a01000 	mov	r1, #0
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814490:	e59d301c 	ldr	r3, [sp, #28]
34814494:	e1a07213 	lsl	r7, r3, r2
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814498:	e59d3014 	ldr	r3, [sp, #20]
						 << (this->erase_shift - 1);
3481449c:	e2422001 	sub	r2, r2, #1
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
348144a0:	e5b30004 	ldr	r0, [r3, #4]!
						 << (this->erase_shift - 1);
348144a4:	e2800001 	add	r0, r0, #1
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
348144a8:	e58d3014 	str	r3, [sp, #20]
						 << (this->erase_shift - 1);
348144ac:	fa002c32 	blx	3481f57c <__ashldi3>
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
348144b0:	e59d3014 	ldr	r3, [sp, #20]
348144b4:	e0600007 	rsb	r0, r0, r7
348144b8:	e5830008 	str	r0, [r3, #8]
		mtd->size += this->diesize[die];
348144bc:	e1c520d8 	ldrd	r2, [r5, #8]
348144c0:	e092a000 	adds	sl, r2, r0
348144c4:	e2a3b000 	adc	fp, r3, #0
348144c8:	e1c5a0f8 	strd	sl, [r5, #8]
348144cc:	eaffffea 	b	3481447c <flexonenand_get_size+0x384>
}
348144d0:	e28dd020 	add	sp, sp, #32
348144d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348144d8:	348261c4 	.word	0x348261c4
348144dc:	348261bb 	.word	0x348261bb
348144e0:	348261cf 	.word	0x348261cf
348144e4:	348261e6 	.word	0x348261e6
348144e8:	34826202 	.word	0x34826202

348144ec <onenand_transfer_auto_oob>:
{
348144ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int readend = column + thislen;
348144f0:	e0827003 	add	r7, r2, r3
	struct onenand_chip *this = mtd->priv;
348144f4:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
348144f8:	e1a0a002 	mov	sl, r2
348144fc:	e24dd018 	sub	sp, sp, #24
34814500:	e1a09001 	mov	r9, r1
	int readcol = column;
34814504:	e1a0500a 	mov	r5, sl
	free = this->ecclayout->oobfree;
34814508:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
	uint8_t *oob_buf = this->oob_buf;
3481450c:	e594b090 	ldr	fp, [r4, #144]	; 0x90
34814510:	e2832e21 	add	r2, r3, #528	; 0x210
34814514:	e283ce25 	add	ip, r3, #592	; 0x250
	int lastgap = 0;
34814518:	e3a03000 	mov	r3, #0
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481451c:	e5121004 	ldr	r1, [r2, #-4]
34814520:	e3510000 	cmp	r1, #0
34814524:	0a00000a 	beq	34814554 <onenand_transfer_auto_oob+0x68>
34814528:	e512e008 	ldr	lr, [r2, #-8]
		if (readcol >= lastgap)
3481452c:	e1550003 	cmp	r5, r3
34814530:	e2822008 	add	r2, r2, #8
34814534:	a063600e 	rsbge	r6, r3, lr
			readcol += free->offset - lastgap;
34814538:	a0865005 	addge	r5, r6, r5
		if (readend >= lastgap)
3481453c:	e1570003 	cmp	r7, r3
34814540:	a063300e 	rsbge	r3, r3, lr
			readend += free->offset - lastgap;
34814544:	a0837007 	addge	r7, r3, r7
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814548:	e152000c 	cmp	r2, ip
		lastgap = free->offset + free->length;
3481454c:	e081300e 	add	r3, r1, lr
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814550:	1afffff1 	bne	3481451c <onenand_transfer_auto_oob+0x30>
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
34814554:	e5903018 	ldr	r3, [r0, #24]
34814558:	e3a02000 	mov	r2, #0
3481455c:	e58db004 	str	fp, [sp, #4]
34814560:	e58d300c 	str	r3, [sp, #12]
34814564:	e3a03000 	mov	r3, #0
34814568:	e58d3008 	str	r3, [sp, #8]
3481456c:	e59f309c 	ldr	r3, [pc, #156]	; 34814610 <onenand_transfer_auto_oob+0x124>
34814570:	e58d3000 	str	r3, [sp]
34814574:	e3a03000 	mov	r3, #0
34814578:	e5941060 	ldr	r1, [r4, #96]	; 0x60
3481457c:	e12fff31 	blx	r1
	free = this->ecclayout->oobfree;
34814580:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
34814584:	e2836e21 	add	r6, r3, #528	; 0x210
34814588:	e2833e25 	add	r3, r3, #592	; 0x250
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481458c:	e5164004 	ldr	r4, [r6, #-4]
34814590:	e3540000 	cmp	r4, #0
34814594:	0a00001a 	beq	34814604 <onenand_transfer_auto_oob+0x118>
		int free_end = free->offset + free->length;
34814598:	e5161008 	ldr	r1, [r6, #-8]
3481459c:	e0814004 	add	r4, r1, r4
		if (free->offset < readend && free_end > readcol) {
348145a0:	e1540005 	cmp	r4, r5
348145a4:	d3a02000 	movle	r2, #0
348145a8:	c3a02001 	movgt	r2, #1
348145ac:	e1510007 	cmp	r1, r7
348145b0:	23a02000 	movcs	r2, #0
348145b4:	e3520000 	cmp	r2, #0
348145b8:	0a00000c 	beq	348145f0 <onenand_transfer_auto_oob+0x104>
			int st = max_t(int,free->offset,readcol);
348145bc:	e1510005 	cmp	r1, r5
			memcpy(buf, oob_buf + st, n);
348145c0:	e1a00009 	mov	r0, r9
			int st = max_t(int,free->offset,readcol);
348145c4:	b1a01005 	movlt	r1, r5
348145c8:	e58d3014 	str	r3, [sp, #20]
			int n = ed - st;
348145cc:	e1540007 	cmp	r4, r7
348145d0:	d0614004 	rsble	r4, r1, r4
348145d4:	c0614007 	rsbgt	r4, r1, r7
			memcpy(buf, oob_buf + st, n);
348145d8:	e08b1001 	add	r1, fp, r1
348145dc:	e1a02004 	mov	r2, r4
			buf += n;
348145e0:	e0899004 	add	r9, r9, r4
			memcpy(buf, oob_buf + st, n);
348145e4:	eb001d84 	bl	3481bbfc <memcpy>
		if (free->offset < readend && free_end > readcol) {
348145e8:	e59d3014 	ldr	r3, [sp, #20]
348145ec:	ea000001 	b	348145f8 <onenand_transfer_auto_oob+0x10c>
		} else if (column == 0)
348145f0:	e35a0000 	cmp	sl, #0
348145f4:	0a000002 	beq	34814604 <onenand_transfer_auto_oob+0x118>
348145f8:	e2866008 	add	r6, r6, #8
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348145fc:	e1560003 	cmp	r6, r3
34814600:	1affffe1 	bne	3481458c <onenand_transfer_auto_oob+0xa0>
}
34814604:	e3a00000 	mov	r0, #0
34814608:	e28dd018 	add	sp, sp, #24
3481460c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814610:	00010020 	.word	0x00010020

34814614 <generic_ffs>:
	if (!x)
34814614:	e3500000 	cmp	r0, #0
34814618:	012fff1e 	bxeq	lr
	if (!(x & 0xffff)) {
3481461c:	e6ff3070 	uxth	r3, r0
34814620:	e3530000 	cmp	r3, #0
		x >>= 16;
34814624:	01a00840 	asreq	r0, r0, #16
		r += 16;
34814628:	03a03011 	moveq	r3, #17
	int r = 1;
3481462c:	13a03001 	movne	r3, #1
	if (!(x & 0xff)) {
34814630:	e31000ff 	tst	r0, #255	; 0xff
		x >>= 8;
34814634:	01a00440 	asreq	r0, r0, #8
		r += 8;
34814638:	02833008 	addeq	r3, r3, #8
	if (!(x & 0xf)) {
3481463c:	e310000f 	tst	r0, #15
		x >>= 4;
34814640:	01a00240 	asreq	r0, r0, #4
		r += 4;
34814644:	02833004 	addeq	r3, r3, #4
	if (!(x & 3)) {
34814648:	e3100003 	tst	r0, #3
		x >>= 2;
3481464c:	01a00140 	asreq	r0, r0, #2
		r += 2;
34814650:	02833002 	addeq	r3, r3, #2
	if (!(x & 1)) {
34814654:	e3100001 	tst	r0, #1
		r += 1;
34814658:	02830001 	addeq	r0, r3, #1
	if (!(x & 1)) {
3481465c:	11a00003 	movne	r0, r3
}
34814660:	e12fff1e 	bx	lr

34814664 <onenand_bufferram_offset>:
	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814664:	e5903094 	ldr	r3, [r0, #148]	; 0x94
34814668:	e5933044 	ldr	r3, [r3, #68]	; 0x44
3481466c:	e3530000 	cmp	r3, #0
34814670:	0a000008 	beq	34814698 <onenand_bufferram_offset+0x34>
		if (area == ONENAND_DATARAM)
34814674:	e3510b01 	cmp	r1, #1024	; 0x400
34814678:	1a000001 	bne	34814684 <onenand_bufferram_offset+0x20>
			return mtd->writesize;
3481467c:	e5900014 	ldr	r0, [r0, #20]
34814680:	e12fff1e 	bx	lr
		if (area == ONENAND_SPARERAM)
34814684:	e59f301c 	ldr	r3, [pc, #28]	; 348146a8 <onenand_bufferram_offset+0x44>
34814688:	e1510003 	cmp	r1, r3
3481468c:	1a000003 	bne	348146a0 <onenand_bufferram_offset+0x3c>
			return mtd->oobsize;
34814690:	e5900018 	ldr	r0, [r0, #24]
34814694:	e12fff1e 	bx	lr
	return 0;
34814698:	e1a00003 	mov	r0, r3
3481469c:	e12fff1e 	bx	lr
348146a0:	e3a00000 	mov	r0, #0
}
348146a4:	e12fff1e 	bx	lr
348146a8:	00010020 	.word	0x00010020

348146ac <onenand_read_bufferram>:
{
348146ac:	e92d4070 	push	{r4, r5, r6, lr}
348146b0:	e1a05000 	mov	r5, r0
348146b4:	e59d4010 	ldr	r4, [sp, #16]
	bufferram += onenand_bufferram_offset(mtd, area);
348146b8:	e1a01004 	mov	r1, r4
348146bc:	ebffffe8 	bl	34814664 <onenand_bufferram_offset>
348146c0:	e59d1018 	ldr	r1, [sp, #24]
	bufferram = this->base + area;
348146c4:	e5953094 	ldr	r3, [r5, #148]	; 0x94
	memcpy_16(buffer, bufferram + offset, count);
348146c8:	e59d201c 	ldr	r2, [sp, #28]
348146cc:	e0844001 	add	r4, r4, r1
348146d0:	e5931000 	ldr	r1, [r3]
348146d4:	e0840000 	add	r0, r4, r0
348146d8:	e0811000 	add	r1, r1, r0
348146dc:	e59d0014 	ldr	r0, [sp, #20]
348146e0:	ebfffe12 	bl	34813f30 <memcpy_16>
}
348146e4:	e3a00000 	mov	r0, #0
348146e8:	e8bd8070 	pop	{r4, r5, r6, pc}

348146ec <onenand_sync_read_bufferram>:
{
348146ec:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
348146f0:	e1a05000 	mov	r5, r0
348146f4:	e59d4018 	ldr	r4, [sp, #24]
	struct onenand_chip *this = mtd->priv;
348146f8:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	bufferram += onenand_bufferram_offset(mtd, area);
348146fc:	e1a01004 	mov	r1, r4
34814700:	ebffffd7 	bl	34814664 <onenand_bufferram_offset>
	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
34814704:	e5963074 	ldr	r3, [r6, #116]	; 0x74
	bufferram += onenand_bufferram_offset(mtd, area);
34814708:	e1a09000 	mov	r9, r0
	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
3481470c:	e3a01902 	mov	r1, #32768	; 0x8000
34814710:	e1a00005 	mov	r0, r5
	bufferram = this->base + area;
34814714:	e5967000 	ldr	r7, [r6]
	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
34814718:	e12fff33 	blx	r3
3481471c:	e59d1020 	ldr	r1, [sp, #32]
	memcpy_16(buffer, bufferram + offset, count);
34814720:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34814724:	e59d001c 	ldr	r0, [sp, #28]
34814728:	e0841001 	add	r1, r4, r1
3481472c:	e0811009 	add	r1, r1, r9
34814730:	e0871001 	add	r1, r7, r1
34814734:	ebfffdfd 	bl	34813f30 <memcpy_16>
	this->mmcontrol(mtd, 0);
34814738:	e1a00005 	mov	r0, r5
3481473c:	e5963074 	ldr	r3, [r6, #116]	; 0x74
34814740:	e3a01000 	mov	r1, #0
34814744:	e12fff33 	blx	r3
}
34814748:	e3a00000 	mov	r0, #0
3481474c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

34814750 <onenand_write_bufferram>:
{
34814750:	e92d4070 	push	{r4, r5, r6, lr}
34814754:	e1a05000 	mov	r5, r0
34814758:	e59d4010 	ldr	r4, [sp, #16]
	bufferram += onenand_bufferram_offset(mtd, area);
3481475c:	e1a01004 	mov	r1, r4
34814760:	ebffffbf 	bl	34814664 <onenand_bufferram_offset>
	bufferram = this->base + area;
34814764:	e5953094 	ldr	r3, [r5, #148]	; 0x94
34814768:	e59d2018 	ldr	r2, [sp, #24]
	memcpy_16(bufferram + offset, buffer, count);
3481476c:	e59d1014 	ldr	r1, [sp, #20]
34814770:	e5933000 	ldr	r3, [r3]
34814774:	e0844002 	add	r4, r4, r2
34814778:	e59d201c 	ldr	r2, [sp, #28]
3481477c:	e0840000 	add	r0, r4, r0
34814780:	e0830000 	add	r0, r3, r0
34814784:	ebfffde9 	bl	34813f30 <memcpy_16>
}
34814788:	e3a00000 	mov	r0, #0
3481478c:	e8bd8070 	pop	{r4, r5, r6, pc}

34814790 <onenand_update_bufferram.isra.4>:
static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
34814790:	e92d4010 	push	{r4, lr}
34814794:	e1a04000 	mov	r4, r0
34814798:	e1a01003 	mov	r1, r3
3481479c:	e1a00002 	mov	r0, r2
		blockpage = (int)(addr >> this->page_shift);
348147a0:	e5942034 	ldr	r2, [r4, #52]	; 0x34
348147a4:	fa002b6d 	blx	3481f560 <__ashrdi3>
	i = ONENAND_NEXT_BUFFERRAM(this);
348147a8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348147ac:	e2232001 	eor	r2, r3, #1
348147b0:	e2833012 	add	r3, r3, #18
348147b4:	e0842102 	add	r2, r4, r2, lsl #2
	if (this->bufferram[i].blockpage == blockpage)
348147b8:	e5921048 	ldr	r1, [r2, #72]	; 0x48
348147bc:	e1510000 	cmp	r1, r0
		this->bufferram[i].blockpage = -1;
348147c0:	03e01000 	mvneq	r1, #0
348147c4:	05821048 	streq	r1, [r2, #72]	; 0x48
	if (valid)
348147c8:	e59d2008 	ldr	r2, [sp, #8]
348147cc:	e3520000 	cmp	r2, #0
		this->bufferram[i].blockpage = -1;
348147d0:	03e02000 	mvneq	r2, #0
		this->bufferram[i].blockpage = blockpage;
348147d4:	17840103 	strne	r0, [r4, r3, lsl #2]
		this->bufferram[i].blockpage = -1;
348147d8:	07842103 	streq	r2, [r4, r3, lsl #2]
}
348147dc:	e3a00000 	mov	r0, #0
348147e0:	e8bd8010 	pop	{r4, pc}

348147e4 <onenand_read_ecc>:
	if (!FLEXONENAND(this))
348147e4:	e590301c 	ldr	r3, [r0, #28]
{
348147e8:	e92d4070 	push	{r4, r5, r6, lr}
348147ec:	e1a04000 	mov	r4, r0
	if (!FLEXONENAND(this))
348147f0:	e3130c02 	tst	r3, #512	; 0x200
348147f4:	1a000005 	bne	34814810 <onenand_read_ecc+0x2c>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);
348147f8:	e5900000 	ldr	r0, [r0]
348147fc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814800:	e2800b7f 	add	r0, r0, #130048	; 0x1fc00
34814804:	e2800c02 	add	r0, r0, #512	; 0x200
34814808:	e12fff33 	blx	r3
3481480c:	e8bd8070 	pop	{r4, r5, r6, pc}
34814810:	e59f5044 	ldr	r5, [pc, #68]	; 3481485c <onenand_read_ecc+0x78>
	for (i = 0; i < 4; i++) {
34814814:	e59f6044 	ldr	r6, [pc, #68]	; 34814860 <onenand_read_ecc+0x7c>
		ecc = this->read_word(this->base
34814818:	e5940000 	ldr	r0, [r4]
3481481c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814820:	e0800085 	add	r0, r0, r5, lsl #1
34814824:	e12fff33 	blx	r3
		if (likely(!ecc))
34814828:	e3500000 	cmp	r0, #0
3481482c:	0a000003 	beq	34814840 <onenand_read_ecc+0x5c>
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
34814830:	e3013010 	movw	r3, #4112	; 0x1010
34814834:	e0033000 	and	r3, r3, r0
34814838:	e3530000 	cmp	r3, #0
3481483c:	1a000004 	bne	34814854 <onenand_read_ecc+0x70>
34814840:	e2855001 	add	r5, r5, #1
	for (i = 0; i < 4; i++) {
34814844:	e1550006 	cmp	r5, r6
34814848:	1afffff2 	bne	34814818 <onenand_read_ecc+0x34>
	return 0;
3481484c:	e3a00000 	mov	r0, #0
34814850:	e8bd8070 	pop	{r4, r5, r6, pc}
			return ONENAND_ECC_2BIT_ALL;
34814854:	e30a0aaa 	movw	r0, #43690	; 0xaaaa
}
34814858:	e8bd8070 	pop	{r4, r5, r6, pc}
3481485c:	0001fe00 	.word	0x0001fe00
34814860:	0001fe04 	.word	0x0001fe04

34814864 <onenand_bbt_wait>:
{
34814864:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34814868:	e5904094 	ldr	r4, [r0, #148]	; 0x94
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
3481486c:	e5940000 	ldr	r0, [r4]
34814870:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814874:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814878:	e2800082 	add	r0, r0, #130	; 0x82
3481487c:	e12fff33 	blx	r3
		if (interrupt & flags)
34814880:	e3100902 	tst	r0, #32768	; 0x8000
34814884:	0afffff8 	beq	3481486c <onenand_bbt_wait+0x8>
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814888:	e5940000 	ldr	r0, [r4]
3481488c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814890:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814894:	e2800082 	add	r0, r0, #130	; 0x82
34814898:	e12fff33 	blx	r3
3481489c:	e1a06000 	mov	r6, r0
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
348148a0:	e5940000 	ldr	r0, [r4]
348148a4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348148a8:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348148ac:	e2800080 	add	r0, r0, #128	; 0x80
348148b0:	e12fff33 	blx	r3
	if (interrupt & ONENAND_INT_READ) {
348148b4:	e3160080 	tst	r6, #128	; 0x80
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
348148b8:	e1a05000 	mov	r5, r0
	if (interrupt & ONENAND_INT_READ) {
348148bc:	0a00000a 	beq	348148ec <onenand_bbt_wait+0x88>
		int ecc = onenand_read_ecc(this);
348148c0:	e1a00004 	mov	r0, r4
348148c4:	ebffffc6 	bl	348147e4 <onenand_read_ecc>
348148c8:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
348148cc:	e30a0aaa 	movw	r0, #43690	; 0xaaaa
348148d0:	e0000001 	and	r0, r0, r1
348148d4:	e3500000 	cmp	r0, #0
348148d8:	0a000009 	beq	34814904 <onenand_bbt_wait+0xa0>
			printk(KERN_INFO "onenand_bbt_wait: ecc error = 0x%04x"
348148dc:	e1a02005 	mov	r2, r5
348148e0:	e59f0038 	ldr	r0, [pc, #56]	; 34814920 <onenand_bbt_wait+0xbc>
348148e4:	ebffd3ac 	bl	3480979c <printf>
348148e8:	ea00000a 	b	34814918 <onenand_bbt_wait+0xb4>
		printk(KERN_ERR "onenand_bbt_wait: read timeout!"
348148ec:	e1a01000 	mov	r1, r0
348148f0:	e1a02006 	mov	r2, r6
348148f4:	e59f0028 	ldr	r0, [pc, #40]	; 34814924 <onenand_bbt_wait+0xc0>
348148f8:	ebffd3a7 	bl	3480979c <printf>
		return ONENAND_BBT_READ_FATAL_ERROR;
348148fc:	e3a00004 	mov	r0, #4
34814900:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (ctrl & ONENAND_CTRL_ERROR) {
34814904:	e3150b01 	tst	r5, #1024	; 0x400
34814908:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
3481490c:	e1a01005 	mov	r1, r5
34814910:	e59f0010 	ldr	r0, [pc, #16]	; 34814928 <onenand_bbt_wait+0xc4>
34814914:	ebffd3a0 	bl	3480979c <printf>
		return ONENAND_BBT_READ_ERROR;
34814918:	e3a00001 	mov	r0, #1
}
3481491c:	e8bd8070 	pop	{r4, r5, r6, pc}
34814920:	3482623a 	.word	0x3482623a
34814924:	34826275 	.word	0x34826275
34814928:	348262ad 	.word	0x348262ad

3481492c <onenand_wait>:
{
3481492c:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34814930:	e5904094 	ldr	r4, [r0, #148]	; 0x94
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814934:	e5940000 	ldr	r0, [r4]
34814938:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481493c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814940:	e2800082 	add	r0, r0, #130	; 0x82
34814944:	e12fff33 	blx	r3
		if (interrupt & flags)
34814948:	e3100902 	tst	r0, #32768	; 0x8000
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
3481494c:	e1a06000 	mov	r6, r0
		if (interrupt & flags)
34814950:	0afffff7 	beq	34814934 <onenand_wait+0x8>
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814954:	e5940000 	ldr	r0, [r4]
34814958:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481495c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814960:	e2800080 	add	r0, r0, #128	; 0x80
34814964:	e12fff33 	blx	r3
	if (interrupt & ONENAND_INT_READ) {
34814968:	e3160080 	tst	r6, #128	; 0x80
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
3481496c:	e1a05000 	mov	r5, r0
	if (interrupt & ONENAND_INT_READ) {
34814970:	0a00000a 	beq	348149a0 <onenand_wait+0x74>
		int ecc = onenand_read_ecc(this);
34814974:	e1a00004 	mov	r0, r4
34814978:	ebffff99 	bl	348147e4 <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
3481497c:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
		int ecc = onenand_read_ecc(this);
34814980:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814984:	e0033000 	and	r3, r3, r0
34814988:	e3530000 	cmp	r3, #0
3481498c:	0a000003 	beq	348149a0 <onenand_wait+0x74>
			printk("onenand_wait: ECC error = 0x%04x\n", ecc);
34814990:	e59f0040 	ldr	r0, [pc, #64]	; 348149d8 <onenand_wait+0xac>
34814994:	ebffd380 	bl	3480979c <printf>
			return -EBADMSG;
34814998:	e3e00049 	mvn	r0, #73	; 0x49
3481499c:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (ctrl & ONENAND_CTRL_ERROR) {
348149a0:	e2050b01 	and	r0, r5, #1024	; 0x400
348149a4:	e6ff0070 	uxth	r0, r0
348149a8:	e3500000 	cmp	r0, #0
348149ac:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
348149b0:	e1a01005 	mov	r1, r5
348149b4:	e59f0020 	ldr	r0, [pc, #32]	; 348149dc <onenand_wait+0xb0>
348149b8:	ebffd377 	bl	3480979c <printf>
		if (ctrl & ONENAND_CTRL_LOCK)
348149bc:	e3150901 	tst	r5, #16384	; 0x4000
348149c0:	0a000002 	beq	348149d0 <onenand_wait+0xa4>
			printk("onenand_wait: it's locked error = 0x%04x\n",
348149c4:	e1a01005 	mov	r1, r5
348149c8:	e59f0010 	ldr	r0, [pc, #16]	; 348149e0 <onenand_wait+0xb4>
348149cc:	ebffd372 	bl	3480979c <printf>
		return -EIO;
348149d0:	e3e00004 	mvn	r0, #4
}
348149d4:	e8bd8070 	pop	{r4, r5, r6, pc}
348149d8:	348262da 	.word	0x348262da
348149dc:	348262fc 	.word	0x348262fc
348149e0:	34826325 	.word	0x34826325

348149e4 <onenand_fill_auto_oob.isra.10>:
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
348149e4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348149e8:	e1a0b001 	mov	fp, r1
	free = this->ecclayout->oobfree;
348149ec:	e590909c 	ldr	r9, [r0, #156]	; 0x9c
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
348149f0:	e1a0a002 	mov	sl, r2
	int writecol = column;
348149f4:	e1a07003 	mov	r7, r3
	int lastgap = 0;
348149f8:	e3a02000 	mov	r2, #0
	int writeend = column + thislen;
348149fc:	e59d5028 	ldr	r5, [sp, #40]	; 0x28
34814a00:	e2896e21 	add	r6, r9, #528	; 0x210
34814a04:	e2899e25 	add	r9, r9, #592	; 0x250
	free = this->ecclayout->oobfree;
34814a08:	e1a01006 	mov	r1, r6
	int writeend = column + thislen;
34814a0c:	e0835005 	add	r5, r3, r5
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814a10:	e511c004 	ldr	ip, [r1, #-4]
34814a14:	e35c0000 	cmp	ip, #0
34814a18:	0a000023 	beq	34814aac <onenand_fill_auto_oob.isra.10+0xc8>
34814a1c:	e5110008 	ldr	r0, [r1, #-8]
		if (writecol >= lastgap)
34814a20:	e1570002 	cmp	r7, r2
34814a24:	e2811008 	add	r1, r1, #8
34814a28:	a062e000 	rsbge	lr, r2, r0
			writecol += free->offset - lastgap;
34814a2c:	a08e7007 	addge	r7, lr, r7
		if (writeend >= lastgap)
34814a30:	e1550002 	cmp	r5, r2
34814a34:	a0622000 	rsbge	r2, r2, r0
			writeend += free->offset - lastgap;
34814a38:	a0825005 	addge	r5, r2, r5
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814a3c:	e1510009 	cmp	r1, r9
		lastgap = free->offset + free->length;
34814a40:	e08c2000 	add	r2, ip, r0
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814a44:	1afffff1 	bne	34814a10 <onenand_fill_auto_oob.isra.10+0x2c>
34814a48:	ea000017 	b	34814aac <onenand_fill_auto_oob.isra.10+0xc8>
		int free_end = free->offset + free->length;
34814a4c:	e5160008 	ldr	r0, [r6, #-8]
34814a50:	e0804004 	add	r4, r0, r4
		if (free->offset < writeend && free_end > writecol) {
34814a54:	e1540007 	cmp	r4, r7
34814a58:	d3a02000 	movle	r2, #0
34814a5c:	c3a02001 	movgt	r2, #1
34814a60:	e1500005 	cmp	r0, r5
34814a64:	23a02000 	movcs	r2, #0
34814a68:	e3520000 	cmp	r2, #0
34814a6c:	0a000012 	beq	34814abc <onenand_fill_auto_oob.isra.10+0xd8>
			int st = max_t(int,free->offset,writecol);
34814a70:	e1500007 	cmp	r0, r7
			memcpy(oob_buf + st, buf, n);
34814a74:	e1a0100a 	mov	r1, sl
			int st = max_t(int,free->offset,writecol);
34814a78:	b1a00007 	movlt	r0, r7
34814a7c:	e58d3004 	str	r3, [sp, #4]
			int n = ed - st;
34814a80:	e1540005 	cmp	r4, r5
34814a84:	d0604004 	rsble	r4, r0, r4
34814a88:	c0604005 	rsbgt	r4, r0, r5
			memcpy(oob_buf + st, buf, n);
34814a8c:	e08b0000 	add	r0, fp, r0
34814a90:	e1a02004 	mov	r2, r4
			buf += n;
34814a94:	e08aa004 	add	sl, sl, r4
			memcpy(oob_buf + st, buf, n);
34814a98:	eb001c57 	bl	3481bbfc <memcpy>
34814a9c:	e59d3004 	ldr	r3, [sp, #4]
34814aa0:	e2866008 	add	r6, r6, #8
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814aa4:	e1560009 	cmp	r6, r9
34814aa8:	0a000005 	beq	34814ac4 <onenand_fill_auto_oob.isra.10+0xe0>
34814aac:	e5164004 	ldr	r4, [r6, #-4]
34814ab0:	e3540000 	cmp	r4, #0
34814ab4:	1affffe4 	bne	34814a4c <onenand_fill_auto_oob.isra.10+0x68>
34814ab8:	ea000001 	b	34814ac4 <onenand_fill_auto_oob.isra.10+0xe0>
		} else if (column == 0)
34814abc:	e3530000 	cmp	r3, #0
34814ac0:	1afffff6 	bne	34814aa0 <onenand_fill_auto_oob.isra.10+0xbc>
}
34814ac4:	e3a00000 	mov	r0, #0
34814ac8:	e28dd008 	add	sp, sp, #8
34814acc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

34814ad0 <onenand_write_ops_nolock>:
{
34814ad0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34814ad4:	e24dd038 	sub	sp, sp, #56	; 0x38
34814ad8:	e59d9058 	ldr	r9, [sp, #88]	; 0x58
34814adc:	e1a05000 	mov	r5, r0
34814ae0:	e1cd21f0 	strd	r2, [sp, #16]
	size_t len = ops->len;
34814ae4:	e5993004 	ldr	r3, [r9, #4]
	struct onenand_chip *this = mtd->priv;
34814ae8:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	if (unlikely((to + len) > mtd->size)) {
34814aec:	e1cd01d0 	ldrd	r0, [sp, #16]
	size_t len = ops->len;
34814af0:	e58d301c 	str	r3, [sp, #28]
	size_t ooblen = ops->ooblen;
34814af4:	e599300c 	ldr	r3, [r9, #12]
34814af8:	e58d3034 	str	r3, [sp, #52]	; 0x34
	const u_char *buf = ops->datbuf;
34814afc:	e5993018 	ldr	r3, [r9, #24]
34814b00:	e58d3028 	str	r3, [sp, #40]	; 0x28
	const u_char *oob = ops->oobbuf;
34814b04:	e599301c 	ldr	r3, [r9, #28]
34814b08:	e58d3018 	str	r3, [sp, #24]
	ops->retlen = 0;
34814b0c:	e3a03000 	mov	r3, #0
34814b10:	e5893008 	str	r3, [r9, #8]
	ops->oobretlen = 0;
34814b14:	e5893010 	str	r3, [r9, #16]
	if (unlikely((to + len) > mtd->size)) {
34814b18:	e59d301c 	ldr	r3, [sp, #28]
34814b1c:	e0900003 	adds	r0, r0, r3
34814b20:	e1c520d8 	ldrd	r2, [r5, #8]
34814b24:	e2a11000 	adc	r1, r1, #0
34814b28:	e1510003 	cmp	r1, r3
34814b2c:	01500002 	cmpeq	r0, r2
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt write to past end of device\n");
34814b30:	859f02a4 	ldrhi	r0, [pc, #676]	; 34814ddc <onenand_write_ops_nolock+0x30c>
	if (unlikely((to + len) > mtd->size)) {
34814b34:	8a00000a 	bhi	34814b64 <onenand_write_ops_nolock+0x94>
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
34814b38:	e1cd01d0 	ldrd	r0, [sp, #16]
34814b3c:	e5963098 	ldr	r3, [r6, #152]	; 0x98
34814b40:	e2433001 	sub	r3, r3, #1
34814b44:	e0011fc3 	and	r1, r1, r3, asr #31
34814b48:	e0000003 	and	r0, r0, r3
34814b4c:	e1902001 	orrs	r2, r0, r1
34814b50:	1a000002 	bne	34814b60 <onenand_write_ops_nolock+0x90>
34814b54:	e59d201c 	ldr	r2, [sp, #28]
34814b58:	e1130002 	tst	r3, r2
34814b5c:	0a000003 	beq	34814b70 <onenand_write_ops_nolock+0xa0>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
34814b60:	e59f0278 	ldr	r0, [pc, #632]	; 34814de0 <onenand_write_ops_nolock+0x310>
34814b64:	ebffd30c 	bl	3480979c <printf>
		return -EINVAL;
34814b68:	e3e00015 	mvn	r0, #21
34814b6c:	ea000098 	b	34814dd4 <onenand_write_ops_nolock+0x304>
	if (ops->mode == MTD_OOB_AUTO)
34814b70:	e5993000 	ldr	r3, [r9]
	column = to & (mtd->writesize - 1);
34814b74:	e5954014 	ldr	r4, [r5, #20]
	if (ops->mode == MTD_OOB_AUTO)
34814b78:	e3530001 	cmp	r3, #1
34814b7c:	e5953018 	ldr	r3, [r5, #24]
		oobsize = this->ecclayout->oobavail;
34814b80:	0596209c 	ldreq	r2, [r6, #156]	; 0x9c
	column = to & (mtd->writesize - 1);
34814b84:	e2444001 	sub	r4, r4, #1
		oobsize = mtd->oobsize;
34814b88:	158d302c 	strne	r3, [sp, #44]	; 0x2c
	oobcolumn = to & (mtd->oobsize - 1);
34814b8c:	e2433001 	sub	r3, r3, #1
		oobsize = this->ecclayout->oobavail;
34814b90:	05922204 	ldreq	r2, [r2, #516]	; 0x204
34814b94:	058d202c 	streq	r2, [sp, #44]	; 0x2c
	oobcolumn = to & (mtd->oobsize - 1);
34814b98:	e59d2010 	ldr	r2, [sp, #16]
34814b9c:	e0033002 	and	r3, r3, r2
	column = to & (mtd->writesize - 1);
34814ba0:	e0044002 	and	r4, r4, r2
	oobcolumn = to & (mtd->oobsize - 1);
34814ba4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34814ba8:	e3a03000 	mov	r3, #0
	int written = 0, column, thislen, subpage;
34814bac:	e1a0a003 	mov	sl, r3
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34814bb0:	e58d3020 	str	r3, [sp, #32]
	while (written < len) {
34814bb4:	e59d301c 	ldr	r3, [sp, #28]
34814bb8:	e15a0003 	cmp	sl, r3
34814bbc:	2a000081 	bcs	34814dc8 <onenand_write_ops_nolock+0x2f8>
		thislen = min_t(int, mtd->writesize - column, len - written);
34814bc0:	e59d301c 	ldr	r3, [sp, #28]
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
34814bc4:	e3011978 	movw	r1, #6520	; 0x1978
34814bc8:	e1a00005 	mov	r0, r5
		thislen = min_t(int, mtd->writesize - column, len - written);
34814bcc:	e06a7003 	rsb	r7, sl, r3
34814bd0:	e5953014 	ldr	r3, [r5, #20]
34814bd4:	e0643003 	rsb	r3, r4, r3
34814bd8:	e1570003 	cmp	r7, r3
34814bdc:	a1a07003 	movge	r7, r3
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
34814be0:	e1cd21d0 	ldrd	r2, [sp, #16]
34814be4:	e58d7000 	str	r7, [sp]
34814be8:	e596b050 	ldr	fp, [r6, #80]	; 0x50
34814bec:	e12fff3b 	blx	fp
		subpage = thislen < mtd->writesize;
34814bf0:	e5952014 	ldr	r2, [r5, #20]
34814bf4:	e1570002 	cmp	r7, r2
34814bf8:	23a03000 	movcs	r3, #0
34814bfc:	33a03001 	movcc	r3, #1
		if (subpage) {
34814c00:	e3530000 	cmp	r3, #0
		subpage = thislen < mtd->writesize;
34814c04:	e58d3030 	str	r3, [sp, #48]	; 0x30
		u_char *wbuf = (u_char *) buf;
34814c08:	059d3028 	ldreq	r3, [sp, #40]	; 0x28
		if (subpage) {
34814c0c:	0a000008 	beq	34814c34 <onenand_write_ops_nolock+0x164>
			memset(this->page_buf, 0xff, mtd->writesize);
34814c10:	e3a010ff 	mov	r1, #255	; 0xff
34814c14:	e596008c 	ldr	r0, [r6, #140]	; 0x8c
34814c18:	eb001bd7 	bl	3481bb7c <memset>
			memcpy(this->page_buf + column, buf, thislen);
34814c1c:	e596008c 	ldr	r0, [r6, #140]	; 0x8c
34814c20:	e1a02007 	mov	r2, r7
34814c24:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34814c28:	e0800004 	add	r0, r0, r4
34814c2c:	eb001bf2 	bl	3481bbfc <memcpy>
			wbuf = this->page_buf;
34814c30:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
34814c34:	e5952014 	ldr	r2, [r5, #20]
34814c38:	e1a00005 	mov	r0, r5
34814c3c:	e58d3004 	str	r3, [sp, #4]
34814c40:	e3a03b01 	mov	r3, #1024	; 0x400
34814c44:	e58d3000 	str	r3, [sp]
34814c48:	e58d200c 	str	r2, [sp, #12]
34814c4c:	e3a02000 	mov	r2, #0
34814c50:	e58d2008 	str	r2, [sp, #8]
34814c54:	e1cd21d0 	ldrd	r2, [sp, #16]
34814c58:	e5961064 	ldr	r1, [r6, #100]	; 0x64
34814c5c:	e12fff31 	blx	r1
		if (oob) {
34814c60:	e59d3018 	ldr	r3, [sp, #24]
34814c64:	e3530000 	cmp	r3, #0
			oobbuf = (u_char *) ffchars;
34814c68:	059fb174 	ldreq	fp, [pc, #372]	; 34814de4 <onenand_write_ops_nolock+0x314>
		if (oob) {
34814c6c:	0a000023 	beq	34814d00 <onenand_write_ops_nolock+0x230>
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814c70:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
			memset(oobbuf, 0xff, mtd->oobsize);
34814c74:	e3a010ff 	mov	r1, #255	; 0xff
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814c78:	e59d2020 	ldr	r2, [sp, #32]
			oobbuf = this->oob_buf;
34814c7c:	e596b090 	ldr	fp, [r6, #144]	; 0x90
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814c80:	e0624003 	rsb	r4, r2, r3
34814c84:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34814c88:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
			memset(oobbuf, 0xff, mtd->oobsize);
34814c8c:	e1a0000b 	mov	r0, fp
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814c90:	e0623003 	rsb	r3, r2, r3
			memset(oobbuf, 0xff, mtd->oobsize);
34814c94:	e5952018 	ldr	r2, [r5, #24]
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814c98:	e1540003 	cmp	r4, r3
34814c9c:	a1a04003 	movge	r4, r3
			memset(oobbuf, 0xff, mtd->oobsize);
34814ca0:	eb001bb5 	bl	3481bb7c <memset>
			if (ops->mode == MTD_OOB_AUTO)
34814ca4:	e5993000 	ldr	r3, [r9]
34814ca8:	e3530001 	cmp	r3, #1
34814cac:	1a000006 	bne	34814ccc <onenand_write_ops_nolock+0x1fc>
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
34814cb0:	e58d4000 	str	r4, [sp]
34814cb4:	e1a0100b 	mov	r1, fp
34814cb8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34814cbc:	e59d2018 	ldr	r2, [sp, #24]
34814cc0:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34814cc4:	ebffff46 	bl	348149e4 <onenand_fill_auto_oob.isra.10>
34814cc8:	ea000004 	b	34814ce0 <onenand_write_ops_nolock+0x210>
				memcpy(oobbuf + oobcolumn, oob, thisooblen);
34814ccc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34814cd0:	e1a02004 	mov	r2, r4
34814cd4:	e59d1018 	ldr	r1, [sp, #24]
34814cd8:	e08b0003 	add	r0, fp, r3
34814cdc:	eb001bc6 	bl	3481bbfc <memcpy>
			oobwritten += thisooblen;
34814ce0:	e59d3020 	ldr	r3, [sp, #32]
34814ce4:	e0833004 	add	r3, r3, r4
34814ce8:	e58d3020 	str	r3, [sp, #32]
			oob += thisooblen;
34814cec:	e59d3018 	ldr	r3, [sp, #24]
34814cf0:	e0833004 	add	r3, r3, r4
34814cf4:	e58d3018 	str	r3, [sp, #24]
			oobcolumn = 0;
34814cf8:	e3a03000 	mov	r3, #0
34814cfc:	e58d3024 	str	r3, [sp, #36]	; 0x24
		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
34814d00:	e5953018 	ldr	r3, [r5, #24]
34814d04:	e3a02000 	mov	r2, #0
34814d08:	e58db004 	str	fp, [sp, #4]
34814d0c:	e1a00005 	mov	r0, r5
34814d10:	e58d300c 	str	r3, [sp, #12]
34814d14:	e3a03000 	mov	r3, #0
34814d18:	e58d3008 	str	r3, [sp, #8]
34814d1c:	e59f30c4 	ldr	r3, [pc, #196]	; 34814de8 <onenand_write_ops_nolock+0x318>
34814d20:	e58d3000 	str	r3, [sp]
34814d24:	e3a03000 	mov	r3, #0
34814d28:	e5961064 	ldr	r1, [r6, #100]	; 0x64
34814d2c:	e12fff31 	blx	r1
		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
34814d30:	e5953014 	ldr	r3, [r5, #20]
34814d34:	e3a01080 	mov	r1, #128	; 0x80
34814d38:	e1a00005 	mov	r0, r5
34814d3c:	e58d3000 	str	r3, [sp]
34814d40:	e1cd21d0 	ldrd	r2, [sp, #16]
34814d44:	e5964050 	ldr	r4, [r6, #80]	; 0x50
34814d48:	e12fff34 	blx	r4
		ret = this->wait(mtd, FL_WRITING);
34814d4c:	e5963054 	ldr	r3, [r6, #84]	; 0x54
34814d50:	e3a01002 	mov	r1, #2
34814d54:	e1a00005 	mov	r0, r5
34814d58:	e12fff33 	blx	r3
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34814d5c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
		ret = this->wait(mtd, FL_WRITING);
34814d60:	e1a04000 	mov	r4, r0
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34814d64:	e1903003 	orrs	r3, r0, r3
34814d68:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34814d6c:	03a03001 	moveq	r3, #1
34814d70:	13a03000 	movne	r3, #0
34814d74:	e58d3000 	str	r3, [sp]
34814d78:	e1cd21d0 	ldrd	r2, [sp, #16]
34814d7c:	ebfffe83 	bl	34814790 <onenand_update_bufferram.isra.4>
		if (ret) {
34814d80:	e3540000 	cmp	r4, #0
34814d84:	0a000003 	beq	34814d98 <onenand_write_ops_nolock+0x2c8>
			printk(KERN_ERR "onenand_write_ops_nolock: write filaed %d\n", ret);
34814d88:	e1a01004 	mov	r1, r4
34814d8c:	e59f0058 	ldr	r0, [pc, #88]	; 34814dec <onenand_write_ops_nolock+0x31c>
34814d90:	ebffd281 	bl	3480979c <printf>
			break;
34814d94:	ea00000c 	b	34814dcc <onenand_write_ops_nolock+0x2fc>
		if (written == len)
34814d98:	e59d301c 	ldr	r3, [sp, #28]
		written += thislen;
34814d9c:	e08aa007 	add	sl, sl, r7
		if (written == len)
34814da0:	e15a0003 	cmp	sl, r3
34814da4:	0a000008 	beq	34814dcc <onenand_write_ops_nolock+0x2fc>
		to += thislen;
34814da8:	e1cd21d0 	ldrd	r2, [sp, #16]
34814dac:	e0922007 	adds	r2, r2, r7
34814db0:	e0a33fc7 	adc	r3, r3, r7, asr #31
34814db4:	e1cd21f0 	strd	r2, [sp, #16]
		buf += thislen;
34814db8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34814dbc:	e0833007 	add	r3, r3, r7
34814dc0:	e58d3028 	str	r3, [sp, #40]	; 0x28
34814dc4:	eaffff7a 	b	34814bb4 <onenand_write_ops_nolock+0xe4>
34814dc8:	e3a04000 	mov	r4, #0
	return ret;
34814dcc:	e1a00004 	mov	r0, r4
	ops->retlen = written;
34814dd0:	e589a008 	str	sl, [r9, #8]
}
34814dd4:	e28dd038 	add	sp, sp, #56	; 0x38
34814dd8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814ddc:	3482634f 	.word	0x3482634f
34814de0:	3482638e 	.word	0x3482638e
34814de4:	34821428 	.word	0x34821428
34814de8:	00010020 	.word	0x00010020
34814dec:	348263d0 	.word	0x348263d0

34814df0 <onenand_write>:
{
34814df0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34814df4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34814df8:	e28d4008 	add	r4, sp, #8
{
34814dfc:	e1a05000 	mov	r5, r0
34814e00:	e1a06002 	mov	r6, r2
	struct mtd_oob_ops ops = {
34814e04:	e3a01000 	mov	r1, #0
34814e08:	e3a02020 	mov	r2, #32
34814e0c:	e1a00004 	mov	r0, r4
{
34814e10:	e1a07003 	mov	r7, r3
	struct mtd_oob_ops ops = {
34814e14:	eb001b58 	bl	3481bb7c <memset>
34814e18:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34814e1c:	e1a02006 	mov	r2, r6
34814e20:	e58d4000 	str	r4, [sp]
34814e24:	e1a00005 	mov	r0, r5
	struct mtd_oob_ops ops = {
34814e28:	e58d300c 	str	r3, [sp, #12]
34814e2c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
34814e30:	e58d3020 	str	r3, [sp, #32]
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34814e34:	e1a03007 	mov	r3, r7
34814e38:	ebffff24 	bl	34814ad0 <onenand_write_ops_nolock>
	*retlen = ops.retlen;
34814e3c:	e59d2010 	ldr	r2, [sp, #16]
34814e40:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34814e44:	e5832000 	str	r2, [r3]
}
34814e48:	e28dd02c 	add	sp, sp, #44	; 0x2c
34814e4c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34814e50 <onenand_write_oob_nolock>:
{
34814e50:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34814e54:	e24dd038 	sub	sp, sp, #56	; 0x38
34814e58:	e59db058 	ldr	fp, [sp, #88]	; 0x58
34814e5c:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
34814e60:	e5909094 	ldr	r9, [r0, #148]	; 0x94
	size_t len = ops->ooblen;
34814e64:	e59b100c 	ldr	r1, [fp, #12]
34814e68:	e5904018 	ldr	r4, [r0, #24]
34814e6c:	e58d1028 	str	r1, [sp, #40]	; 0x28
	const u_char *buf = ops->oobbuf;
34814e70:	e59b101c 	ldr	r1, [fp, #28]
34814e74:	e58d101c 	str	r1, [sp, #28]
	mtd_oob_mode_t mode = ops->mode;
34814e78:	e59b1000 	ldr	r1, [fp]
34814e7c:	e58d102c 	str	r1, [sp, #44]	; 0x2c
	to += ops->ooboffs;
34814e80:	e59b1014 	ldr	r1, [fp, #20]
34814e84:	e0926001 	adds	r6, r2, r1
34814e88:	e2a37000 	adc	r7, r3, #0
	ops->oobretlen = 0;
34814e8c:	e3a03000 	mov	r3, #0
34814e90:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
34814e94:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
	to += ops->ooboffs;
34814e98:	e1cd61f0 	strd	r6, [sp, #16]
	if (mode == MTD_OOB_AUTO)
34814e9c:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34814ea0:	0599309c 	ldreq	r3, [r9, #156]	; 0x9c
		oobsize = mtd->oobsize;
34814ea4:	11a0a004 	movne	sl, r4
	column = to & (mtd->oobsize - 1);
34814ea8:	e2444001 	sub	r4, r4, #1
		oobsize = this->ecclayout->oobavail;
34814eac:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	column = to & (mtd->oobsize - 1);
34814eb0:	e59d3010 	ldr	r3, [sp, #16]
34814eb4:	e0044003 	and	r4, r4, r3
	if (unlikely(column >= oobsize)) {
34814eb8:	e154000a 	cmp	r4, sl
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
34814ebc:	a59f0268 	ldrge	r0, [pc, #616]	; 3481512c <onenand_write_oob_nolock+0x2dc>
	if (unlikely(column >= oobsize)) {
34814ec0:	aa000004 	bge	34814ed8 <onenand_write_oob_nolock+0x88>
	if (unlikely(column + len > oobsize)) {
34814ec4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34814ec8:	e0843003 	add	r3, r4, r3
34814ecc:	e153000a 	cmp	r3, sl
34814ed0:	9a000003 	bls	34814ee4 <onenand_write_oob_nolock+0x94>
		printk(KERN_ERR "onenand_write_oob_nolock: "
34814ed4:	e59f0254 	ldr	r0, [pc, #596]	; 34815130 <onenand_write_oob_nolock+0x2e0>
34814ed8:	ebffd22f 	bl	3480979c <printf>
		return -EINVAL;
34814edc:	e3e00015 	mvn	r0, #21
34814ee0:	ea00008f 	b	34815124 <onenand_write_oob_nolock+0x2d4>
	if (unlikely(to >= mtd->size ||
34814ee4:	e1c500d8 	ldrd	r0, [r5, #8]
34814ee8:	e1cd02f0 	strd	r0, [sp, #32]
34814eec:	e1cd62d0 	ldrd	r6, [sp, #32]
34814ef0:	e1cd01d0 	ldrd	r0, [sp, #16]
34814ef4:	e1510007 	cmp	r1, r7
34814ef8:	01500006 	cmpeq	r0, r6
34814efc:	2a000017 	bcs	34814f60 <onenand_write_oob_nolock+0x110>
34814f00:	e5996034 	ldr	r6, [r9, #52]	; 0x34
34814f04:	e1a00003 	mov	r0, r3
34814f08:	e3a01000 	mov	r1, #0
34814f0c:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
34814f10:	e1a02006 	mov	r2, r6
34814f14:	e1cd02d0 	ldrd	r0, [sp, #32]
34814f18:	fa00298a 	blx	3481f548 <__lshrdi3>
34814f1c:	e1a02006 	mov	r2, r6
34814f20:	e1cd02f0 	strd	r0, [sp, #32]
34814f24:	e1cd01d0 	ldrd	r0, [sp, #16]
34814f28:	fa00298c 	blx	3481f560 <__ashrdi3>
34814f2c:	e1cd22d0 	ldrd	r2, [sp, #32]
34814f30:	e0522000 	subs	r2, r2, r0
34814f34:	e0c33001 	sbc	r3, r3, r1
34814f38:	e1a06002 	mov	r6, r2
34814f3c:	e001039a 	mul	r1, sl, r3
34814f40:	e1a03fca 	asr	r3, sl, #31
34814f44:	e0231396 	mla	r3, r6, r3, r1
34814f48:	e081069a 	umull	r0, r1, sl, r6
34814f4c:	e0831001 	add	r1, r3, r1
34814f50:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
34814f54:	e1530001 	cmp	r3, r1
34814f58:	01520000 	cmpeq	r2, r0
34814f5c:	9a000001 	bls	34814f68 <onenand_write_oob_nolock+0x118>
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
34814f60:	e59f01cc 	ldr	r0, [pc, #460]	; 34815134 <onenand_write_oob_nolock+0x2e4>
34814f64:	eaffffdb 	b	34814ed8 <onenand_write_oob_nolock+0x88>
	oobbuf = this->oob_buf;
34814f68:	e5993090 	ldr	r3, [r9, #144]	; 0x90
	int written = 0, oobcmd;
34814f6c:	e3a07000 	mov	r7, #0
	oobbuf = this->oob_buf;
34814f70:	e58d3020 	str	r3, [sp, #32]
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
34814f74:	e599302c 	ldr	r3, [r9, #44]	; 0x2c
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
34814f78:	e3130008 	tst	r3, #8
34814f7c:	13a03080 	movne	r3, #128	; 0x80
34814f80:	03a0301a 	moveq	r3, #26
34814f84:	e58d3030 	str	r3, [sp, #48]	; 0x30
	while (written < len) {
34814f88:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34814f8c:	e1570003 	cmp	r7, r3
34814f90:	2a000060 	bcs	34815118 <onenand_write_oob_nolock+0x2c8>
		int thislen = min_t(int, oobsize, len - written);
34814f94:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
34814f98:	e3011978 	movw	r1, #6520	; 0x1978
34814f9c:	e1a00005 	mov	r0, r5
		int thislen = min_t(int, oobsize, len - written);
34814fa0:	e0676003 	rsb	r6, r7, r3
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
34814fa4:	e5953018 	ldr	r3, [r5, #24]
		int thislen = min_t(int, oobsize, len - written);
34814fa8:	e156000a 	cmp	r6, sl
34814fac:	a1a0600a 	movge	r6, sl
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
34814fb0:	e58d3000 	str	r3, [sp]
34814fb4:	e1cd21d0 	ldrd	r2, [sp, #16]
34814fb8:	e599c050 	ldr	ip, [r9, #80]	; 0x50
34814fbc:	e12fff3c 	blx	ip
		memset(oobbuf, 0xff, mtd->oobsize);
34814fc0:	e5952018 	ldr	r2, [r5, #24]
34814fc4:	e3a010ff 	mov	r1, #255	; 0xff
34814fc8:	e59d0020 	ldr	r0, [sp, #32]
34814fcc:	eb001aea 	bl	3481bb7c <memset>
		if (mode == MTD_OOB_AUTO)
34814fd0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
34814fd4:	e3530001 	cmp	r3, #1
34814fd8:	1a000006 	bne	34814ff8 <onenand_write_oob_nolock+0x1a8>
			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
34814fdc:	e58d6000 	str	r6, [sp]
34814fe0:	e1a03004 	mov	r3, r4
34814fe4:	e59d201c 	ldr	r2, [sp, #28]
34814fe8:	e59d1020 	ldr	r1, [sp, #32]
34814fec:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34814ff0:	ebfffe7b 	bl	348149e4 <onenand_fill_auto_oob.isra.10>
34814ff4:	ea000004 	b	3481500c <onenand_write_oob_nolock+0x1bc>
			memcpy(oobbuf + column, buf, thislen);
34814ff8:	e59d3020 	ldr	r3, [sp, #32]
34814ffc:	e1a02006 	mov	r2, r6
34815000:	e59d101c 	ldr	r1, [sp, #28]
34815004:	e0830004 	add	r0, r3, r4
34815008:	eb001afb 	bl	3481bbfc <memcpy>
		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
3481500c:	e5953018 	ldr	r3, [r5, #24]
34815010:	e3a04000 	mov	r4, #0
34815014:	e58d4008 	str	r4, [sp, #8]
34815018:	e3a02000 	mov	r2, #0
3481501c:	e1a00005 	mov	r0, r5
34815020:	e58d300c 	str	r3, [sp, #12]
34815024:	e59d3020 	ldr	r3, [sp, #32]
34815028:	e58d3004 	str	r3, [sp, #4]
3481502c:	e59f3104 	ldr	r3, [pc, #260]	; 34815138 <onenand_write_oob_nolock+0x2e8>
34815030:	e58d3000 	str	r3, [sp]
34815034:	e3a03000 	mov	r3, #0
34815038:	e5991064 	ldr	r1, [r9, #100]	; 0x64
3481503c:	e12fff31 	blx	r1
		if (ONENAND_IS_4KB_PAGE(this)) {
34815040:	e599302c 	ldr	r3, [r9, #44]	; 0x2c
34815044:	e3130008 	tst	r3, #8
34815048:	0a00000f 	beq	3481508c <onenand_write_oob_nolock+0x23c>
			memset(this->page_buf, 0xff, mtd->writesize);
3481504c:	e5952014 	ldr	r2, [r5, #20]
34815050:	e3a010ff 	mov	r1, #255	; 0xff
34815054:	e599008c 	ldr	r0, [r9, #140]	; 0x8c
34815058:	eb001ac7 	bl	3481bb7c <memset>
			this->write_bufferram(mtd, 0, ONENAND_DATARAM,
3481505c:	e5953014 	ldr	r3, [r5, #20]
34815060:	e3a02000 	mov	r2, #0
34815064:	e58d4008 	str	r4, [sp, #8]
34815068:	e1a00005 	mov	r0, r5
3481506c:	e58d300c 	str	r3, [sp, #12]
34815070:	e599308c 	ldr	r3, [r9, #140]	; 0x8c
34815074:	e58d3004 	str	r3, [sp, #4]
34815078:	e3a03b01 	mov	r3, #1024	; 0x400
3481507c:	e58d3000 	str	r3, [sp]
34815080:	e3a03000 	mov	r3, #0
34815084:	e5991064 	ldr	r1, [r9, #100]	; 0x64
34815088:	e12fff31 	blx	r1
		this->command(mtd, oobcmd, to, mtd->oobsize);
3481508c:	e5953018 	ldr	r3, [r5, #24]
34815090:	e1a00005 	mov	r0, r5
34815094:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34815098:	e58d3000 	str	r3, [sp]
3481509c:	e1cd21d0 	ldrd	r2, [sp, #16]
348150a0:	e5994050 	ldr	r4, [r9, #80]	; 0x50
348150a4:	e12fff34 	blx	r4
		onenand_update_bufferram(mtd, to, 0);
348150a8:	e3a03000 	mov	r3, #0
348150ac:	e5950094 	ldr	r0, [r5, #148]	; 0x94
348150b0:	e58d3000 	str	r3, [sp]
348150b4:	e1cd21d0 	ldrd	r2, [sp, #16]
348150b8:	ebfffdb4 	bl	34814790 <onenand_update_bufferram.isra.4>
		ret = this->wait(mtd, FL_WRITING);
348150bc:	e5993054 	ldr	r3, [r9, #84]	; 0x54
348150c0:	e3a01002 	mov	r1, #2
348150c4:	e1a00005 	mov	r0, r5
348150c8:	e12fff33 	blx	r3
		if (ret) {
348150cc:	e2504000 	subs	r4, r0, #0
348150d0:	0a000003 	beq	348150e4 <onenand_write_oob_nolock+0x294>
			printk(KERN_ERR "onenand_write_oob_nolock: write failed %d\n", ret);
348150d4:	e1a01004 	mov	r1, r4
348150d8:	e59f005c 	ldr	r0, [pc, #92]	; 3481513c <onenand_write_oob_nolock+0x2ec>
348150dc:	ebffd1ae 	bl	3480979c <printf>
			break;
348150e0:	ea00000d 	b	3481511c <onenand_write_oob_nolock+0x2cc>
		if (written == len)
348150e4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
		written += thislen;
348150e8:	e0877006 	add	r7, r7, r6
		if (written == len)
348150ec:	e1570003 	cmp	r7, r3
348150f0:	0a000009 	beq	3481511c <onenand_write_oob_nolock+0x2cc>
		to += mtd->writesize;
348150f4:	e1cd01d0 	ldrd	r0, [sp, #16]
348150f8:	e5953014 	ldr	r3, [r5, #20]
348150fc:	e0900003 	adds	r0, r0, r3
		buf += thislen;
34815100:	e59d301c 	ldr	r3, [sp, #28]
		to += mtd->writesize;
34815104:	e2a11000 	adc	r1, r1, #0
34815108:	e1cd01f0 	strd	r0, [sp, #16]
		buf += thislen;
3481510c:	e0833006 	add	r3, r3, r6
34815110:	e58d301c 	str	r3, [sp, #28]
34815114:	eaffff9b 	b	34814f88 <onenand_write_oob_nolock+0x138>
34815118:	e3a04000 	mov	r4, #0
	return ret;
3481511c:	e1a00004 	mov	r0, r4
	ops->oobretlen = written;
34815120:	e58b7010 	str	r7, [fp, #16]
}
34815124:	e28dd038 	add	sp, sp, #56	; 0x38
34815128:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481512c:	348263fb 	.word	0x348263fb
34815130:	3482643b 	.word	0x3482643b
34815134:	34826478 	.word	0x34826478
34815138:	00010020 	.word	0x00010020
3481513c:	348264b9 	.word	0x348264b9

34815140 <onenand_write_oob>:
{
34815140:	e59d1000 	ldr	r1, [sp]
	switch (ops->mode) {
34815144:	e591c000 	ldr	ip, [r1]
34815148:	e35c0001 	cmp	ip, #1
3481514c:	8a000005 	bhi	34815168 <onenand_write_oob+0x28>
	if (ops->datbuf)
34815150:	e591c018 	ldr	ip, [r1, #24]
34815154:	e35c0000 	cmp	ip, #0
34815158:	0a000000 	beq	34815160 <onenand_write_oob+0x20>
		ret = onenand_write_ops_nolock(mtd, to, ops);
3481515c:	eafffe5b 	b	34814ad0 <onenand_write_ops_nolock>
		ret = onenand_write_oob_nolock(mtd, to, ops);
34815160:	e58d1000 	str	r1, [sp]
34815164:	eaffff39 	b	34814e50 <onenand_write_oob_nolock>
}
34815168:	e3e00015 	mvn	r0, #21
3481516c:	e12fff1e 	bx	lr

34815170 <onenand_block_isbad_nolock.constprop.14>:
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
34815170:	e92d4007 	push	{r0, r1, r2, lr}
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34815174:	e3a0c000 	mov	ip, #0
	struct bbm_info *bbm = this->bbm;
34815178:	e5901094 	ldr	r1, [r0, #148]	; 0x94
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
3481517c:	e59110a0 	ldr	r1, [r1, #160]	; 0xa0
34815180:	e58dc000 	str	ip, [sp]
34815184:	e5911010 	ldr	r1, [r1, #16]
34815188:	e12fff31 	blx	r1
}
3481518c:	e28dd00c 	add	sp, sp, #12
34815190:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34815194 <onenand_block_isbad>:
{
34815194:	e92d0030 	push	{r4, r5}
	if (ofs > mtd->size)
34815198:	e1c040d8 	ldrd	r4, [r0, #8]
3481519c:	e1530005 	cmp	r3, r5
348151a0:	01520004 	cmpeq	r2, r4
348151a4:	8a000001 	bhi	348151b0 <onenand_block_isbad+0x1c>
}
348151a8:	e8bd0030 	pop	{r4, r5}
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
348151ac:	eaffffef 	b	34815170 <onenand_block_isbad_nolock.constprop.14>
}
348151b0:	e3e00015 	mvn	r0, #21
348151b4:	e8bd0030 	pop	{r4, r5}
348151b8:	e12fff1e 	bx	lr

348151bc <onenand_block_markbad>:
{
348151bc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
348151c0:	e1a04000 	mov	r4, r0
348151c4:	e1a06002 	mov	r6, r2
348151c8:	e1a07003 	mov	r7, r3
	struct onenand_chip *this = mtd->priv;
348151cc:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	ret = onenand_block_isbad(mtd, ofs);
348151d0:	ebffffef 	bl	34815194 <onenand_block_isbad>
	if (ret) {
348151d4:	e3500000 	cmp	r0, #0
348151d8:	1a000005 	bne	348151f4 <onenand_block_markbad+0x38>
	ret = this->block_markbad(mtd, ofs);
348151dc:	e5951078 	ldr	r1, [r5, #120]	; 0x78
348151e0:	e1a02006 	mov	r2, r6
348151e4:	e1a03007 	mov	r3, r7
348151e8:	e1a00004 	mov	r0, r4
}
348151ec:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	ret = this->block_markbad(mtd, ofs);
348151f0:	e12fff11 	bx	r1
348151f4:	e0000fc0 	and	r0, r0, r0, asr #31
}
348151f8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

348151fc <onenand_block>:
{
348151fc:	e92d4070 	push	{r4, r5, r6, lr}
34815200:	e1a05000 	mov	r5, r0
	if (!FLEXONENAND(this))
34815204:	e595401c 	ldr	r4, [r5, #28]
{
34815208:	e1a00002 	mov	r0, r2
3481520c:	e1a01003 	mov	r1, r3
	if (!FLEXONENAND(this))
34815210:	e3140c02 	tst	r4, #512	; 0x200
34815214:	1a000002 	bne	34815224 <onenand_block+0x28>
		return addr >> this->erase_shift;
34815218:	e5952030 	ldr	r2, [r5, #48]	; 0x30
3481521c:	fa0028cf 	blx	3481f560 <__ashrdi3>
34815220:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
34815224:	e2144008 	ands	r4, r4, #8
34815228:	0a000008 	beq	34815250 <onenand_block+0x54>
3481522c:	e5952010 	ldr	r2, [r5, #16]
34815230:	e3a03000 	mov	r3, #0
34815234:	e1500002 	cmp	r0, r2
34815238:	e0d1c003 	sbcs	ip, r1, r3
	unsigned int boundary, blk, die = 0;
3481523c:	b3a04000 	movlt	r4, #0
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
34815240:	ba000002 	blt	34815250 <onenand_block+0x54>
		addr -= this->diesize[0];
34815244:	e0500002 	subs	r0, r0, r2
		die = 1;
34815248:	e3a04001 	mov	r4, #1
		addr -= this->diesize[0];
3481524c:	e0c11003 	sbc	r1, r1, r3
	boundary = this->boundary[die];
34815250:	e2843002 	add	r3, r4, #2
	blk = addr >> (this->erase_shift - 1);
34815254:	e5952030 	ldr	r2, [r5, #48]	; 0x30
	boundary = this->boundary[die];
34815258:	e7956103 	ldr	r6, [r5, r3, lsl #2]
	blk = addr >> (this->erase_shift - 1);
3481525c:	e2422001 	sub	r2, r2, #1
34815260:	fa0028be 	blx	3481f560 <__ashrdi3>
	if (blk > boundary)
34815264:	e1500006 	cmp	r0, r6
34815268:	82866001 	addhi	r6, r6, #1
		blk = (blk + boundary + 1) >> 1;
3481526c:	80860000 	addhi	r0, r6, r0
34815270:	81a000a0 	lsrhi	r0, r0, #1
	blk += die ? this->density_mask : 0;
34815274:	e3540000 	cmp	r4, #0
34815278:	15954028 	ldrne	r4, [r5, #40]	; 0x28
3481527c:	e0840000 	add	r0, r4, r0
}
34815280:	e8bd8070 	pop	{r4, r5, r6, pc}

34815284 <onenand_default_block_markbad>:
{
34815284:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
34815288:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct onenand_chip *this = mtd->priv;
3481528c:	e590a094 	ldr	sl, [r0, #148]	; 0x94
	struct mtd_oob_ops ops = {
34815290:	e28d7010 	add	r7, sp, #16
	u_char buf[2] = {0, 0};
34815294:	e3a01000 	mov	r1, #0
{
34815298:	e1a06000 	mov	r6, r0
3481529c:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
348152a0:	e1a00007 	mov	r0, r7
348152a4:	e3a02020 	mov	r2, #32
{
348152a8:	e1a05003 	mov	r5, r3
	u_char buf[2] = {0, 0};
348152ac:	e5cd100c 	strb	r1, [sp, #12]
348152b0:	e5cd100d 	strb	r1, [sp, #13]
	struct bbm_info *bbm = this->bbm;
348152b4:	e59a90a0 	ldr	r9, [sl, #160]	; 0xa0
	struct mtd_oob_ops ops = {
348152b8:	eb001a2f 	bl	3481bb7c <memset>
348152bc:	e3a03002 	mov	r3, #2
	block = onenand_block(this, ofs);
348152c0:	e1a02004 	mov	r2, r4
	struct mtd_oob_ops ops = {
348152c4:	e58d301c 	str	r3, [sp, #28]
348152c8:	e28d300c 	add	r3, sp, #12
348152cc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	block = onenand_block(this, ofs);
348152d0:	e1a0000a 	mov	r0, sl
348152d4:	e1a03005 	mov	r3, r5
348152d8:	ebffffc7 	bl	348151fc <onenand_block>
	if (bbm->bbt)
348152dc:	e599300c 	ldr	r3, [r9, #12]
348152e0:	e3530000 	cmp	r3, #0
		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
348152e4:	17d31140 	ldrbne	r1, [r3, r0, asr #2]
348152e8:	12002003 	andne	r2, r0, #3
348152ec:	11a02082 	lslne	r2, r2, #1
348152f0:	13a0c001 	movne	ip, #1
348152f4:	1181221c 	orrne	r2, r1, ip, lsl r2
348152f8:	17c32140 	strbne	r2, [r3, r0, asr #2]
	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
348152fc:	e5992004 	ldr	r2, [r9, #4]
34815300:	e5963018 	ldr	r3, [r6, #24]
	return onenand_write_oob_nolock(mtd, ofs, &ops);
34815304:	e58d7000 	str	r7, [sp]
	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
34815308:	e3c22001 	bic	r2, r2, #1
3481530c:	e0822003 	add	r2, r2, r3
	return onenand_write_oob_nolock(mtd, ofs, &ops);
34815310:	e0940002 	adds	r0, r4, r2
34815314:	e2a51000 	adc	r1, r5, #0
34815318:	e1a02000 	mov	r2, r0
3481531c:	e1a03001 	mov	r3, r1
34815320:	e1a00006 	mov	r0, r6
34815324:	ebfffec9 	bl	34814e50 <onenand_write_oob_nolock>
}
34815328:	e28dd034 	add	sp, sp, #52	; 0x34
3481532c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

34815330 <onenand_addr>:
	if (!FLEXONENAND(this))
34815330:	e590c01c 	ldr	ip, [r0, #28]
{
34815334:	e1a03000 	mov	r3, r0
	if (!FLEXONENAND(this))
34815338:	e31c0c02 	tst	ip, #512	; 0x200
3481533c:	1a000005 	bne	34815358 <onenand_addr+0x28>
{
34815340:	e92d4010 	push	{r4, lr}
34815344:	e1a00001 	mov	r0, r1
		return (loff_t) block << this->erase_shift;
34815348:	e5932030 	ldr	r2, [r3, #48]	; 0x30
3481534c:	e1a01fc1 	asr	r1, r1, #31
34815350:	fa002889 	blx	3481f57c <__ashldi3>
34815354:	e8bd8010 	pop	{r4, pc}
	return flexonenand_addr(this, block);
34815358:	eafffb00 	b	34813f60 <flexonenand_addr>

3481535c <onenand_command>:
	switch (cmd) {
3481535c:	e351002c 	cmp	r1, #44	; 0x2c
{
34815360:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815364:	e1a06001 	mov	r6, r1
	struct onenand_chip *this = mtd->priv;
34815368:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	switch (cmd) {
3481536c:	0a000074 	beq	34815544 <onenand_command+0x1e8>
34815370:	e1a07002 	mov	r7, r2
34815374:	e594a000 	ldr	sl, [r4]
34815378:	e594906c 	ldr	r9, [r4, #108]	; 0x6c
3481537c:	ca000006 	bgt	3481539c <onenand_command+0x40>
34815380:	e3510027 	cmp	r1, #39	; 0x27
34815384:	0a00006e 	beq	34815544 <onenand_command+0x1e8>
34815388:	e351002a 	cmp	r1, #42	; 0x2a
3481538c:	0a00006c 	beq	34815544 <onenand_command+0x1e8>
34815390:	e3510023 	cmp	r1, #35	; 0x23
34815394:	1a00001a 	bne	34815404 <onenand_command+0xa8>
34815398:	ea000069 	b	34815544 <onenand_command+0x1e8>
3481539c:	e3510094 	cmp	r1, #148	; 0x94
348153a0:	0a000011 	beq	348153ec <onenand_command+0x90>
348153a4:	ca000005 	bgt	348153c0 <onenand_command+0x64>
348153a8:	e3510066 	cmp	r1, #102	; 0x66
		block = addr * this->density_mask;
348153ac:	05945028 	ldreq	r5, [r4, #40]	; 0x28
		page = -1;
348153b0:	03e07000 	mvneq	r7, #0
		block = addr * this->density_mask;
348153b4:	00050592 	muleq	r5, r2, r5
	switch (cmd) {
348153b8:	0a00002d 	beq	34815474 <onenand_command+0x118>
348153bc:	ea000010 	b	34815404 <onenand_command+0xa8>
348153c0:	e3012978 	movw	r2, #6520	; 0x1978
348153c4:	e1510002 	cmp	r1, r2
348153c8:	0a000007 	beq	348153ec <onenand_command+0x90>
348153cc:	e3012985 	movw	r2, #6533	; 0x1985
348153d0:	e1510002 	cmp	r1, r2
348153d4:	1a00000a 	bne	34815404 <onenand_command+0xa8>
		block = addr * this->density_mask;
348153d8:	e5945028 	ldr	r5, [r4, #40]	; 0x28
348153dc:	e0050597 	mul	r5, r7, r5
		page = 0;
348153e0:	e3a07000 	mov	r7, #0
		cmd = ONENAND_CMD_READ;
348153e4:	e1a06007 	mov	r6, r7
		break;
348153e8:	ea000021 	b	34815474 <onenand_command+0x118>
		block = onenand_block(this, addr);
348153ec:	e1a02007 	mov	r2, r7
348153f0:	e1a00004 	mov	r0, r4
348153f4:	ebffff80 	bl	348151fc <onenand_block>
		page = -1;
348153f8:	e3e07000 	mvn	r7, #0
		block = onenand_block(this, addr);
348153fc:	e1a05000 	mov	r5, r0
		break;
34815400:	ea00000a 	b	34815430 <onenand_command+0xd4>
		block = onenand_block(this, addr);
34815404:	e1a02007 	mov	r2, r7
34815408:	e1a00004 	mov	r0, r4
3481540c:	ebffff7a 	bl	348151fc <onenand_block>
			- onenand_addr(this, block)) >> this->page_shift;
34815410:	e1a01000 	mov	r1, r0
		block = onenand_block(this, addr);
34815414:	e1a05000 	mov	r5, r0
			- onenand_addr(this, block)) >> this->page_shift;
34815418:	e1a00004 	mov	r0, r4
3481541c:	ebffffc3 	bl	34815330 <onenand_addr>
		page &= this->page_mask;
34815420:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		page = (int) (addr
34815424:	e0600007 	rsb	r0, r0, r7
34815428:	e5947034 	ldr	r7, [r4, #52]	; 0x34
		page &= this->page_mask;
3481542c:	e0037750 	and	r7, r3, r0, asr r7
	if (cmd == ONENAND_CMD_BUFFERRAM) {
34815430:	e3013978 	movw	r3, #6520	; 0x1978
34815434:	e1560003 	cmp	r6, r3
34815438:	1a00000d 	bne	34815474 <onenand_command+0x118>
	if (block & this->density_mask)
3481543c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value,
34815440:	e59f1134 	ldr	r1, [pc, #308]	; 3481557c <onenand_command+0x220>
	return ONENAND_DDP_CHIP0;
34815444:	e1150003 	tst	r5, r3
		this->write_word(value,
34815448:	13a00902 	movne	r0, #32768	; 0x8000
3481544c:	03a00000 	moveq	r0, #0
34815450:	e08a1001 	add	r1, sl, r1
34815454:	e12fff39 	blx	r9
		if (ONENAND_IS_4KB_PAGE(this))
34815458:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481545c:	e3130008 	tst	r3, #8
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815460:	05943044 	ldreq	r3, [r4, #68]	; 0x44
			ONENAND_SET_BUFFERRAM0(this);
34815464:	13a03000 	movne	r3, #0
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815468:	02233001 	eoreq	r3, r3, #1
3481546c:	e5843044 	str	r3, [r4, #68]	; 0x44
34815470:	ea00003f 	b	34815574 <onenand_command+0x218>
	if (block != -1) {
34815474:	e3750001 	cmn	r5, #1
34815478:	0a000011 	beq	348154c4 <onenand_command+0x168>
3481547c:	e5940028 	ldr	r0, [r4, #40]	; 0x28
		this->write_word(value,
34815480:	e28a1a1e 	add	r1, sl, #122880	; 0x1e000
34815484:	e2811c02 	add	r1, r1, #512	; 0x200
	if (block & this->density_mask)
34815488:	e1150000 	tst	r5, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
3481548c:	10200005 	eorne	r0, r0, r5
	if (block & this->density_mask)
34815490:	01a00005 	moveq	r0, r5
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34815494:	13800902 	orrne	r0, r0, #32768	; 0x8000
		this->write_word(value,
34815498:	e6ff0070 	uxth	r0, r0
3481549c:	e12fff39 	blx	r9
	if (block & this->density_mask)
348154a0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value,
348154a4:	e5942000 	ldr	r2, [r4]
348154a8:	e59f10cc 	ldr	r1, [pc, #204]	; 3481557c <onenand_command+0x220>
	return ONENAND_DDP_CHIP0;
348154ac:	e1150003 	tst	r5, r3
		this->write_word(value,
348154b0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348154b4:	13a00902 	movne	r0, #32768	; 0x8000
348154b8:	03a00000 	moveq	r0, #0
348154bc:	e0821001 	add	r1, r2, r1
348154c0:	e12fff33 	blx	r3
	if (page != -1) {
348154c4:	e3770001 	cmn	r7, #1
348154c8:	0a00001d 	beq	34815544 <onenand_command+0x1e8>
348154cc:	e3560013 	cmp	r6, #19
348154d0:	8a00000c 	bhi	34815508 <onenand_command+0x1ac>
348154d4:	e3a02001 	mov	r2, #1
348154d8:	e59f30a0 	ldr	r3, [pc, #160]	; 34815580 <onenand_command+0x224>
348154dc:	e1a02612 	lsl	r2, r2, r6
348154e0:	e0033002 	and	r3, r3, r2
348154e4:	e3530000 	cmp	r3, #0
348154e8:	0a000006 	beq	34815508 <onenand_command+0x1ac>
			if (ONENAND_IS_4KB_PAGE(this))
348154ec:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348154f0:	e3130008 	tst	r3, #8
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
348154f4:	05945044 	ldreq	r5, [r4, #68]	; 0x44
				dataram = ONENAND_SET_BUFFERRAM0(this);
348154f8:	13a05000 	movne	r5, #0
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
348154fc:	02255001 	eoreq	r5, r5, #1
34815500:	e5845044 	str	r5, [r4, #68]	; 0x44
34815504:	ea000000 	b	3481550c <onenand_command+0x1b0>
			dataram = ONENAND_CURRENT_BUFFERRAM(this);
34815508:	e5945044 	ldr	r5, [r4, #68]	; 0x44
		this->write_word(value,
3481550c:	e5942000 	ldr	r2, [r4]
	fpa = page & ONENAND_FPA_MASK;
34815510:	e207007f 	and	r0, r7, #127	; 0x7f
		this->write_word(value,
34815514:	e59f1068 	ldr	r1, [pc, #104]	; 34815584 <onenand_command+0x228>
34815518:	e1a00100 	lsl	r0, r0, #2
3481551c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815520:	e0821001 	add	r1, r2, r1
34815524:	e12fff33 	blx	r3
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
34815528:	e5941000 	ldr	r1, [r4]
		bsa |= ONENAND_BSA_DATARAM0;	/* DataRAM0 */
3481552c:	e3550000 	cmp	r5, #0
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
34815530:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815534:	13a00b03 	movne	r0, #3072	; 0xc00
34815538:	03a00b02 	moveq	r0, #2048	; 0x800
3481553c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815540:	e12fff33 	blx	r3
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
34815544:	e5941000 	ldr	r1, [r4]
34815548:	e3a00000 	mov	r0, #0
3481554c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815550:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815554:	e2811082 	add	r1, r1, #130	; 0x82
34815558:	e12fff33 	blx	r3
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
3481555c:	e5941000 	ldr	r1, [r4]
34815560:	e6ff0076 	uxth	r0, r6
34815564:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815568:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481556c:	e2811040 	add	r1, r1, #64	; 0x40
34815570:	e12fff33 	blx	r3
}
34815574:	e3a00000 	mov	r0, #0
34815578:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481557c:	0001e202 	.word	0x0001e202
34815580:	00080021 	.word	0x00080021
34815584:	0001e20e 	.word	0x0001e20e

34815588 <flexonenand_region>:
	for (i = 0; i < mtd->numeraseregions; i++)
34815588:	e590102c 	ldr	r1, [r0, #44]	; 0x2c
{
3481558c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34815590:	e1a04002 	mov	r4, r2
34815594:	e1a05003 	mov	r5, r3
		if (addr < mtd->eraseregions[i].offset)
34815598:	e3a02018 	mov	r2, #24
	for (i = 0; i < mtd->numeraseregions; i++)
3481559c:	e3a03000 	mov	r3, #0
348155a0:	e1530001 	cmp	r3, r1
348155a4:	aa000006 	bge	348155c4 <flexonenand_region+0x3c>
		if (addr < mtd->eraseregions[i].offset)
348155a8:	e00c0392 	mul	ip, r2, r3
348155ac:	e590e030 	ldr	lr, [r0, #48]	; 0x30
348155b0:	e18e60dc 	ldrd	r6, [lr, ip]
348155b4:	e1550007 	cmp	r5, r7
348155b8:	01540006 	cmpeq	r4, r6
	for (i = 0; i < mtd->numeraseregions; i++)
348155bc:	22833001 	addcs	r3, r3, #1
348155c0:	2afffff6 	bcs	348155a0 <flexonenand_region+0x18>
	return i - 1;
348155c4:	e2430001 	sub	r0, r3, #1
}
348155c8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

348155cc <onenand_recover_lsb>:
{
348155cc:	e92d42f3 	push	{r0, r1, r4, r5, r6, r7, r9, lr}
348155d0:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
348155d4:	e5905094 	ldr	r5, [r0, #148]	; 0x94
{
348155d8:	e59d9020 	ldr	r9, [sp, #32]
	if (!FLEXONENAND(this))
348155dc:	e595101c 	ldr	r1, [r5, #28]
348155e0:	e3110c02 	tst	r1, #512	; 0x200
348155e4:	0a00001c 	beq	3481565c <onenand_recover_lsb+0x90>
	if (status != -EBADMSG && status != ONENAND_BBT_READ_ECC_ERROR)
348155e8:	e3590002 	cmp	r9, #2
348155ec:	1379004a 	cmnne	r9, #74	; 0x4a
348155f0:	1a000019 	bne	3481565c <onenand_recover_lsb+0x90>
348155f4:	e1a06002 	mov	r6, r2
348155f8:	e1a07003 	mov	r7, r3
	i = flexonenand_region(mtd, addr);
348155fc:	ebffffe1 	bl	34815588 <flexonenand_region>
	if (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))
34815600:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34815604:	e3a03018 	mov	r3, #24
34815608:	e0202093 	mla	r0, r3, r0, r2
3481560c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
34815610:	e5902008 	ldr	r2, [r0, #8]
34815614:	e1b03332 	lsrs	r3, r2, r3
34815618:	0a00000f 	beq	3481565c <onenand_recover_lsb+0x90>
	printk("onenand_recover_lsb:"
3481561c:	e59f0044 	ldr	r0, [pc, #68]	; 34815668 <onenand_recover_lsb+0x9c>
34815620:	ebffd05d 	bl	3480979c <printf>
	this->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);
34815624:	e5953040 	ldr	r3, [r5, #64]	; 0x40
34815628:	e1a02006 	mov	r2, r6
3481562c:	e3a01005 	mov	r1, #5
34815630:	e1a00004 	mov	r0, r4
34815634:	e58d3000 	str	r3, [sp]
34815638:	e1a03007 	mov	r3, r7
3481563c:	e5959050 	ldr	r9, [r5, #80]	; 0x50
34815640:	e12fff39 	blx	r9
	return this->wait(mtd, FL_READING);
34815644:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34815648:	e3a01001 	mov	r1, #1
3481564c:	e1a00004 	mov	r0, r4
}
34815650:	e28dd008 	add	sp, sp, #8
34815654:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	return this->wait(mtd, FL_READING);
34815658:	e12fff13 	bx	r3
}
3481565c:	e1a00009 	mov	r0, r9
34815660:	e28dd008 	add	sp, sp, #8
34815664:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34815668:	348264e4 	.word	0x348264e4

3481566c <onenand_read_ops_nolock>:
{
3481566c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815670:	e24dd050 	sub	sp, sp, #80	; 0x50
34815674:	e59da070 	ldr	sl, [sp, #112]	; 0x70
34815678:	e1a06000 	mov	r6, r0
3481567c:	e1cd21f0 	strd	r2, [sp, #16]
	size_t len = ops->len;
34815680:	e59a3004 	ldr	r3, [sl, #4]
	struct onenand_chip *this = mtd->priv;
34815684:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	oobcolumn = from & (mtd->oobsize - 1);
34815688:	e59d9010 	ldr	r9, [sp, #16]
	size_t len = ops->len;
3481568c:	e58d301c 	str	r3, [sp, #28]
	size_t ooblen = ops->ooblen;
34815690:	e59a300c 	ldr	r3, [sl, #12]
	int writesize = this->writesize;
34815694:	e594b040 	ldr	fp, [r4, #64]	; 0x40
	size_t ooblen = ops->ooblen;
34815698:	e58d3044 	str	r3, [sp, #68]	; 0x44
	u_char *buf = ops->datbuf;
3481569c:	e59a3018 	ldr	r3, [sl, #24]
348156a0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	u_char *oobbuf = ops->oobbuf;
348156a4:	e59a301c 	ldr	r3, [sl, #28]
348156a8:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if (ops->mode == MTD_OOB_AUTO)
348156ac:	e59a3000 	ldr	r3, [sl]
348156b0:	e3530001 	cmp	r3, #1
348156b4:	e5903018 	ldr	r3, [r0, #24]
		oobsize = this->ecclayout->oobavail;
348156b8:	0594209c 	ldreq	r2, [r4, #156]	; 0x9c
	if ((from + len) > mtd->size) {
348156bc:	e1cd01d0 	ldrd	r0, [sp, #16]
		oobsize = mtd->oobsize;
348156c0:	158d3040 	strne	r3, [sp, #64]	; 0x40
	oobcolumn = from & (mtd->oobsize - 1);
348156c4:	e2433001 	sub	r3, r3, #1
348156c8:	e0033009 	and	r3, r3, r9
		oobsize = this->ecclayout->oobavail;
348156cc:	05922204 	ldreq	r2, [r2, #516]	; 0x204
	oobcolumn = from & (mtd->oobsize - 1);
348156d0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	if ((from + len) > mtd->size) {
348156d4:	e59d301c 	ldr	r3, [sp, #28]
		oobsize = this->ecclayout->oobavail;
348156d8:	058d2040 	streq	r2, [sp, #64]	; 0x40
	if ((from + len) > mtd->size) {
348156dc:	e0900003 	adds	r0, r0, r3
348156e0:	e1c620d8 	ldrd	r2, [r6, #8]
348156e4:	e2a11000 	adc	r1, r1, #0
348156e8:	e1510003 	cmp	r1, r3
348156ec:	01500002 	cmpeq	r0, r2
348156f0:	9a000006 	bls	34815710 <onenand_read_ops_nolock+0xa4>
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
348156f4:	e59f0454 	ldr	r0, [pc, #1108]	; 34815b50 <onenand_read_ops_nolock+0x4e4>
348156f8:	ebffd027 	bl	3480979c <printf>
		ops->retlen = 0;
348156fc:	e3a03000 	mov	r3, #0
		return -EINVAL;
34815700:	e3e00015 	mvn	r0, #21
		ops->retlen = 0;
34815704:	e58a3008 	str	r3, [sl, #8]
		ops->oobretlen = 0;
34815708:	e58a3010 	str	r3, [sl, #16]
		return -EINVAL;
3481570c:	ea00010d 	b	34815b48 <onenand_read_ops_nolock+0x4dc>
	stats = mtd->ecc_stats;
34815710:	e5963080 	ldr	r3, [r6, #128]	; 0x80
34815714:	e58d304c 	str	r3, [sp, #76]	; 0x4c
34815718:	e5963084 	ldr	r3, [r6, #132]	; 0x84
3481571c:	e58d3048 	str	r3, [sp, #72]	; 0x48
	if (read < len) {
34815720:	e59d301c 	ldr	r3, [sp, #28]
34815724:	e3530000 	cmp	r3, #0
34815728:	0a000038 	beq	34815810 <onenand_read_ops_nolock+0x1a4>
		blockpage = (int) (addr >> this->page_shift);
3481572c:	e5942034 	ldr	r2, [r4, #52]	; 0x34
34815730:	e1cd01d0 	ldrd	r0, [sp, #16]
34815734:	fa002789 	blx	3481f560 <__ashrdi3>
	i = ONENAND_CURRENT_BUFFERRAM(this);
34815738:	e5943044 	ldr	r3, [r4, #68]	; 0x44
	if (this->bufferram[i].blockpage == blockpage)
3481573c:	e2832012 	add	r2, r3, #18
34815740:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34815744:	e1520000 	cmp	r2, r0
34815748:	0a000005 	beq	34815764 <onenand_read_ops_nolock+0xf8>
		i = ONENAND_NEXT_BUFFERRAM(this);
3481574c:	e2233001 	eor	r3, r3, #1
		if (this->bufferram[i].blockpage == blockpage) {
34815750:	e2832012 	add	r2, r3, #18
34815754:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34815758:	e1520000 	cmp	r2, r0
			ONENAND_SET_NEXT_BUFFERRAM(this);
3481575c:	05843044 	streq	r3, [r4, #68]	; 0x44
		if (this->bufferram[i].blockpage == blockpage) {
34815760:	1a00000f 	bne	348157a4 <onenand_read_ops_nolock+0x138>
	if (found && ONENAND_IS_DDP(this)) {
34815764:	e594301c 	ldr	r3, [r4, #28]
34815768:	e3130008 	tst	r3, #8
3481576c:	0a000027 	beq	34815810 <onenand_read_ops_nolock+0x1a4>
		int block = onenand_block(this, addr);
34815770:	e1cd21d0 	ldrd	r2, [sp, #16]
34815774:	e1a00004 	mov	r0, r4
34815778:	ebfffe9f 	bl	348151fc <onenand_block>
	if (block & this->density_mask)
3481577c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34815780:	e5942000 	ldr	r2, [r4]
34815784:	e59f13c8 	ldr	r1, [pc, #968]	; 34815b54 <onenand_read_ops_nolock+0x4e8>
	return ONENAND_DDP_CHIP0;
34815788:	e1100003 	tst	r0, r3
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
3481578c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815790:	13a00902 	movne	r0, #32768	; 0x8000
34815794:	03a00000 	moveq	r0, #0
34815798:	e0821001 	add	r1, r2, r1
3481579c:	e12fff33 	blx	r3
348157a0:	ea00001a 	b	34815810 <onenand_read_ops_nolock+0x1a4>
			this->main_buf = buf;
348157a4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
348157a8:	e3a01000 	mov	r1, #0
348157ac:	e1a00006 	mov	r0, r6
			this->main_buf = buf;
348157b0:	e5843080 	str	r3, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
348157b4:	e1cd21d0 	ldrd	r2, [sp, #16]
348157b8:	e58db000 	str	fp, [sp]
348157bc:	e5945050 	ldr	r5, [r4, #80]	; 0x50
348157c0:	e12fff35 	blx	r5
			ret = this->wait(mtd, FL_READING);
348157c4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348157c8:	e3a01001 	mov	r1, #1
348157cc:	e1a00006 	mov	r0, r6
348157d0:	e12fff33 	blx	r3
			if (unlikely(ret))
348157d4:	e2505000 	subs	r5, r0, #0
348157d8:	0a000004 	beq	348157f0 <onenand_read_ops_nolock+0x184>
				ret = onenand_recover_lsb(mtd, from, ret);
348157dc:	e58d5000 	str	r5, [sp]
348157e0:	e1a00006 	mov	r0, r6
348157e4:	e1cd21d0 	ldrd	r2, [sp, #16]
348157e8:	ebffff77 	bl	348155cc <onenand_recover_lsb>
348157ec:	e1a05000 	mov	r5, r0
			onenand_update_bufferram(mtd, from, !ret);
348157f0:	e16f3f15 	clz	r3, r5
348157f4:	e5960094 	ldr	r0, [r6, #148]	; 0x94
348157f8:	e1a032a3 	lsr	r3, r3, #5
348157fc:	e58d3000 	str	r3, [sp]
34815800:	e1cd21d0 	ldrd	r2, [sp, #16]
34815804:	ebfffbe1 	bl	34814790 <onenand_update_bufferram.isra.4>
			if (ret == -EBADMSG)
34815808:	e375004a 	cmn	r5, #74	; 0x4a
3481580c:	1a000000 	bne	34815814 <onenand_read_ops_nolock+0x1a8>
	int ret = 0, boundary = 0;
34815810:	e3a05000 	mov	r5, #0
	thislen = min_t(int, writesize, len - read);
34815814:	e59d301c 	ldr	r3, [sp, #28]
34815818:	e153000b 	cmp	r3, fp
3481581c:	b1a07003 	movlt	r7, r3
	column = from & (writesize - 1);
34815820:	e24b3001 	sub	r3, fp, #1
	thislen = min_t(int, writesize, len - read);
34815824:	a1a0700b 	movge	r7, fp
	column = from & (writesize - 1);
34815828:	e0093003 	and	r3, r9, r3
3481582c:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (column + thislen > writesize)
34815830:	e0833007 	add	r3, r3, r7
34815834:	e153000b 	cmp	r3, fp
		thislen = writesize - column;
34815838:	c59d3034 	ldrgt	r3, [sp, #52]	; 0x34
3481583c:	c063700b 	rsbgt	r7, r3, fp
				ret = 0;
34815840:	e3a03000 	mov	r3, #0
34815844:	e1a09003 	mov	r9, r3
34815848:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481584c:	e58d3038 	str	r3, [sp, #56]	; 0x38
	while (!ret) {
34815850:	e3550000 	cmp	r5, #0
34815854:	1a0000ab 	bne	34815b08 <onenand_read_ops_nolock+0x49c>
		from += thislen;
34815858:	e1cd21d0 	ldrd	r2, [sp, #16]
3481585c:	e0922007 	adds	r2, r2, r7
34815860:	e0a33fc7 	adc	r3, r3, r7, asr #31
34815864:	e1cd22f0 	strd	r2, [sp, #32]
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34815868:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481586c:	e3130008 	tst	r3, #8
34815870:	1a000023 	bne	34815904 <onenand_read_ops_nolock+0x298>
34815874:	e59d201c 	ldr	r2, [sp, #28]
34815878:	e0893007 	add	r3, r9, r7
3481587c:	e1530002 	cmp	r3, r2
34815880:	2a00001f 	bcs	34815904 <onenand_read_ops_nolock+0x298>
			this->main_buf = buf + thislen;
34815884:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815888:	e1a01005 	mov	r1, r5
3481588c:	e1a00006 	mov	r0, r6
			this->main_buf = buf + thislen;
34815890:	e0833007 	add	r3, r3, r7
34815894:	e5843080 	str	r3, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815898:	e58db000 	str	fp, [sp]
3481589c:	e1cd22d0 	ldrd	r2, [sp, #32]
348158a0:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348158a4:	e12fff3c 	blx	ip
			if (ONENAND_IS_DDP(this) &&
348158a8:	e594301c 	ldr	r3, [r4, #28]
348158ac:	e3130008 	tst	r3, #8
348158b0:	0a00000f 	beq	348158f4 <onenand_read_ops_nolock+0x288>
					unlikely(from == (this->chipsize >> 1))) {
348158b4:	e5942018 	ldr	r2, [r4, #24]
348158b8:	e3a03000 	mov	r3, #0
			if (ONENAND_IS_DDP(this) &&
348158bc:	e1cd02d0 	ldrd	r0, [sp, #32]
					unlikely(from == (this->chipsize >> 1))) {
348158c0:	e1a020a2 	lsr	r2, r2, #1
			if (ONENAND_IS_DDP(this) &&
348158c4:	e1510003 	cmp	r1, r3
348158c8:	01500002 	cmpeq	r0, r2
348158cc:	1a000008 	bne	348158f4 <onenand_read_ops_nolock+0x288>
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
348158d0:	e5942000 	ldr	r2, [r4]
348158d4:	e1a00005 	mov	r0, r5
348158d8:	e59f1274 	ldr	r1, [pc, #628]	; 34815b54 <onenand_read_ops_nolock+0x4e8>
348158dc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348158e0:	e0821001 	add	r1, r2, r1
348158e4:	e12fff33 	blx	r3
				boundary = 1;
348158e8:	e3a03001 	mov	r3, #1
348158ec:	e58d3028 	str	r3, [sp, #40]	; 0x28
348158f0:	ea000000 	b	348158f8 <onenand_read_ops_nolock+0x28c>
				boundary = 0;
348158f4:	e58d5028 	str	r5, [sp, #40]	; 0x28
			ONENAND_SET_PREV_BUFFERRAM(this);
348158f8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348158fc:	e2233001 	eor	r3, r3, #1
34815900:	e5843044 	str	r3, [r4, #68]	; 0x44
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
34815904:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
34815908:	e1a00006 	mov	r0, r6
3481590c:	e58d700c 	str	r7, [sp, #12]
34815910:	e58d3008 	str	r3, [sp, #8]
34815914:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
34815918:	e58d3004 	str	r3, [sp, #4]
3481591c:	e3a03b01 	mov	r3, #1024	; 0x400
34815920:	e58d3000 	str	r3, [sp]
34815924:	e1cd21d0 	ldrd	r2, [sp, #16]
34815928:	e5941060 	ldr	r1, [r4, #96]	; 0x60
3481592c:	e12fff31 	blx	r1
		if (oobbuf) {
34815930:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
34815934:	e3530000 	cmp	r3, #0
34815938:	0a000023 	beq	348159cc <onenand_read_ops_nolock+0x360>
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
3481593c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34815940:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
34815944:	e0625003 	rsb	r5, r2, r3
			thisooblen = oobsize - oobcolumn;
34815948:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3481594c:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
34815950:	e0623003 	rsb	r3, r2, r3
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34815954:	e1550003 	cmp	r5, r3
34815958:	a1a05003 	movge	r5, r3
			if (ops->mode == MTD_OOB_AUTO)
3481595c:	e59a3000 	ldr	r3, [sl]
34815960:	e3530001 	cmp	r3, #1
34815964:	1a000004 	bne	3481597c <onenand_read_ops_nolock+0x310>
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
34815968:	e1a03005 	mov	r3, r5
3481596c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34815970:	e1a00006 	mov	r0, r6
34815974:	ebfffadc 	bl	348144ec <onenand_transfer_auto_oob>
34815978:	ea00000b 	b	348159ac <onenand_read_ops_nolock+0x340>
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
3481597c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
34815980:	e3a02000 	mov	r2, #0
34815984:	e58d500c 	str	r5, [sp, #12]
34815988:	e1a00006 	mov	r0, r6
3481598c:	e58d3008 	str	r3, [sp, #8]
34815990:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
34815994:	e58d3004 	str	r3, [sp, #4]
34815998:	e59f31b8 	ldr	r3, [pc, #440]	; 34815b58 <onenand_read_ops_nolock+0x4ec>
3481599c:	e58d3000 	str	r3, [sp]
348159a0:	e3a03000 	mov	r3, #0
348159a4:	e5941060 	ldr	r1, [r4, #96]	; 0x60
348159a8:	e12fff31 	blx	r1
			oobread += thisooblen;
348159ac:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
348159b0:	e0833005 	add	r3, r3, r5
348159b4:	e58d3038 	str	r3, [sp, #56]	; 0x38
			oobbuf += thisooblen;
348159b8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
348159bc:	e0833005 	add	r3, r3, r5
348159c0:	e58d3030 	str	r3, [sp, #48]	; 0x30
			oobcolumn = 0;
348159c4:	e3a03000 	mov	r3, #0
348159c8:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		if (ONENAND_IS_4KB_PAGE(this) && (read + thislen < len)) {
348159cc:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348159d0:	e3130008 	tst	r3, #8
348159d4:	1a000001 	bne	348159e0 <onenand_read_ops_nolock+0x374>
			oobcolumn = 0;
348159d8:	e3a05000 	mov	r5, #0
348159dc:	ea00001c 	b	34815a54 <onenand_read_ops_nolock+0x3e8>
		if (ONENAND_IS_4KB_PAGE(this) && (read + thislen < len)) {
348159e0:	e59d201c 	ldr	r2, [sp, #28]
348159e4:	e0893007 	add	r3, r9, r7
348159e8:	e1530002 	cmp	r3, r2
348159ec:	2afffff9 	bcs	348159d8 <onenand_read_ops_nolock+0x36c>
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
348159f0:	e1cd22d0 	ldrd	r2, [sp, #32]
348159f4:	e3a01000 	mov	r1, #0
348159f8:	e58db000 	str	fp, [sp]
348159fc:	e1a00006 	mov	r0, r6
34815a00:	e5945050 	ldr	r5, [r4, #80]	; 0x50
34815a04:	e12fff35 	blx	r5
			ret = this->wait(mtd, FL_READING);
34815a08:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815a0c:	e3a01001 	mov	r1, #1
34815a10:	e1a00006 	mov	r0, r6
34815a14:	e12fff33 	blx	r3
			if (unlikely(ret))
34815a18:	e2505000 	subs	r5, r0, #0
34815a1c:	0a000004 	beq	34815a34 <onenand_read_ops_nolock+0x3c8>
				ret = onenand_recover_lsb(mtd, from, ret);
34815a20:	e58d5000 	str	r5, [sp]
34815a24:	e1a00006 	mov	r0, r6
34815a28:	e1cd22d0 	ldrd	r2, [sp, #32]
34815a2c:	ebfffee6 	bl	348155cc <onenand_recover_lsb>
34815a30:	e1a05000 	mov	r5, r0
			onenand_update_bufferram(mtd, from, !ret);
34815a34:	e16f3f15 	clz	r3, r5
34815a38:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34815a3c:	e1a032a3 	lsr	r3, r3, #5
34815a40:	e58d3000 	str	r3, [sp]
34815a44:	e1cd22d0 	ldrd	r2, [sp, #32]
34815a48:	ebfffb50 	bl	34814790 <onenand_update_bufferram.isra.4>
			if (ret == -EBADMSG)
34815a4c:	e375004a 	cmn	r5, #74	; 0x4a
34815a50:	0affffe0 	beq	348159d8 <onenand_read_ops_nolock+0x36c>
		if (read == len)
34815a54:	e59d301c 	ldr	r3, [sp, #28]
		read += thislen;
34815a58:	e0899007 	add	r9, r9, r7
		if (read == len)
34815a5c:	e1590003 	cmp	r9, r3
34815a60:	0a000028 	beq	34815b08 <onenand_read_ops_nolock+0x49c>
		if (unlikely(boundary))
34815a64:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34815a68:	e3530000 	cmp	r3, #0
34815a6c:	0a000005 	beq	34815a88 <onenand_read_ops_nolock+0x41c>
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
34815a70:	e5942000 	ldr	r2, [r4]
34815a74:	e3a00902 	mov	r0, #32768	; 0x8000
34815a78:	e59f10d4 	ldr	r1, [pc, #212]	; 34815b54 <onenand_read_ops_nolock+0x4e8>
34815a7c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815a80:	e0821001 	add	r1, r2, r1
34815a84:	e12fff33 	blx	r3
		if (!ONENAND_IS_4KB_PAGE(this))
34815a88:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34815a8c:	e2133008 	ands	r3, r3, #8
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815a90:	05942044 	ldreq	r2, [r4, #68]	; 0x44
34815a94:	02222001 	eoreq	r2, r2, #1
34815a98:	05842044 	streq	r2, [r4, #68]	; 0x44
		buf += thislen;
34815a9c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34815aa0:	e0822007 	add	r2, r2, r7
34815aa4:	e58d202c 	str	r2, [sp, #44]	; 0x2c
		thislen = min_t(int, writesize, len - read);
34815aa8:	e59d201c 	ldr	r2, [sp, #28]
34815aac:	e0697002 	rsb	r7, r9, r2
34815ab0:	e157000b 	cmp	r7, fp
34815ab4:	a1a0700b 	movge	r7, fp
		if (!ONENAND_IS_4KB_PAGE(this)) {
34815ab8:	e3530000 	cmp	r3, #0
34815abc:	1a00000c 	bne	34815af4 <onenand_read_ops_nolock+0x488>
			ret = this->wait(mtd, FL_READING);
34815ac0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815ac4:	e3a01001 	mov	r1, #1
34815ac8:	e1a00006 	mov	r0, r6
34815acc:	e12fff33 	blx	r3
			onenand_update_bufferram(mtd, from, !ret);
34815ad0:	e1a05000 	mov	r5, r0
34815ad4:	e16f0f10 	clz	r0, r0
34815ad8:	e1a002a0 	lsr	r0, r0, #5
34815adc:	e1cd22d0 	ldrd	r2, [sp, #32]
34815ae0:	e58d0000 	str	r0, [sp]
34815ae4:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34815ae8:	ebfffb28 	bl	34814790 <onenand_update_bufferram.isra.4>
				ret = 0;
34815aec:	e375004a 	cmn	r5, #74	; 0x4a
34815af0:	03a05000 	moveq	r5, #0
34815af4:	e3a03000 	mov	r3, #0
34815af8:	e58d3034 	str	r3, [sp, #52]	; 0x34
		from += thislen;
34815afc:	e1cd22d0 	ldrd	r2, [sp, #32]
34815b00:	e1cd21f0 	strd	r2, [sp, #16]
34815b04:	eaffff51 	b	34815850 <onenand_read_ops_nolock+0x1e4>
	ops->oobretlen = oobread;
34815b08:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	if (ret)
34815b0c:	e3550000 	cmp	r5, #0
	ops->retlen = read;
34815b10:	e58a9008 	str	r9, [sl, #8]
34815b14:	11a00005 	movne	r0, r5
	ops->oobretlen = oobread;
34815b18:	e58a3010 	str	r3, [sl, #16]
	if (ret)
34815b1c:	1a000009 	bne	34815b48 <onenand_read_ops_nolock+0x4dc>
	if (mtd->ecc_stats.failed - stats.failed)
34815b20:	e5963084 	ldr	r3, [r6, #132]	; 0x84
34815b24:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
34815b28:	e1530002 	cmp	r3, r2
		return -EBADMSG;
34815b2c:	13e00049 	mvnne	r0, #73	; 0x49
	if (mtd->ecc_stats.failed - stats.failed)
34815b30:	1a000004 	bne	34815b48 <onenand_read_ops_nolock+0x4dc>
	return mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
34815b34:	e5963080 	ldr	r3, [r6, #128]	; 0x80
34815b38:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
34815b3c:	e1530002 	cmp	r3, r2
34815b40:	13e00074 	mvnne	r0, #116	; 0x74
34815b44:	03a00000 	moveq	r0, #0
}
34815b48:	e28dd050 	add	sp, sp, #80	; 0x50
34815b4c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815b50:	34826527 	.word	0x34826527
34815b54:	0001e202 	.word	0x0001e202
34815b58:	00010020 	.word	0x00010020

34815b5c <onenand_read>:
{
34815b5c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34815b60:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34815b64:	e28d4008 	add	r4, sp, #8
{
34815b68:	e1a05000 	mov	r5, r0
34815b6c:	e1a06002 	mov	r6, r2
	struct mtd_oob_ops ops = {
34815b70:	e3a01000 	mov	r1, #0
34815b74:	e3a02020 	mov	r2, #32
34815b78:	e1a00004 	mov	r0, r4
{
34815b7c:	e1a07003 	mov	r7, r3
	struct mtd_oob_ops ops = {
34815b80:	eb0017fd 	bl	3481bb7c <memset>
34815b84:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
	ret = onenand_read_ops_nolock(mtd, from, &ops);
34815b88:	e1a02006 	mov	r2, r6
34815b8c:	e58d4000 	str	r4, [sp]
34815b90:	e1a00005 	mov	r0, r5
	struct mtd_oob_ops ops = {
34815b94:	e58d300c 	str	r3, [sp, #12]
34815b98:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
34815b9c:	e58d3020 	str	r3, [sp, #32]
	ret = onenand_read_ops_nolock(mtd, from, &ops);
34815ba0:	e1a03007 	mov	r3, r7
34815ba4:	ebfffeb0 	bl	3481566c <onenand_read_ops_nolock>
	*retlen = ops.retlen;
34815ba8:	e59d2010 	ldr	r2, [sp, #16]
34815bac:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34815bb0:	e5832000 	str	r2, [r3]
}
34815bb4:	e28dd02c 	add	sp, sp, #44	; 0x2c
34815bb8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34815bbc <onenand_read_oob_nolock>:
{
34815bbc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815bc0:	e24dd030 	sub	sp, sp, #48	; 0x30
	size_t len = ops->ooblen;
34815bc4:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
{
34815bc8:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
34815bcc:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	size_t len = ops->ooblen;
34815bd0:	e591100c 	ldr	r1, [r1, #12]
34815bd4:	e5906018 	ldr	r6, [r0, #24]
34815bd8:	e58d101c 	str	r1, [sp, #28]
	mtd_oob_mode_t mode = ops->mode;
34815bdc:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34815be0:	e5911000 	ldr	r1, [r1]
34815be4:	e58d1028 	str	r1, [sp, #40]	; 0x28
	u_char *buf = ops->oobbuf;
34815be8:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34815bec:	e591101c 	ldr	r1, [r1, #28]
34815bf0:	e58d1018 	str	r1, [sp, #24]
	from += ops->ooboffs;
34815bf4:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34815bf8:	e5911014 	ldr	r1, [r1, #20]
34815bfc:	e092a001 	adds	sl, r2, r1
	ops->oobretlen = 0;
34815c00:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
	from += ops->ooboffs;
34815c04:	e2a3b000 	adc	fp, r3, #0
	ops->oobretlen = 0;
34815c08:	e3a03000 	mov	r3, #0
	from += ops->ooboffs;
34815c0c:	e1cda1f0 	strd	sl, [sp, #16]
	ops->oobretlen = 0;
34815c10:	e5823010 	str	r3, [r2, #16]
	if (mode == MTD_OOB_AUTO)
34815c14:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34815c18:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34815c1c:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
		oobsize = mtd->oobsize;
34815c20:	11a09006 	movne	r9, r6
	column = from & (mtd->oobsize - 1);
34815c24:	e2466001 	sub	r6, r6, #1
		oobsize = this->ecclayout->oobavail;
34815c28:	05939204 	ldreq	r9, [r3, #516]	; 0x204
	column = from & (mtd->oobsize - 1);
34815c2c:	e59d3010 	ldr	r3, [sp, #16]
34815c30:	e0066003 	and	r6, r6, r3
	if (unlikely(column >= oobsize)) {
34815c34:	e1560009 	cmp	r6, r9
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
34815c38:	a59f0200 	ldrge	r0, [pc, #512]	; 34815e40 <onenand_read_oob_nolock+0x284>
	if (unlikely(column >= oobsize)) {
34815c3c:	aa00001d 	bge	34815cb8 <onenand_read_oob_nolock+0xfc>
	if (unlikely(from >= mtd->size ||
34815c40:	e1c500d8 	ldrd	r0, [r5, #8]
34815c44:	e1cd21d0 	ldrd	r2, [sp, #16]
34815c48:	e1530001 	cmp	r3, r1
34815c4c:	01520000 	cmpeq	r2, r0
34815c50:	2a000017 	bcs	34815cb4 <onenand_read_oob_nolock+0xf8>
34815c54:	e59d301c 	ldr	r3, [sp, #28]
34815c58:	e3a0b000 	mov	fp, #0
34815c5c:	e5974034 	ldr	r4, [r7, #52]	; 0x34
34815c60:	e0863003 	add	r3, r6, r3
34815c64:	e1a0a003 	mov	sl, r3
34815c68:	e1a02004 	mov	r2, r4
34815c6c:	e1cda2f0 	strd	sl, [sp, #32]
34815c70:	fa002634 	blx	3481f548 <__lshrdi3>
34815c74:	e1a02004 	mov	r2, r4
34815c78:	e1a0a000 	mov	sl, r0
34815c7c:	e1a0b001 	mov	fp, r1
34815c80:	e1cd01d0 	ldrd	r0, [sp, #16]
34815c84:	fa002635 	blx	3481f560 <__ashrdi3>
34815c88:	e05a0000 	subs	r0, sl, r0
34815c8c:	e1a03fc9 	asr	r3, r9, #31
34815c90:	e0cb1001 	sbc	r1, fp, r1
34815c94:	e0010199 	mul	r1, r9, r1
34815c98:	e0231390 	mla	r3, r0, r3, r1
34815c9c:	e0810099 	umull	r0, r1, r9, r0
34815ca0:	e0831001 	add	r1, r3, r1
34815ca4:	e1cd22d0 	ldrd	r2, [sp, #32]
34815ca8:	e1530001 	cmp	r3, r1
34815cac:	01520000 	cmpeq	r2, r0
34815cb0:	9a000003 	bls	34815cc4 <onenand_read_oob_nolock+0x108>
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
34815cb4:	e59f0188 	ldr	r0, [pc, #392]	; 34815e44 <onenand_read_oob_nolock+0x288>
34815cb8:	ebffceb7 	bl	3480979c <printf>
		return -EINVAL;
34815cbc:	e3e00015 	mvn	r0, #21
34815cc0:	ea00005c 	b	34815e38 <onenand_read_oob_nolock+0x27c>
	stats = mtd->ecc_stats;
34815cc4:	e5953084 	ldr	r3, [r5, #132]	; 0x84
	int ret = 0, readcmd;
34815cc8:	e3a04000 	mov	r4, #0
	int read = 0, thislen, column, oobsize;
34815ccc:	e1a0b004 	mov	fp, r4
	stats = mtd->ecc_stats;
34815cd0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34815cd4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34815cd8:	e3130008 	tst	r3, #8
34815cdc:	13a03000 	movne	r3, #0
34815ce0:	03a03013 	moveq	r3, #19
34815ce4:	e58d3020 	str	r3, [sp, #32]
	while (read < len) {
34815ce8:	e59d301c 	ldr	r3, [sp, #28]
34815cec:	e15b0003 	cmp	fp, r3
34815cf0:	2a000046 	bcs	34815e10 <onenand_read_oob_nolock+0x254>
		thislen = min_t(int, thislen, len);
34815cf4:	e59d301c 	ldr	r3, [sp, #28]
		thislen = oobsize - column;
34815cf8:	e066a009 	rsb	sl, r6, r9
		this->command(mtd, readcmd, from, mtd->oobsize);
34815cfc:	e59d1020 	ldr	r1, [sp, #32]
34815d00:	e1a00005 	mov	r0, r5
		thislen = min_t(int, thislen, len);
34815d04:	e15a0003 	cmp	sl, r3
34815d08:	a1a0a003 	movge	sl, r3
		this->spare_buf = buf;
34815d0c:	e59d3018 	ldr	r3, [sp, #24]
34815d10:	e5873084 	str	r3, [r7, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
34815d14:	e5953018 	ldr	r3, [r5, #24]
34815d18:	e58d3000 	str	r3, [sp]
34815d1c:	e1cd21d0 	ldrd	r2, [sp, #16]
34815d20:	e5974050 	ldr	r4, [r7, #80]	; 0x50
34815d24:	e12fff34 	blx	r4
		onenand_update_bufferram(mtd, from, 0);
34815d28:	e3a03000 	mov	r3, #0
34815d2c:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34815d30:	e58d3000 	str	r3, [sp]
34815d34:	e1cd21d0 	ldrd	r2, [sp, #16]
34815d38:	ebfffa94 	bl	34814790 <onenand_update_bufferram.isra.4>
		ret = this->wait(mtd, FL_READING);
34815d3c:	e5973054 	ldr	r3, [r7, #84]	; 0x54
34815d40:	e3a01001 	mov	r1, #1
34815d44:	e1a00005 	mov	r0, r5
34815d48:	e12fff33 	blx	r3
		if (unlikely(ret))
34815d4c:	e2504000 	subs	r4, r0, #0
34815d50:	0a000004 	beq	34815d68 <onenand_read_oob_nolock+0x1ac>
			ret = onenand_recover_lsb(mtd, from, ret);
34815d54:	e58d4000 	str	r4, [sp]
34815d58:	e1a00005 	mov	r0, r5
34815d5c:	e1cd21d0 	ldrd	r2, [sp, #16]
34815d60:	ebfffe19 	bl	348155cc <onenand_recover_lsb>
34815d64:	e1a04000 	mov	r4, r0
		if (ret && ret != -EBADMSG) {
34815d68:	e3540000 	cmp	r4, #0
34815d6c:	1374004a 	cmnne	r4, #74	; 0x4a
34815d70:	0a000003 	beq	34815d84 <onenand_read_oob_nolock+0x1c8>
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
34815d74:	e1a01004 	mov	r1, r4
34815d78:	e59f00c8 	ldr	r0, [pc, #200]	; 34815e48 <onenand_read_oob_nolock+0x28c>
34815d7c:	ebffce86 	bl	3480979c <printf>
			break;
34815d80:	ea000022 	b	34815e10 <onenand_read_oob_nolock+0x254>
		if (mode == MTD_OOB_AUTO)
34815d84:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34815d88:	e3530001 	cmp	r3, #1
34815d8c:	1a000005 	bne	34815da8 <onenand_read_oob_nolock+0x1ec>
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
34815d90:	e1a0300a 	mov	r3, sl
34815d94:	e1a02006 	mov	r2, r6
34815d98:	e59d1018 	ldr	r1, [sp, #24]
34815d9c:	e1a00005 	mov	r0, r5
34815da0:	ebfff9d1 	bl	348144ec <onenand_transfer_auto_oob>
34815da4:	ea00000a 	b	34815dd4 <onenand_read_oob_nolock+0x218>
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34815da8:	e59d3018 	ldr	r3, [sp, #24]
34815dac:	e3a02000 	mov	r2, #0
34815db0:	e58da00c 	str	sl, [sp, #12]
34815db4:	e1a00005 	mov	r0, r5
34815db8:	e58d6008 	str	r6, [sp, #8]
34815dbc:	e58d3004 	str	r3, [sp, #4]
34815dc0:	e59f3084 	ldr	r3, [pc, #132]	; 34815e4c <onenand_read_oob_nolock+0x290>
34815dc4:	e58d3000 	str	r3, [sp]
34815dc8:	e3a03000 	mov	r3, #0
34815dcc:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34815dd0:	e12fff31 	blx	r1
		if (read == len)
34815dd4:	e59d301c 	ldr	r3, [sp, #28]
		read += thislen;
34815dd8:	e08bb00a 	add	fp, fp, sl
		if (read == len)
34815ddc:	e15b0003 	cmp	fp, r3
34815de0:	0a00000a 	beq	34815e10 <onenand_read_oob_nolock+0x254>
		buf += thislen;
34815de4:	e59d3018 	ldr	r3, [sp, #24]
34815de8:	e083300a 	add	r3, r3, sl
34815dec:	e58d3018 	str	r3, [sp, #24]
		if (read < len) {
34815df0:	2affffbc 	bcs	34815ce8 <onenand_read_oob_nolock+0x12c>
			from += mtd->writesize;
34815df4:	e1cd01d0 	ldrd	r0, [sp, #16]
			column = 0;
34815df8:	e3a06000 	mov	r6, #0
			from += mtd->writesize;
34815dfc:	e5953014 	ldr	r3, [r5, #20]
34815e00:	e0900003 	adds	r0, r0, r3
34815e04:	e2a11000 	adc	r1, r1, #0
34815e08:	e1cd01f0 	strd	r0, [sp, #16]
34815e0c:	eaffffb5 	b	34815ce8 <onenand_read_oob_nolock+0x12c>
	ops->oobretlen = read;
34815e10:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
	if (ret)
34815e14:	e3540000 	cmp	r4, #0
34815e18:	11a00004 	movne	r0, r4
	ops->oobretlen = read;
34815e1c:	e583b010 	str	fp, [r3, #16]
	if (ret)
34815e20:	1a000004 	bne	34815e38 <onenand_read_oob_nolock+0x27c>
	if (mtd->ecc_stats.failed - stats.failed)
34815e24:	e5953084 	ldr	r3, [r5, #132]	; 0x84
	return 0;
34815e28:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34815e2c:	e1530002 	cmp	r3, r2
34815e30:	13e00049 	mvnne	r0, #73	; 0x49
34815e34:	03a00000 	moveq	r0, #0
}
34815e38:	e28dd030 	add	sp, sp, #48	; 0x30
34815e3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815e40:	34826563 	.word	0x34826563
34815e44:	348265a1 	.word	0x348265a1
34815e48:	348265e2 	.word	0x348265e2
34815e4c:	00010020 	.word	0x00010020

34815e50 <onenand_read_oob>:
{
34815e50:	e59d1000 	ldr	r1, [sp]
	switch (ops->mode) {
34815e54:	e591c000 	ldr	ip, [r1]
34815e58:	e35c0001 	cmp	ip, #1
34815e5c:	8a000005 	bhi	34815e78 <onenand_read_oob+0x28>
	if (ops->datbuf)
34815e60:	e591c018 	ldr	ip, [r1, #24]
34815e64:	e35c0000 	cmp	ip, #0
34815e68:	0a000000 	beq	34815e70 <onenand_read_oob+0x20>
		ret = onenand_read_ops_nolock(mtd, from, ops);
34815e6c:	eafffdfe 	b	3481566c <onenand_read_ops_nolock>
		ret = onenand_read_oob_nolock(mtd, from, ops);
34815e70:	e58d1000 	str	r1, [sp]
34815e74:	eaffff50 	b	34815bbc <onenand_read_oob_nolock>
}
34815e78:	e3e00015 	mvn	r0, #21
34815e7c:	e12fff1e 	bx	lr

34815e80 <onenand_erase>:
{
34815e80:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815e84:	e24dd018 	sub	sp, sp, #24
	unsigned int len = instr->len;
34815e88:	e5913010 	ldr	r3, [r1, #16]
{
34815e8c:	e1a06000 	mov	r6, r0
	loff_t addr = instr->addr;
34815e90:	e1c1a0d8 	ldrd	sl, [r1, #8]
	unsigned int len = instr->len;
34815e94:	e58d3010 	str	r3, [sp, #16]
34815e98:	e58d3008 	str	r3, [sp, #8]
	if (unlikely((len + addr) > mtd->size)) {
34815e9c:	e09a4003 	adds	r4, sl, r3
34815ea0:	e1c020d8 	ldrd	r2, [r0, #8]
34815ea4:	e2ab5000 	adc	r5, fp, #0
	struct onenand_chip *this = mtd->priv;
34815ea8:	e5909094 	ldr	r9, [r0, #148]	; 0x94
	if (unlikely((len + addr) > mtd->size)) {
34815eac:	e1550003 	cmp	r5, r3
34815eb0:	01540002 	cmpeq	r4, r2
34815eb4:	8a000093 	bhi	34816108 <onenand_erase+0x288>
	if (FLEXONENAND(this)) {
34815eb8:	e599301c 	ldr	r3, [r9, #28]
34815ebc:	e1a04001 	mov	r4, r1
34815ec0:	e2131c02 	ands	r1, r3, #512	; 0x200
34815ec4:	0a000012 	beq	34815f14 <onenand_erase+0x94>
		i = flexonenand_region(mtd, addr);
34815ec8:	e1a0200a 	mov	r2, sl
34815ecc:	e1a0300b 	mov	r3, fp
34815ed0:	ebfffdac 	bl	34815588 <flexonenand_region>
		region = &mtd->eraseregions[i];
34815ed4:	e3a03018 	mov	r3, #24
34815ed8:	e0000093 	mul	r0, r3, r0
34815edc:	e5963030 	ldr	r3, [r6, #48]	; 0x30
34815ee0:	e0837000 	add	r7, r3, r0
		region_end = region->offset
34815ee4:	e18320d0 	ldrd	r2, [r3, r0]
		block_size = region->erasesize;
34815ee8:	e5975008 	ldr	r5, [r7, #8]
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815eec:	e3a03000 	mov	r3, #0
			+ region->erasesize * region->numblocks;
34815ef0:	e597100c 	ldr	r1, [r7, #12]
		region_end = region->offset
34815ef4:	e0212591 	mla	r1, r1, r5, r2
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815ef8:	e05a2002 	subs	r2, sl, r2
		region_end = region->offset
34815efc:	e58d100c 	str	r1, [sp, #12]
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815f00:	e2451001 	sub	r1, r5, #1
34815f04:	e0022001 	and	r2, r2, r1
34815f08:	e1923003 	orrs	r3, r2, r3
34815f0c:	0a00000a 	beq	34815f3c <onenand_erase+0xbc>
34815f10:	ea00007c 	b	34816108 <onenand_erase+0x288>
		block_size = 1 << this->erase_shift;
34815f14:	e5993030 	ldr	r3, [r9, #48]	; 0x30
34815f18:	e3a05001 	mov	r5, #1
34815f1c:	e1a05315 	lsl	r5, r5, r3
		if (unlikely(addr & (block_size - 1))) {
34815f20:	e3a03000 	mov	r3, #0
34815f24:	e2450001 	sub	r0, r5, #1
34815f28:	e00a2000 	and	r2, sl, r0
34815f2c:	e1923003 	orrs	r3, r2, r3
34815f30:	1a000074 	bne	34816108 <onenand_erase+0x288>
	struct mtd_erase_region_info *region = NULL;
34815f34:	e1a07001 	mov	r7, r1
	unsigned int region_end = 0;
34815f38:	e58d100c 	str	r1, [sp, #12]
	if (unlikely(len & (block_size - 1))) {
34815f3c:	e59d2010 	ldr	r2, [sp, #16]
34815f40:	e2453001 	sub	r3, r5, #1
34815f44:	e1130002 	tst	r3, r2
34815f48:	1a00006e 	bne	34816108 <onenand_erase+0x288>
	instr->fail_addr = 0xffffffff;
34815f4c:	e3a03000 	mov	r3, #0
34815f50:	e3e02000 	mvn	r2, #0
34815f54:	e1c421f8 	strd	r2, [r4, #24]
	instr->state = MTD_ERASING;
34815f58:	e3a03002 	mov	r3, #2
34815f5c:	e5c43038 	strb	r3, [r4, #56]	; 0x38
	while (len) {
34815f60:	e59d3008 	ldr	r3, [sp, #8]
34815f64:	e3530000 	cmp	r3, #0
34815f68:	0a00004b 	beq	3481609c <onenand_erase+0x21c>
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
34815f6c:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34815f70:	e3530000 	cmp	r3, #0
34815f74:	1a00000a 	bne	34815fa4 <onenand_erase+0x124>
34815f78:	e1a0200a 	mov	r2, sl
34815f7c:	e1a0300b 	mov	r3, fp
34815f80:	e1a00006 	mov	r0, r6
34815f84:	ebfffc79 	bl	34815170 <onenand_block_isbad_nolock.constprop.14>
34815f88:	e3500000 	cmp	r0, #0
34815f8c:	0a000004 	beq	34815fa4 <onenand_erase+0x124>
			printk(KERN_WARNING "onenand_erase: attempt to erase"
34815f90:	e1a0100a 	mov	r1, sl
34815f94:	e59f0178 	ldr	r0, [pc, #376]	; 34816114 <onenand_erase+0x294>
34815f98:	ebffcdff 	bl	3480979c <printf>
			instr->state = MTD_ERASE_FAILED;
34815f9c:	e3a03010 	mov	r3, #16
34815fa0:	ea00003e 	b	348160a0 <onenand_erase+0x220>
		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
34815fa4:	e58d5000 	str	r5, [sp]
34815fa8:	e1a0200a 	mov	r2, sl
34815fac:	e1a0300b 	mov	r3, fp
34815fb0:	e3a01094 	mov	r1, #148	; 0x94
34815fb4:	e599c050 	ldr	ip, [r9, #80]	; 0x50
34815fb8:	e1a00006 	mov	r0, r6
34815fbc:	e12fff3c 	blx	ip
34815fc0:	e596c094 	ldr	ip, [r6, #148]	; 0x94
	loff_t end_addr = addr + len;
34815fc4:	e09a2005 	adds	r2, sl, r5
34815fc8:	e2ab3000 	adc	r3, fp, #0
34815fcc:	e1cd21f0 	strd	r2, [sp, #16]
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815fd0:	e59ce034 	ldr	lr, [ip, #52]	; 0x34
34815fd4:	e59c0048 	ldr	r0, [ip, #72]	; 0x48
34815fd8:	e1a00e10 	lsl	r0, r0, lr
34815fdc:	e1a01fc0 	asr	r1, r0, #31
		if (buf_addr >= addr && buf_addr < end_addr)
34815fe0:	e1500002 	cmp	r0, r2
34815fe4:	e0d13003 	sbcs	r3, r1, r3
34815fe8:	b3a03001 	movlt	r3, #1
34815fec:	a3a03000 	movge	r3, #0
34815ff0:	e150000a 	cmp	r0, sl
34815ff4:	e0d1200b 	sbcs	r2, r1, fp
34815ff8:	e1cd01d0 	ldrd	r0, [sp, #16]
34815ffc:	b3a03000 	movlt	r3, #0
34816000:	a2033001 	andge	r3, r3, #1
34816004:	e3530000 	cmp	r3, #0
			this->bufferram[i].blockpage = -1;
34816008:	13e03000 	mvnne	r3, #0
3481600c:	158c3048 	strne	r3, [ip, #72]	; 0x48
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816010:	e59c304c 	ldr	r3, [ip, #76]	; 0x4c
34816014:	e1a02e13 	lsl	r2, r3, lr
34816018:	e1a03fc2 	asr	r3, r2, #31
		if (buf_addr >= addr && buf_addr < end_addr)
3481601c:	e1520000 	cmp	r2, r0
		ret = this->wait(mtd, FL_ERASING);
34816020:	e1a00006 	mov	r0, r6
		if (buf_addr >= addr && buf_addr < end_addr)
34816024:	e0d31001 	sbcs	r1, r3, r1
34816028:	a3a01000 	movge	r1, #0
3481602c:	b3a01001 	movlt	r1, #1
34816030:	e152000a 	cmp	r2, sl
34816034:	e0d3300b 	sbcs	r3, r3, fp
34816038:	a2013001 	andge	r3, r1, #1
3481603c:	b3a03000 	movlt	r3, #0
34816040:	e3530000 	cmp	r3, #0
		ret = this->wait(mtd, FL_ERASING);
34816044:	e3a01003 	mov	r1, #3
			this->bufferram[i].blockpage = -1;
34816048:	13e03000 	mvnne	r3, #0
3481604c:	158c304c 	strne	r3, [ip, #76]	; 0x4c
		ret = this->wait(mtd, FL_ERASING);
34816050:	e5993054 	ldr	r3, [r9, #84]	; 0x54
34816054:	e12fff33 	blx	r3
		if (ret) {
34816058:	e3500000 	cmp	r0, #0
			instr->state = MTD_ERASE_FAILED;
3481605c:	13a03010 	movne	r3, #16
			instr->fail_addr = addr;
34816060:	11c4a1f8 	strdne	sl, [r4, #24]
			instr->state = MTD_ERASE_FAILED;
34816064:	15c43038 	strbne	r3, [r4, #56]	; 0x38
			goto erase_exit;
34816068:	1a00001e 	bne	348160e8 <onenand_erase+0x268>
		len -= block_size;
3481606c:	e59d3008 	ldr	r3, [sp, #8]
		if (addr == region_end) {
34816070:	e1cd01d0 	ldrd	r0, [sp, #16]
34816074:	e59d200c 	ldr	r2, [sp, #12]
		len -= block_size;
34816078:	e0653003 	rsb	r3, r5, r3
3481607c:	e58d3008 	str	r3, [sp, #8]
		if (addr == region_end) {
34816080:	e3a03000 	mov	r3, #0
34816084:	e1510003 	cmp	r1, r3
34816088:	01500002 	cmpeq	r0, r2
3481608c:	1a000013 	bne	348160e0 <onenand_erase+0x260>
			if (!len)
34816090:	e59d3008 	ldr	r3, [sp, #8]
34816094:	e3530000 	cmp	r3, #0
34816098:	1a000002 	bne	348160a8 <onenand_erase+0x228>
	instr->state = MTD_ERASE_DONE;
3481609c:	e3a03008 	mov	r3, #8
348160a0:	e5c43038 	strb	r3, [r4, #56]	; 0x38
348160a4:	ea00000f 	b	348160e8 <onenand_erase+0x268>
			block_size = region->erasesize;
348160a8:	e5975020 	ldr	r5, [r7, #32]
			region++;
348160ac:	e2873018 	add	r3, r7, #24
				+ region->erasesize * region->numblocks;
348160b0:	e5971024 	ldr	r1, [r7, #36]	; 0x24
			region_end = region->offset
348160b4:	e5972018 	ldr	r2, [r7, #24]
348160b8:	e0222591 	mla	r2, r1, r5, r2
			if (len & (block_size - 1)) {
348160bc:	e59d1008 	ldr	r1, [sp, #8]
			region_end = region->offset
348160c0:	e58d200c 	str	r2, [sp, #12]
			if (len & (block_size - 1)) {
348160c4:	e2452001 	sub	r2, r5, #1
348160c8:	e1110002 	tst	r1, r2
348160cc:	0a000002 	beq	348160dc <onenand_erase+0x25c>
				printk("onenand_erase: Unaligned address\n");
348160d0:	e59f0040 	ldr	r0, [pc, #64]	; 34816118 <onenand_erase+0x298>
348160d4:	ebffcdb0 	bl	3480979c <printf>
				goto erase_exit;
348160d8:	ea000002 	b	348160e8 <onenand_erase+0x268>
			region++;
348160dc:	e1a07003 	mov	r7, r3
	loff_t end_addr = addr + len;
348160e0:	e1cda1d0 	ldrd	sl, [sp, #16]
348160e4:	eaffff9d 	b	34815f60 <onenand_erase+0xe0>
	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
348160e8:	e5d43038 	ldrb	r3, [r4, #56]	; 0x38
348160ec:	e3530008 	cmp	r3, #8
348160f0:	13e00004 	mvnne	r0, #4
348160f4:	1a000004 	bne	3481610c <onenand_erase+0x28c>
		mtd_erase_callback(instr);
348160f8:	e1a00004 	mov	r0, r4
348160fc:	ebfff584 	bl	34813714 <mtd_erase_callback>
34816100:	e3a00000 	mov	r0, #0
34816104:	ea000000 	b	3481610c <onenand_erase+0x28c>
		return -EINVAL;
34816108:	e3e00015 	mvn	r0, #21
}
3481610c:	e28dd018 	add	sp, sp, #24
34816110:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816114:	3482660f 	.word	0x3482660f
34816118:	3482664b 	.word	0x3482664b

3481611c <onenand_bbt_read_oob>:
{
3481611c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34816120:	e24dd020 	sub	sp, sp, #32
34816124:	e1cd21f0 	strd	r2, [sp, #16]
34816128:	e3a05000 	mov	r5, #0
3481612c:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
34816130:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	size_t len = ops->ooblen;
34816134:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
	if (unlikely((from + len) > mtd->size)) {
34816138:	e1cd01d0 	ldrd	r0, [sp, #16]
	size_t len = ops->ooblen;
3481613c:	e593900c 	ldr	r9, [r3, #12]
	u_char *buf = ops->oobbuf;
34816140:	e593a01c 	ldr	sl, [r3, #28]
	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34816144:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34816148:	e3130008 	tst	r3, #8
3481614c:	11a03005 	movne	r3, r5
34816150:	03a03013 	moveq	r3, #19
34816154:	e58d301c 	str	r3, [sp, #28]
	if (unlikely((from + len) > mtd->size)) {
34816158:	e0900009 	adds	r0, r0, r9
	ops->oobretlen = 0;
3481615c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
	if (unlikely((from + len) > mtd->size)) {
34816160:	e2a11000 	adc	r1, r1, #0
	ops->oobretlen = 0;
34816164:	e5835010 	str	r5, [r3, #16]
	if (unlikely((from + len) > mtd->size)) {
34816168:	e1c420d8 	ldrd	r2, [r4, #8]
3481616c:	e1510003 	cmp	r1, r3
34816170:	01500002 	cmpeq	r0, r2
34816174:	9a000003 	bls	34816188 <onenand_bbt_read_oob+0x6c>
		printk(KERN_ERR "onenand_bbt_read_oob: Attempt read beyond end of device\n");
34816178:	e59f0104 	ldr	r0, [pc, #260]	; 34816284 <onenand_bbt_read_oob+0x168>
3481617c:	ebffcd86 	bl	3480979c <printf>
		return ONENAND_BBT_READ_FATAL_ERROR;
34816180:	e3a00004 	mov	r0, #4
34816184:	ea00003c 	b	3481627c <onenand_bbt_read_oob+0x160>
	column = from & (mtd->oobsize - 1);
34816188:	e5943018 	ldr	r3, [r4, #24]
3481618c:	e59d2010 	ldr	r2, [sp, #16]
34816190:	e2433001 	sub	r3, r3, #1
34816194:	e003b002 	and	fp, r3, r2
	while (read < len) {
34816198:	e1550009 	cmp	r5, r9
3481619c:	2a000033 	bcs	34816270 <onenand_bbt_read_oob+0x154>
		thislen = mtd->oobsize - column;
348161a0:	e5946018 	ldr	r6, [r4, #24]
		this->command(mtd, readcmd, from, mtd->oobsize);
348161a4:	e1a00004 	mov	r0, r4
348161a8:	e5943018 	ldr	r3, [r4, #24]
348161ac:	e59d101c 	ldr	r1, [sp, #28]
		thislen = mtd->oobsize - column;
348161b0:	e06b6006 	rsb	r6, fp, r6
		this->spare_buf = buf;
348161b4:	e587a084 	str	sl, [r7, #132]	; 0x84
		thislen = min_t(int, thislen, len);
348161b8:	e1560009 	cmp	r6, r9
		this->command(mtd, readcmd, from, mtd->oobsize);
348161bc:	e58d3000 	str	r3, [sp]
348161c0:	e1cd21d0 	ldrd	r2, [sp, #16]
		thislen = min_t(int, thislen, len);
348161c4:	a1a06009 	movge	r6, r9
		this->command(mtd, readcmd, from, mtd->oobsize);
348161c8:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348161cc:	e12fff3c 	blx	ip
		onenand_update_bufferram(mtd, from, 0);
348161d0:	e3a03000 	mov	r3, #0
348161d4:	e5940094 	ldr	r0, [r4, #148]	; 0x94
348161d8:	e58d3000 	str	r3, [sp]
348161dc:	e1cd21d0 	ldrd	r2, [sp, #16]
348161e0:	ebfff96a 	bl	34814790 <onenand_update_bufferram.isra.4>
		ret = this->bbt_wait(mtd, FL_READING);
348161e4:	e5973058 	ldr	r3, [r7, #88]	; 0x58
348161e8:	e3a01001 	mov	r1, #1
348161ec:	e1a00004 	mov	r0, r4
348161f0:	e12fff33 	blx	r3
		if (unlikely(ret))
348161f4:	e3500000 	cmp	r0, #0
348161f8:	1a00000c 	bne	34816230 <onenand_bbt_read_oob+0x114>
		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
348161fc:	e59f3084 	ldr	r3, [pc, #132]	; 34816288 <onenand_bbt_read_oob+0x16c>
34816200:	e3a02000 	mov	r2, #0
34816204:	e58d600c 	str	r6, [sp, #12]
34816208:	e1a00004 	mov	r0, r4
3481620c:	e98d0c00 	stmib	sp, {sl, fp}
		read += thislen;
34816210:	e0855006 	add	r5, r5, r6
		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816214:	e58d3000 	str	r3, [sp]
34816218:	e3a03000 	mov	r3, #0
3481621c:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34816220:	e12fff31 	blx	r1
		if (read == len)
34816224:	e1550009 	cmp	r5, r9
34816228:	1a000007 	bne	3481624c <onenand_bbt_read_oob+0x130>
3481622c:	ea00000f 	b	34816270 <onenand_bbt_read_oob+0x154>
			ret = onenand_recover_lsb(mtd, from, ret);
34816230:	e58d0000 	str	r0, [sp]
34816234:	e1a00004 	mov	r0, r4
34816238:	e1cd21d0 	ldrd	r2, [sp, #16]
3481623c:	ebfffce2 	bl	348155cc <onenand_recover_lsb>
		if (ret)
34816240:	e3500000 	cmp	r0, #0
34816244:	0affffec 	beq	348161fc <onenand_bbt_read_oob+0xe0>
34816248:	ea000009 	b	34816274 <onenand_bbt_read_oob+0x158>
		buf += thislen;
3481624c:	e08aa006 	add	sl, sl, r6
		if (read < len) {
34816250:	2affffd0 	bcs	34816198 <onenand_bbt_read_oob+0x7c>
			from += this->writesize;
34816254:	e1cd01d0 	ldrd	r0, [sp, #16]
			column = 0;
34816258:	e3a0b000 	mov	fp, #0
			from += this->writesize;
3481625c:	e5973040 	ldr	r3, [r7, #64]	; 0x40
34816260:	e0900003 	adds	r0, r0, r3
34816264:	e2a11000 	adc	r1, r1, #0
34816268:	e1cd01f0 	strd	r0, [sp, #16]
3481626c:	eaffffc9 	b	34816198 <onenand_bbt_read_oob+0x7c>
34816270:	e3a00000 	mov	r0, #0
	ops->oobretlen = read;
34816274:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
34816278:	e5835010 	str	r5, [r3, #16]
}
3481627c:	e28dd020 	add	sp, sp, #32
34816280:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816284:	3482666d 	.word	0x3482666d
34816288:	00010020 	.word	0x00010020

3481628c <onenand_print_device_info>:
{
3481628c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34816290:	e1a04000 	mov	r4, r0
34816294:	e24dd014 	sub	sp, sp, #20
	char *dev_info = malloc(80);
34816298:	e3a00050 	mov	r0, #80	; 0x50
{
3481629c:	e1a06001 	mov	r6, r1
	return (density & ONENAND_DEVICE_DENSITY_MASK);
348162a0:	e7e37254 	ubfx	r7, r4, #4, #4
	char *dev_info = malloc(80);
348162a4:	ebffcf0b 	bl	34809ed8 <malloc>
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
348162a8:	e59fe078 	ldr	lr, [pc, #120]	; 34816328 <onenand_print_device_info+0x9c>
348162ac:	e3140004 	tst	r4, #4
348162b0:	e59f3074 	ldr	r3, [pc, #116]	; 3481632c <onenand_print_device_info+0xa0>
348162b4:	e3a0c010 	mov	ip, #16
348162b8:	e1a0c71c 	lsl	ip, ip, r7
348162bc:	e59f706c 	ldr	r7, [pc, #108]	; 34816330 <onenand_print_device_info+0xa4>
348162c0:	11a0200e 	movne	r2, lr
348162c4:	e59f1068 	ldr	r1, [pc, #104]	; 34816334 <onenand_print_device_info+0xa8>
348162c8:	01a02003 	moveq	r2, r3
348162cc:	e3140c02 	tst	r4, #512	; 0x200
348162d0:	e59f3060 	ldr	r3, [pc, #96]	; 34816338 <onenand_print_device_info+0xac>
348162d4:	01a0300e 	moveq	r3, lr
348162d8:	e3140008 	tst	r4, #8
	char *dev_info = malloc(80);
348162dc:	e1a05000 	mov	r5, r0
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
348162e0:	01a0100e 	moveq	r1, lr
348162e4:	e59fe050 	ldr	lr, [pc, #80]	; 3481633c <onenand_print_device_info+0xb0>
348162e8:	e3140003 	tst	r4, #3
348162ec:	e58d400c 	str	r4, [sp, #12]
348162f0:	01a0e007 	moveq	lr, r7
348162f4:	e88d5002 	stm	sp, {r1, ip, lr}
348162f8:	e59f1040 	ldr	r1, [pc, #64]	; 34816340 <onenand_print_device_info+0xb4>
348162fc:	eb0019c1 	bl	3481ca08 <sprintf>
	sprintf(p, "\nOneNAND version = 0x%04x", version);
34816300:	e1a02006 	mov	r2, r6
34816304:	e59f1038 	ldr	r1, [pc, #56]	; 34816344 <onenand_print_device_info+0xb8>
34816308:	e0850000 	add	r0, r5, r0
3481630c:	eb0019bd 	bl	3481ca08 <sprintf>
	printk("%s\n", dev_info);
34816310:	e1a01005 	mov	r1, r5
34816314:	e59f002c 	ldr	r0, [pc, #44]	; 34816348 <onenand_print_device_info+0xbc>
34816318:	ebffcd1f 	bl	3480979c <printf>
}
3481631c:	e1a00005 	mov	r0, r5
34816320:	e28dd014 	add	sp, sp, #20
34816324:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34816328:	34822afd 	.word	0x34822afd
3481632c:	348266a6 	.word	0x348266a6
34816330:	348266bc 	.word	0x348266bc
34816334:	348266ad 	.word	0x348266ad
34816338:	348261ab 	.word	0x348261ab
3481633c:	348266b3 	.word	0x348266b3
34816340:	348266c0 	.word	0x348266c0
34816344:	348266e7 	.word	0x348266e7
34816348:	34824c10 	.word	0x34824c10

3481634c <flexonenand_set_boundary>:
{
3481634c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34816350:	e24dd038 	sub	sp, sp, #56	; 0x38
	struct onenand_chip *this = mtd->priv;
34816354:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	if (die >= this->dies)
34816358:	e594c004 	ldr	ip, [r4, #4]
3481635c:	e151000c 	cmp	r1, ip
34816360:	2a0000c4 	bcs	34816678 <flexonenand_set_boundary+0x32c>
	if (boundary == this->boundary[die])
34816364:	e281c002 	add	ip, r1, #2
34816368:	e794c10c 	ldr	ip, [r4, ip, lsl #2]
3481636c:	e152000c 	cmp	r2, ip
		return 0;
34816370:	03a06000 	moveq	r6, #0
	if (boundary == this->boundary[die])
34816374:	0a0000c2 	beq	34816684 <flexonenand_set_boundary+0x338>
34816378:	e1a09002 	mov	r9, r2
	density = onenand_get_density(this->device_id);
3481637c:	e594201c 	ldr	r2, [r4, #28]
34816380:	e58d3014 	str	r3, [sp, #20]
34816384:	e1a07001 	mov	r7, r1
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816388:	e3a03401 	mov	r3, #16777216	; 0x1000000
3481638c:	e1a05000 	mov	r5, r0
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816390:	e7e31252 	ubfx	r1, r2, #4, #4
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34816394:	e7e021d2 	ubfx	r2, r2, #3, #1
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816398:	e1a03113 	lsl	r3, r3, r1
3481639c:	e5941030 	ldr	r1, [r4, #48]	; 0x30
348163a0:	e1a03153 	asr	r3, r3, r1
	if (boundary >= blksperdie) {
348163a4:	e1590253 	cmp	r9, r3, asr r2
348163a8:	ba000002 	blt	348163b8 <flexonenand_set_boundary+0x6c>
		printk("flexonenand_set_boundary:"
348163ac:	e59f02dc 	ldr	r0, [pc, #732]	; 34816690 <flexonenand_set_boundary+0x344>
348163b0:	ebffccf9 	bl	3480979c <printf>
348163b4:	ea0000af 	b	34816678 <flexonenand_set_boundary+0x32c>
	old = this->boundary[die] + (die * this->density_mask);
348163b8:	e5946028 	ldr	r6, [r4, #40]	; 0x28
	struct mtd_oob_ops ops = {
348163bc:	e28db018 	add	fp, sp, #24
348163c0:	e3a02020 	mov	r2, #32
348163c4:	e3a01000 	mov	r1, #0
348163c8:	e1a0000b 	mov	r0, fp
	old = this->boundary[die] + (die * this->density_mask);
348163cc:	e0060796 	mul	r6, r6, r7
348163d0:	e086300c 	add	r3, r6, ip
	new = boundary + (die * this->density_mask);
348163d4:	e0866009 	add	r6, r6, r9
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
348163d8:	e1560003 	cmp	r6, r3
348163dc:	b1a0a006 	movlt	sl, r6
348163e0:	a1a0a003 	movge	sl, r3
						+ 1, max(old, new));
348163e4:	b1a06003 	movlt	r6, r3
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
348163e8:	e28aa001 	add	sl, sl, #1
	struct mtd_oob_ops ops = {
348163ec:	eb0015e2 	bl	3481bb7c <memset>
348163f0:	e5953018 	ldr	r3, [r5, #24]
	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
348163f4:	e1a02006 	mov	r2, r6
348163f8:	e1a0100a 	mov	r1, sl
348163fc:	e59f0290 	ldr	r0, [pc, #656]	; 34816694 <flexonenand_set_boundary+0x348>
	struct mtd_oob_ops ops = {
34816400:	e58d3024 	str	r3, [sp, #36]	; 0x24
34816404:	e5943090 	ldr	r3, [r4, #144]	; 0x90
34816408:	e58d3034 	str	r3, [sp, #52]	; 0x34
	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
3481640c:	ebffcce2 	bl	3480979c <printf>
	for (block = start; block <= end; block++) {
34816410:	e15a0006 	cmp	sl, r6
34816414:	ca000021 	bgt	348164a0 <flexonenand_set_boundary+0x154>
		addr = flexonenand_addr(this, block);
34816418:	e1a0100a 	mov	r1, sl
3481641c:	e1a00004 	mov	r0, r4
34816420:	ebfff6ce 	bl	34813f60 <flexonenand_addr>
34816424:	e1cd00f8 	strd	r0, [sp, #8]
		if (onenand_block_isbad_nolock(mtd, addr, 0))
34816428:	e1a02000 	mov	r2, r0
3481642c:	e1a03001 	mov	r3, r1
34816430:	e1a00005 	mov	r0, r5
34816434:	ebfffb4d 	bl	34815170 <onenand_block_isbad_nolock.constprop.14>
34816438:	e3500000 	cmp	r0, #0
3481643c:	1a000015 	bne	34816498 <flexonenand_set_boundary+0x14c>
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
34816440:	e58db000 	str	fp, [sp]
34816444:	e1a00005 	mov	r0, r5
34816448:	e1cd20d8 	ldrd	r2, [sp, #8]
3481644c:	ebfffdda 	bl	34815bbc <onenand_read_oob_nolock>
		if (ret)
34816450:	e3500000 	cmp	r0, #0
34816454:	1a000033 	bne	34816528 <flexonenand_set_boundary+0x1dc>
		for (i = 0; i < mtd->oobsize; i++)
34816458:	e5953018 	ldr	r3, [r5, #24]
3481645c:	e1500003 	cmp	r0, r3
34816460:	0a000003 	beq	34816474 <flexonenand_set_boundary+0x128>
			if (this->oob_buf[i] != 0xff)
34816464:	e5942090 	ldr	r2, [r4, #144]	; 0x90
34816468:	e7d22000 	ldrb	r2, [r2, r0]
3481646c:	e35200ff 	cmp	r2, #255	; 0xff
34816470:	0a000006 	beq	34816490 <flexonenand_set_boundary+0x144>
		if (i != mtd->oobsize) {
34816474:	e1500003 	cmp	r0, r3
34816478:	0a000006 	beq	34816498 <flexonenand_set_boundary+0x14c>
			printk(KERN_WARNING "Block %d not erased.\n", block);
3481647c:	e1a0100a 	mov	r1, sl
34816480:	e59f0210 	ldr	r0, [pc, #528]	; 34816698 <flexonenand_set_boundary+0x34c>
34816484:	ebffccc4 	bl	3480979c <printf>
			return 1;
34816488:	e3a06001 	mov	r6, #1
3481648c:	ea000026 	b	3481652c <flexonenand_set_boundary+0x1e0>
		for (i = 0; i < mtd->oobsize; i++)
34816490:	e2800001 	add	r0, r0, #1
34816494:	eafffff0 	b	3481645c <flexonenand_set_boundary+0x110>
	for (block = start; block <= end; block++) {
34816498:	e28aa001 	add	sl, sl, #1
3481649c:	eaffffdb 	b	34816410 <flexonenand_set_boundary+0xc4>
	this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
348164a0:	e1a03fc7 	asr	r3, r7, #31
	return 0;
348164a4:	e3a06000 	mov	r6, #0
	this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
348164a8:	e1a02007 	mov	r2, r7
348164ac:	e58d6000 	str	r6, [sp]
348164b0:	e3a01066 	mov	r1, #102	; 0x66
348164b4:	e594a050 	ldr	sl, [r4, #80]	; 0x50
348164b8:	e1a00005 	mov	r0, r5
348164bc:	e1cd20f8 	strd	r2, [sp, #8]
348164c0:	e12fff3a 	blx	sl
	this->wait(mtd, FL_SYNCING);
348164c4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348164c8:	e3a01004 	mov	r1, #4
348164cc:	e1a00005 	mov	r0, r5
348164d0:	e12fff33 	blx	r3
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
348164d4:	e1cd20d8 	ldrd	r2, [sp, #8]
348164d8:	e3011985 	movw	r1, #6533	; 0x1985
348164dc:	e58d6000 	str	r6, [sp]
348164e0:	e1a00005 	mov	r0, r5
348164e4:	e594a050 	ldr	sl, [r4, #80]	; 0x50
348164e8:	e12fff3a 	blx	sl
	ret = this->wait(mtd, FL_READING);
348164ec:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348164f0:	e3a01001 	mov	r1, #1
348164f4:	e1a00005 	mov	r0, r5
348164f8:	e12fff33 	blx	r3
348164fc:	e1a0a000 	mov	sl, r0
	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
34816500:	e5940000 	ldr	r0, [r4]
34816504:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816508:	e2800b01 	add	r0, r0, #1024	; 0x400
3481650c:	e12fff33 	blx	r3
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
34816510:	e1a00740 	asr	r0, r0, #14
34816514:	e3500003 	cmp	r0, #3
34816518:	0a000006 	beq	34816538 <flexonenand_set_boundary+0x1ec>
		printk(KERN_ERR "flexonenand_set_boundary: boundary locked\n");
3481651c:	e59f0178 	ldr	r0, [pc, #376]	; 3481669c <flexonenand_set_boundary+0x350>
34816520:	ebffcc9d 	bl	3480979c <printf>
		goto out;
34816524:	ea000044 	b	3481663c <flexonenand_set_boundary+0x2f0>
		if (ret)
34816528:	e1a06000 	mov	r6, r0
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
3481652c:	e59f016c 	ldr	r0, [pc, #364]	; 348166a0 <flexonenand_set_boundary+0x354>
34816530:	ebffcc99 	bl	3480979c <printf>
		return ret;
34816534:	ea000052 	b	34816684 <flexonenand_set_boundary+0x338>
	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
34816538:	e59d1014 	ldr	r1, [sp, #20]
3481653c:	e59f2160 	ldr	r2, [pc, #352]	; 348166a4 <flexonenand_set_boundary+0x358>
34816540:	e59f3160 	ldr	r3, [pc, #352]	; 348166a8 <flexonenand_set_boundary+0x35c>
34816544:	e3510000 	cmp	r1, #0
34816548:	e59f015c 	ldr	r0, [pc, #348]	; 348166ac <flexonenand_set_boundary+0x360>
3481654c:	11a03002 	movne	r3, r2
34816550:	e1a01007 	mov	r1, r7
34816554:	e1a02009 	mov	r2, r9
34816558:	ebffcc8f 	bl	3480979c <printf>
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
3481655c:	e59d3014 	ldr	r3, [sp, #20]
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
34816560:	e3a01094 	mov	r1, #148	; 0x94
34816564:	e1a00005 	mov	r0, r5
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
34816568:	e3530000 	cmp	r3, #0
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
3481656c:	e3a03000 	mov	r3, #0
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
34816570:	03a06903 	moveq	r6, #49152	; 0xc000
	addr = die ? this->diesize[0] : 0;
34816574:	e3570000 	cmp	r7, #0
34816578:	1594b010 	ldrne	fp, [r4, #16]
3481657c:	01a0b007 	moveq	fp, r7
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
34816580:	e58d3000 	str	r3, [sp]
34816584:	e594a050 	ldr	sl, [r4, #80]	; 0x50
34816588:	e1a0200b 	mov	r2, fp
3481658c:	e12fff3a 	blx	sl
	ret = this->wait(mtd, FL_ERASING);
34816590:	e3a01003 	mov	r1, #3
34816594:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816598:	e1a00005 	mov	r0, r5
3481659c:	e12fff33 	blx	r3
	if (ret) {
348165a0:	e250a000 	subs	sl, r0, #0
		printk("flexonenand_set_boundary:"
348165a4:	11a01007 	movne	r1, r7
348165a8:	159f0100 	ldrne	r0, [pc, #256]	; 348166b0 <flexonenand_set_boundary+0x364>
	if (ret) {
348165ac:	1a000015 	bne	34816608 <flexonenand_set_boundary+0x2bc>
	this->write_word(boundary, this->base + ONENAND_DATARAM);
348165b0:	e5941000 	ldr	r1, [r4]
	boundary &= FLEXONENAND_PI_MASK;
348165b4:	e7e90059 	ubfx	r0, r9, #0, #10
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
348165b8:	e1860000 	orr	r0, r6, r0
	this->write_word(boundary, this->base + ONENAND_DATARAM);
348165bc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348165c0:	e6ff0070 	uxth	r0, r0
348165c4:	e2811b01 	add	r1, r1, #1024	; 0x400
348165c8:	e12fff33 	blx	r3
	this->command(mtd, ONENAND_CMD_PROG, addr, 0);
348165cc:	e58da000 	str	sl, [sp]
348165d0:	e1a0300a 	mov	r3, sl
348165d4:	e1a0200b 	mov	r2, fp
348165d8:	e3a01080 	mov	r1, #128	; 0x80
348165dc:	e5946050 	ldr	r6, [r4, #80]	; 0x50
348165e0:	e1a00005 	mov	r0, r5
348165e4:	e12fff36 	blx	r6
	ret = this->wait(mtd, FL_WRITING);
348165e8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348165ec:	e3a01002 	mov	r1, #2
348165f0:	e1a00005 	mov	r0, r5
348165f4:	e12fff33 	blx	r3
	if (ret) {
348165f8:	e250a000 	subs	sl, r0, #0
348165fc:	0a000003 	beq	34816610 <flexonenand_set_boundary+0x2c4>
		printk("flexonenand_set_boundary:"
34816600:	e59f00ac 	ldr	r0, [pc, #172]	; 348166b4 <flexonenand_set_boundary+0x368>
34816604:	e1a01007 	mov	r1, r7
34816608:	ebffcc63 	bl	3480979c <printf>
		goto out;
3481660c:	ea00000a 	b	3481663c <flexonenand_set_boundary+0x2f0>
	this->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);
34816610:	e58da000 	str	sl, [sp]
34816614:	e3a01005 	mov	r1, #5
34816618:	e1cd20d8 	ldrd	r2, [sp, #8]
3481661c:	e1a00005 	mov	r0, r5
34816620:	e5946050 	ldr	r6, [r4, #80]	; 0x50
34816624:	e12fff36 	blx	r6
	ret = this->wait(mtd, FL_WRITING);
34816628:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481662c:	e3a01002 	mov	r1, #2
34816630:	e1a00005 	mov	r0, r5
34816634:	e12fff33 	blx	r3
34816638:	e1a0a000 	mov	sl, r0
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);
3481663c:	e5941000 	ldr	r1, [r4]
34816640:	e3a000f0 	mov	r0, #240	; 0xf0
34816644:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816648:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481664c:	e2811040 	add	r1, r1, #64	; 0x40
34816650:	e12fff33 	blx	r3
	this->wait(mtd, FL_RESETING);
34816654:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816658:	e3a01006 	mov	r1, #6
3481665c:	e1a00005 	mov	r0, r5
34816660:	e12fff33 	blx	r3
	if (!ret)
34816664:	e35a0000 	cmp	sl, #0
34816668:	1a000004 	bne	34816680 <flexonenand_set_boundary+0x334>
		flexonenand_get_size(mtd);
3481666c:	e1a00005 	mov	r0, r5
34816670:	ebfff6a0 	bl	348140f8 <flexonenand_get_size>
34816674:	ea000001 	b	34816680 <flexonenand_set_boundary+0x334>
		return -EINVAL;
34816678:	e3e06015 	mvn	r6, #21
3481667c:	ea000000 	b	34816684 <flexonenand_set_boundary+0x338>
34816680:	e1a0600a 	mov	r6, sl
}
34816684:	e1a00006 	mov	r0, r6
34816688:	e28dd038 	add	sp, sp, #56	; 0x38
3481668c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816690:	34826701 	.word	0x34826701
34816694:	34826749 	.word	0x34826749
34816698:	34826765 	.word	0x34826765
3481669c:	348267c1 	.word	0x348267c1
348166a0:	3482677b 	.word	0x3482677b
348166a4:	348261bb 	.word	0x348261bb
348166a8:	348261c4 	.word	0x348261c4
348166ac:	348267ec 	.word	0x348267ec
348166b0:	34826826 	.word	0x34826826
348166b4:	3482685b 	.word	0x3482685b

348166b8 <onenand_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
348166b8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348166bc:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
348166c0:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int dev_id, ver_id;
	int density;
	int ret;

	ret = this->chip_probe(mtd);
348166c4:	e5943070 	ldr	r3, [r4, #112]	; 0x70
348166c8:	e12fff33 	blx	r3
	if (ret)
348166cc:	e3500000 	cmp	r0, #0
348166d0:	1a0000b5 	bne	348169ac <onenand_probe+0x2f4>
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
348166d4:	e5940000 	ldr	r0, [r4]
348166d8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348166dc:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348166e0:	e2800002 	add	r0, r0, #2
348166e4:	e12fff33 	blx	r3
348166e8:	e1a07000 	mov	r7, r0
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
348166ec:	e5940000 	ldr	r0, [r4]
348166f0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348166f4:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348166f8:	e2800004 	add	r0, r0, #4
348166fc:	e12fff33 	blx	r3
34816700:	e1a06000 	mov	r6, r0
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
34816704:	e5940000 	ldr	r0, [r4]
34816708:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481670c:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816710:	e280000c 	add	r0, r0, #12
34816714:	e12fff33 	blx	r3

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
34816718:	e1a01006 	mov	r1, r6
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
3481671c:	e5840024 	str	r0, [r4, #36]	; 0x24
	mtd->name = onenand_print_device_info(dev_id, ver_id);
34816720:	e1a00007 	mov	r0, r7
34816724:	ebfffed8 	bl	3481628c <onenand_print_device_info>
34816728:	e5850020 	str	r0, [r5, #32]
	this->device_id = dev_id;
	this->version_id = ver_id;
3481672c:	e5846020 	str	r6, [r4, #32]
34816730:	e5956094 	ldr	r6, [r5, #148]	; 0x94
	this->device_id = dev_id;
34816734:	e584701c 	str	r7, [r4, #28]
	density = onenand_get_density(this->device_id);
34816738:	e596201c 	ldr	r2, [r6, #28]
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
3481673c:	e5961020 	ldr	r1, [r6, #32]
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816740:	e7e30252 	ubfx	r0, r2, #4, #4
	switch (density) {
34816744:	e3500004 	cmp	r0, #4
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
34816748:	e1a01421 	lsr	r1, r1, #8
	switch (density) {
3481674c:	0a000009 	beq	34816778 <onenand_probe+0xc0>
34816750:	e3500005 	cmp	r0, #5
34816754:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
34816758:	0a000002 	beq	34816768 <onenand_probe+0xb0>
3481675c:	e3500003 	cmp	r0, #3
34816760:	1a000010 	bne	348167a8 <onenand_probe+0xf0>
34816764:	ea00000a 	b	34816794 <onenand_probe+0xdc>
		if (ONENAND_IS_DDP(this))
34816768:	e3120008 	tst	r2, #8
			this->options |= ONENAND_HAS_2PLANE;
3481676c:	13833004 	orrne	r3, r3, #4
			this->options |= ONENAND_HAS_4KB_PAGE;
34816770:	03833008 	orreq	r3, r3, #8
34816774:	e586302c 	str	r3, [r6, #44]	; 0x2c
		if (!ONENAND_IS_DDP(this))
34816778:	e3120008 	tst	r2, #8
			this->options |= ONENAND_HAS_2PLANE;
3481677c:	0596302c 	ldreq	r3, [r6, #44]	; 0x2c
34816780:	03833004 	orreq	r3, r3, #4
34816784:	0586302c 	streq	r3, [r6, #44]	; 0x2c
		this->options |= ONENAND_HAS_UNLOCK_ALL;
34816788:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
3481678c:	e3833002 	orr	r3, r3, #2
34816790:	e586302c 	str	r3, [r6, #44]	; 0x2c
		if (process)
34816794:	e3510000 	cmp	r1, #0
			this->options |= ONENAND_HAS_UNLOCK_ALL;
34816798:	1596302c 	ldrne	r3, [r6, #44]	; 0x2c
3481679c:	13833002 	orrne	r3, r3, #2
		if (process)
348167a0:	1a000003 	bne	348167b4 <onenand_probe+0xfc>
348167a4:	ea000003 	b	348167b8 <onenand_probe+0x100>
		if (!process)
348167a8:	e3510000 	cmp	r1, #0
348167ac:	1a000001 	bne	348167b8 <onenand_probe+0x100>
			this->options |= ONENAND_HAS_CONT_LOCK;
348167b0:	e3833001 	orr	r3, r3, #1
348167b4:	e586302c 	str	r3, [r6, #44]	; 0x2c
	if (ONENAND_IS_MLC(this))
348167b8:	e5963024 	ldr	r3, [r6, #36]	; 0x24
348167bc:	e3130001 	tst	r3, #1
		this->options |= ONENAND_HAS_4KB_PAGE;
348167c0:	1596302c 	ldrne	r3, [r6, #44]	; 0x2c
348167c4:	13833008 	orrne	r3, r3, #8
348167c8:	1586302c 	strne	r3, [r6, #44]	; 0x2c
	if (ONENAND_IS_4KB_PAGE(this))
348167cc:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
348167d0:	e3130008 	tst	r3, #8
		this->options &= ~ONENAND_HAS_2PLANE;
348167d4:	13c33004 	bicne	r3, r3, #4
348167d8:	1586302c 	strne	r3, [r6, #44]	; 0x2c
	if (FLEXONENAND(this)) {
348167dc:	e3120c02 	tst	r2, #512	; 0x200
		this->options &= ~ONENAND_HAS_CONT_LOCK;
348167e0:	1596302c 	ldrne	r3, [r6, #44]	; 0x2c
348167e4:	13c33001 	bicne	r3, r3, #1
		this->options |= ONENAND_HAS_UNLOCK_ALL;
348167e8:	13833002 	orrne	r3, r3, #2
348167ec:	1586302c 	strne	r3, [r6, #44]	; 0x2c
	if (this->options & ONENAND_HAS_CONT_LOCK)
348167f0:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
348167f4:	e3130001 	tst	r3, #1
348167f8:	0a000001 	beq	34816804 <onenand_probe+0x14c>
		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
348167fc:	e59f01b0 	ldr	r0, [pc, #432]	; 348169b4 <onenand_probe+0x2fc>
34816800:	ebffcbe5 	bl	3480979c <printf>
	if (this->options & ONENAND_HAS_UNLOCK_ALL)
34816804:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
34816808:	e3130002 	tst	r3, #2
3481680c:	0a000001 	beq	34816818 <onenand_probe+0x160>
		printk(KERN_DEBUG "Chip support all block unlock\n");
34816810:	e59f01a0 	ldr	r0, [pc, #416]	; 348169b8 <onenand_probe+0x300>
34816814:	ebffcbe0 	bl	3480979c <printf>
	if (this->options & ONENAND_HAS_2PLANE)
34816818:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
3481681c:	e3130004 	tst	r3, #4
34816820:	0a000001 	beq	3481682c <onenand_probe+0x174>
		printk(KERN_DEBUG "Chip has 2 plane\n");
34816824:	e59f0190 	ldr	r0, [pc, #400]	; 348169bc <onenand_probe+0x304>
34816828:	ebffcbdb 	bl	3480979c <printf>
	if (this->options & ONENAND_HAS_4KB_PAGE)
3481682c:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
34816830:	e3130008 	tst	r3, #8
34816834:	0a000001 	beq	34816840 <onenand_probe+0x188>
		printk(KERN_DEBUG "Chip has 4KiB pagesize\n");
34816838:	e59f0180 	ldr	r0, [pc, #384]	; 348169c0 <onenand_probe+0x308>
3481683c:	ebffcbd6 	bl	3480979c <printf>

	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
34816840:	e594301c 	ldr	r3, [r4, #28]
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816844:	e7e37257 	ubfx	r7, r7, #4, #4
	if (FLEXONENAND(this)) {
34816848:	e3130c02 	tst	r3, #512	; 0x200
3481684c:	1a000035 	bne	34816928 <onenand_probe+0x270>
	this->chipsize = (16 << density) << 20;

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34816850:	e5940000 	ldr	r0, [r4]
	this->chipsize = (16 << density) << 20;
34816854:	e3a03401 	mov	r3, #16777216	; 0x1000000
34816858:	e1a07713 	lsl	r7, r3, r7
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
3481685c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816860:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
	this->chipsize = (16 << density) << 20;
34816864:	e5847018 	str	r7, [r4, #24]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34816868:	e2800006 	add	r0, r0, #6
3481686c:	e12fff33 	blx	r3
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34816870:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	mtd->writesize =
34816874:	e5850014 	str	r0, [r5, #20]
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
34816878:	e594901c 	ldr	r9, [r4, #28]
	if (ONENAND_IS_4KB_PAGE(this))
3481687c:	e3130008 	tst	r3, #8
		mtd->writesize <<= 1;
34816880:	11a00080 	lslne	r0, r0, #1
34816884:	15850014 	strne	r0, [r5, #20]
	if (FLEXONENAND(this))
34816888:	e219ac02 	ands	sl, r9, #512	; 0x200
	mtd->oobsize = mtd->writesize >> 5;
3481688c:	e5956014 	ldr	r6, [r5, #20]
34816890:	e1a032a6 	lsr	r3, r6, #5
34816894:	e5853018 	str	r3, [r5, #24]
	mtd->erasesize = mtd->writesize << 6;
34816898:	e1a03306 	lsl	r3, r6, #6
3481689c:	e5853010 	str	r3, [r5, #16]
		mtd->erasesize <<= 1;
348168a0:	11a03386 	lslne	r3, r6, #7
348168a4:	15853010 	strne	r3, [r5, #16]

	this->erase_shift = ffs(mtd->erasesize) - 1;
348168a8:	e5953010 	ldr	r3, [r5, #16]
348168ac:	e1a00003 	mov	r0, r3
348168b0:	e58d3004 	str	r3, [sp, #4]
348168b4:	ebfff756 	bl	34814614 <generic_ffs>
348168b8:	e2407001 	sub	r7, r0, #1
348168bc:	e1a0b000 	mov	fp, r0
348168c0:	e5847030 	str	r7, [r4, #48]	; 0x30
	this->page_shift = ffs(mtd->writesize) - 1;
348168c4:	e1a00006 	mov	r0, r6
348168c8:	ebfff751 	bl	34814614 <generic_ffs>
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348168cc:	e59d3004 	ldr	r3, [sp, #4]
	this->page_shift = ffs(mtd->writesize) - 1;
348168d0:	e2400001 	sub	r0, r0, #1
	this->ppb_shift = (this->erase_shift - this->page_shift);
348168d4:	e0607007 	rsb	r7, r0, r7
	this->page_shift = ffs(mtd->writesize) - 1;
348168d8:	e5840034 	str	r0, [r4, #52]	; 0x34
	this->ppb_shift = (this->erase_shift - this->page_shift);
348168dc:	e5847038 	str	r7, [r4, #56]	; 0x38
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348168e0:	e1a01006 	mov	r1, r6
348168e4:	e1a00003 	mov	r0, r3
348168e8:	fa0021cc 	blx	3481f020 <__udivsi3>
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
348168ec:	e3190008 	tst	r9, #8
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348168f0:	e2400001 	sub	r0, r0, #1
348168f4:	e584003c 	str	r0, [r4, #60]	; 0x3c
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
348168f8:	15940018 	ldrne	r0, [r4, #24]
	/* It's real page size */
	this->writesize = mtd->writesize;
348168fc:	e5846040 	str	r6, [r4, #64]	; 0x40
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
34816900:	11a00b30 	lsrne	r0, r0, fp
34816904:	15840028 	strne	r0, [r4, #40]	; 0x28

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
34816908:	e35a0000 	cmp	sl, #0
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
3481690c:	05943018 	ldreq	r3, [r4, #24]
34816910:	0585a00c 	streq	sl, [r5, #12]
34816914:	05853008 	streq	r3, [r5, #8]
	if (FLEXONENAND(this))
34816918:	0a000010 	beq	34816960 <onenand_probe+0x2a8>
		flexonenand_get_size(mtd);
3481691c:	e1a00005 	mov	r0, r5
34816920:	ebfff5f4 	bl	348140f8 <flexonenand_get_size>
34816924:	ea00000d 	b	34816960 <onenand_probe+0x2a8>
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
34816928:	e3130008 	tst	r3, #8
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
3481692c:	e3a00030 	mov	r0, #48	; 0x30
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
34816930:	13a03002 	movne	r3, #2
34816934:	03a03001 	moveq	r3, #1
		mtd->numeraseregions = this->dies << 1;
34816938:	e1a02083 	lsl	r2, r3, #1
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
3481693c:	e5843004 	str	r3, [r4, #4]
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34816940:	e0000390 	mul	r0, r0, r3
		mtd->numeraseregions = this->dies << 1;
34816944:	e585202c 	str	r2, [r5, #44]	; 0x2c
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34816948:	ebffcd62 	bl	34809ed8 <malloc>
		if (!mtd->eraseregions)
3481694c:	e3500000 	cmp	r0, #0
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34816950:	e5850030 	str	r0, [r5, #48]	; 0x30
		if (!mtd->eraseregions)
34816954:	1affffbd 	bne	34816850 <onenand_probe+0x198>
			return -ENOMEM;
34816958:	e3e0000b 	mvn	r0, #11
3481695c:	ea000012 	b	348169ac <onenand_probe+0x2f4>

	mtd->flags = MTD_CAP_NANDFLASH;
34816960:	e3a03b01 	mov	r3, #1024	; 0x400
	mtd->write_oob = onenand_write_oob;
	mtd->sync = onenand_sync;
	mtd->block_isbad = onenand_block_isbad;
	mtd->block_markbad = onenand_block_markbad;

	return 0;
34816964:	e3a00000 	mov	r0, #0
	mtd->flags = MTD_CAP_NANDFLASH;
34816968:	e5853004 	str	r3, [r5, #4]
	mtd->erase = onenand_erase;
3481696c:	e59f3050 	ldr	r3, [pc, #80]	; 348169c4 <onenand_probe+0x30c>
34816970:	e5853034 	str	r3, [r5, #52]	; 0x34
	mtd->read = onenand_read;
34816974:	e59f304c 	ldr	r3, [pc, #76]	; 348169c8 <onenand_probe+0x310>
34816978:	e5853040 	str	r3, [r5, #64]	; 0x40
	mtd->write = onenand_write;
3481697c:	e59f3048 	ldr	r3, [pc, #72]	; 348169cc <onenand_probe+0x314>
34816980:	e5853044 	str	r3, [r5, #68]	; 0x44
	mtd->read_oob = onenand_read_oob;
34816984:	e59f3044 	ldr	r3, [pc, #68]	; 348169d0 <onenand_probe+0x318>
34816988:	e585304c 	str	r3, [r5, #76]	; 0x4c
	mtd->write_oob = onenand_write_oob;
3481698c:	e59f3040 	ldr	r3, [pc, #64]	; 348169d4 <onenand_probe+0x31c>
34816990:	e5853050 	str	r3, [r5, #80]	; 0x50
	mtd->sync = onenand_sync;
34816994:	e59f303c 	ldr	r3, [pc, #60]	; 348169d8 <onenand_probe+0x320>
34816998:	e585306c 	str	r3, [r5, #108]	; 0x6c
	mtd->block_isbad = onenand_block_isbad;
3481699c:	e59f3038 	ldr	r3, [pc, #56]	; 348169dc <onenand_probe+0x324>
348169a0:	e5853078 	str	r3, [r5, #120]	; 0x78
	mtd->block_markbad = onenand_block_markbad;
348169a4:	e59f3034 	ldr	r3, [pc, #52]	; 348169e0 <onenand_probe+0x328>
348169a8:	e585307c 	str	r3, [r5, #124]	; 0x7c
}
348169ac:	e28dd008 	add	sp, sp, #8
348169b0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348169b4:	34826890 	.word	0x34826890
348169b8:	348268b0 	.word	0x348268b0
348169bc:	348268cf 	.word	0x348268cf
348169c0:	348268e1 	.word	0x348268e1
348169c4:	34815e80 	.word	0x34815e80
348169c8:	34815b5c 	.word	0x34815b5c
348169cc:	34814df0 	.word	0x34814df0
348169d0:	34815e50 	.word	0x34815e50
348169d4:	34815140 	.word	0x34815140
348169d8:	34813ff8 	.word	0x34813ff8
348169dc:	34815194 	.word	0x34815194
348169e0:	348151bc 	.word	0x348151bc

348169e4 <onenand_scan>:
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
348169e4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348169e8:	e1a09000 	mov	r9, r0
	int i;
	struct onenand_chip *this = mtd->priv;
348169ec:	e5904094 	ldr	r4, [r0, #148]	; 0x94

	if (!this->read_word)
348169f0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348169f4:	e3530000 	cmp	r3, #0
		this->read_word = onenand_readw;
348169f8:	059f3554 	ldreq	r3, [pc, #1364]	; 34816f54 <onenand_scan+0x570>
348169fc:	05843068 	streq	r3, [r4, #104]	; 0x68
	if (!this->write_word)
34816a00:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816a04:	e3530000 	cmp	r3, #0
		this->write_word = onenand_writew;
34816a08:	059f3548 	ldreq	r3, [pc, #1352]	; 34816f58 <onenand_scan+0x574>
34816a0c:	0584306c 	streq	r3, [r4, #108]	; 0x6c

	if (!this->command)
34816a10:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34816a14:	e3530000 	cmp	r3, #0
		this->command = onenand_command;
34816a18:	059f353c 	ldreq	r3, [pc, #1340]	; 34816f5c <onenand_scan+0x578>
34816a1c:	05843050 	streq	r3, [r4, #80]	; 0x50
	if (!this->wait)
34816a20:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816a24:	e3530000 	cmp	r3, #0
		this->wait = onenand_wait;
34816a28:	059f3530 	ldreq	r3, [pc, #1328]	; 34816f60 <onenand_scan+0x57c>
34816a2c:	05843054 	streq	r3, [r4, #84]	; 0x54
	if (!this->bbt_wait)
34816a30:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34816a34:	e3530000 	cmp	r3, #0
		this->bbt_wait = onenand_bbt_wait;
34816a38:	059f3524 	ldreq	r3, [pc, #1316]	; 34816f64 <onenand_scan+0x580>
34816a3c:	05843058 	streq	r3, [r4, #88]	; 0x58

	if (!this->read_bufferram)
34816a40:	e5943060 	ldr	r3, [r4, #96]	; 0x60
34816a44:	e3530000 	cmp	r3, #0
		this->read_bufferram = onenand_read_bufferram;
34816a48:	059f3518 	ldreq	r3, [pc, #1304]	; 34816f68 <onenand_scan+0x584>
34816a4c:	05843060 	streq	r3, [r4, #96]	; 0x60
	if (!this->write_bufferram)
34816a50:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34816a54:	e3530000 	cmp	r3, #0
		this->write_bufferram = onenand_write_bufferram;
34816a58:	059f350c 	ldreq	r3, [pc, #1292]	; 34816f6c <onenand_scan+0x588>
34816a5c:	05843064 	streq	r3, [r4, #100]	; 0x64

	if (!this->chip_probe)
34816a60:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34816a64:	e3530000 	cmp	r3, #0
		this->chip_probe = onenand_chip_probe;
34816a68:	059f3500 	ldreq	r3, [pc, #1280]	; 34816f70 <onenand_scan+0x58c>
34816a6c:	05843070 	streq	r3, [r4, #112]	; 0x70

	if (!this->block_markbad)
34816a70:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34816a74:	e3530000 	cmp	r3, #0
		this->block_markbad = onenand_default_block_markbad;
34816a78:	059f34f4 	ldreq	r3, [pc, #1268]	; 34816f74 <onenand_scan+0x590>
34816a7c:	05843078 	streq	r3, [r4, #120]	; 0x78
	if (!this->scan_bbt)
34816a80:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34816a84:	e3530000 	cmp	r3, #0
		this->scan_bbt = onenand_default_bbt;
34816a88:	059f34e8 	ldreq	r3, [pc, #1256]	; 34816f78 <onenand_scan+0x594>
34816a8c:	0584307c 	streq	r3, [r4, #124]	; 0x7c

	if (onenand_probe(mtd))
34816a90:	ebffff08 	bl	348166b8 <onenand_probe>
34816a94:	e3500000 	cmp	r0, #0
34816a98:	1a000128 	bne	34816f40 <onenand_scan+0x55c>
		return -ENXIO;

	/* Set Sync. Burst Read after probing */
	if (this->mmcontrol) {
34816a9c:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34816aa0:	e3530000 	cmp	r3, #0
34816aa4:	0a000003 	beq	34816ab8 <onenand_scan+0xd4>
		printk(KERN_INFO "OneNAND Sync. Burst Read support\n");
34816aa8:	e59f04cc 	ldr	r0, [pc, #1228]	; 34816f7c <onenand_scan+0x598>
34816aac:	ebffcb3a 	bl	3480979c <printf>
		this->read_bufferram = onenand_sync_read_bufferram;
34816ab0:	e59f34c8 	ldr	r3, [pc, #1224]	; 34816f80 <onenand_scan+0x59c>
34816ab4:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
34816ab8:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
34816abc:	e3530000 	cmp	r3, #0
34816ac0:	1a00000b 	bne	34816af4 <onenand_scan+0x110>
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
34816ac4:	e3a01001 	mov	r1, #1
34816ac8:	e5990014 	ldr	r0, [r9, #20]
34816acc:	ebffce77 	bl	3480a4b0 <calloc>
		if (!this->page_buf) {
34816ad0:	e3500000 	cmp	r0, #0
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
34816ad4:	e584008c 	str	r0, [r4, #140]	; 0x8c
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
34816ad8:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
34816adc:	13833a01 	orrne	r3, r3, #4096	; 0x1000
34816ae0:	1584302c 	strne	r3, [r4, #44]	; 0x2c
		if (!this->page_buf) {
34816ae4:	1a000002 	bne	34816af4 <onenand_scan+0x110>
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
34816ae8:	e59f0494 	ldr	r0, [pc, #1172]	; 34816f84 <onenand_scan+0x5a0>
34816aec:	ebffcb2a 	bl	3480979c <printf>
34816af0:	ea000114 	b	34816f48 <onenand_scan+0x564>
	}
	if (!this->oob_buf) {
34816af4:	e5943090 	ldr	r3, [r4, #144]	; 0x90
34816af8:	e3530000 	cmp	r3, #0
34816afc:	1a000012 	bne	34816b4c <onenand_scan+0x168>
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
34816b00:	e3a01001 	mov	r1, #1
34816b04:	e5990018 	ldr	r0, [r9, #24]
34816b08:	ebffce68 	bl	3480a4b0 <calloc>
		if (!this->oob_buf) {
34816b0c:	e3500000 	cmp	r0, #0
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
34816b10:	e5840090 	str	r0, [r4, #144]	; 0x90
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
34816b14:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
34816b18:	13833a02 	orrne	r3, r3, #8192	; 0x2000
34816b1c:	1584302c 	strne	r3, [r4, #44]	; 0x2c
		if (!this->oob_buf) {
34816b20:	1a000009 	bne	34816b4c <onenand_scan+0x168>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
34816b24:	e59f045c 	ldr	r0, [pc, #1116]	; 34816f88 <onenand_scan+0x5a4>
34816b28:	ebffcb1b 	bl	3480979c <printf>
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
34816b2c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34816b30:	e3130a01 	tst	r3, #4096	; 0x1000
34816b34:	0a000103 	beq	34816f48 <onenand_scan+0x564>
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
34816b38:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
				kfree(this->page_buf);
34816b3c:	e594008c 	ldr	r0, [r4, #140]	; 0x8c
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
34816b40:	e584302c 	str	r3, [r4, #44]	; 0x2c
				kfree(this->page_buf);
34816b44:	ebffcc59 	bl	34809cb0 <free>
34816b48:	ea0000fe 	b	34816f48 <onenand_scan+0x564>
	this->state = FL_READY;

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34816b4c:	e5991018 	ldr	r1, [r9, #24]
	this->state = FL_READY;
34816b50:	e3a05000 	mov	r5, #0
34816b54:	e5845088 	str	r5, [r4, #136]	; 0x88
	switch (mtd->oobsize) {
34816b58:	e3510040 	cmp	r1, #64	; 0x40
34816b5c:	0a00000b 	beq	34816b90 <onenand_scan+0x1ac>
34816b60:	e3510080 	cmp	r1, #128	; 0x80
34816b64:	0a000005 	beq	34816b80 <onenand_scan+0x19c>
34816b68:	e3510020 	cmp	r1, #32
34816b6c:	e59f6418 	ldr	r6, [pc, #1048]	; 34816f8c <onenand_scan+0x5a8>
34816b70:	1a00000b 	bne	34816ba4 <onenand_scan+0x1c0>
		this->ecclayout = &onenand_oob_64;
		mtd->subpage_sft = 2;
		break;

	case 32:
		this->ecclayout = &onenand_oob_32;
34816b74:	e584609c 	str	r6, [r4, #156]	; 0x9c
		mtd->subpage_sft = 1;
34816b78:	e3a03001 	mov	r3, #1
34816b7c:	ea000006 	b	34816b9c <onenand_scan+0x1b8>
		this->ecclayout = &onenand_oob_128;
34816b80:	e59f3408 	ldr	r3, [pc, #1032]	; 34816f90 <onenand_scan+0x5ac>
34816b84:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 0;
34816b88:	e5895090 	str	r5, [r9, #144]	; 0x90
		break;
34816b8c:	ea000008 	b	34816bb4 <onenand_scan+0x1d0>
		this->ecclayout = &onenand_oob_64;
34816b90:	e59f33fc 	ldr	r3, [pc, #1020]	; 34816f94 <onenand_scan+0x5b0>
34816b94:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 2;
34816b98:	e3a03002 	mov	r3, #2
		mtd->subpage_sft = 1;
34816b9c:	e5893090 	str	r3, [r9, #144]	; 0x90
		break;
34816ba0:	ea000003 	b	34816bb4 <onenand_scan+0x1d0>

	default:
		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
34816ba4:	e59f03ec 	ldr	r0, [pc, #1004]	; 34816f98 <onenand_scan+0x5b4>
34816ba8:	ebffcafb 	bl	3480979c <printf>
			mtd->oobsize);
		mtd->subpage_sft = 0;
34816bac:	e5895090 	str	r5, [r9, #144]	; 0x90
		/* To prevent kernel oops */
		this->ecclayout = &onenand_oob_32;
34816bb0:	e584609c 	str	r6, [r4, #156]	; 0x9c
		break;
	}

	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
34816bb4:	e5992090 	ldr	r2, [r9, #144]	; 0x90
34816bb8:	e5993014 	ldr	r3, [r9, #20]
34816bbc:	e1a03233 	lsr	r3, r3, r2

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
34816bc0:	e3a02000 	mov	r2, #0
	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
34816bc4:	e5843098 	str	r3, [r4, #152]	; 0x98
	this->ecclayout->oobavail = 0;
34816bc8:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
34816bcc:	e5832204 	str	r2, [r3, #516]	; 0x204
34816bd0:	e283c040 	add	ip, r3, #64	; 0x40
34816bd4:	e1a02003 	mov	r2, r3
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
34816bd8:	e592020c 	ldr	r0, [r2, #524]	; 0x20c
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816bdc:	e3500000 	cmp	r0, #0
34816be0:	0a000005 	beq	34816bfc <onenand_scan+0x218>
		this->ecclayout->oobavail +=
34816be4:	e5931204 	ldr	r1, [r3, #516]	; 0x204
34816be8:	e2822008 	add	r2, r2, #8
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816bec:	e152000c 	cmp	r2, ip
		this->ecclayout->oobavail +=
34816bf0:	e0811000 	add	r1, r1, r0
34816bf4:	e5831204 	str	r1, [r3, #516]	; 0x204
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816bf8:	1afffff6 	bne	34816bd8 <onenand_scan+0x1f4>
	struct onenand_chip *this = mtd->priv;
34816bfc:	e5995094 	ldr	r5, [r9, #148]	; 0x94
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
34816c00:	e5932204 	ldr	r2, [r3, #516]	; 0x204

	mtd->ecclayout = this->ecclayout;
34816c04:	e5893028 	str	r3, [r9, #40]	; 0x28
	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34816c08:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
	mtd->oobavail = this->ecclayout->oobavail;
34816c0c:	e589201c 	str	r2, [r9, #28]
	size_t len = mtd->size;
34816c10:	e599a008 	ldr	sl, [r9, #8]
	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34816c14:	e3130002 	tst	r3, #2
34816c18:	0a00004c 	beq	34816d50 <onenand_scan+0x36c>
		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
34816c1c:	e5951000 	ldr	r1, [r5]
34816c20:	e3a00000 	mov	r0, #0
34816c24:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816c28:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816c2c:	e2811098 	add	r1, r1, #152	; 0x98
34816c30:	e12fff33 	blx	r3
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34816c34:	e3a03000 	mov	r3, #0
34816c38:	e3a01027 	mov	r1, #39	; 0x27
34816c3c:	e58d3000 	str	r3, [sp]
34816c40:	e3a02000 	mov	r2, #0
34816c44:	e3a03000 	mov	r3, #0
34816c48:	e5956050 	ldr	r6, [r5, #80]	; 0x50
34816c4c:	e1a00009 	mov	r0, r9
34816c50:	e12fff36 	blx	r6
		this->wait(mtd, FL_LOCKING);
34816c54:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816c58:	e3a01008 	mov	r1, #8
34816c5c:	e1a00009 	mov	r0, r9
34816c60:	e12fff33 	blx	r3
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816c64:	e5950000 	ldr	r0, [r5]
34816c68:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816c6c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816c70:	e2800080 	add	r0, r0, #128	; 0x80
34816c74:	e12fff33 	blx	r3
34816c78:	e3100902 	tst	r0, #32768	; 0x8000
34816c7c:	1afffff8 	bne	34816c64 <onenand_scan+0x280>
	end = this->chipsize >> this->erase_shift;
34816c80:	e5957018 	ldr	r7, [r5, #24]
	for (block = 0; block < end; block++) {
34816c84:	e3a06000 	mov	r6, #0
	end = this->chipsize >> this->erase_shift;
34816c88:	e5953030 	ldr	r3, [r5, #48]	; 0x30
34816c8c:	e1a07337 	lsr	r7, r7, r3
34816c90:	ea000000 	b	34816c98 <onenand_scan+0x2b4>
	for (block = 0; block < end; block++) {
34816c94:	e2866001 	add	r6, r6, #1
34816c98:	e1560007 	cmp	r6, r7
34816c9c:	0a0000a2 	beq	34816f2c <onenand_scan+0x548>
34816ca0:	e5950028 	ldr	r0, [r5, #40]	; 0x28
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816ca4:	e5951000 	ldr	r1, [r5]
34816ca8:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
	if (block & this->density_mask)
34816cac:	e1160000 	tst	r6, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816cb0:	10200006 	eorne	r0, r0, r6
		value = onenand_block_address(this, block);
34816cb4:	01a00006 	moveq	r0, r6
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816cb8:	13800902 	orrne	r0, r0, #32768	; 0x8000
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816cbc:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34816cc0:	e6ff0070 	uxth	r0, r0
34816cc4:	e2811c02 	add	r1, r1, #512	; 0x200
34816cc8:	e12fff33 	blx	r3
	if (block & this->density_mask)
34816ccc:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816cd0:	e5952000 	ldr	r2, [r5]
34816cd4:	e59f12c0 	ldr	r1, [pc, #704]	; 34816f9c <onenand_scan+0x5b8>
	return ONENAND_DDP_CHIP0;
34816cd8:	e1160003 	tst	r6, r3
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816cdc:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816ce0:	13a00902 	movne	r0, #32768	; 0x8000
34816ce4:	03a00000 	moveq	r0, #0
34816ce8:	e0821001 	add	r1, r2, r1
34816cec:	e12fff33 	blx	r3
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
34816cf0:	e5951000 	ldr	r1, [r5]
34816cf4:	e6ff0076 	uxth	r0, r6
34816cf8:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816cfc:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816d00:	e2811098 	add	r1, r1, #152	; 0x98
34816d04:	e12fff33 	blx	r3
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816d08:	e5950000 	ldr	r0, [r5]
34816d0c:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816d10:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816d14:	e280009c 	add	r0, r0, #156	; 0x9c
34816d18:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US)) {
34816d1c:	e3100004 	tst	r0, #4
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816d20:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US)) {
34816d24:	1affffda 	bne	34816c94 <onenand_scan+0x2b0>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
34816d28:	e1a01006 	mov	r1, r6
34816d2c:	e59f026c 	ldr	r0, [pc, #620]	; 34816fa0 <onenand_scan+0x5bc>
34816d30:	ebffca99 	bl	3480979c <printf>
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34816d34:	e595301c 	ldr	r3, [r5, #28]
34816d38:	e2033f82 	and	r3, r3, #520	; 0x208
34816d3c:	e3530008 	cmp	r3, #8
			ofs = this->chipsize >> 1;
34816d40:	0595a018 	ldreq	sl, [r5, #24]
34816d44:	01a0a0aa 	lsreq	sl, sl, #1
34816d48:	01a0600a 	moveq	r6, sl
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34816d4c:	0a000000 	beq	34816d54 <onenand_scan+0x370>
	loff_t ofs = 0;
34816d50:	e3a06000 	mov	r6, #0
	struct onenand_chip *this = mtd->priv;
34816d54:	e5995094 	ldr	r5, [r9, #148]	; 0x94
			ofs = this->chipsize >> 1;
34816d58:	e3a07000 	mov	r7, #0
	start = onenand_block(this, ofs);
34816d5c:	e1a02006 	mov	r2, r6
34816d60:	e1a03007 	mov	r3, r7
34816d64:	e1a00005 	mov	r0, r5
34816d68:	ebfff923 	bl	348151fc <onenand_block>
	end = onenand_block(this, ofs + len);
34816d6c:	e096200a 	adds	r2, r6, sl
	start = onenand_block(this, ofs);
34816d70:	e1a0b000 	mov	fp, r0
	end = onenand_block(this, ofs + len);
34816d74:	e2a73000 	adc	r3, r7, #0
34816d78:	e1a00005 	mov	r0, r5
34816d7c:	ebfff91e 	bl	348151fc <onenand_block>
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34816d80:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
	end = onenand_block(this, ofs + len);
34816d84:	e1a07000 	mov	r7, r0
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34816d88:	e21aa001 	ands	sl, sl, #1
	start = onenand_block(this, ofs);
34816d8c:	01a0600b 	moveq	r6, fp
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34816d90:	0a00003d 	beq	34816e8c <onenand_scan+0x4a8>
		this->write_word(start,
34816d94:	e5951000 	ldr	r1, [r5]
34816d98:	e6ff007b 	uxth	r0, fp
34816d9c:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816da0:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816da4:	e2811098 	add	r1, r1, #152	; 0x98
34816da8:	e12fff33 	blx	r3
		this->write_word(end - 1,
34816dac:	e5951000 	ldr	r1, [r5]
34816db0:	e2470001 	sub	r0, r7, #1
34816db4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816db8:	e6ff0070 	uxth	r0, r0
34816dbc:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816dc0:	e281109a 	add	r1, r1, #154	; 0x9a
34816dc4:	e12fff33 	blx	r3
		this->command(mtd, cmd, 0, 0);
34816dc8:	e3a03000 	mov	r3, #0
34816dcc:	e3a01023 	mov	r1, #35	; 0x23
34816dd0:	e58d3000 	str	r3, [sp]
34816dd4:	e3a02000 	mov	r2, #0
34816dd8:	e3a03000 	mov	r3, #0
34816ddc:	e5956050 	ldr	r6, [r5, #80]	; 0x50
34816de0:	e1a00009 	mov	r0, r9
34816de4:	e12fff36 	blx	r6
		this->wait(mtd, FL_UNLOCKING);
34816de8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816dec:	e3a01007 	mov	r1, #7
34816df0:	e1a00009 	mov	r0, r9
34816df4:	e12fff33 	blx	r3
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816df8:	e5950000 	ldr	r0, [r5]
34816dfc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816e00:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816e04:	e2800080 	add	r0, r0, #128	; 0x80
34816e08:	e12fff33 	blx	r3
34816e0c:	e3100902 	tst	r0, #32768	; 0x8000
34816e10:	1afffff8 	bne	34816df8 <onenand_scan+0x414>
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816e14:	e5950000 	ldr	r0, [r5]
34816e18:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816e1c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816e20:	e280009c 	add	r0, r0, #156	; 0x9c
34816e24:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34816e28:	e3100004 	tst	r0, #4
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816e2c:	e1a01000 	mov	r1, r0
		if (!(status & ONENAND_WP_US))
34816e30:	1a00003d 	bne	34816f2c <onenand_scan+0x548>
			printk(KERN_ERR "wp status = 0x%x\n", status);
34816e34:	e59f0168 	ldr	r0, [pc, #360]	; 34816fa4 <onenand_scan+0x5c0>
34816e38:	ebffca57 	bl	3480979c <printf>
34816e3c:	ea00003a 	b	34816f2c <onenand_scan+0x548>
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816e40:	e5950000 	ldr	r0, [r5]
34816e44:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816e48:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816e4c:	e2800080 	add	r0, r0, #128	; 0x80
34816e50:	e12fff33 	blx	r3
34816e54:	e3100902 	tst	r0, #32768	; 0x8000
34816e58:	1afffff8 	bne	34816e40 <onenand_scan+0x45c>
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816e5c:	e5950000 	ldr	r0, [r5]
34816e60:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816e64:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816e68:	e280009c 	add	r0, r0, #156	; 0x9c
34816e6c:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34816e70:	e3100004 	tst	r0, #4
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816e74:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US))
34816e78:	1a000002 	bne	34816e88 <onenand_scan+0x4a4>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n",
34816e7c:	e1a01006 	mov	r1, r6
34816e80:	e59f0118 	ldr	r0, [pc, #280]	; 34816fa0 <onenand_scan+0x5bc>
34816e84:	ebffca44 	bl	3480979c <printf>
	for (block = start; block < end; block++) {
34816e88:	e2866001 	add	r6, r6, #1
34816e8c:	e1560007 	cmp	r6, r7
34816e90:	aa000025 	bge	34816f2c <onenand_scan+0x548>
34816e94:	e5950028 	ldr	r0, [r5, #40]	; 0x28
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816e98:	e5951000 	ldr	r1, [r5]
34816e9c:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
	if (block & this->density_mask)
34816ea0:	e1160000 	tst	r6, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816ea4:	10200006 	eorne	r0, r0, r6
	if (block & this->density_mask)
34816ea8:	01a00006 	moveq	r0, r6
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816eac:	13800902 	orrne	r0, r0, #32768	; 0x8000
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816eb0:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34816eb4:	e6ff0070 	uxth	r0, r0
34816eb8:	e2811c02 	add	r1, r1, #512	; 0x200
34816ebc:	e12fff33 	blx	r3
	if (block & this->density_mask)
34816ec0:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816ec4:	e5952000 	ldr	r2, [r5]
34816ec8:	e59f10cc 	ldr	r1, [pc, #204]	; 34816f9c <onenand_scan+0x5b8>
	return ONENAND_DDP_CHIP0;
34816ecc:	e1160003 	tst	r6, r3
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816ed0:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816ed4:	13a00902 	movne	r0, #32768	; 0x8000
34816ed8:	03a00000 	moveq	r0, #0
34816edc:	e0821001 	add	r1, r2, r1
34816ee0:	e12fff33 	blx	r3
		this->write_word(block,
34816ee4:	e5951000 	ldr	r1, [r5]
34816ee8:	e6ff0076 	uxth	r0, r6
34816eec:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816ef0:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816ef4:	e2811098 	add	r1, r1, #152	; 0x98
34816ef8:	e12fff33 	blx	r3
		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
34816efc:	e58da000 	str	sl, [sp]
34816f00:	e3a02000 	mov	r2, #0
34816f04:	e595b050 	ldr	fp, [r5, #80]	; 0x50
34816f08:	e3a03000 	mov	r3, #0
34816f0c:	e3a01023 	mov	r1, #35	; 0x23
34816f10:	e1a00009 	mov	r0, r9
34816f14:	e12fff3b 	blx	fp
		this->wait(mtd, FL_UNLOCKING);
34816f18:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816f1c:	e3a01007 	mov	r1, #7
34816f20:	e1a00009 	mov	r0, r9
34816f24:	e12fff33 	blx	r3
34816f28:	eaffffc4 	b	34816e40 <onenand_scan+0x45c>

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
34816f2c:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34816f30:	e1a00009 	mov	r0, r9
}
34816f34:	e28dd008 	add	sp, sp, #8
34816f38:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
	return this->scan_bbt(mtd);
34816f3c:	e12fff13 	bx	r3
		return -ENXIO;
34816f40:	e3e00005 	mvn	r0, #5
34816f44:	ea000000 	b	34816f4c <onenand_scan+0x568>
			return -ENOMEM;
34816f48:	e3e0000b 	mvn	r0, #11
}
34816f4c:	e28dd008 	add	sp, sp, #8
34816f50:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816f54:	34813f4c 	.word	0x34813f4c
34816f58:	34813f58 	.word	0x34813f58
34816f5c:	3481535c 	.word	0x3481535c
34816f60:	3481492c 	.word	0x3481492c
34816f64:	34814864 	.word	0x34814864
34816f68:	348146ac 	.word	0x348146ac
34816f6c:	34814750 	.word	0x34814750
34816f70:	34813ffc 	.word	0x34813ffc
34816f74:	34815284 	.word	0x34815284
34816f78:	34817228 	.word	0x34817228
34816f7c:	348268f9 	.word	0x348268f9
34816f80:	348146ec 	.word	0x348146ec
34816f84:	3482691b 	.word	0x3482691b
34816f88:	34826944 	.word	0x34826944
34816f8c:	34827cb4 	.word	0x34827cb4
34816f90:	34827824 	.word	0x34827824
34816f94:	34827a6c 	.word	0x34827a6c
34816f98:	3482696a 	.word	0x3482696a
34816f9c:	0001e202 	.word	0x0001e202
34816fa0:	34826990 	.word	0x34826990
34816fa4:	3482699c 	.word	0x3482699c

34816fa8 <onenand_release>:
/**
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
34816fa8:	e12fff1e 	bx	lr

34816fac <onenand_isbad_bbt>:
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
34816fac:	e5900094 	ldr	r0, [r0, #148]	; 0x94
{
34816fb0:	e92d4010 	push	{r4, lr}
	struct bbm_info *bbm = this->bbm;
34816fb4:	e59040a0 	ldr	r4, [r0, #160]	; 0xa0
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
34816fb8:	ebfff88f 	bl	348151fc <onenand_block>
34816fbc:	e1a00080 	lsl	r0, r0, #1
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
34816fc0:	e594300c 	ldr	r3, [r4, #12]
34816fc4:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
34816fc8:	e2000006 	and	r0, r0, #6
34816fcc:	e1a00053 	asr	r0, r3, r0

	MTDDEBUG (MTD_DEBUG_LEVEL2,
		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
		(unsigned int)offs, block >> 1, res);

	switch ((int)res) {
34816fd0:	e2100003 	ands	r0, r0, #3
34816fd4:	08bd8010 	popeq	{r4, pc}
34816fd8:	e3500002 	cmp	r0, #2
	case 0x00:
		return 0;
	case 0x01:
		return 1;
34816fdc:	13a00001 	movne	r0, #1
	case 0x02:
		return allowbbt ? 0 : 1;
34816fe0:	059d0008 	ldreq	r0, [sp, #8]
34816fe4:	016f0f10 	clzeq	r0, r0
34816fe8:	01a002a0 	lsreq	r0, r0, #5
	}

	return 1;
}
34816fec:	e8bd8010 	pop	{r4, pc}

34816ff0 <onenand_memory_bbt>:
{
34816ff0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34816ff4:	e24ddd42 	sub	sp, sp, #4224	; 0x1080
	struct onenand_chip *this = mtd->priv;
34816ff8:	e5907094 	ldr	r7, [r0, #148]	; 0x94
{
34816ffc:	e24dd030 	sub	sp, sp, #48	; 0x30
34817000:	e1a06000 	mov	r6, r0
34817004:	e1a05001 	mov	r5, r1
	bd->options &= ~NAND_BBT_SCANEMPTY;
34817008:	e5913000 	ldr	r3, [r1]
	from = 0;
3481700c:	e3a0a000 	mov	sl, #0
	struct bbm_info *bbm = this->bbm;
34817010:	e59790a0 	ldr	r9, [r7, #160]	; 0xa0
	from = 0;
34817014:	e3a0b000 	mov	fp, #0
	printk(KERN_INFO "Scanning device for bad blocks\n");
34817018:	e59f014c 	ldr	r0, [pc, #332]	; 3481716c <onenand_memory_bbt+0x17c>
	ops.mode = MTD_OOB_PLACE;
3481701c:	e3a04000 	mov	r4, #0
	bd->options &= ~NAND_BBT_SCANEMPTY;
34817020:	e3c33b02 	bic	r3, r3, #2048	; 0x800
34817024:	e5813000 	str	r3, [r1]
	printk(KERN_INFO "Scanning device for bad blocks\n");
34817028:	ebffc9db 	bl	3480979c <printf>
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
3481702c:	e5993000 	ldr	r3, [r9]
34817030:	e5971018 	ldr	r1, [r7, #24]
	readlen = bd->len;
34817034:	e5952014 	ldr	r2, [r5, #20]
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817038:	e2433001 	sub	r3, r3, #1
	ops.mode = MTD_OOB_PLACE;
3481703c:	e58d4010 	str	r4, [sp, #16]
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
34817040:	e58d4020 	str	r4, [sp, #32]
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817044:	e1a03331 	lsr	r3, r1, r3
	ops.ooblen = readlen;
34817048:	e58d201c 	str	r2, [sp, #28]
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
3481704c:	e58d4018 	str	r4, [sp, #24]
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817050:	e58d3008 	str	r3, [sp, #8]
	ops.oobbuf = buf;
34817054:	e28d3030 	add	r3, sp, #48	; 0x30
34817058:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			ret = onenand_bbt_read_oob(mtd,
3481705c:	e2433020 	sub	r3, r3, #32
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
34817060:	e58d4024 	str	r4, [sp, #36]	; 0x24
34817064:	e58d4014 	str	r4, [sp, #20]
			ret = onenand_bbt_read_oob(mtd,
34817068:	e58d300c 	str	r3, [sp, #12]
	for (i = startblock; i < numblocks;) {
3481706c:	e59d3008 	ldr	r3, [sp, #8]
34817070:	e1540003 	cmp	r4, r3
34817074:	aa000036 	bge	34817154 <onenand_memory_bbt+0x164>
			ret = onenand_bbt_read_oob(mtd,
34817078:	e5952008 	ldr	r2, [r5, #8]
3481707c:	e59d300c 	ldr	r3, [sp, #12]
34817080:	e09a0002 	adds	r0, sl, r2
34817084:	e0ab1fc2 	adc	r1, fp, r2, asr #31
34817088:	e58d3000 	str	r3, [sp]
3481708c:	e1a02000 	mov	r2, r0
34817090:	e1a03001 	mov	r3, r1
34817094:	e1a00006 	mov	r0, r6
34817098:	ebfffc1f 	bl	3481611c <onenand_bbt_read_oob>
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
3481709c:	e3500004 	cmp	r0, #4
348170a0:	0a00002d 	beq	3481715c <onenand_memory_bbt+0x16c>
			if (ret || check_short_pattern
348170a4:	e3500000 	cmp	r0, #0
348170a8:	0a00001e 	beq	34817128 <onenand_memory_bbt+0x138>
				bbm->bbt[i >> 3] |= 0x03 << (i & 0x6);
348170ac:	e599100c 	ldr	r1, [r9, #12]
348170b0:	e3a00003 	mov	r0, #3
348170b4:	e2043006 	and	r3, r4, #6
348170b8:	e7d121c4 	ldrb	r2, [r1, r4, asr #3]
348170bc:	e1823310 	orr	r3, r2, r0, lsl r3
				printk(KERN_WARNING
348170c0:	e1a0200a 	mov	r2, sl
348170c4:	e59f00a4 	ldr	r0, [pc, #164]	; 34817170 <onenand_memory_bbt+0x180>
				bbm->bbt[i >> 3] |= 0x03 << (i & 0x6);
348170c8:	e7c131c4 	strb	r3, [r1, r4, asr #3]
				printk(KERN_WARNING
348170cc:	e1a010c4 	asr	r1, r4, #1
348170d0:	ebffc9b1 	bl	3480979c <printf>
		if (FLEXONENAND(this)) {
348170d4:	e597301c 	ldr	r3, [r7, #28]
		i += 2;
348170d8:	e2844002 	add	r4, r4, #2
		if (FLEXONENAND(this)) {
348170dc:	e3130c02 	tst	r3, #512	; 0x200
348170e0:	0a00000a 	beq	34817110 <onenand_memory_bbt+0x120>
			rgn = flexonenand_region(mtd, from);
348170e4:	e1a0200a 	mov	r2, sl
348170e8:	e1a0300b 	mov	r3, fp
348170ec:	e1a00006 	mov	r0, r6
348170f0:	ebfff924 	bl	34815588 <flexonenand_region>
			from += mtd->eraseregions[rgn].erasesize;
348170f4:	e5962030 	ldr	r2, [r6, #48]	; 0x30
348170f8:	e3a03018 	mov	r3, #24
348170fc:	e0202093 	mla	r0, r3, r0, r2
34817100:	e5903008 	ldr	r3, [r0, #8]
34817104:	e09aa003 	adds	sl, sl, r3
34817108:	e2abb000 	adc	fp, fp, #0
3481710c:	eaffffd6 	b	3481706c <onenand_memory_bbt+0x7c>
			from += (1 << bbm->bbt_erase_shift);
34817110:	e5992000 	ldr	r2, [r9]
34817114:	e3a03001 	mov	r3, #1
34817118:	e1a03213 	lsl	r3, r3, r2
3481711c:	e09aa003 	adds	sl, sl, r3
34817120:	e0abbfc3 	adc	fp, fp, r3, asr #31
34817124:	eaffffd0 	b	3481706c <onenand_memory_bbt+0x7c>
	for (i = 0; i < td->len; i++) {
34817128:	e5953014 	ldr	r3, [r5, #20]
3481712c:	e1500003 	cmp	r0, r3
34817130:	aaffffe7 	bge	348170d4 <onenand_memory_bbt+0xe4>
		if (p[i] != td->pattern[i])
34817134:	e5952020 	ldr	r2, [r5, #32]
34817138:	e28d1030 	add	r1, sp, #48	; 0x30
3481713c:	e7d11000 	ldrb	r1, [r1, r0]
34817140:	e7d22000 	ldrb	r2, [r2, r0]
34817144:	e1510002 	cmp	r1, r2
34817148:	1affffd7 	bne	348170ac <onenand_memory_bbt+0xbc>
	for (i = 0; i < td->len; i++) {
3481714c:	e2800001 	add	r0, r0, #1
34817150:	eafffff5 	b	3481712c <onenand_memory_bbt+0x13c>
	return 0;
34817154:	e3a00000 	mov	r0, #0
34817158:	ea000000 	b	34817160 <onenand_memory_bbt+0x170>
				return -EIO;
3481715c:	e3e00004 	mvn	r0, #4
}
34817160:	e28ddd42 	add	sp, sp, #4224	; 0x1080
34817164:	e28dd030 	add	sp, sp, #48	; 0x30
34817168:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481716c:	348269ae 	.word	0x348269ae
34817170:	348269ce 	.word	0x348269ce

34817174 <onenand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817174:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34817178:	e1a07000 	mov	r7, r0
	struct onenand_chip *this = mtd->priv;
3481717c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
{
34817180:	e1a09001 	mov	r9, r1
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
34817184:	e5956030 	ldr	r6, [r5, #48]	; 0x30
34817188:	e5953018 	ldr	r3, [r5, #24]
	struct bbm_info *bbm = this->bbm;
3481718c:	e59540a0 	ldr	r4, [r5, #160]	; 0xa0
	len = this->chipsize >> (this->erase_shift + 2);
34817190:	e2866002 	add	r6, r6, #2
34817194:	e1a06633 	lsr	r6, r3, r6
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817198:	e1a00006 	mov	r0, r6
3481719c:	ebffcb4d 	bl	34809ed8 <malloc>
	if (!bbm->bbt) {
348171a0:	e3500000 	cmp	r0, #0
	bbm->bbt = malloc(len);
348171a4:	e584000c 	str	r0, [r4, #12]
	if (!bbm->bbt) {
348171a8:	1a000003 	bne	348171bc <onenand_scan_bbt+0x48>
		printk(KERN_ERR "onenand_scan_bbt: Out of memory\n");
348171ac:	e59f0068 	ldr	r0, [pc, #104]	; 3481721c <onenand_scan_bbt+0xa8>
348171b0:	ebffc979 	bl	3480979c <printf>
		return -ENOMEM;
348171b4:	e3e0000b 	mvn	r0, #11
348171b8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	}
	/* Clear the memory bad block table */
	memset(bbm->bbt, 0x00, len);
348171bc:	e1a02006 	mov	r2, r6
348171c0:	e3a01000 	mov	r1, #0
348171c4:	eb00126c 	bl	3481bb7c <memset>

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;
348171c8:	e3a03000 	mov	r3, #0

	if (!bbm->isbad_bbt)
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348171cc:	e1a01009 	mov	r1, r9
	bbm->badblockpos = ONENAND_BADBLOCK_POS;
348171d0:	e5843004 	str	r3, [r4, #4]
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348171d4:	e1a00007 	mov	r0, r7
	bbm->bbt_erase_shift = this->erase_shift;
348171d8:	e5953030 	ldr	r3, [r5, #48]	; 0x30
348171dc:	e5843000 	str	r3, [r4]
	if (!bbm->isbad_bbt)
348171e0:	e5943010 	ldr	r3, [r4, #16]
348171e4:	e3530000 	cmp	r3, #0
		bbm->isbad_bbt = onenand_isbad_bbt;
348171e8:	059f3030 	ldreq	r3, [pc, #48]	; 34817220 <onenand_scan_bbt+0xac>
348171ec:	05843010 	streq	r3, [r4, #16]
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348171f0:	ebffff7e 	bl	34816ff0 <onenand_memory_bbt>
348171f4:	e2505000 	subs	r5, r0, #0
348171f8:	0a000005 	beq	34817214 <onenand_scan_bbt+0xa0>
		printk(KERN_ERR
348171fc:	e59f0020 	ldr	r0, [pc, #32]	; 34817224 <onenand_scan_bbt+0xb0>
34817200:	ebffc965 	bl	3480979c <printf>
		       "onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\n");
		free(bbm->bbt);
34817204:	e594000c 	ldr	r0, [r4, #12]
34817208:	ebffcaa8 	bl	34809cb0 <free>
		bbm->bbt = NULL;
3481720c:	e3a03000 	mov	r3, #0
34817210:	e584300c 	str	r3, [r4, #12]
34817214:	e1a00005 	mov	r0, r5
	}

	return ret;
}
34817218:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3481721c:	348269eb 	.word	0x348269eb
34817220:	34816fac 	.word	0x34816fac
34817224:	34826a0c 	.word	0x34826a0c

34817228 <onenand_default_bbt>:
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817228:	e92d4070 	push	{r4, r5, r6, lr}
3481722c:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
34817230:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817234:	e3a0001c 	mov	r0, #28
34817238:	ebffcb26 	bl	34809ed8 <malloc>
	if (!this->bbm)
3481723c:	e3500000 	cmp	r0, #0
	this->bbm = malloc(sizeof(struct bbm_info));
34817240:	e1a04000 	mov	r4, r0
34817244:	e58600a0 	str	r0, [r6, #160]	; 0xa0
	if (!this->bbm)
34817248:	0a00000a 	beq	34817278 <onenand_default_bbt+0x50>
		return -ENOMEM;

	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));
3481724c:	e3a01000 	mov	r1, #0
34817250:	e3a0201c 	mov	r2, #28
34817254:	eb001248 	bl	3481bb7c <memset>

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817258:	e5943014 	ldr	r3, [r4, #20]
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
3481725c:	e1a00005 	mov	r0, r5
	if (!bbm->badblock_pattern)
34817260:	e3530000 	cmp	r3, #0
		bbm->badblock_pattern = &largepage_memorybased;
34817264:	059f3014 	ldreq	r3, [pc, #20]	; 34817280 <onenand_default_bbt+0x58>
34817268:	05843014 	streq	r3, [r4, #20]
	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
3481726c:	e5941014 	ldr	r1, [r4, #20]
}
34817270:	e8bd4070 	pop	{r4, r5, r6, lr}
	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817274:	eaffffbe 	b	34817174 <onenand_scan_bbt>
}
34817278:	e3e0000b 	mvn	r0, #11
3481727c:	e8bd8070 	pop	{r4, r5, r6, pc}
34817280:	34827efc 	.word	0x34827efc

34817284 <s3c_write_cmd>:
	return readl(onenand->ahb_addr + cmd);
}

static void s3c_write_cmd(int value, unsigned int cmd)
{
	writel(value, onenand->ahb_addr + cmd);
34817284:	e59f300c 	ldr	r3, [pc, #12]	; 34817298 <s3c_write_cmd+0x14>
34817288:	e5933000 	ldr	r3, [r3]
3481728c:	e5933008 	ldr	r3, [r3, #8]
34817290:	e7830001 	str	r0, [r3, r1]
34817294:	e12fff1e 	bx	lr
34817298:	3482a8e8 	.word	0x3482a8e8

3481729c <s3c_mem_addr>:
	return (fba << 12) | (fpa << 6) | (fsa << 4);
}
#elif defined(CONFIG_S5P)
static unsigned int s3c_mem_addr(int fba, int fpa, int fsa)
{
	return (fba << 13) | (fpa << 7) | (fsa << 5);
3481729c:	e1a02282 	lsl	r2, r2, #5
348172a0:	e1821381 	orr	r1, r2, r1, lsl #7
}
348172a4:	e1810680 	orr	r0, r1, r0, lsl #13
348172a8:	e12fff1e 	bx	lr

348172ac <s3c_onenand_reset>:
static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
348172ac:	e59f3064 	ldr	r3, [pc, #100]	; 34817318 <s3c_onenand_reset+0x6c>
348172b0:	e3a01002 	mov	r1, #2
348172b4:	e5932000 	ldr	r2, [r3]
348172b8:	e592201c 	ldr	r2, [r2, #28]
348172bc:	e5821020 	str	r1, [r2, #32]
	while (timeout--) {
348172c0:	e59f2054 	ldr	r2, [pc, #84]	; 3481731c <s3c_onenand_reset+0x70>
348172c4:	e2522001 	subs	r2, r2, #1
348172c8:	0a000004 	beq	348172e0 <s3c_onenand_reset+0x34>
		stat = readl(&onenand->reg->int_err_stat);
348172cc:	e5931000 	ldr	r1, [r3]
348172d0:	e591101c 	ldr	r1, [r1, #28]
348172d4:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & RST_CMP)
348172d8:	e3110a01 	tst	r1, #4096	; 0x1000
348172dc:	0afffff8 	beq	348172c4 <s3c_onenand_reset+0x18>
			break;
	}
	stat = readl(&onenand->reg->int_err_stat);
348172e0:	e5932000 	ldr	r2, [r3]
348172e4:	e592201c 	ldr	r2, [r2, #28]
348172e8:	e5921030 	ldr	r1, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
348172ec:	e5932000 	ldr	r2, [r3]
348172f0:	e592201c 	ldr	r2, [r2, #28]
348172f4:	e5821050 	str	r1, [r2, #80]	; 0x50

	/* Clear interrupt */
	writel(0x0, &onenand->reg->int_err_ack);
348172f8:	e5932000 	ldr	r2, [r3]
348172fc:	e592101c 	ldr	r1, [r2, #28]
34817300:	e3a02000 	mov	r2, #0
34817304:	e5812050 	str	r2, [r1, #80]	; 0x50
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
34817308:	e5933000 	ldr	r3, [r3]
3481730c:	e593301c 	ldr	r3, [r3, #28]
34817310:	e5832060 	str	r2, [r3, #96]	; 0x60
34817314:	e12fff1e 	bx	lr
34817318:	3482a8e8 	.word	0x3482a8e8
3481731c:	00010001 	.word	0x00010001

34817320 <s3c_get_bufferram>:
	return 0;
}

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;
34817320:	e590c094 	ldr	ip, [r0, #148]	; 0x94
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34817324:	e3510b01 	cmp	r1, #1024	; 0x400
34817328:	e59f3038 	ldr	r3, [pc, #56]	; 34817368 <s3c_get_bufferram+0x48>
	int index = ONENAND_CURRENT_BUFFERRAM(this);
3481732c:	e59c2044 	ldr	r2, [ip, #68]	; 0x44
		p = (unsigned char *) onenand->page_buf;
34817330:	e5933000 	ldr	r3, [r3]
	if (area == ONENAND_DATARAM) {
34817334:	1a000004 	bne	3481734c <s3c_get_bufferram+0x2c>
		if (index == 1)
34817338:	e3520001 	cmp	r2, #1
		p = (unsigned char *) onenand->page_buf;
3481733c:	e5933010 	ldr	r3, [r3, #16]
			p += this->writesize;
34817340:	059c2040 	ldreq	r2, [ip, #64]	; 0x40
		if (index == 1)
34817344:	1a000005 	bne	34817360 <s3c_get_bufferram+0x40>
34817348:	ea000003 	b	3481735c <s3c_get_bufferram+0x3c>
	} else {
		p = (unsigned char *) onenand->oob_buf;
		if (index == 1)
3481734c:	e3520001 	cmp	r2, #1
		p = (unsigned char *) onenand->oob_buf;
34817350:	e5933014 	ldr	r3, [r3, #20]
		if (index == 1)
34817354:	1a000001 	bne	34817360 <s3c_get_bufferram+0x40>
			p += mtd->oobsize;
34817358:	e5902018 	ldr	r2, [r0, #24]
3481735c:	e0833002 	add	r3, r3, r2
	}

	return p;
}
34817360:	e1a00003 	mov	r0, r3
34817364:	e12fff1e 	bx	lr
34817368:	3482a8e8 	.word	0x3482a8e8

3481736c <s3c_onenand_bbt_wait>:
	return 0;
}

static int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)
{
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
3481736c:	e59f3070 	ldr	r3, [pc, #112]	; 348173e4 <s3c_onenand_bbt_wait+0x78>
{
34817370:	e92d4010 	push	{r4, lr}
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
34817374:	e5932000 	ldr	r2, [r3]
34817378:	e5921004 	ldr	r1, [r2, #4]
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;

	while (timeout--) {
3481737c:	e59f2064 	ldr	r2, [pc, #100]	; 348173e8 <s3c_onenand_bbt_wait+0x7c>
34817380:	e2522001 	subs	r2, r2, #1
34817384:	0a000002 	beq	34817394 <s3c_onenand_bbt_wait+0x28>
		stat = readl(&reg->int_err_stat);
34817388:	e5910030 	ldr	r0, [r1, #48]	; 0x30
		if (stat & flags)
3481738c:	e3100e41 	tst	r0, #1040	; 0x410
34817390:	0afffffa 	beq	34817380 <s3c_onenand_bbt_wait+0x14>
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34817394:	e5932000 	ldr	r2, [r3]
34817398:	e592201c 	ldr	r2, [r2, #28]
3481739c:	e5922030 	ldr	r2, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
348173a0:	e5933000 	ldr	r3, [r3]

	if (stat & LD_FAIL_ECC_ERR) {
348173a4:	e3120001 	tst	r2, #1
	writel(stat, &onenand->reg->int_err_ack);
348173a8:	e593301c 	ldr	r3, [r3, #28]
348173ac:	e5832050 	str	r2, [r3, #80]	; 0x50
	if (stat & LD_FAIL_ECC_ERR) {
348173b0:	1a000006 	bne	348173d0 <s3c_onenand_bbt_wait+0x64>
		s3c_onenand_reset();
		return ONENAND_BBT_READ_ERROR;
	}

	if (stat & LOAD_CMP) {
348173b4:	e3120010 	tst	r2, #16
348173b8:	0a000007 	beq	348173dc <s3c_onenand_bbt_wait+0x70>
		int ecc = readl(&onenand->reg->ecc_err_stat);
348173bc:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
348173c0:	e3013010 	movw	r3, #4112	; 0x1010
348173c4:	e0033002 	and	r3, r3, r2
348173c8:	e3530000 	cmp	r3, #0
348173cc:	0a000002 	beq	348173dc <s3c_onenand_bbt_wait+0x70>
		s3c_onenand_reset();
348173d0:	ebffffb5 	bl	348172ac <s3c_onenand_reset>
		return ONENAND_BBT_READ_ERROR;
348173d4:	e3a00001 	mov	r0, #1
348173d8:	e8bd8010 	pop	{r4, pc}
			s3c_onenand_reset();
			return ONENAND_BBT_READ_ERROR;
		}
	}

	return 0;
348173dc:	e3a00000 	mov	r0, #0
348173e0:	e8bd8010 	pop	{r4, pc}
348173e4:	3482a8e8 	.word	0x3482a8e8
348173e8:	00010001 	.word	0x00010001

348173ec <onenand_write_bufferram>:
{
348173ec:	e92d4010 	push	{r4, lr}
	p = s3c_get_bufferram(mtd, area);
348173f0:	e59d1008 	ldr	r1, [sp, #8]
348173f4:	ebffffc9 	bl	34817320 <s3c_get_bufferram>
	memcpy(p + offset, buffer, count);
348173f8:	e59d3010 	ldr	r3, [sp, #16]
348173fc:	e59d2014 	ldr	r2, [sp, #20]
34817400:	e59d100c 	ldr	r1, [sp, #12]
34817404:	e0800003 	add	r0, r0, r3
34817408:	eb0011fb 	bl	3481bbfc <memcpy>
}
3481740c:	e3a00000 	mov	r0, #0
34817410:	e8bd8010 	pop	{r4, pc}

34817414 <onenand_read_bufferram>:
{
34817414:	e92d4010 	push	{r4, lr}
	p = s3c_get_bufferram(mtd, area);
34817418:	e59d1008 	ldr	r1, [sp, #8]
3481741c:	ebffffbf 	bl	34817320 <s3c_get_bufferram>
	memcpy(buffer, p + offset, count);
34817420:	e59d1010 	ldr	r1, [sp, #16]
34817424:	e59d2014 	ldr	r2, [sp, #20]
34817428:	e0801001 	add	r1, r0, r1
3481742c:	e59d000c 	ldr	r0, [sp, #12]
34817430:	eb0011f1 	bl	3481bbfc <memcpy>
}
34817434:	e3a00000 	mov	r0, #0
34817438:	e8bd8010 	pop	{r4, pc}

3481743c <s3c_onenand_wait>:
{
3481743c:	e2411001 	sub	r1, r1, #1
34817440:	e92d4070 	push	{r4, r5, r6, lr}
34817444:	e3510007 	cmp	r1, #7
34817448:	e1a05000 	mov	r5, r0
	switch (state) {
3481744c:	83a01b01 	movhi	r1, #1024	; 0x400
34817450:	959f30c0 	ldrls	r3, [pc, #192]	; 34817518 <s3c_onenand_wait+0xdc>
34817454:	91a01081 	lslls	r1, r1, #1
34817458:	919310b1 	ldrhls	r1, [r3, r1]
3481745c:	e59f30b8 	ldr	r3, [pc, #184]	; 3481751c <s3c_onenand_wait+0xe0>
34817460:	e59f00b8 	ldr	r0, [pc, #184]	; 34817520 <s3c_onenand_wait+0xe4>
	while (timeout--) {
34817464:	e2533001 	subs	r3, r3, #1
34817468:	e59f20b0 	ldr	r2, [pc, #176]	; 34817520 <s3c_onenand_wait+0xe4>
3481746c:	0a000004 	beq	34817484 <s3c_onenand_wait+0x48>
		stat = readl(&onenand->reg->int_err_stat);
34817470:	e590c000 	ldr	ip, [r0]
34817474:	e59cc01c 	ldr	ip, [ip, #28]
34817478:	e59cc030 	ldr	ip, [ip, #48]	; 0x30
		if (stat & flags)
3481747c:	e111000c 	tst	r1, ip
34817480:	0afffff7 	beq	34817464 <s3c_onenand_wait+0x28>
	stat = readl(&onenand->reg->int_err_stat);
34817484:	e5923000 	ldr	r3, [r2]
34817488:	e593301c 	ldr	r3, [r3, #28]
3481748c:	e5934030 	ldr	r4, [r3, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817490:	e5923000 	ldr	r3, [r2]
	if (stat & LOAD_CMP) {
34817494:	e3140010 	tst	r4, #16
	writel(stat, &onenand->reg->int_err_ack);
34817498:	e593301c 	ldr	r3, [r3, #28]
3481749c:	e5834050 	str	r4, [r3, #80]	; 0x50
	if (stat & LOAD_CMP) {
348174a0:	0a00000c 	beq	348174d8 <s3c_onenand_wait+0x9c>
		ecc = readl(&onenand->reg->ecc_err_stat);
348174a4:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
348174a8:	e3013010 	movw	r3, #4112	; 0x1010
348174ac:	e0033002 	and	r3, r3, r2
348174b0:	e3530000 	cmp	r3, #0
348174b4:	0a000007 	beq	348174d8 <s3c_onenand_wait+0x9c>
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
348174b8:	e59f1064 	ldr	r1, [pc, #100]	; 34817524 <s3c_onenand_wait+0xe8>
348174bc:	e59f0064 	ldr	r0, [pc, #100]	; 34817528 <s3c_onenand_wait+0xec>
348174c0:	ebffc8b5 	bl	3480979c <printf>
			mtd->ecc_stats.failed++;
348174c4:	e5953084 	ldr	r3, [r5, #132]	; 0x84
			return -EBADMSG;
348174c8:	e3e00049 	mvn	r0, #73	; 0x49
			mtd->ecc_stats.failed++;
348174cc:	e2833001 	add	r3, r3, #1
348174d0:	e5853084 	str	r3, [r5, #132]	; 0x84
			return -EBADMSG;
348174d4:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {
348174d8:	e300010d 	movw	r0, #269	; 0x10d
348174dc:	e0000004 	and	r0, r0, r4
348174e0:	e3500000 	cmp	r0, #0
348174e4:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk(KERN_INFO "%s: controller error = 0x%04x\n",
348174e8:	e1a02004 	mov	r2, r4
348174ec:	e59f1030 	ldr	r1, [pc, #48]	; 34817524 <s3c_onenand_wait+0xe8>
348174f0:	e59f0034 	ldr	r0, [pc, #52]	; 3481752c <s3c_onenand_wait+0xf0>
348174f4:	ebffc8a8 	bl	3480979c <printf>
		if (stat & LOCKED_BLK)
348174f8:	e3140c01 	tst	r4, #256	; 0x100
348174fc:	0a000003 	beq	34817510 <s3c_onenand_wait+0xd4>
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
34817500:	e1a02004 	mov	r2, r4
34817504:	e59f1018 	ldr	r1, [pc, #24]	; 34817524 <s3c_onenand_wait+0xe8>
34817508:	e59f0020 	ldr	r0, [pc, #32]	; 34817530 <s3c_onenand_wait+0xf4>
3481750c:	ebffc8a2 	bl	3480979c <printf>
		return -EIO;
34817510:	e3e00004 	mvn	r0, #4
}
34817514:	e8bd8070 	pop	{r4, r5, r6, pc}
34817518:	348214a8 	.word	0x348214a8
3481751c:	00100001 	.word	0x00100001
34817520:	3482a8e8 	.word	0x3482a8e8
34817524:	348214b8 	.word	0x348214b8
34817528:	34826a4c 	.word	0x34826a4c
3481752c:	34826a64 	.word	0x34826a64
34817530:	34826a83 	.word	0x34826a83

34817534 <s3c_onenand_readw>:
	struct onenand_chip *this = onenand->mtd->priv;
34817534:	e59f3130 	ldr	r3, [pc, #304]	; 3481766c <s3c_onenand_readw+0x138>
{
34817538:	e92d4010 	push	{r4, lr}
	struct onenand_chip *this = onenand->mtd->priv;
3481753c:	e5933000 	ldr	r3, [r3]
34817540:	e5932000 	ldr	r2, [r3]
	int reg = addr - this->base;
34817544:	e5922094 	ldr	r2, [r2, #148]	; 0x94
34817548:	e5922000 	ldr	r2, [r2]
3481754c:	e0620000 	rsb	r0, r2, r0
	switch (reg) {
34817550:	e59f2118 	ldr	r2, [pc, #280]	; 34817670 <s3c_onenand_readw+0x13c>
34817554:	e1500002 	cmp	r0, r2
34817558:	0a000029 	beq	34817604 <s3c_onenand_readw+0xd0>
3481755c:	ca000008 	bgt	34817584 <s3c_onenand_readw+0x50>
34817560:	e2422004 	sub	r2, r2, #4
34817564:	e1500002 	cmp	r0, r2
34817568:	0a000021 	beq	348175f4 <s3c_onenand_readw+0xc0>
3481756c:	e2822002 	add	r2, r2, #2
34817570:	e1500002 	cmp	r0, r2
34817574:	0a00002d 	beq	34817630 <s3c_onenand_readw+0xfc>
34817578:	e3500a1e 	cmp	r0, #122880	; 0x1e000
3481757c:	1a000012 	bne	348175cc <s3c_onenand_readw+0x98>
34817580:	ea000025 	b	3481761c <s3c_onenand_readw+0xe8>
34817584:	e59f20e8 	ldr	r2, [pc, #232]	; 34817674 <s3c_onenand_readw+0x140>
34817588:	e1500002 	cmp	r0, r2
3481758c:	0a00001f 	beq	34817610 <s3c_onenand_readw+0xdc>
34817590:	ca000005 	bgt	348175ac <s3c_onenand_readw+0x78>
34817594:	e59f20dc 	ldr	r2, [pc, #220]	; 34817678 <s3c_onenand_readw+0x144>
34817598:	e1500002 	cmp	r0, r2
		return readl(&onenand->reg->tech);
3481759c:	0593301c 	ldreq	r3, [r3, #28]
348175a0:	059300c0 	ldreq	r0, [r3, #192]	; 0xc0
	switch (reg) {
348175a4:	0a000014 	beq	348175fc <s3c_onenand_readw+0xc8>
348175a8:	ea000007 	b	348175cc <s3c_onenand_readw+0x98>
348175ac:	e59f20c8 	ldr	r2, [pc, #200]	; 3481767c <s3c_onenand_readw+0x148>
348175b0:	e1500002 	cmp	r0, r2
348175b4:	0a00002a 	beq	34817664 <s3c_onenand_readw+0x130>
348175b8:	e282201c 	add	r2, r2, #28
348175bc:	e1500002 	cmp	r0, r2
348175c0:	1a000001 	bne	348175cc <s3c_onenand_readw+0x98>
		return ONENAND_WP_US;
348175c4:	e3a00004 	mov	r0, #4
348175c8:	e8bd8010 	pop	{r4, pc}
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348175cc:	e3500b01 	cmp	r0, #1024	; 0x400
	int word_addr = reg >> 1;
348175d0:	e1a010c0 	asr	r1, r0, #1
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348175d4:	aa000018 	bge	3481763c <s3c_onenand_readw+0x108>
348175d8:	e593200c 	ldr	r2, [r3, #12]
348175dc:	e3520000 	cmp	r2, #0
348175e0:	0a000015 	beq	3481763c <s3c_onenand_readw+0x108>
		if (word_addr == 0)
348175e4:	e3510000 	cmp	r1, #0
348175e8:	0a00000b 	beq	3481761c <s3c_onenand_readw+0xe8>
		if (word_addr == 1)
348175ec:	e3510001 	cmp	r1, #1
348175f0:	1a00000c 	bne	34817628 <s3c_onenand_readw+0xf4>
		return readl(&onenand->reg->device_id);
348175f4:	e593301c 	ldr	r3, [r3, #28]
348175f8:	e5930080 	ldr	r0, [r3, #128]	; 0x80
348175fc:	e6ff0070 	uxth	r0, r0
34817600:	e8bd8010 	pop	{r4, pc}
		return readl(&onenand->reg->data_buf_size);
34817604:	e593301c 	ldr	r3, [r3, #28]
34817608:	e5930090 	ldr	r0, [r3, #144]	; 0x90
3481760c:	eafffffa 	b	348175fc <s3c_onenand_readw+0xc8>
		return readl(&onenand->reg->mem_cfg);
34817610:	e593301c 	ldr	r3, [r3, #28]
34817614:	e5930000 	ldr	r0, [r3]
34817618:	eafffff7 	b	348175fc <s3c_onenand_readw+0xc8>
			return readl(&onenand->reg->manufact_id);
3481761c:	e593301c 	ldr	r3, [r3, #28]
34817620:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34817624:	eafffff4 	b	348175fc <s3c_onenand_readw+0xc8>
		if (word_addr == 2)
34817628:	e3510002 	cmp	r1, #2
3481762c:	1a000002 	bne	3481763c <s3c_onenand_readw+0x108>
			return readl(&onenand->reg->flash_ver_id);
34817630:	e593301c 	ldr	r3, [r3, #28]
34817634:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34817638:	eaffffef 	b	348175fc <s3c_onenand_readw+0xc8>
	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
3481763c:	e1a02101 	lsl	r2, r1, #2
	return readl(onenand->ahb_addr + cmd);
34817640:	e5933008 	ldr	r3, [r3, #8]
	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
34817644:	e3822303 	orr	r2, r2, #201326592	; 0xc000000
	return readl(onenand->ahb_addr + cmd);
34817648:	e7930002 	ldr	r0, [r3, r2]
	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
3481764c:	e6ff4070 	uxth	r4, r0
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
34817650:	e59f0028 	ldr	r0, [pc, #40]	; 34817680 <s3c_onenand_readw+0x14c>
34817654:	e1a02004 	mov	r2, r4
34817658:	ebffc84f 	bl	3480979c <printf>
	return value;
3481765c:	e6ff0074 	uxth	r0, r4
34817660:	e8bd8010 	pop	{r4, pc}
		return 0;
34817664:	e3a00000 	mov	r0, #0
}
34817668:	e8bd8010 	pop	{r4, pc}
3481766c:	3482a8e8 	.word	0x3482a8e8
34817670:	0001e006 	.word	0x0001e006
34817674:	0001e442 	.word	0x0001e442
34817678:	0001e00c 	.word	0x0001e00c
3481767c:	0001e480 	.word	0x0001e480
34817680:	34826aa3 	.word	0x34826aa3

34817684 <s3c_onenand_writew>:
	struct onenand_chip *this = onenand->mtd->priv;
34817684:	e59f20cc 	ldr	r2, [pc, #204]	; 34817758 <s3c_onenand_writew+0xd4>
{
34817688:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = onenand->mtd->priv;
3481768c:	e592c000 	ldr	ip, [r2]
34817690:	e59c3000 	ldr	r3, [ip]
	int reg = addr - this->base;
34817694:	e5933094 	ldr	r3, [r3, #148]	; 0x94
34817698:	e5933000 	ldr	r3, [r3]
3481769c:	e0631001 	rsb	r1, r3, r1
	switch (reg) {
348176a0:	e59f30b4 	ldr	r3, [pc, #180]	; 3481775c <s3c_onenand_writew+0xd8>
348176a4:	e1510003 	cmp	r1, r3
348176a8:	08bd8070 	popeq	{r4, r5, r6, pc}
348176ac:	e1a03002 	mov	r3, r2
348176b0:	ca000003 	bgt	348176c4 <s3c_onenand_writew+0x40>
348176b4:	e59f20a4 	ldr	r2, [pc, #164]	; 34817760 <s3c_onenand_writew+0xdc>
348176b8:	e1510002 	cmp	r1, r2
348176bc:	1a00000b 	bne	348176f0 <s3c_onenand_writew+0x6c>
348176c0:	e8bd8070 	pop	{r4, r5, r6, pc}
348176c4:	e59fe098 	ldr	lr, [pc, #152]	; 34817764 <s3c_onenand_writew+0xe0>
348176c8:	e151000e 	cmp	r1, lr
348176cc:	0a000003 	beq	348176e0 <s3c_onenand_writew+0x5c>
348176d0:	e59f2090 	ldr	r2, [pc, #144]	; 34817768 <s3c_onenand_writew+0xe4>
348176d4:	e1510002 	cmp	r1, r2
348176d8:	1a000004 	bne	348176f0 <s3c_onenand_writew+0x6c>
348176dc:	e8bd8070 	pop	{r4, r5, r6, pc}
		writel(value, &onenand->reg->mem_cfg);
348176e0:	e5923000 	ldr	r3, [r2]
348176e4:	e593301c 	ldr	r3, [r3, #28]
348176e8:	e5830000 	str	r0, [r3]
		return;
348176ec:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (reg < ONENAND_DATARAM) {
348176f0:	e3510b01 	cmp	r1, #1024	; 0x400
348176f4:	aa00000c 	bge	3481772c <s3c_onenand_writew+0xa8>
		if (value == ONENAND_CMD_READID) {
348176f8:	e3500090 	cmp	r0, #144	; 0x90
			onenand->bootram_command = 1;
348176fc:	03a03001 	moveq	r3, #1
34817700:	058c300c 	streq	r3, [ip, #12]
		if (value == ONENAND_CMD_READID) {
34817704:	08bd8070 	popeq	{r4, r5, r6, pc}
		if (value == ONENAND_CMD_RESET) {
34817708:	e35000f0 	cmp	r0, #240	; 0xf0
3481770c:	1a000006 	bne	3481772c <s3c_onenand_writew+0xa8>
			writel(ONENAND_MEM_RESET_COLD,
34817710:	e5933000 	ldr	r3, [r3]
34817714:	e3a01002 	mov	r1, #2
34817718:	e593201c 	ldr	r2, [r3, #28]
3481771c:	e5821020 	str	r1, [r2, #32]
			onenand->bootram_command = 0;
34817720:	e3a02000 	mov	r2, #0
34817724:	e583200c 	str	r2, [r3, #12]
34817728:	e8bd8070 	pop	{r4, r5, r6, pc}
	int word_addr = reg >> 1;
3481772c:	e1a040c1 	asr	r4, r1, #1
34817730:	e1a05000 	mov	r5, r0
	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
34817734:	e1a02000 	mov	r2, r0
34817738:	e59f002c 	ldr	r0, [pc, #44]	; 3481776c <s3c_onenand_writew+0xe8>
3481773c:	e1a01004 	mov	r1, r4
34817740:	ebffc815 	bl	3480979c <printf>
	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34817744:	e1a01104 	lsl	r1, r4, #2
34817748:	e1a00005 	mov	r0, r5
}
3481774c:	e8bd4070 	pop	{r4, r5, r6, lr}
	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34817750:	e3811303 	orr	r1, r1, #201326592	; 0xc000000
34817754:	eafffeca 	b	34817284 <s3c_write_cmd>
34817758:	3482a8e8 	.word	0x3482a8e8
3481775c:	0001e202 	.word	0x0001e202
34817760:	0001e200 	.word	0x0001e200
34817764:	0001e442 	.word	0x0001e442
34817768:	0001e498 	.word	0x0001e498
3481776c:	34826adf 	.word	0x34826adf

34817770 <s3c_onenand_check_lock_status.isra.0>:
}

static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
34817770:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
34817774:	e3a04000 	mov	r4, #0
	end = this->chipsize >> this->erase_shift;
34817778:	e5906018 	ldr	r6, [r0, #24]
3481777c:	e5903030 	ldr	r3, [r0, #48]	; 0x30
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34817780:	e59f506c 	ldr	r5, [pc, #108]	; 348177f4 <s3c_onenand_check_lock_status.isra.0+0x84>
	end = this->chipsize >> this->erase_shift;
34817784:	e1a06336 	lsr	r6, r6, r3
	for (block = 0; block < end; block++) {
34817788:	e1540006 	cmp	r4, r6
3481778c:	0a000017 	beq	348177f0 <s3c_onenand_check_lock_status.isra.0+0x80>
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34817790:	e5953000 	ldr	r3, [r5]
34817794:	e3a02000 	mov	r2, #0
34817798:	e1a01002 	mov	r1, r2
3481779c:	e1a00004 	mov	r0, r4
348177a0:	e5933018 	ldr	r3, [r3, #24]
348177a4:	e12fff33 	blx	r3
	return readl(onenand->ahb_addr + cmd);
348177a8:	e5953000 	ldr	r3, [r5]
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
348177ac:	e3800301 	orr	r0, r0, #67108864	; 0x4000000
	return readl(onenand->ahb_addr + cmd);
348177b0:	e5933008 	ldr	r3, [r3, #8]
348177b4:	e7933000 	ldr	r3, [r3, r0]

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
348177b8:	e5953000 	ldr	r3, [r5]
348177bc:	e593301c 	ldr	r3, [r3, #28]
348177c0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
348177c4:	e3130c01 	tst	r3, #256	; 0x100
348177c8:	0a000006 	beq	348177e8 <s3c_onenand_check_lock_status.isra.0+0x78>
			printf("block %d is write-protected!\n", block);
348177cc:	e1a01004 	mov	r1, r4
348177d0:	e59f0020 	ldr	r0, [pc, #32]	; 348177f8 <s3c_onenand_check_lock_status.isra.0+0x88>
348177d4:	ebffc7f0 	bl	3480979c <printf>
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
348177d8:	e5953000 	ldr	r3, [r5]
348177dc:	e3a02c01 	mov	r2, #256	; 0x100
348177e0:	e593301c 	ldr	r3, [r3, #28]
348177e4:	e5832050 	str	r2, [r3, #80]	; 0x50
	for (block = 0; block < end; block++) {
348177e8:	e2844001 	add	r4, r4, #1
348177ec:	eaffffe5 	b	34817788 <s3c_onenand_check_lock_status.isra.0+0x18>
		}
	}
}
348177f0:	e8bd8070 	pop	{r4, r5, r6, pc}
348177f4:	3482a8e8 	.word	0x3482a8e8
348177f8:	34826b1b 	.word	0x34826b1b

348177fc <s3c_onenand_unlock_all>:

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
348177fc:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
34817800:	e3a02000 	mov	r2, #0
	struct onenand_chip *this = mtd->priv;
34817804:	e5906094 	ldr	r6, [r0, #148]	; 0x94
{
34817808:	e1a05000 	mov	r5, r0
	this->subpagesize = mtd->writesize;
3481780c:	e5903014 	ldr	r3, [r0, #20]
	size_t len = this->chipsize;
34817810:	e5964018 	ldr	r4, [r6, #24]
	this->subpagesize = mtd->writesize;
34817814:	e5863098 	str	r3, [r6, #152]	; 0x98

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817818:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
	mtd->subpage_sft = 0;
3481781c:	e5802090 	str	r2, [r0, #144]	; 0x90
	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817820:	e2133002 	ands	r3, r3, #2
34817824:	0a000010 	beq	3481786c <s3c_onenand_unlock_all+0x70>
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34817828:	e58d2000 	str	r2, [sp]
3481782c:	e3a03000 	mov	r3, #0
34817830:	e5964050 	ldr	r4, [r6, #80]	; 0x50
34817834:	e3a02000 	mov	r2, #0
34817838:	e3a01027 	mov	r1, #39	; 0x27
3481783c:	e12fff34 	blx	r4

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);
34817840:	e5963054 	ldr	r3, [r6, #84]	; 0x54
34817844:	e3a01008 	mov	r1, #8
34817848:	e1a00005 	mov	r0, r5
3481784c:	e12fff33 	blx	r3

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34817850:	e596301c 	ldr	r3, [r6, #28]
34817854:	e3130008 	tst	r3, #8
			s3c_onenand_check_lock_status(mtd);
			return;
		}

		/* All blocks on another chip */
		ofs = this->chipsize >> 1;
34817858:	15964018 	ldrne	r4, [r6, #24]
3481785c:	11a040a4 	lsrne	r4, r4, #1
34817860:	11a00004 	movne	r0, r4
		if (!ONENAND_IS_DDP(this)) {
34817864:	1a000001 	bne	34817870 <s3c_onenand_unlock_all+0x74>
34817868:	ea000021 	b	348178f4 <s3c_onenand_unlock_all+0xf8>
	loff_t ofs = 0;
3481786c:	e1a00003 	mov	r0, r3
	struct onenand_chip *this = mtd->priv;
34817870:	e5956094 	ldr	r6, [r5, #148]	; 0x94
	start = ofs >> this->erase_shift;
34817874:	e3a01000 	mov	r1, #0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817878:	e59f9084 	ldr	r9, [pc, #132]	; 34817904 <s3c_onenand_unlock_all+0x108>
	start = ofs >> this->erase_shift;
3481787c:	e5962030 	ldr	r2, [r6, #48]	; 0x30
34817880:	fa001f36 	blx	3481f560 <__ashrdi3>
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817884:	e5993000 	ldr	r3, [r9]
34817888:	e3a02000 	mov	r2, #0
	start = ofs >> this->erase_shift;
3481788c:	e1a07000 	mov	r7, r0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817890:	e1a01002 	mov	r1, r2
34817894:	e1a00007 	mov	r0, r7
34817898:	e5933018 	ldr	r3, [r3, #24]
3481789c:	e12fff33 	blx	r3
348178a0:	e1a0a000 	mov	sl, r0
	end = start + (len >> this->erase_shift) - 1;
348178a4:	e5960030 	ldr	r0, [r6, #48]	; 0x30
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348178a8:	e5993000 	ldr	r3, [r9]
348178ac:	e3a02000 	mov	r2, #0
348178b0:	e1a01002 	mov	r1, r2
	end = start + (len >> this->erase_shift) - 1;
348178b4:	e1a00034 	lsr	r0, r4, r0
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348178b8:	e5933018 	ldr	r3, [r3, #24]
348178bc:	e2400001 	sub	r0, r0, #1
348178c0:	e0800007 	add	r0, r0, r7
348178c4:	e12fff33 	blx	r3
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348178c8:	e38a1302 	orr	r1, sl, #134217728	; 0x8000000
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348178cc:	e1a04000 	mov	r4, r0
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348178d0:	e3a00008 	mov	r0, #8
348178d4:	ebfffe6a 	bl	34817284 <s3c_write_cmd>
		s3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(end_mem_addr));
348178d8:	e3841302 	orr	r1, r4, #134217728	; 0x8000000
348178dc:	e3a00009 	mov	r0, #9
348178e0:	ebfffe67 	bl	34817284 <s3c_write_cmd>
	this->wait(mtd, FL_LOCKING);
348178e4:	e5963054 	ldr	r3, [r6, #84]	; 0x54
348178e8:	e3a01008 	mov	r1, #8
348178ec:	e1a00005 	mov	r0, r5
348178f0:	e12fff33 	blx	r3
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348178f4:	e5950094 	ldr	r0, [r5, #148]	; 0x94
}
348178f8:	e28dd00c 	add	sp, sp, #12
348178fc:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	s3c_onenand_check_lock_status(mtd);
34817900:	eaffff9a 	b	34817770 <s3c_onenand_check_lock_status.isra.0>
34817904:	3482a8e8 	.word	0x3482a8e8

34817908 <s3c_onenand_command>:
{
34817908:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481790c:	e1a0a002 	mov	sl, r2
	struct onenand_chip *this = mtd->priv;
34817910:	e5907094 	ldr	r7, [r0, #148]	; 0x94
{
34817914:	e1a05001 	mov	r5, r1
34817918:	e1a09000 	mov	r9, r0
	fpa = (int) (addr >> this->page_shift);
3481791c:	e1a01003 	mov	r1, r3
34817920:	e1a0000a 	mov	r0, sl
{
34817924:	e1a0b003 	mov	fp, r3
	fpa = (int) (addr >> this->page_shift);
34817928:	e5972034 	ldr	r2, [r7, #52]	; 0x34
3481792c:	fa001f0b 	blx	3481f560 <__ashrdi3>
	fpa &= this->page_mask;
34817930:	e597403c 	ldr	r4, [r7, #60]	; 0x3c
	fba = (int) (addr >> this->erase_shift);
34817934:	e1a0100b 	mov	r1, fp
	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817938:	e59f621c 	ldr	r6, [pc, #540]	; 34817b5c <s3c_onenand_command+0x254>
	fba = (int) (addr >> this->erase_shift);
3481793c:	e5972030 	ldr	r2, [r7, #48]	; 0x30
	fpa &= this->page_mask;
34817940:	e0044000 	and	r4, r4, r0
	fba = (int) (addr >> this->erase_shift);
34817944:	e1a0000a 	mov	r0, sl
34817948:	fa001f04 	blx	3481f560 <__ashrdi3>
	mem_addr = onenand->mem_addr(fba, fpa, fsa);
3481794c:	e5963000 	ldr	r3, [r6]
34817950:	e1a01004 	mov	r1, r4
34817954:	e3a02000 	mov	r2, #0
34817958:	e5933018 	ldr	r3, [r3, #24]
3481795c:	e12fff33 	blx	r3
	switch (cmd) {
34817960:	e3550013 	cmp	r5, #19
	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817964:	e1a04000 	mov	r4, r0
	switch (cmd) {
34817968:	0a000004 	beq	34817980 <s3c_onenand_command+0x78>
3481796c:	e3013978 	movw	r3, #6520	; 0x1978
34817970:	e1550003 	cmp	r5, r3
34817974:	0a000001 	beq	34817980 <s3c_onenand_command+0x78>
34817978:	e3550000 	cmp	r5, #0
3481797c:	1a000002 	bne	3481798c <s3c_onenand_command+0x84>
		ONENAND_SET_NEXT_BUFFERRAM(this);
34817980:	e5973044 	ldr	r3, [r7, #68]	; 0x44
34817984:	e2233001 	eor	r3, r3, #1
34817988:	e5873044 	str	r3, [r7, #68]	; 0x44
	m = (unsigned int *) onenand->page_buf;
3481798c:	e5963000 	ldr	r3, [r6]
34817990:	e5992018 	ldr	r2, [r9, #24]
34817994:	e593a010 	ldr	sl, [r3, #16]
	s = (unsigned int *) onenand->oob_buf;
34817998:	e593b014 	ldr	fp, [r3, #20]
	if (index) {
3481799c:	e5973044 	ldr	r3, [r7, #68]	; 0x44
348179a0:	e3530000 	cmp	r3, #0
		m += (this->writesize >> 2);
348179a4:	15973040 	ldrne	r3, [r7, #64]	; 0x40
	mcount = mtd->writesize >> 2;
348179a8:	e5997014 	ldr	r7, [r9, #20]
	scount = mtd->oobsize >> 2;
348179ac:	e1a09122 	lsr	r9, r2, #2
		m += (this->writesize >> 2);
348179b0:	13c33003 	bicne	r3, r3, #3
348179b4:	108aa003 	addne	sl, sl, r3
		s += (mtd->oobsize >> 2);
348179b8:	13c23003 	bicne	r3, r2, #3
348179bc:	108bb003 	addne	fp, fp, r3
	switch (cmd) {
348179c0:	e3550027 	cmp	r5, #39	; 0x27
	mcount = mtd->writesize >> 2;
348179c4:	e1a07127 	lsr	r7, r7, #2
	switch (cmd) {
348179c8:	0a00005b 	beq	34817b3c <s3c_onenand_command+0x234>
348179cc:	ca000007 	bgt	348179f0 <s3c_onenand_command+0xe8>
348179d0:	e3550013 	cmp	r5, #19
348179d4:	0a00001c 	beq	34817a4c <s3c_onenand_command+0x144>
348179d8:	e355001a 	cmp	r5, #26
348179dc:	0a00003b 	beq	34817ad0 <s3c_onenand_command+0x1c8>
348179e0:	e3550000 	cmp	r5, #0
348179e4:	1a00005a 	bne	34817b54 <s3c_onenand_command+0x24c>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
348179e8:	e3844301 	orr	r4, r4, #67108864	; 0x4000000
348179ec:	ea00000e 	b	34817a2c <s3c_onenand_command+0x124>
	switch (cmd) {
348179f0:	e3550080 	cmp	r5, #128	; 0x80
348179f4:	0a00002c 	beq	34817aac <s3c_onenand_command+0x1a4>
348179f8:	ca000004 	bgt	34817a10 <s3c_onenand_command+0x108>
348179fc:	e3550071 	cmp	r5, #113	; 0x71
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
34817a00:	03841302 	orreq	r1, r4, #134217728	; 0x8000000
34817a04:	03a00015 	moveq	r0, #21
	switch (cmd) {
34817a08:	0a000050 	beq	34817b50 <s3c_onenand_command+0x248>
34817a0c:	ea000050 	b	34817b54 <s3c_onenand_command+0x24c>
34817a10:	e3550094 	cmp	r5, #148	; 0x94
34817a14:	0a00004b 	beq	34817b48 <s3c_onenand_command+0x240>
34817a18:	e3550095 	cmp	r5, #149	; 0x95
		s3c_write_cmd(ONENAND_MULTI_ERASE_SET, CMD_MAP_10(mem_addr));
34817a1c:	03841302 	orreq	r1, r4, #134217728	; 0x8000000
34817a20:	03a00001 	moveq	r0, #1
	switch (cmd) {
34817a24:	0a000049 	beq	34817b50 <s3c_onenand_command+0x248>
34817a28:	ea000049 	b	34817b54 <s3c_onenand_command+0x24c>
		for (i = 0; i < mcount; i++)
34817a2c:	e1550007 	cmp	r5, r7
34817a30:	aa000047 	bge	34817b54 <s3c_onenand_command+0x24c>
	return readl(onenand->ahb_addr + cmd);
34817a34:	e5963000 	ldr	r3, [r6]
34817a38:	e5933008 	ldr	r3, [r3, #8]
34817a3c:	e7933004 	ldr	r3, [r3, r4]
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817a40:	e78a3105 	str	r3, [sl, r5, lsl #2]
		for (i = 0; i < mcount; i++)
34817a44:	e2855001 	add	r5, r5, #1
34817a48:	eafffff7 	b	34817a2c <s3c_onenand_command+0x124>
		writel(TSRF, &onenand->reg->trans_spare);
34817a4c:	e5963000 	ldr	r3, [r6]
34817a50:	e3a02001 	mov	r2, #1
34817a54:	e593301c 	ldr	r3, [r3, #28]
34817a58:	e5832140 	str	r2, [r3, #320]	; 0x140
		for (i = 0; i < mcount; i++)
34817a5c:	e3a03000 	mov	r3, #0
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817a60:	e3842301 	orr	r2, r4, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
34817a64:	e1530007 	cmp	r3, r7
34817a68:	aa000005 	bge	34817a84 <s3c_onenand_command+0x17c>
	return readl(onenand->ahb_addr + cmd);
34817a6c:	e5961000 	ldr	r1, [r6]
34817a70:	e5911008 	ldr	r1, [r1, #8]
34817a74:	e7911002 	ldr	r1, [r1, r2]
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817a78:	e78a1103 	str	r1, [sl, r3, lsl #2]
		for (i = 0; i < mcount; i++)
34817a7c:	e2833001 	add	r3, r3, #1
34817a80:	eafffff7 	b	34817a64 <s3c_onenand_command+0x15c>
34817a84:	e3a03000 	mov	r3, #0
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817a88:	e3844301 	orr	r4, r4, #67108864	; 0x4000000
		for (i = 0; i < scount; i++)
34817a8c:	e1530009 	cmp	r3, r9
34817a90:	aa000024 	bge	34817b28 <s3c_onenand_command+0x220>
	return readl(onenand->ahb_addr + cmd);
34817a94:	e5962000 	ldr	r2, [r6]
34817a98:	e5922008 	ldr	r2, [r2, #8]
34817a9c:	e7922004 	ldr	r2, [r2, r4]
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817aa0:	e78b2103 	str	r2, [fp, r3, lsl #2]
		for (i = 0; i < scount; i++)
34817aa4:	e2833001 	add	r3, r3, #1
34817aa8:	eafffff7 	b	34817a8c <s3c_onenand_command+0x184>
	switch (cmd) {
34817aac:	e3a05000 	mov	r5, #0
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817ab0:	e3844301 	orr	r4, r4, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
34817ab4:	e1550007 	cmp	r5, r7
34817ab8:	aa000025 	bge	34817b54 <s3c_onenand_command+0x24c>
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817abc:	e79a0105 	ldr	r0, [sl, r5, lsl #2]
34817ac0:	e1a01004 	mov	r1, r4
34817ac4:	ebfffdee 	bl	34817284 <s3c_write_cmd>
		for (i = 0; i < mcount; i++)
34817ac8:	e2855001 	add	r5, r5, #1
34817acc:	eafffff8 	b	34817ab4 <s3c_onenand_command+0x1ac>
		writel(TSRF, &onenand->reg->trans_spare);
34817ad0:	e5963000 	ldr	r3, [r6]
		for (i = 0; i < mcount; i++)
34817ad4:	e3a05000 	mov	r5, #0
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34817ad8:	e384a301 	orr	sl, r4, #67108864	; 0x4000000
		writel(TSRF, &onenand->reg->trans_spare);
34817adc:	e3a02001 	mov	r2, #1
34817ae0:	e593301c 	ldr	r3, [r3, #28]
34817ae4:	e5832140 	str	r2, [r3, #320]	; 0x140
		for (i = 0; i < mcount; i++)
34817ae8:	e1550007 	cmp	r5, r7
34817aec:	aa000004 	bge	34817b04 <s3c_onenand_command+0x1fc>
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34817af0:	e1a0100a 	mov	r1, sl
34817af4:	e3e00000 	mvn	r0, #0
34817af8:	ebfffde1 	bl	34817284 <s3c_write_cmd>
		for (i = 0; i < mcount; i++)
34817afc:	e2855001 	add	r5, r5, #1
34817b00:	eafffff8 	b	34817ae8 <s3c_onenand_command+0x1e0>
34817b04:	e3a05000 	mov	r5, #0
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34817b08:	e3844301 	orr	r4, r4, #67108864	; 0x4000000
		for (i = 0; i < scount; i++)
34817b0c:	e1550009 	cmp	r5, r9
34817b10:	aa000004 	bge	34817b28 <s3c_onenand_command+0x220>
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34817b14:	e79b0105 	ldr	r0, [fp, r5, lsl #2]
34817b18:	e1a01004 	mov	r1, r4
34817b1c:	ebfffdd8 	bl	34817284 <s3c_write_cmd>
		for (i = 0; i < scount; i++)
34817b20:	e2855001 	add	r5, r5, #1
34817b24:	eafffff8 	b	34817b0c <s3c_onenand_command+0x204>
		writel(0, &onenand->reg->trans_spare);
34817b28:	e5963000 	ldr	r3, [r6]
34817b2c:	e3a02000 	mov	r2, #0
34817b30:	e593301c 	ldr	r3, [r3, #28]
34817b34:	e5832140 	str	r2, [r3, #320]	; 0x140
		return 0;
34817b38:	ea000005 	b	34817b54 <s3c_onenand_command+0x24c>
		s3c_write_cmd(ONENAND_UNLOCK_ALL, CMD_MAP_10(mem_addr));
34817b3c:	e3841302 	orr	r1, r4, #134217728	; 0x8000000
34817b40:	e3a0000e 	mov	r0, #14
34817b44:	ea000001 	b	34817b50 <s3c_onenand_command+0x248>
		s3c_write_cmd(ONENAND_ERASE_START, CMD_MAP_10(mem_addr));
34817b48:	e3841302 	orr	r1, r4, #134217728	; 0x8000000
34817b4c:	e3a00003 	mov	r0, #3
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
34817b50:	ebfffdcb 	bl	34817284 <s3c_write_cmd>
}
34817b54:	e3a00000 	mov	r0, #0
34817b58:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817b5c:	3482a8e8 	.word	0x3482a8e8

34817b60 <s5pc110_chip_probe>:
#endif

int s5pc110_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
34817b60:	e3a00000 	mov	r0, #0
34817b64:	e12fff1e 	bx	lr

34817b68 <s5pc210_chip_probe>:

int s5pc210_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
34817b68:	e3a00000 	mov	r0, #0
34817b6c:	e12fff1e 	bx	lr

34817b70 <s3c_onenand_init>:

void s3c_onenand_init(struct mtd_info *mtd)
{
34817b70:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34817b74:	e1a07000 	mov	r7, r0
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34817b78:	e59f50e0 	ldr	r5, [pc, #224]	; 34817c60 <s3c_onenand_init+0xf0>
	struct onenand_chip *this = mtd->priv;
34817b7c:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	onenand = malloc(sizeof(struct s3c_onenand));
34817b80:	e3a00020 	mov	r0, #32
34817b84:	ebffc8d3 	bl	34809ed8 <malloc>
	if (!onenand)
34817b88:	e3500000 	cmp	r0, #0
	onenand = malloc(sizeof(struct s3c_onenand));
34817b8c:	e1a06000 	mov	r6, r0
34817b90:	e5850000 	str	r0, [r5]
	if (!onenand)
34817b94:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34817b98:	e3a00a01 	mov	r0, #4096	; 0x1000
34817b9c:	ebffc8cd 	bl	34809ed8 <malloc>
	if (!onenand->page_buf)
34817ba0:	e5953000 	ldr	r3, [r5]
	onenand->page_buf = malloc(size * sizeof(char));
34817ba4:	e5860010 	str	r0, [r6, #16]
	if (!onenand->page_buf)
34817ba8:	e5930010 	ldr	r0, [r3, #16]
34817bac:	e3500000 	cmp	r0, #0
34817bb0:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
		return;
	memset(onenand->page_buf, 0xff, size);
34817bb4:	e3a02a01 	mov	r2, #4096	; 0x1000
34817bb8:	e3a010ff 	mov	r1, #255	; 0xff
34817bbc:	eb000fee 	bl	3481bb7c <memset>

	onenand->oob_buf = malloc(128 * sizeof(char));
34817bc0:	e3a00080 	mov	r0, #128	; 0x80
34817bc4:	e5956000 	ldr	r6, [r5]
34817bc8:	ebffc8c2 	bl	34809ed8 <malloc>
	if (!onenand->oob_buf)
34817bcc:	e5953000 	ldr	r3, [r5]
	onenand->oob_buf = malloc(128 * sizeof(char));
34817bd0:	e5860014 	str	r0, [r6, #20]
	if (!onenand->oob_buf)
34817bd4:	e5930014 	ldr	r0, [r3, #20]
34817bd8:	e3500000 	cmp	r0, #0
34817bdc:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
		return;
	memset(onenand->oob_buf, 0xff, 128);
34817be0:	e3a02080 	mov	r2, #128	; 0x80
34817be4:	e3a010ff 	mov	r1, #255	; 0xff
34817be8:	eb000fe3 	bl	3481bb7c <memset>

	onenand->mtd = mtd;
34817bec:	e5953000 	ldr	r3, [r5]
#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
	onenand->ahb_addr = (void *)0xB0000000;
34817bf0:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
	onenand->base = (void *)0xE7100000;
34817bf4:	e59f2068 	ldr	r2, [pc, #104]	; 34817c64 <s3c_onenand_init+0xf4>
	onenand->ahb_addr = (void *)0xB0000000;
34817bf8:	e5831008 	str	r1, [r3, #8]
#endif
	onenand->mem_addr = s3c_mem_addr;
34817bfc:	e59f1064 	ldr	r1, [pc, #100]	; 34817c68 <s3c_onenand_init+0xf8>
	onenand->mtd = mtd;
34817c00:	e5837000 	str	r7, [r3]
	onenand->base = (void *)0xE7100000;
34817c04:	e5832004 	str	r2, [r3, #4]
	onenand->mem_addr = s3c_mem_addr;
34817c08:	e5831018 	str	r1, [r3, #24]
	onenand->reg = (struct samsung_onenand *)onenand->base;
34817c0c:	e583201c 	str	r2, [r3, #28]

	this->read_word = s3c_onenand_readw;
34817c10:	e59f3054 	ldr	r3, [pc, #84]	; 34817c6c <s3c_onenand_init+0xfc>
34817c14:	e5843068 	str	r3, [r4, #104]	; 0x68
	this->write_word = s3c_onenand_writew;
34817c18:	e59f3050 	ldr	r3, [pc, #80]	; 34817c70 <s3c_onenand_init+0x100>
34817c1c:	e584306c 	str	r3, [r4, #108]	; 0x6c

	this->wait = s3c_onenand_wait;
34817c20:	e59f304c 	ldr	r3, [pc, #76]	; 34817c74 <s3c_onenand_init+0x104>
34817c24:	e5843054 	str	r3, [r4, #84]	; 0x54
	this->bbt_wait = s3c_onenand_bbt_wait;
34817c28:	e59f3048 	ldr	r3, [pc, #72]	; 34817c78 <s3c_onenand_init+0x108>
34817c2c:	e5843058 	str	r3, [r4, #88]	; 0x58
	this->unlock_all = s3c_onenand_unlock_all;
34817c30:	e59f3044 	ldr	r3, [pc, #68]	; 34817c7c <s3c_onenand_init+0x10c>
34817c34:	e584305c 	str	r3, [r4, #92]	; 0x5c
	this->command = s3c_onenand_command;
34817c38:	e59f3040 	ldr	r3, [pc, #64]	; 34817c80 <s3c_onenand_init+0x110>
34817c3c:	e5843050 	str	r3, [r4, #80]	; 0x50

	this->read_bufferram = onenand_read_bufferram;
34817c40:	e59f303c 	ldr	r3, [pc, #60]	; 34817c84 <s3c_onenand_init+0x114>
34817c44:	e5843060 	str	r3, [r4, #96]	; 0x60
	this->write_bufferram = onenand_write_bufferram;
34817c48:	e59f3038 	ldr	r3, [pc, #56]	; 34817c88 <s3c_onenand_init+0x118>
34817c4c:	e5843064 	str	r3, [r4, #100]	; 0x64

	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34817c50:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34817c54:	e3833c02 	orr	r3, r3, #512	; 0x200
34817c58:	e584302c 	str	r3, [r4, #44]	; 0x2c
34817c5c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34817c60:	3482a8e8 	.word	0x3482a8e8
34817c64:	e7100000 	.word	0xe7100000
34817c68:	3481729c 	.word	0x3481729c
34817c6c:	34817534 	.word	0x34817534
34817c70:	34817684 	.word	0x34817684
34817c74:	3481743c 	.word	0x3481743c
34817c78:	3481736c 	.word	0x3481736c
34817c7c:	348177fc 	.word	0x348177fc
34817c80:	34817908 	.word	0x34817908
34817c84:	34817414 	.word	0x34817414
34817c88:	348173ec 	.word	0x348173ec

34817c8c <samsung_get_base_uart>:
IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34817c8c:	e59f3028 	ldr	r3, [pc, #40]	; 34817cbc <samsung_get_base_uart+0x30>
34817c90:	e5932000 	ldr	r2, [r3]
SAMSUNG_BASE(uart, UART_BASE)
34817c94:	e3520cc1 	cmp	r2, #49408	; 0xc100
34817c98:	0a000005 	beq	34817cb4 <samsung_get_base_uart+0x28>
34817c9c:	e59f301c 	ldr	r3, [pc, #28]	; 34817cc0 <samsung_get_base_uart+0x34>
34817ca0:	e30c0110 	movw	r0, #49424	; 0xc110
34817ca4:	e1520000 	cmp	r2, r0
34817ca8:	13a00000 	movne	r0, #0
34817cac:	01a00003 	moveq	r0, r3
34817cb0:	e12fff1e 	bx	lr
34817cb4:	e3a0033b 	mov	r0, #-335544320	; 0xec000000
34817cb8:	e12fff1e 	bx	lr
34817cbc:	34827004 	.word	0x34827004
34817cc0:	e2900000 	.word	0xe2900000

34817cc4 <serial_setbrg_dev>:
	0xdfdf,
	0xffdf,
};

void serial_setbrg_dev(const int dev_index)
{
34817cc4:	e92d4070 	push	{r4, r5, r6, lr}
34817cc8:	e1a05000 	mov	r5, r0
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817ccc:	ebffffee 	bl	34817c8c <samsung_get_base_uart>
34817cd0:	e0804505 	add	r4, r0, r5, lsl #10
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);
	u32 uclk = get_uart_clk(dev_index);
34817cd4:	e1a00005 	mov	r0, r5
34817cd8:	ebffa685 	bl	348016f4 <get_uart_clk>
	u32 baudrate = gd->baudrate;
34817cdc:	e5981008 	ldr	r1, [r8, #8]
	u32 val;

	val = uclk / baudrate;
34817ce0:	fa001cce 	blx	3481f020 <__udivsi3>

	writel(val / 16 - 1, &uart->ubrdiv);
34817ce4:	e1a03220 	lsr	r3, r0, #4
34817ce8:	e2433001 	sub	r3, r3, #1
34817cec:	e5843028 	str	r3, [r4, #40]	; 0x28

	if (s5p_uart_divslot())
		writew(udivslot[val % 16], &uart->rest.slot);
34817cf0:	e200000f 	and	r0, r0, #15
34817cf4:	e59f300c 	ldr	r3, [pc, #12]	; 34817d08 <serial_setbrg_dev+0x44>
34817cf8:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34817cfc:	e6ff3073 	uxth	r3, r3
34817d00:	e1c432bc 	strh	r3, [r4, #44]	; 0x2c
34817d04:	e8bd8070 	pop	{r4, r5, r6, pc}
34817d08:	348201b4 	.word	0x348201b4

34817d0c <s5p_serial0_setbrg>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817d0c:	e3a00000 	mov	r0, #0
34817d10:	eaffffeb 	b	34817cc4 <serial_setbrg_dev>

34817d14 <s5p_serial1_setbrg>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817d14:	e3a00001 	mov	r0, #1
34817d18:	eaffffe9 	b	34817cc4 <serial_setbrg_dev>

34817d1c <s5p_serial2_setbrg>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817d1c:	e3a00002 	mov	r0, #2
34817d20:	eaffffe7 	b	34817cc4 <serial_setbrg_dev>

34817d24 <s5p_serial3_setbrg>:
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817d24:	e3a00003 	mov	r0, #3
34817d28:	eaffffe5 	b	34817cc4 <serial_setbrg_dev>

34817d2c <serial_init_dev>:
{
34817d2c:	e92d4070 	push	{r4, r5, r6, lr}
34817d30:	e1a05000 	mov	r5, r0
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817d34:	ebffffd4 	bl	34817c8c <samsung_get_base_uart>
34817d38:	e0803505 	add	r3, r0, r5, lsl #10
	writel(0, &uart->ufcon);
34817d3c:	e3a04000 	mov	r4, #0
34817d40:	e5834008 	str	r4, [r3, #8]
	writel(0, &uart->umcon);
34817d44:	e583400c 	str	r4, [r3, #12]
	writel(0x3, &uart->ulcon);
34817d48:	e3a02003 	mov	r2, #3
34817d4c:	e7802505 	str	r2, [r0, r5, lsl #10]
	writel(0x245, &uart->ucon);
34817d50:	e3002245 	movw	r2, #581	; 0x245
	serial_setbrg_dev(dev_index);
34817d54:	e1a00005 	mov	r0, r5
	writel(0x245, &uart->ucon);
34817d58:	e5832004 	str	r2, [r3, #4]
	serial_setbrg_dev(dev_index);
34817d5c:	ebffffd8 	bl	34817cc4 <serial_setbrg_dev>
}
34817d60:	e1a00004 	mov	r0, r4
34817d64:	e8bd8070 	pop	{r4, r5, r6, pc}

34817d68 <s5p_serial0_init>:
DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817d68:	e3a00000 	mov	r0, #0
34817d6c:	eaffffee 	b	34817d2c <serial_init_dev>

34817d70 <s5p_serial1_init>:
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817d70:	e3a00001 	mov	r0, #1
34817d74:	eaffffec 	b	34817d2c <serial_init_dev>

34817d78 <s5p_serial2_init>:
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817d78:	e3a00002 	mov	r0, #2
34817d7c:	eaffffea 	b	34817d2c <serial_init_dev>

34817d80 <s5p_serial3_init>:
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817d80:	e3a00003 	mov	r0, #3
34817d84:	eaffffe8 	b	34817d2c <serial_init_dev>

34817d88 <serial_getc_dev>:
{
34817d88:	e92d4070 	push	{r4, r5, r6, lr}
	u32 offset = dev_index * sizeof(struct s5p_uart);
34817d8c:	e1a06500 	lsl	r6, r0, #10
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817d90:	ebffffbd 	bl	34817c8c <samsung_get_base_uart>
34817d94:	e0805006 	add	r5, r0, r6
	while (!(readl(&uart->utrstat) & 0x1)) {
34817d98:	e5950010 	ldr	r0, [r5, #16]
34817d9c:	e2104001 	ands	r4, r0, #1
34817da0:	1a000006 	bne	34817dc0 <serial_getc_dev+0x38>
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817da4:	ebffffb8 	bl	34817c8c <samsung_get_base_uart>
34817da8:	e0800006 	add	r0, r0, r6
	return readl(&uart->uerstat) & mask;
34817dac:	e5903014 	ldr	r3, [r0, #20]
		if (serial_err_check(dev_index, 0))
34817db0:	e313000f 	tst	r3, #15
34817db4:	0afffff7 	beq	34817d98 <serial_getc_dev+0x10>
			return 0;
34817db8:	e1a00004 	mov	r0, r4
}
34817dbc:	e8bd8070 	pop	{r4, r5, r6, pc}
	return (int)(readb(&uart->urxh) & 0xff);
34817dc0:	e5d50024 	ldrb	r0, [r5, #36]	; 0x24
34817dc4:	e6ef0070 	uxtb	r0, r0
34817dc8:	e8bd8070 	pop	{r4, r5, r6, pc}

34817dcc <s5p_serial0_getc>:
DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817dcc:	e3a00000 	mov	r0, #0
34817dd0:	eaffffec 	b	34817d88 <serial_getc_dev>

34817dd4 <s5p_serial1_getc>:
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817dd4:	e3a00001 	mov	r0, #1
34817dd8:	eaffffea 	b	34817d88 <serial_getc_dev>

34817ddc <s5p_serial2_getc>:
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817ddc:	e3a00002 	mov	r0, #2
34817de0:	eaffffe8 	b	34817d88 <serial_getc_dev>

34817de4 <s5p_serial3_getc>:
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817de4:	e3a00003 	mov	r0, #3
34817de8:	eaffffe6 	b	34817d88 <serial_getc_dev>

34817dec <serial_putc_dev>:
{
34817dec:	e92d4070 	push	{r4, r5, r6, lr}
	u32 offset = dev_index * sizeof(struct s5p_uart);
34817df0:	e1a06501 	lsl	r6, r1, #10
{
34817df4:	e1a04000 	mov	r4, r0
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817df8:	ebffffa3 	bl	34817c8c <samsung_get_base_uart>
34817dfc:	e0805006 	add	r5, r0, r6
	while (!(readl(&uart->utrstat) & 0x2)) {
34817e00:	e5953010 	ldr	r3, [r5, #16]
34817e04:	e3130002 	tst	r3, #2
34817e08:	1a000005 	bne	34817e24 <serial_putc_dev+0x38>
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817e0c:	ebffff9e 	bl	34817c8c <samsung_get_base_uart>
34817e10:	e0800006 	add	r0, r0, r6
	return readl(&uart->uerstat) & mask;
34817e14:	e5903014 	ldr	r3, [r0, #20]
		if (serial_err_check(dev_index, 1))
34817e18:	e3130008 	tst	r3, #8
34817e1c:	0afffff7 	beq	34817e00 <serial_putc_dev+0x14>
34817e20:	e8bd8070 	pop	{r4, r5, r6, pc}
	if (c == '\n')
34817e24:	e354000a 	cmp	r4, #10
	writeb(c, &uart->utxh);
34817e28:	e5c54020 	strb	r4, [r5, #32]
	if (c == '\n')
34817e2c:	18bd8070 	popne	{r4, r5, r6, pc}
		serial_putc('\r');
34817e30:	e3a0000d 	mov	r0, #13
}
34817e34:	e8bd4070 	pop	{r4, r5, r6, lr}
		serial_putc('\r');
34817e38:	eaffdafb 	b	3480ea2c <serial_putc>

34817e3c <s5p_serial0_putc>:
DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817e3c:	e3a01000 	mov	r1, #0
34817e40:	eaffffe9 	b	34817dec <serial_putc_dev>

34817e44 <s5p_serial1_putc>:
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817e44:	e3a01001 	mov	r1, #1
34817e48:	eaffffe7 	b	34817dec <serial_putc_dev>

34817e4c <s5p_serial2_putc>:
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817e4c:	e3a01002 	mov	r1, #2
34817e50:	eaffffe5 	b	34817dec <serial_putc_dev>

34817e54 <s5p_serial3_putc>:
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817e54:	e3a01003 	mov	r1, #3
34817e58:	eaffffe3 	b	34817dec <serial_putc_dev>

34817e5c <serial_tstc_dev>:
{
34817e5c:	e92d4010 	push	{r4, lr}
34817e60:	e1a04000 	mov	r4, r0
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817e64:	ebffff88 	bl	34817c8c <samsung_get_base_uart>
34817e68:	e0800504 	add	r0, r0, r4, lsl #10
	return (int)(readl(&uart->utrstat) & 0x1);
34817e6c:	e5900010 	ldr	r0, [r0, #16]
}
34817e70:	e2000001 	and	r0, r0, #1
34817e74:	e8bd8010 	pop	{r4, pc}

34817e78 <s5p_serial0_tstc>:
DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817e78:	e3a00000 	mov	r0, #0
34817e7c:	eafffff6 	b	34817e5c <serial_tstc_dev>

34817e80 <s5p_serial1_tstc>:
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817e80:	e3a00001 	mov	r0, #1
34817e84:	eafffff4 	b	34817e5c <serial_tstc_dev>

34817e88 <s5p_serial2_tstc>:
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817e88:	e3a00002 	mov	r0, #2
34817e8c:	eafffff2 	b	34817e5c <serial_tstc_dev>

34817e90 <s5p_serial3_tstc>:
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817e90:	e3a00003 	mov	r0, #3
34817e94:	eafffff0 	b	34817e5c <serial_tstc_dev>

34817e98 <serial_puts_dev>:
{
34817e98:	e92d4070 	push	{r4, r5, r6, lr}
34817e9c:	e1a05001 	mov	r5, r1
34817ea0:	e2404001 	sub	r4, r0, #1
	while (*s)
34817ea4:	e5f40001 	ldrb	r0, [r4, #1]!
34817ea8:	e3500000 	cmp	r0, #0
34817eac:	0a000002 	beq	34817ebc <serial_puts_dev+0x24>
		serial_putc_dev(*s++, dev_index);
34817eb0:	e1a01005 	mov	r1, r5
34817eb4:	ebffffcc 	bl	34817dec <serial_putc_dev>
34817eb8:	eafffff9 	b	34817ea4 <serial_puts_dev+0xc>
}
34817ebc:	e8bd8070 	pop	{r4, r5, r6, pc}

34817ec0 <s5p_serial0_puts>:
DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817ec0:	e3a01000 	mov	r1, #0
34817ec4:	eafffff3 	b	34817e98 <serial_puts_dev>

34817ec8 <s5p_serial1_puts>:
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817ec8:	e3a01001 	mov	r1, #1
34817ecc:	eafffff1 	b	34817e98 <serial_puts_dev>

34817ed0 <s5p_serial2_puts>:
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817ed0:	e3a01002 	mov	r1, #2
34817ed4:	eaffffef 	b	34817e98 <serial_puts_dev>

34817ed8 <s5p_serial3_puts>:
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817ed8:	e3a01003 	mov	r1, #3
34817edc:	eaffffed 	b	34817e98 <serial_puts_dev>

34817ee0 <default_serial_console>:
#elif defined(CONFIG_SERIAL3)
	return &s5p_serial3_device;
#else
#error "CONFIG_SERIAL? missing."
#endif
}
34817ee0:	e59f0000 	ldr	r0, [pc]	; 34817ee8 <default_serial_console+0x8>
34817ee4:	e12fff1e 	bx	lr
34817ee8:	34827f24 	.word	0x34827f24

34817eec <usb_ep_autoconfig>:
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34817eec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34817ef0:	e1a07000 	mov	r7, r0
34817ef4:	e5b74008 	ldr	r4, [r7, #8]!
{
34817ef8:	e1a09000 	mov	r9, r0
34817efc:	e1a05001 	mov	r5, r1
		if (++epnum > 15)
34817f00:	e59fa1d8 	ldr	sl, [pc, #472]	; 348180e0 <usb_ep_autoconfig+0x1f4>
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34817f04:	e244400c 	sub	r4, r4, #12
34817f08:	e284300c 	add	r3, r4, #12
34817f0c:	e1530007 	cmp	r3, r7
34817f10:	0a00006e 	beq	348180d0 <usb_ep_autoconfig+0x1e4>
	if (NULL != ep->driver_data)
34817f14:	e5943000 	ldr	r3, [r4]
34817f18:	e3530000 	cmp	r3, #0
34817f1c:	1a000068 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
34817f20:	e5d56003 	ldrb	r6, [r5, #3]
	if (USB_ENDPOINT_XFER_CONTROL == type)
34817f24:	e2166003 	ands	r6, r6, #3
34817f28:	0a000065 	beq	348180c4 <usb_ep_autoconfig+0x1d8>
	if ('e' != ep->name[0])
34817f2c:	e5940004 	ldr	r0, [r4, #4]
34817f30:	e5d03000 	ldrb	r3, [r0]
34817f34:	e3530065 	cmp	r3, #101	; 0x65
34817f38:	1a000061 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
	if ('-' != ep->name[2]) {
34817f3c:	e5d03002 	ldrb	r3, [r0, #2]
34817f40:	e353002d 	cmp	r3, #45	; 0x2d
34817f44:	1a000008 	bne	34817f6c <usb_ep_autoconfig+0x80>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34817f48:	e5d51005 	ldrb	r1, [r5, #5]
	switch (type) {
34817f4c:	e3560001 	cmp	r6, #1
34817f50:	e5d53004 	ldrb	r3, [r5, #4]
34817f54:	e1831401 	orr	r1, r3, r1, lsl #8
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34817f58:	e7ea2051 	ubfx	r2, r1, #0, #11
	switch (type) {
34817f5c:	0a00002a 	beq	3481800c <usb_ep_autoconfig+0x120>
34817f60:	e3560003 	cmp	r6, #3
34817f64:	0a000022 	beq	34817ff4 <usb_ep_autoconfig+0x108>
34817f68:	ea000037 	b	3481804c <usb_ep_autoconfig+0x160>
		tmp = strrchr(ep->name, '-');
34817f6c:	e3a0102d 	mov	r1, #45	; 0x2d
34817f70:	eb000e60 	bl	3481b8f8 <strrchr>
		if (tmp) {
34817f74:	e3500000 	cmp	r0, #0
34817f78:	0a00000d 	beq	34817fb4 <usb_ep_autoconfig+0xc8>
			switch (type) {
34817f7c:	e3560002 	cmp	r6, #2
34817f80:	0a000005 	beq	34817f9c <usb_ep_autoconfig+0xb0>
34817f84:	e3560003 	cmp	r6, #3
34817f88:	e5d03002 	ldrb	r3, [r0, #2]
34817f8c:	1a000005 	bne	34817fa8 <usb_ep_autoconfig+0xbc>
				if ('s' == tmp[2])	/* == "-iso" */
34817f90:	e3530073 	cmp	r3, #115	; 0x73
34817f94:	1a00000a 	bne	34817fc4 <usb_ep_autoconfig+0xd8>
34817f98:	ea000049 	b	348180c4 <usb_ep_autoconfig+0x1d8>
				if ('b' != tmp[1])	/* != "-bulk" */
34817f9c:	e5d03001 	ldrb	r3, [r0, #1]
34817fa0:	e3530062 	cmp	r3, #98	; 0x62
34817fa4:	ea000000 	b	34817fac <usb_ep_autoconfig+0xc0>
				if ('s' != tmp[2])	/* != "-iso" */
34817fa8:	e3530073 	cmp	r3, #115	; 0x73
34817fac:	1a000044 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
34817fb0:	ea000003 	b	34817fc4 <usb_ep_autoconfig+0xd8>
			tmp = ep->name + strlen(ep->name);
34817fb4:	e594b004 	ldr	fp, [r4, #4]
34817fb8:	e1a0000b 	mov	r0, fp
34817fbc:	eb000e45 	bl	3481b8d8 <strlen>
34817fc0:	e08b0000 	add	r0, fp, r0
		if (!isdigit(*tmp)) {
34817fc4:	e5503001 	ldrb	r3, [r0, #-1]
34817fc8:	e2432030 	sub	r2, r3, #48	; 0x30
34817fcc:	e3520009 	cmp	r2, #9
34817fd0:	9affffdc 	bls	34817f48 <usb_ep_autoconfig+0x5c>
			if (desc->bEndpointAddress & USB_DIR_IN) {
34817fd4:	e1d520d2 	ldrsb	r2, [r5, #2]
34817fd8:	e3520000 	cmp	r2, #0
34817fdc:	aa000001 	bge	34817fe8 <usb_ep_autoconfig+0xfc>
				if ('n' != *tmp)
34817fe0:	e353006e 	cmp	r3, #110	; 0x6e
34817fe4:	ea000000 	b	34817fec <usb_ep_autoconfig+0x100>
				if ('t' != *tmp)
34817fe8:	e3530074 	cmp	r3, #116	; 0x74
34817fec:	1a000034 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
34817ff0:	eaffffd4 	b	34817f48 <usb_ep_autoconfig+0x5c>
		if (!gadget->is_dualspeed && max > 64)
34817ff4:	e5d90014 	ldrb	r0, [r9, #20]
34817ff8:	e3520040 	cmp	r2, #64	; 0x40
34817ffc:	93a03000 	movls	r3, #0
34818000:	83a03001 	movhi	r3, #1
34818004:	e1d33000 	bics	r3, r3, r0
34818008:	1a00002d 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
		if (ep->maxpacket < max)
3481800c:	e1d431b4 	ldrh	r3, [r4, #20]
34818010:	e1530002 	cmp	r3, r2
34818014:	3a00002a 	bcc	348180c4 <usb_ep_autoconfig+0x1d8>
		if (!gadget->is_dualspeed && max > 1023)
34818018:	e5d93014 	ldrb	r3, [r9, #20]
3481801c:	e2033001 	and	r3, r3, #1
34818020:	e2233001 	eor	r3, r3, #1
34818024:	e3520b01 	cmp	r2, #1024	; 0x400
34818028:	33a02000 	movcc	r2, #0
3481802c:	22032001 	andcs	r2, r3, #1
34818030:	e3520000 	cmp	r2, #0
34818034:	1a000022 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
		if ((get_unaligned(&desc->wMaxPacketSize) &
34818038:	e3110b06 	tst	r1, #6144	; 0x1800
			if (!gadget->is_dualspeed)
3481803c:	03a03000 	moveq	r3, #0
34818040:	12033001 	andne	r3, r3, #1
34818044:	e3530000 	cmp	r3, #0
34818048:	1a00001d 	bne	348180c4 <usb_ep_autoconfig+0x1d8>
	if (isdigit(ep->name[2])) {
3481804c:	e5940004 	ldr	r0, [r4, #4]
34818050:	e5d03002 	ldrb	r3, [r0, #2]
34818054:	e2433030 	sub	r3, r3, #48	; 0x30
34818058:	e3530009 	cmp	r3, #9
3481805c:	8a000007 	bhi	34818080 <usb_ep_autoconfig+0x194>
		u8	num = simple_strtoul(&ep->name[2], NULL, 10);
34818060:	e3a0200a 	mov	r2, #10
34818064:	e3a01000 	mov	r1, #0
34818068:	e2800002 	add	r0, r0, #2
3481806c:	eb0011bc 	bl	3481c764 <simple_strtoul>
		desc->bEndpointAddress |= num;
34818070:	e5d53002 	ldrb	r3, [r5, #2]
34818074:	e1800003 	orr	r0, r0, r3
34818078:	e5c50002 	strb	r0, [r5, #2]
3481807c:	ea000007 	b	348180a0 <usb_ep_autoconfig+0x1b4>
		if (++epnum > 15)
34818080:	e59a3000 	ldr	r3, [sl]
34818084:	e2833001 	add	r3, r3, #1
34818088:	e353000f 	cmp	r3, #15
3481808c:	e58a3000 	str	r3, [sl]
34818090:	8a00000b 	bhi	348180c4 <usb_ep_autoconfig+0x1d8>
		desc->bEndpointAddress |= epnum;
34818094:	e5d52002 	ldrb	r2, [r5, #2]
34818098:	e1833002 	orr	r3, r3, r2
3481809c:	e5c53002 	strb	r3, [r5, #2]
	if (USB_ENDPOINT_XFER_BULK == type) {
348180a0:	e3560002 	cmp	r6, #2
348180a4:	1a00000b 	bne	348180d8 <usb_ep_autoconfig+0x1ec>
		int size = ep->maxpacket;
348180a8:	e1d431b4 	ldrh	r3, [r4, #20]
348180ac:	e3530040 	cmp	r3, #64	; 0x40
348180b0:	a3a03040 	movge	r3, #64	; 0x40
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
348180b4:	e5c53004 	strb	r3, [r5, #4]
	*p++ = val >> 8;
348180b8:	e3a03000 	mov	r3, #0
348180bc:	e5c53005 	strb	r3, [r5, #5]
348180c0:	ea000004 	b	348180d8 <usb_ep_autoconfig+0x1ec>
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
348180c4:	e594400c 	ldr	r4, [r4, #12]
348180c8:	e244400c 	sub	r4, r4, #12
348180cc:	eaffff8d 	b	34817f08 <usb_ep_autoconfig+0x1c>
		if (ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Fail */
	return NULL;
348180d0:	e3a00000 	mov	r0, #0
348180d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			return ep;
348180d8:	e1a00004 	mov	r0, r4
}
348180dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348180e0:	3482a8ec 	.word	0x3482a8ec

348180e4 <usb_ep_autoconfig_reset>:
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
348180e4:	e5b03008 	ldr	r3, [r0, #8]!
348180e8:	e3a01000 	mov	r1, #0
348180ec:	e243300c 	sub	r3, r3, #12
348180f0:	e283200c 	add	r2, r3, #12
348180f4:	e1520000 	cmp	r2, r0
		ep->driver_data = NULL;
348180f8:	15831000 	strne	r1, [r3]
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
348180fc:	1593300c 	ldrne	r3, [r3, #12]
34818100:	1243300c 	subne	r3, r3, #12
34818104:	1afffff9 	bne	348180f0 <usb_ep_autoconfig_reset+0xc>
	}
#ifdef	MANY_ENDPOINTS
	in_epnum = 0;
#endif
	epnum = 0;
34818108:	e59f3008 	ldr	r3, [pc, #8]	; 34818118 <usb_ep_autoconfig_reset+0x34>
3481810c:	e3a02000 	mov	r2, #0
34818110:	e5832000 	str	r2, [r3]
34818114:	e12fff1e 	bx	lr
34818118:	3482a8ec 	.word	0x3482a8ec

3481811c <usb_descriptor_fillbuf>:
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
	u8	*dest = buf;

	if (!src)
3481811c:	e3520000 	cmp	r2, #0
34818120:	0a000014 	beq	34818178 <usb_descriptor_fillbuf+0x5c>
{
34818124:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34818128:	e1a09000 	mov	r9, r0
3481812c:	e1a07001 	mov	r7, r1
34818130:	e2425004 	sub	r5, r2, #4
	if (!src)
34818134:	e1a04000 	mov	r4, r0
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
34818138:	e5b51004 	ldr	r1, [r5, #4]!
3481813c:	e3510000 	cmp	r1, #0
34818140:	0a00000a 	beq	34818170 <usb_descriptor_fillbuf+0x54>
		unsigned		len = (*src)->bLength;
34818144:	e5d16000 	ldrb	r6, [r1]

		if (len > buflen)
34818148:	e1560007 	cmp	r6, r7
3481814c:	9a000001 	bls	34818158 <usb_descriptor_fillbuf+0x3c>
		return -EINVAL;
34818150:	e3e00015 	mvn	r0, #21
34818154:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			return -EINVAL;
		memcpy(dest, *src, len);
34818158:	e1a00004 	mov	r0, r4
3481815c:	e1a02006 	mov	r2, r6
34818160:	eb000ea5 	bl	3481bbfc <memcpy>
		buflen -= len;
34818164:	e0667007 	rsb	r7, r6, r7
		dest += len;
34818168:	e0844006 	add	r4, r4, r6
3481816c:	eafffff1 	b	34818138 <usb_descriptor_fillbuf+0x1c>
	}
	return dest - (u8 *)buf;
34818170:	e0690004 	rsb	r0, r9, r4
}
34818174:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return -EINVAL;
34818178:	e3e00015 	mvn	r0, #21
}
3481817c:	e12fff1e 	bx	lr

34818180 <usb_gadget_config_buf>:
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818180:	e3530000 	cmp	r3, #0
34818184:	13520008 	cmpne	r2, #8
34818188:	9a00001f 	bls	3481820c <usb_gadget_config_buf+0x8c>
{
3481818c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34818190:	e1a04001 	mov	r4, r1
		return -EINVAL;
	*cp = *config;
34818194:	e3a07009 	mov	r7, #9
34818198:	e1a06003 	mov	r6, r3
3481819c:	e1a01000 	mov	r1, r0
348181a0:	e1a05002 	mov	r5, r2
348181a4:	e1a00004 	mov	r0, r4
348181a8:	e1a02007 	mov	r2, r7
348181ac:	eb000e92 	bl	3481bbfc <memcpy>

	/* then interface/endpoint/class/vendor/... */
	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,
348181b0:	e1a02006 	mov	r2, r6
348181b4:	e2451009 	sub	r1, r5, #9
348181b8:	e0840007 	add	r0, r4, r7
348181bc:	ebffffd6 	bl	3481811c <usb_descriptor_fillbuf>
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
348181c0:	e3500000 	cmp	r0, #0
348181c4:	b8bd82f0 	poplt	{r4, r5, r6, r7, r9, pc}
		return len;
	len += USB_DT_CONFIG_SIZE;
348181c8:	e0800007 	add	r0, r0, r7
	if (len > 0xffff)
348181cc:	e3500801 	cmp	r0, #65536	; 0x10000
348181d0:	ba000001 	blt	348181dc <usb_gadget_config_buf+0x5c>
		return -EINVAL;
348181d4:	e3e00015 	mvn	r0, #21
348181d8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
348181dc:	e3a03002 	mov	r3, #2
	cp->bLength = USB_DT_CONFIG_SIZE;
348181e0:	e5c47000 	strb	r7, [r4]
	cp->bDescriptorType = USB_DT_CONFIG;
348181e4:	e5c43001 	strb	r3, [r4, #1]
	cp->wTotalLength = cpu_to_le16(len);
348181e8:	e6ff3070 	uxth	r3, r0
348181ec:	e5c43002 	strb	r3, [r4, #2]
348181f0:	e1a03423 	lsr	r3, r3, #8
348181f4:	e5c43003 	strb	r3, [r4, #3]
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
348181f8:	e5d43007 	ldrb	r3, [r4, #7]
348181fc:	e1e03c83 	mvn	r3, r3, lsl #25
34818200:	e1e03ca3 	mvn	r3, r3, lsr #25
34818204:	e5c43007 	strb	r3, [r4, #7]
	return len;
}
34818208:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return -EINVAL;
3481820c:	e3e00015 	mvn	r0, #21
}
34818210:	e12fff1e 	bx	lr

34818214 <usb_gadget_get_string>:
{
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818214:	e3510000 	cmp	r1, #0
{
34818218:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	if (id == 0) {
3481821c:	1a00000a 	bne	3481824c <usb_gadget_get_string+0x38>
		buf[0] = 4;
34818220:	e3a04004 	mov	r4, #4
		buf[1] = USB_DT_STRING;
34818224:	e3a03003 	mov	r3, #3
		buf[0] = 4;
34818228:	e5c24000 	strb	r4, [r2]
		buf[1] = USB_DT_STRING;
3481822c:	e5c23001 	strb	r3, [r2, #1]
		buf[2] = (u8) table->language;
34818230:	e1d030b0 	ldrh	r3, [r0]
34818234:	e5c23002 	strb	r3, [r2, #2]
		buf[3] = (u8) (table->language >> 8);
34818238:	e1d030b0 	ldrh	r3, [r0]
		return 4;
3481823c:	e1a00004 	mov	r0, r4
		buf[3] = (u8) (table->language >> 8);
34818240:	e1a03423 	lsr	r3, r3, #8
34818244:	e5c23003 	strb	r3, [r2, #3]
		return 4;
34818248:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	}
	for (s = table->strings; s && s->s; s++)
3481824c:	e5907004 	ldr	r7, [r0, #4]
34818250:	e3570000 	cmp	r7, #0
34818254:	1a000001 	bne	34818260 <usb_gadget_get_string+0x4c>
		if (s->id == id)
			break;

	/* unrecognized: stall. */
	if (!s || !s->s)
		return -EINVAL;
34818258:	e3e00015 	mvn	r0, #21
3481825c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	for (s = table->strings; s && s->s; s++)
34818260:	e5970004 	ldr	r0, [r7, #4]
34818264:	e3500000 	cmp	r0, #0
34818268:	0afffffa 	beq	34818258 <usb_gadget_get_string+0x44>
		if (s->id == id)
3481826c:	e5d73000 	ldrb	r3, [r7]
34818270:	e1530001 	cmp	r3, r1
	for (s = table->strings; s && s->s; s++)
34818274:	12877008 	addne	r7, r7, #8
34818278:	1afffff4 	bne	34818250 <usb_gadget_get_string+0x3c>
3481827c:	e1a05002 	mov	r5, r2

	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
34818280:	eb000d94 	bl	3481b8d8 <strlen>
34818284:	e350007e 	cmp	r0, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
34818288:	e2856002 	add	r6, r5, #2
	len = min((size_t) 126, strlen(s->s));
3481828c:	31a04000 	movcc	r4, r0
34818290:	23a0407e 	movcs	r4, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
34818294:	e1a02084 	lsl	r2, r4, #1
34818298:	e3a01000 	mov	r1, #0
3481829c:	e1a00006 	mov	r0, r6
348182a0:	eb000e35 	bl	3481bb7c <memset>
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
348182a4:	e5972004 	ldr	r2, [r7, #4]
	int	count = 0;
348182a8:	e3a00000 	mov	r0, #0
	while (len != 0 && (c = (u8) *s++) != 0) {
348182ac:	e1500004 	cmp	r0, r4
348182b0:	1a000006 	bne	348182d0 <usb_gadget_get_string+0xbc>
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
348182b4:	e2840001 	add	r0, r4, #1
	buf[1] = USB_DT_STRING;
348182b8:	e3a03003 	mov	r3, #3
	buf[0] = (len + 1) * 2;
348182bc:	e1a00080 	lsl	r0, r0, #1
	buf[1] = USB_DT_STRING;
348182c0:	e5c53001 	strb	r3, [r5, #1]
	buf[0] = (len + 1) * 2;
348182c4:	e6ef0070 	uxtb	r0, r0
348182c8:	e5c50000 	strb	r0, [r5]
	return buf[0];
348182cc:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	while (len != 0 && (c = (u8) *s++) != 0) {
348182d0:	e5d23000 	ldrb	r3, [r2]
348182d4:	e3530000 	cmp	r3, #0
348182d8:	0a00002c 	beq	34818390 <usb_gadget_get_string+0x17c>
		if ((c & 0x80)) {
348182dc:	e3130080 	tst	r3, #128	; 0x80
	while (len != 0 && (c = (u8) *s++) != 0) {
348182e0:	0282c001 	addeq	ip, r2, #1
			uchar = c;
348182e4:	06ff3073 	uxtheq	r3, r3
		if ((c & 0x80)) {
348182e8:	0a000022 	beq	34818378 <usb_gadget_get_string+0x164>
			if ((c & 0xe0) == 0xc0) {
348182ec:	e20310e0 	and	r1, r3, #224	; 0xe0
348182f0:	e35100c0 	cmp	r1, #192	; 0xc0
348182f4:	1a000009 	bne	34818320 <usb_gadget_get_string+0x10c>
				c = (u8) *s++;
348182f8:	e5d21001 	ldrb	r1, [r2, #1]
348182fc:	e282c002 	add	ip, r2, #2
				uchar = (c & 0x1f) << 6;
34818300:	e203301f 	and	r3, r3, #31
34818304:	e1a03303 	lsl	r3, r3, #6
				if ((c & 0xc0) != 0x80)
34818308:	e20120c0 	and	r2, r1, #192	; 0xc0
3481830c:	e3520080 	cmp	r2, #128	; 0x80
34818310:	1affffd0 	bne	34818258 <usb_gadget_get_string+0x44>
				uchar |= c;
34818314:	e201103f 	and	r1, r1, #63	; 0x3f
34818318:	e1833001 	orr	r3, r3, r1
3481831c:	ea000015 	b	34818378 <usb_gadget_get_string+0x164>
			} else if ((c & 0xf0) == 0xe0) {
34818320:	e20310f0 	and	r1, r3, #240	; 0xf0
34818324:	e35100e0 	cmp	r1, #224	; 0xe0
34818328:	1affffca 	bne	34818258 <usb_gadget_get_string+0x44>
				c = (u8) *s++;
3481832c:	e5d21001 	ldrb	r1, [r2, #1]
				uchar = (c & 0x0f) << 12;
34818330:	e1a03603 	lsl	r3, r3, #12
				if ((c & 0xc0) != 0x80)
34818334:	e201c0c0 	and	ip, r1, #192	; 0xc0
34818338:	e35c0080 	cmp	ip, #128	; 0x80
3481833c:	1affffc5 	bne	34818258 <usb_gadget_get_string+0x44>
				uchar |= c << 6;
34818340:	e201103f 	and	r1, r1, #63	; 0x3f
				c = (u8) *s++;
34818344:	e282c003 	add	ip, r2, #3
				uchar |= c << 6;
34818348:	e1833301 	orr	r3, r3, r1, lsl #6
				c = (u8) *s++;
3481834c:	e5d21002 	ldrb	r1, [r2, #2]
				uchar |= c << 6;
34818350:	e6ff3073 	uxth	r3, r3
				if ((c & 0xc0) != 0x80)
34818354:	e20120c0 	and	r2, r1, #192	; 0xc0
34818358:	e3520080 	cmp	r2, #128	; 0x80
3481835c:	1affffbd 	bne	34818258 <usb_gadget_get_string+0x44>
				uchar |= c;
34818360:	e201103f 	and	r1, r1, #63	; 0x3f
34818364:	e1833001 	orr	r3, r3, r1
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818368:	e2832b0a 	add	r2, r3, #10240	; 0x2800
3481836c:	e6ff2072 	uxth	r2, r2
34818370:	e3520b02 	cmp	r2, #2048	; 0x800
34818374:	3affffb7 	bcc	34818258 <usb_gadget_get_string+0x44>
	*p++ = val;
34818378:	e4c63002 	strb	r3, [r6], #2
	*p++ = val >> 8;
3481837c:	e1a03423 	lsr	r3, r3, #8
		count++;
34818380:	e2800001 	add	r0, r0, #1
34818384:	e5463001 	strb	r3, [r6, #-1]
34818388:	e1a0200c 	mov	r2, ip
3481838c:	eaffffc6 	b	348182ac <usb_gadget_get_string+0x98>
	while (len != 0 && (c = (u8) *s++) != 0) {
34818390:	e1a04000 	mov	r4, r0
34818394:	eaffffc6 	b	348182b4 <usb_gadget_get_string+0xa0>

34818398 <udc_reinit>:

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34818398:	e5903004 	ldr	r3, [r0, #4]
	INIT_LIST_HEAD(&dev->gadget.ep_list);
3481839c:	e280c008 	add	ip, r0, #8
{
348183a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	list->next = list;
348183a4:	e580c008 	str	ip, [r0, #8]
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
348183a8:	e283200c 	add	r2, r3, #12
	list->prev = list;
348183ac:	e580c00c 	str	ip, [r0, #12]
	list->next = list;
348183b0:	e583200c 	str	r2, [r3, #12]
	list->prev = list;
348183b4:	e5832010 	str	r2, [r3, #16]
	dev->ep0state = WAIT_FOR_SETUP;
348183b8:	e3a02000 	mov	r2, #0
348183bc:	e28030a4 	add	r3, r0, #164	; 0xa4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
348183c0:	e1a01002 	mov	r1, r2
	dev->ep0state = WAIT_FOR_SETUP;
348183c4:	e5802054 	str	r2, [r0, #84]	; 0x54
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348183c8:	e2822001 	add	r2, r2, #1
348183cc:	e243e02c 	sub	lr, r3, #44	; 0x2c
348183d0:	e3520004 	cmp	r2, #4
		ep->desc = 0;
348183d4:	e5031030 	str	r1, [r3, #-48]	; 0xffffffd0
		ep->stopped = 0;
348183d8:	e5431018 	strb	r1, [r3, #-24]	; 0xffffffe8
	list->next = list;
348183dc:	e503e02c 	str	lr, [r3, #-44]	; 0xffffffd4
	list->prev = list;
348183e0:	e503e028 	str	lr, [r3, #-40]	; 0xffffffd8
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
348183e4:	e5031024 	str	r1, [r3, #-36]	; 0xffffffdc
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348183e8:	0a000005 	beq	34818404 <udc_reinit+0x6c>
	__list_add(new, head->prev, head);
348183ec:	e590e00c 	ldr	lr, [r0, #12]
	next->prev = new;
348183f0:	e580300c 	str	r3, [r0, #12]
	new->prev = prev;
348183f4:	e8835000 	stm	r3, {ip, lr}
	prev->next = new;
348183f8:	e58e3000 	str	r3, [lr]
348183fc:	e2833040 	add	r3, r3, #64	; 0x40
34818400:	eafffff0 	b	348183c8 <udc_reinit+0x30>
	}

	/* the rest was statically initialized, and is read-only */
}
34818404:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

34818408 <set_max_pktsize>:
	/* 14. Initialize OTG Link Core.*/
	writel(GAHBCFG_INIT, &reg->gahbcfg);
}

static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
{
34818408:	e59f3068 	ldr	r3, [pc, #104]	; 34818478 <set_max_pktsize+0x70>
	unsigned int ep_ctrl;
	int i;

	if (speed == USB_SPEED_HIGH) {
3481840c:	e3510003 	cmp	r1, #3
34818410:	e3a02040 	mov	r2, #64	; 0x40
		ep0_fifo_size = 64;
		ep_fifo_size = 512;
		ep_fifo_size2 = 1024;
34818414:	03a0cb01 	moveq	ip, #1024	; 0x400
		dev->gadget.speed = USB_SPEED_HIGH;
34818418:	05801010 	streq	r1, [r0, #16]
		dev->gadget.speed = USB_SPEED_FULL;
	}

	dev->ep[0].ep.maxpacket = ep0_fifo_size;
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
		dev->ep[i].ep.maxpacket = ep_fifo_size;
3481841c:	e2800f4b 	add	r0, r0, #300	; 0x12c
		ep0_fifo_size = 64;
34818420:	e5832000 	str	r2, [r3]
		ep_fifo_size2 = 1024;
34818424:	03a02c02 	moveq	r2, #512	; 0x200
		ep_fifo_size = 64;
34818428:	15832004 	strne	r2, [r3, #4]
		ep_fifo_size2 = 64;
3481842c:	15832008 	strne	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_FULL;
34818430:	13a02002 	movne	r2, #2
		ep_fifo_size2 = 1024;
34818434:	09831004 	stmibeq	r3, {r2, ip}
		dev->ep[i].ep.maxpacket = ep_fifo_size;
34818438:	e1d330b4 	ldrh	r3, [r3, #4]
		dev->gadget.speed = USB_SPEED_FULL;
3481843c:	1500211c 	strne	r2, [r0, #-284]	; 0xfffffee4
	dev->ep[0].ep.maxpacket = ep0_fifo_size;
34818440:	e3a02040 	mov	r2, #64	; 0x40
34818444:	e1402cb0 	strh	r2, [r0, #-192]	; 0xffffff40
		dev->ep[i].ep.maxpacket = ep_fifo_size;
34818448:	e14038b0 	strh	r3, [r0, #-128]	; 0xffffff80
3481844c:	e14034b0 	strh	r3, [r0, #-64]	; 0xffffffc0
34818450:	e1c030b0 	strh	r3, [r0]

	/* EP0 - Control IN (64 bytes)*/
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818454:	e59f3020 	ldr	r3, [pc, #32]	; 3481847c <set_max_pktsize+0x74>
34818458:	e5932000 	ldr	r2, [r3]
3481845c:	e5921900 	ldr	r1, [r2, #2304]	; 0x900
	writel(ep_ctrl|(0<<0), &reg->in_endp[EP0_CON].diepctl);
34818460:	e5932000 	ldr	r2, [r3]
34818464:	e5821900 	str	r1, [r2, #2304]	; 0x900

	/* EP0 - Control OUT (64 bytes)*/
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34818468:	e5922b00 	ldr	r2, [r2, #2816]	; 0xb00
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
3481846c:	e5933000 	ldr	r3, [r3]
34818470:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
34818474:	e12fff1e 	bx	lr
34818478:	34827fe4 	.word	0x34827fe4
3481847c:	3482a8f0 	.word	0x3482a8f0

34818480 <s3c_fifo_status>:
{
	int count = 0;
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
34818480:	e3500000 	cmp	r0, #0
34818484:	0a000004 	beq	3481849c <s3c_fifo_status+0x1c>
	}

	debug("%s: %d\n", __func__, ep_index(ep));

	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
34818488:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
3481848c:	e3530000 	cmp	r3, #0
		return -EOPNOTSUPP;

	return count;
34818490:	b3e0005e 	mvnlt	r0, #94	; 0x5e
34818494:	a3a00000 	movge	r0, #0
34818498:	e12fff1e 	bx	lr
		return -ENODEV;
3481849c:	e3e00012 	mvn	r0, #18
}
348184a0:	e12fff1e 	bx	lr

348184a4 <s3c_fifo_flush>:

/*
 * Flush EP FIFO
 */
static void s3c_fifo_flush(struct usb_ep *_ep)
{
348184a4:	e12fff1e 	bx	lr

348184a8 <setdma_rx>:

}


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
348184a8:	e92d4070 	push	{r4, r5, r6, lr}
348184ac:	e1a06000 	mov	r6, r0
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
348184b0:	e5d04035 	ldrb	r4, [r0, #53]	; 0x35

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
348184b4:	e5913004 	ldr	r3, [r1, #4]
	buf = req->req.buf + req->req.actual;
348184b8:	e5910024 	ldr	r0, [r1, #36]	; 0x24
	u32 ep_num = ep_index(ep);
348184bc:	e204400f 	and	r4, r4, #15
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
348184c0:	e1d651b4 	ldrh	r5, [r6, #20]
	buf = req->req.buf + req->req.actual;
348184c4:	e5912000 	ldr	r2, [r1]
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
348184c8:	e0603003 	rsb	r3, r0, r3
348184cc:	e1550003 	cmp	r5, r3
348184d0:	21a05003 	movcs	r5, r3

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
348184d4:	e5963018 	ldr	r3, [r6, #24]
	buf = req->req.buf + req->req.actual;
348184d8:	e0822000 	add	r2, r2, r0
	ep->len = length;
348184dc:	e586502c 	str	r5, [r6, #44]	; 0x2c
	ep->dma_buf = buf;
348184e0:	e5862030 	str	r2, [r6, #48]	; 0x30
				(unsigned long) ep->dev->dma_buf[ep_num]
348184e4:	e0833104 	add	r3, r3, r4, lsl #2
348184e8:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
348184ec:	e2801901 	add	r1, r0, #16384	; 0x4000
348184f0:	ebffa23b 	bl	34800de4 <invalidate_dcache_range>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;

	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
348184f4:	e59f3050 	ldr	r3, [pc, #80]	; 3481854c <setdma_rx+0xa4>
348184f8:	e2840058 	add	r0, r4, #88	; 0x58
348184fc:	e5932000 	ldr	r2, [r3]
34818500:	e7921280 	ldr	r1, [r2, r0, lsl #5]

	writel(the_controller->dma_addr[ep_index(ep)+1],
34818504:	e5d62035 	ldrb	r2, [r6, #53]	; 0x35
34818508:	e593c004 	ldr	ip, [r3, #4]
3481850c:	e202200f 	and	r2, r2, #15
34818510:	e2822011 	add	r2, r2, #17
34818514:	e79cc102 	ldr	ip, [ip, r2, lsl #2]
34818518:	e5932000 	ldr	r2, [r3]
3481851c:	e1a04284 	lsl	r4, r4, #5
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34818520:	e3855702 	orr	r5, r5, #524288	; 0x80000
	writel(the_controller->dma_addr[ep_index(ep)+1],
34818524:	e0822004 	add	r2, r2, r4
34818528:	e582cb14 	str	ip, [r2, #2836]	; 0xb14
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
3481852c:	e5932000 	ldr	r2, [r3]
34818530:	e0824004 	add	r4, r2, r4
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
34818534:	e3812321 	orr	r2, r1, #-2080374784	; 0x84000000
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34818538:	e5845b10 	str	r5, [r4, #2832]	; 0xb10
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
3481853c:	e5933000 	ldr	r3, [r3]
34818540:	e7832280 	str	r2, [r3, r0, lsl #5]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
34818544:	e3a00000 	mov	r0, #0
34818548:	e8bd8070 	pop	{r4, r5, r6, pc}
3481854c:	3482a8f0 	.word	0x3482a8f0

34818550 <s3c_ep0_complete_out>:
{
34818550:	e92d4010 	push	{r4, lr}
				(unsigned long) usb_ctrl_dma_addr
34818554:	e59f4034 	ldr	r4, [pc, #52]	; 34818590 <s3c_ep0_complete_out+0x40>
34818558:	e5940008 	ldr	r0, [r4, #8]
	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
3481855c:	e2801901 	add	r1, r0, #16384	; 0x4000
34818560:	ebffa21f 	bl	34800de4 <invalidate_dcache_range>
	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34818564:	e59f2028 	ldr	r2, [pc, #40]	; 34818594 <s3c_ep0_complete_out+0x44>
34818568:	e5943000 	ldr	r3, [r4]
3481856c:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
34818570:	e5942008 	ldr	r2, [r4, #8]
34818574:	e5943000 	ldr	r3, [r4]
34818578:	e5832b14 	str	r2, [r3, #2836]	; 0xb14
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
3481857c:	e5933b00 	ldr	r3, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34818580:	e3833321 	orr	r3, r3, #-2080374784	; 0x84000000
34818584:	e5942000 	ldr	r2, [r4]
34818588:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
3481858c:	e8bd8010 	pop	{r4, pc}
34818590:	3482a8f0 	.word	0x3482a8f0
34818594:	00080008 	.word	0x00080008

34818598 <done>:
{
34818598:	e92d4070 	push	{r4, r5, r6, lr}
3481859c:	e1a04000 	mov	r4, r0
	unsigned int stopped = ep->stopped;
348185a0:	e5d05034 	ldrb	r5, [r0, #52]	; 0x34
	list_del_init(&req->queue);
348185a4:	e2813028 	add	r3, r1, #40	; 0x28
	__list_del(entry->prev, entry->next);
348185a8:	e591002c 	ldr	r0, [r1, #44]	; 0x2c
348185ac:	e591c028 	ldr	ip, [r1, #40]	; 0x28
	next->prev = prev;
348185b0:	e58c0004 	str	r0, [ip, #4]
	prev->next = next;
348185b4:	e580c000 	str	ip, [r0]
	req->req.complete(&ep->ep, &req->req);
348185b8:	e1a00004 	mov	r0, r4
	list->next = list;
348185bc:	e5813028 	str	r3, [r1, #40]	; 0x28
	list->prev = list;
348185c0:	e581302c 	str	r3, [r1, #44]	; 0x2c
	if (likely(req->req.status == -EINPROGRESS))
348185c4:	e5913020 	ldr	r3, [r1, #32]
348185c8:	e3730073 	cmn	r3, #115	; 0x73
	ep->stopped = 1;
348185cc:	e3a03001 	mov	r3, #1
		req->req.status = status;
348185d0:	05812020 	streq	r2, [r1, #32]
	ep->stopped = 1;
348185d4:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	req->req.complete(&ep->ep, &req->req);
348185d8:	e5913010 	ldr	r3, [r1, #16]
348185dc:	e12fff33 	blx	r3
	ep->stopped = stopped;
348185e0:	e5c45034 	strb	r5, [r4, #52]	; 0x34
348185e4:	e8bd8070 	pop	{r4, r5, r6, pc}

348185e8 <nuke>:
{
348185e8:	e92d4070 	push	{r4, r5, r6, lr}
348185ec:	e1a04000 	mov	r4, r0
348185f0:	e1a06001 	mov	r6, r1
	while (!list_empty(&ep->queue)) {
348185f4:	e2805020 	add	r5, r0, #32
	return head->next == head;
348185f8:	e5941020 	ldr	r1, [r4, #32]
348185fc:	e1510005 	cmp	r1, r5
34818600:	0a000004 	beq	34818618 <nuke+0x30>
		done(ep, req, status);
34818604:	e1a02006 	mov	r2, r6
34818608:	e2411028 	sub	r1, r1, #40	; 0x28
3481860c:	e1a00004 	mov	r0, r4
34818610:	ebffffe0 	bl	34818598 <done>
34818614:	eafffff7 	b	348185f8 <nuke+0x10>
}
34818618:	e8bd8070 	pop	{r4, r5, r6, pc}

3481861c <s3c_ep_disable>:
{
3481861c:	e92d4010 	push	{r4, lr}
	if (!_ep || !ep->desc) {
34818620:	e2504000 	subs	r4, r0, #0
34818624:	0a000009 	beq	34818650 <s3c_ep_disable+0x34>
34818628:	e594301c 	ldr	r3, [r4, #28]
3481862c:	e3530000 	cmp	r3, #0
34818630:	0a000006 	beq	34818650 <s3c_ep_disable+0x34>
	nuke(ep, -ESHUTDOWN);
34818634:	e3e0106b 	mvn	r1, #107	; 0x6b
34818638:	ebffffea 	bl	348185e8 <nuke>
	ep->desc = 0;
3481863c:	e3a00000 	mov	r0, #0
	ep->stopped = 1;
34818640:	e3a03001 	mov	r3, #1
	ep->desc = 0;
34818644:	e584001c 	str	r0, [r4, #28]
	ep->stopped = 1;
34818648:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	return 0;
3481864c:	e8bd8010 	pop	{r4, pc}
		return -EINVAL;
34818650:	e3e00015 	mvn	r0, #21
}
34818654:	e8bd8010 	pop	{r4, pc}

34818658 <s3c_dequeue>:
	if (!_ep || ep->ep.name == ep0name)
34818658:	e3500000 	cmp	r0, #0
{
3481865c:	e92d4010 	push	{r4, lr}
	if (!_ep || ep->ep.name == ep0name)
34818660:	0a000014 	beq	348186b8 <s3c_dequeue+0x60>
34818664:	e5902004 	ldr	r2, [r0, #4]
34818668:	e59f3050 	ldr	r3, [pc, #80]	; 348186c0 <s3c_dequeue+0x68>
3481866c:	e1520003 	cmp	r2, r3
	list_for_each_entry(req, &ep->queue, queue) {
34818670:	11a02000 	movne	r2, r0
34818674:	15b23020 	ldrne	r3, [r2, #32]!
	if (!_ep || ep->ep.name == ep0name)
34818678:	0a00000e 	beq	348186b8 <s3c_dequeue+0x60>
	list_for_each_entry(req, &ep->queue, queue) {
3481867c:	e2433028 	sub	r3, r3, #40	; 0x28
34818680:	e283c028 	add	ip, r3, #40	; 0x28
34818684:	e15c0002 	cmp	ip, r2
34818688:	0a000003 	beq	3481869c <s3c_dequeue+0x44>
		if (&req->req == _req)
3481868c:	e1530001 	cmp	r3, r1
34818690:	0a000003 	beq	348186a4 <s3c_dequeue+0x4c>
	list_for_each_entry(req, &ep->queue, queue) {
34818694:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34818698:	eafffff7 	b	3481867c <s3c_dequeue+0x24>
	if (&req->req != _req) {
3481869c:	e1530001 	cmp	r3, r1
348186a0:	1a000004 	bne	348186b8 <s3c_dequeue+0x60>
	done(ep, req, -ECONNRESET);
348186a4:	e3e02067 	mvn	r2, #103	; 0x67
348186a8:	e1a01003 	mov	r1, r3
348186ac:	ebffffb9 	bl	34818598 <done>
	return 0;
348186b0:	e3a00000 	mov	r0, #0
348186b4:	e8bd8010 	pop	{r4, pc}
		return -EINVAL;
348186b8:	e3e00015 	mvn	r0, #21
}
348186bc:	e8bd8010 	pop	{r4, pc}
348186c0:	348201f4 	.word	0x348201f4

348186c4 <reconfig_usbd>:
{
348186c4:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
348186c8:	e3a05001 	mov	r5, #1
348186cc:	e59f4174 	ldr	r4, [pc, #372]	; 34818848 <reconfig_usbd+0x184>
348186d0:	e5943000 	ldr	r3, [r4]
348186d4:	e5835010 	str	r5, [r3, #16]
	writel(0<<15		/* PHY Low Power Clock sel*/
348186d8:	e5943000 	ldr	r3, [r4]
348186dc:	e305240f 	movw	r2, #21519	; 0x540f
348186e0:	e583200c 	str	r2, [r3, #12]
	uTemp = readl(&reg->dctl);
348186e4:	e5933804 	ldr	r3, [r3, #2052]	; 0x804
	uTemp |= SOFT_DISCONNECT;
348186e8:	e3833002 	orr	r3, r3, #2
	writel(uTemp, &reg->dctl);
348186ec:	e5942000 	ldr	r2, [r4]
	udelay(20);
348186f0:	e3a00014 	mov	r0, #20
	writel(uTemp, &reg->dctl);
348186f4:	e5823804 	str	r3, [r2, #2052]	; 0x804
	udelay(20);
348186f8:	eb000dc3 	bl	3481be0c <udelay>
	uTemp = readl(&reg->dctl);
348186fc:	e5943000 	ldr	r3, [r4]
34818700:	e5933804 	ldr	r3, [r3, #2052]	; 0x804
	uTemp = uTemp & ~SOFT_DISCONNECT;
34818704:	e3c33002 	bic	r3, r3, #2
	writel(uTemp, &reg->dctl);
34818708:	e5942000 	ldr	r2, [r4]
3481870c:	e5823804 	str	r3, [r2, #2052]	; 0x804
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
34818710:	e5943000 	ldr	r3, [r4]
34818714:	e3a02701 	mov	r2, #262144	; 0x40000
	mdelay(1);
34818718:	e1a00005 	mov	r0, r5
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
3481871c:	e5832800 	str	r2, [r3, #2048]	; 0x800
	mdelay(1);
34818720:	eb000dc5 	bl	3481be3c <mdelay>
	writel(GINTMSK_INIT, &reg->gintmsk);
34818724:	e59f2120 	ldr	r2, [pc, #288]	; 3481884c <reconfig_usbd+0x188>
34818728:	e5943000 	ldr	r3, [r4]
3481872c:	e5832018 	str	r2, [r3, #24]
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
34818730:	e5942000 	ldr	r2, [r4]
34818734:	e3a03312 	mov	r3, #1207959552	; 0x48000000
34818738:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
3481873c:	e5942000 	ldr	r2, [r4]
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818740:	e1a00005 	mov	r0, r5
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
34818744:	e5823900 	str	r3, [r2, #2304]	; 0x900
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
34818748:	e5941000 	ldr	r1, [r4]
3481874c:	e280c058 	add	ip, r0, #88	; 0x58
34818750:	e59f20f0 	ldr	r2, [pc, #240]	; 34818848 <reconfig_usbd+0x184>
34818754:	e781328c 	str	r3, [r1, ip, lsl #5]
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818758:	e280c048 	add	ip, r0, #72	; 0x48
3481875c:	e5941000 	ldr	r1, [r4]
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818760:	e2800001 	add	r0, r0, #1
34818764:	e3500004 	cmp	r0, #4
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818768:	e781328c 	str	r3, [r1, ip, lsl #5]
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
3481876c:	1afffff5 	bne	34818748 <reconfig_usbd+0x84>
	writel(((1 << EP0_CON) << DAINT_OUT_BIT)
34818770:	e59f10d8 	ldr	r1, [pc, #216]	; 34818850 <reconfig_usbd+0x18c>
34818774:	e5923000 	ldr	r3, [r2]
34818778:	e583181c 	str	r1, [r3, #2076]	; 0x81c
	writel(DOEPMSK_INIT, &reg->doepmsk);
3481877c:	e5921000 	ldr	r1, [r2]
34818780:	e3a0300d 	mov	r3, #13
34818784:	e5813814 	str	r3, [r1, #2068]	; 0x814
	writel(DIEPMSK_INIT, &reg->diepmsk);
34818788:	e5921000 	ldr	r1, [r2]
3481878c:	e5813810 	str	r3, [r1, #2064]	; 0x810
	writel(RX_FIFO_SIZE >> 2, &reg->grxfsiz);
34818790:	e5923000 	ldr	r3, [r2]
34818794:	e3a01b01 	mov	r1, #1024	; 0x400
34818798:	e5831024 	str	r1, [r3, #36]	; 0x24
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
3481879c:	e5923000 	ldr	r3, [r2]
348187a0:	e3a0cc06 	mov	ip, #1536	; 0x600
348187a4:	e59f20a8 	ldr	r2, [pc, #168]	; 34818854 <reconfig_usbd+0x190>
348187a8:	e5832028 	str	r2, [r3, #40]	; 0x28
348187ac:	e3a02000 	mov	r2, #0
348187b0:	e003029c 	mul	r3, ip, r2
348187b4:	e2833a02 	add	r3, r3, #8192	; 0x2000
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348187b8:	e1a03143 	asr	r3, r3, #2
348187bc:	e3833506 	orr	r3, r3, #25165824	; 0x1800000
348187c0:	e5941000 	ldr	r1, [r4]
348187c4:	e2820040 	add	r0, r2, #64	; 0x40
348187c8:	e2822001 	add	r2, r2, #1
	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
348187cc:	e352000f 	cmp	r2, #15
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348187d0:	e0811100 	add	r1, r1, r0, lsl #2
348187d4:	e5813004 	str	r3, [r1, #4]
	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
348187d8:	1afffff4 	bne	348187b0 <reconfig_usbd+0xec>
	writel(RX_FIFO_FLUSH, &reg->grstctl);
348187dc:	e59f3064 	ldr	r3, [pc, #100]	; 34818848 <reconfig_usbd+0x184>
348187e0:	e3a02010 	mov	r2, #16
348187e4:	e5933000 	ldr	r3, [r3]
348187e8:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
348187ec:	e5942000 	ldr	r2, [r4]
348187f0:	e59f3050 	ldr	r3, [pc, #80]	; 34818848 <reconfig_usbd+0x184>
348187f4:	e5922010 	ldr	r2, [r2, #16]
348187f8:	e3120010 	tst	r2, #16
348187fc:	1afffffa 	bne	348187ec <reconfig_usbd+0x128>
	writel(TX_FIFO_FLUSH_ALL, &reg->grstctl);
34818800:	e5932000 	ldr	r2, [r3]
34818804:	e3a01b01 	mov	r1, #1024	; 0x400
34818808:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_FLUSH_ALL | TX_FIFO_FLUSH, &reg->grstctl);
3481880c:	e5933000 	ldr	r3, [r3]
34818810:	e3a02e42 	mov	r2, #1056	; 0x420
34818814:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34818818:	e5942000 	ldr	r2, [r4]
3481881c:	e59f3024 	ldr	r3, [pc, #36]	; 34818848 <reconfig_usbd+0x184>
34818820:	e5922010 	ldr	r2, [r2, #16]
34818824:	e3120020 	tst	r2, #32
34818828:	1afffffa 	bne	34818818 <reconfig_usbd+0x154>
	writel(DEPCTL_EPDIS | DEPCTL_CNAK,
3481882c:	e5932000 	ldr	r2, [r3]
34818830:	e3a01311 	mov	r1, #1140850688	; 0x44000000
34818834:	e5821b00 	str	r1, [r2, #2816]	; 0xb00
	writel(GAHBCFG_INIT, &reg->gahbcfg);
34818838:	e5933000 	ldr	r3, [r3]
3481883c:	e3a02027 	mov	r2, #39	; 0x27
34818840:	e5832008 	str	r2, [r3, #8]
34818844:	e8bd8070 	pop	{r4, r5, r6, pc}
34818848:	3482a8f0 	.word	0x3482a8f0
3481884c:	800c3800 	.word	0x800c3800
34818850:	00010001 	.word	0x00010001
34818854:	04000400 	.word	0x04000400

34818858 <s3c_free_request>:
	WARN_ON(!list_empty(&req->queue));
34818858:	e5912028 	ldr	r2, [r1, #40]	; 0x28
3481885c:	e2813028 	add	r3, r1, #40	; 0x28
{
34818860:	e92d4010 	push	{r4, lr}
34818864:	e1a04001 	mov	r4, r1
	WARN_ON(!list_empty(&req->queue));
34818868:	e1520003 	cmp	r2, r3
3481886c:	0a000003 	beq	34818880 <s3c_free_request+0x28>
34818870:	e3a02faf 	mov	r2, #700	; 0x2bc
34818874:	e59f1010 	ldr	r1, [pc, #16]	; 3481888c <s3c_free_request+0x34>
34818878:	e59f0010 	ldr	r0, [pc, #16]	; 34818890 <s3c_free_request+0x38>
3481887c:	ebffc3c6 	bl	3480979c <printf>
	kfree(req);
34818880:	e1a00004 	mov	r0, r4
}
34818884:	e8bd4010 	pop	{r4, lr}
	kfree(req);
34818888:	eaffc508 	b	34809cb0 <free>
3481888c:	34826b39 	.word	0x34826b39
34818890:	34826b47 	.word	0x34826b47

34818894 <s3c_alloc_request>:
{
34818894:	e92d4010 	push	{r4, lr}
	req = memalign(CONFIG_SYS_CACHELINE_SIZE, sizeof(*req));
34818898:	e3a01030 	mov	r1, #48	; 0x30
3481889c:	e3a00040 	mov	r0, #64	; 0x40
348188a0:	ebffc865 	bl	3480aa3c <memalign>
	if (!req)
348188a4:	e2504000 	subs	r4, r0, #0
348188a8:	0a000005 	beq	348188c4 <s3c_alloc_request+0x30>
	memset(req, 0, sizeof *req);
348188ac:	e3a02030 	mov	r2, #48	; 0x30
348188b0:	e3a01000 	mov	r1, #0
348188b4:	eb000cb0 	bl	3481bb7c <memset>
	INIT_LIST_HEAD(&req->queue);
348188b8:	e2843028 	add	r3, r4, #40	; 0x28
	list->next = list;
348188bc:	e5843028 	str	r3, [r4, #40]	; 0x28
	list->prev = list;
348188c0:	e584302c 	str	r3, [r4, #44]	; 0x2c
}
348188c4:	e1a00004 	mov	r0, r4
348188c8:	e8bd8010 	pop	{r4, pc}

348188cc <s3c_udc_ep0_zlp.isra.2>:
static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
348188cc:	e92d4070 	push	{r4, r5, r6, lr}
348188d0:	e1a05000 	mov	r5, r0
			   (unsigned long) usb_ctrl_dma_addr
348188d4:	e59f403c 	ldr	r4, [pc, #60]	; 34818918 <s3c_udc_ep0_zlp.isra.2+0x4c>
348188d8:	e5940008 	ldr	r0, [r4, #8]
	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
348188dc:	e2801901 	add	r1, r0, #16384	; 0x4000
348188e0:	ebffa12d 	bl	34800d9c <flush_dcache_range>
	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
348188e4:	e5942008 	ldr	r2, [r4, #8]
348188e8:	e5943000 	ldr	r3, [r4]
348188ec:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
348188f0:	e5943000 	ldr	r3, [r4]
348188f4:	e3a02702 	mov	r2, #524288	; 0x80000
348188f8:	e5832910 	str	r2, [r3, #2320]	; 0x910
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348188fc:	e5933900 	ldr	r3, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34818900:	e3833321 	orr	r3, r3, #-2080374784	; 0x84000000
34818904:	e5942000 	ldr	r2, [r4]
34818908:	e5823900 	str	r3, [r2, #2304]	; 0x900
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
3481890c:	e3a03007 	mov	r3, #7
34818910:	e5853000 	str	r3, [r5]
34818914:	e8bd8070 	pop	{r4, r5, r6, pc}
34818918:	3482a8f0 	.word	0x3482a8f0

3481891c <complete_rx>:

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
3481891c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_ep *ep = &dev->ep[ep_num];
34818920:	e1a07301 	lsl	r7, r1, #6
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818924:	e59fc144 	ldr	ip, [pc, #324]	; 34818a70 <complete_rx+0x154>
34818928:	e080e007 	add	lr, r0, r7
	struct s3c_ep *ep = &dev->ep[ep_num];
3481892c:	e2876058 	add	r6, r7, #88	; 0x58
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818930:	e5de308d 	ldrb	r3, [lr, #141]	; 0x8d
	struct s3c_ep *ep = &dev->ep[ep_num];
34818934:	e0806006 	add	r6, r0, r6
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818938:	e59c2004 	ldr	r2, [ip, #4]
	return head->next == head;
3481893c:	e59e9078 	ldr	r9, [lr, #120]	; 0x78
34818940:	e203300f 	and	r3, r3, #15
34818944:	e0823103 	add	r3, r2, r3, lsl #2
34818948:	e593a030 	ldr	sl, [r3, #48]	; 0x30

	if (list_empty(&ep->queue)) {
3481894c:	e2873078 	add	r3, r7, #120	; 0x78
34818950:	e0803003 	add	r3, r0, r3
34818954:	e1590003 	cmp	r9, r3
34818958:	e58d3004 	str	r3, [sp, #4]
3481895c:	0a000041 	beq	34818a68 <complete_rx+0x14c>
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
34818960:	e59c3000 	ldr	r3, [ip]
	req = list_entry(ep->queue.next, struct s3c_request, queue);
34818964:	e249b028 	sub	fp, r9, #40	; 0x28
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
34818968:	e0833281 	add	r3, r3, r1, lsl #5
3481896c:	e5935b10 	ldr	r5, [r3, #2832]	; 0xb10
34818970:	e0802301 	add	r2, r0, r1, lsl #6

	if (ep_num == EP0_CON)
34818974:	e3510000 	cmp	r1, #0
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
34818978:	0205507f 	andeq	r5, r5, #127	; 0x7f
3481897c:	e58d1008 	str	r1, [sp, #8]
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
34818980:	e5923084 	ldr	r3, [r2, #132]	; 0x84
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
34818984:	17ee5055 	ubfxne	r5, r5, #0, #15
34818988:	e1a04000 	mov	r4, r0

	invalidate_dcache_range((unsigned long) p,
3481898c:	e28a1901 	add	r1, sl, #16384	; 0x4000
34818990:	e1a0000a 	mov	r0, sl
	xfer_size = ep->len - xfer_size;
34818994:	e58d200c 	str	r2, [sp, #12]
34818998:	e0655003 	rsb	r5, r5, r3
	invalidate_dcache_range((unsigned long) p,
3481899c:	ebffa110 	bl	34800de4 <invalidate_dcache_range>
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
348189a0:	e59d200c 	ldr	r2, [sp, #12]
348189a4:	e0843007 	add	r3, r4, r7
348189a8:	e1a0100a 	mov	r1, sl
348189ac:	e5930088 	ldr	r0, [r3, #136]	; 0x88
348189b0:	e58d300c 	str	r3, [sp, #12]
348189b4:	e5922084 	ldr	r2, [r2, #132]	; 0x84
348189b8:	eb000c8f 	bl	3481bbfc <memcpy>

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
348189bc:	e5191024 	ldr	r1, [r9, #-36]	; 0xffffffdc
348189c0:	e5192004 	ldr	r2, [r9, #-4]
	is_short = (xfer_size < ep->ep.maxpacket);
348189c4:	e59d300c 	ldr	r3, [sp, #12]
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
348189c8:	e0620001 	rsb	r0, r2, r1
348189cc:	e1550000 	cmp	r5, r0
348189d0:	90822005 	addls	r2, r2, r5
348189d4:	80822000 	addhi	r2, r2, r0
348189d8:	e5092004 	str	r2, [r9, #-4]
	is_short = (xfer_size < ep->ep.maxpacket);
348189dc:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
348189e0:	e1550003 	cmp	r5, r3
348189e4:	23a03000 	movcs	r3, #0
348189e8:	33a03001 	movcc	r3, #1
348189ec:	e1520001 	cmp	r2, r1
348189f0:	11a05003 	movne	r5, r3
348189f4:	03835001 	orreq	r5, r3, #1
348189f8:	e3550000 	cmp	r5, #0
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
348189fc:	01a0100b 	moveq	r1, fp
	if (is_short || req->req.actual == req->req.length) {
34818a00:	0a000014 	beq	34818a58 <complete_rx+0x13c>
		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
34818a04:	e59d3008 	ldr	r3, [sp, #8]
34818a08:	e3530000 	cmp	r3, #0
34818a0c:	1a000007 	bne	34818a30 <complete_rx+0x114>
34818a10:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34818a14:	e3530004 	cmp	r3, #4
34818a18:	1a000004 	bne	34818a30 <complete_rx+0x114>
			s3c_udc_ep0_zlp(dev);
34818a1c:	e2840054 	add	r0, r4, #84	; 0x54
34818a20:	ebffffa9 	bl	348188cc <s3c_udc_ep0_zlp.isra.2>
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
34818a24:	e3a03007 	mov	r3, #7
34818a28:	e5843054 	str	r3, [r4, #84]	; 0x54
34818a2c:	ea00000d 	b	34818a68 <complete_rx+0x14c>
			done(ep, req, 0);
34818a30:	e1a0100b 	mov	r1, fp
34818a34:	e3a02000 	mov	r2, #0
34818a38:	e1a00006 	mov	r0, r6
34818a3c:	e0844007 	add	r4, r4, r7
34818a40:	ebfffed4 	bl	34818598 <done>
34818a44:	e5941078 	ldr	r1, [r4, #120]	; 0x78
			if (!list_empty(&ep->queue)) {
34818a48:	e59d3004 	ldr	r3, [sp, #4]
34818a4c:	e1510003 	cmp	r1, r3
				setdma_rx(ep, req);
34818a50:	12411028 	subne	r1, r1, #40	; 0x28
			if (!list_empty(&ep->queue)) {
34818a54:	0a000003 	beq	34818a68 <complete_rx+0x14c>
		setdma_rx(ep, req);
34818a58:	e1a00006 	mov	r0, r6
}
34818a5c:	e28dd010 	add	sp, sp, #16
34818a60:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
		setdma_rx(ep, req);
34818a64:	eafffe8f 	b	348184a8 <setdma_rx>
}
34818a68:	e28dd010 	add	sp, sp, #16
34818a6c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34818a70:	3482a8f0 	.word	0x3482a8f0

34818a74 <set_udc_gadget_private_data>:
	the_controller->gadget.dev.device_data = p;
34818a74:	e59f3008 	ldr	r3, [pc, #8]	; 34818a84 <set_udc_gadget_private_data+0x10>
34818a78:	e5933004 	ldr	r3, [r3, #4]
34818a7c:	e5830020 	str	r0, [r3, #32]
34818a80:	e12fff1e 	bx	lr
34818a84:	3482a8f0 	.word	0x3482a8f0

34818a88 <get_udc_gadget_private_data>:
}
34818a88:	e5900020 	ldr	r0, [r0, #32]
34818a8c:	e12fff1e 	bx	lr

34818a90 <otg_phy_init>:
	dev->pdata->phy_control(1);
34818a90:	e5903028 	ldr	r3, [r0, #40]	; 0x28
{
34818a94:	e92d4070 	push	{r4, r5, r6, lr}
34818a98:	e1a05000 	mov	r5, r0
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
34818a9c:	e59f409c 	ldr	r4, [pc, #156]	; 34818b40 <otg_phy_init+0xb0>
	dev->pdata->phy_control(1);
34818aa0:	e3a00001 	mov	r0, #1
34818aa4:	e5933000 	ldr	r3, [r3]
34818aa8:	e12fff33 	blx	r3
	printf("USB PHY0 Enable\n");
34818aac:	e59f0090 	ldr	r0, [pc, #144]	; 34818b44 <otg_phy_init+0xb4>
34818ab0:	ebffc339 	bl	3480979c <printf>
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
34818ab4:	e594300c 	ldr	r3, [r4, #12]
34818ab8:	e5933000 	ldr	r3, [r3]
34818abc:	e3833001 	orr	r3, r3, #1
34818ac0:	e594200c 	ldr	r2, [r4, #12]
34818ac4:	e5823000 	str	r3, [r2]
	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
34818ac8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34818acc:	e5933010 	ldr	r3, [r3, #16]
34818ad0:	e3530020 	cmp	r3, #32
		writel((readl(&phy->phypwr)
34818ad4:	e5943010 	ldr	r3, [r4, #16]
34818ad8:	e5933000 	ldr	r3, [r3]
34818adc:	03c33039 	biceq	r3, r3, #57	; 0x39
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34818ae0:	13c33019 	bicne	r3, r3, #25
34818ae4:	e5942010 	ldr	r2, [r4, #16]
34818ae8:	e5823000 	str	r3, [r2]
	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34818aec:	e5943010 	ldr	r3, [r4, #16]
34818af0:	e5933004 	ldr	r3, [r3, #4]
34818af4:	e3c33017 	bic	r3, r3, #23
34818af8:	e3833003 	orr	r3, r3, #3
34818afc:	e5942010 	ldr	r2, [r4, #16]
34818b00:	e5823004 	str	r3, [r2, #4]
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34818b04:	e5923008 	ldr	r3, [r2, #8]
34818b08:	e3c33007 	bic	r3, r3, #7
34818b0c:	e3833001 	orr	r3, r3, #1
34818b10:	e5942010 	ldr	r2, [r4, #16]
	udelay(10);
34818b14:	e3a0000a 	mov	r0, #10
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34818b18:	e5823008 	str	r3, [r2, #8]
	udelay(10);
34818b1c:	eb000cba 	bl	3481be0c <udelay>
	writel(readl(&phy->rstcon)
34818b20:	e5943010 	ldr	r3, [r4, #16]
34818b24:	e5933008 	ldr	r3, [r3, #8]
34818b28:	e3c33007 	bic	r3, r3, #7
34818b2c:	e5942010 	ldr	r2, [r4, #16]
	udelay(10);
34818b30:	e3a0000a 	mov	r0, #10
}
34818b34:	e8bd4070 	pop	{r4, r5, r6, lr}
	writel(readl(&phy->rstcon)
34818b38:	e5823008 	str	r3, [r2, #8]
	udelay(10);
34818b3c:	ea000cb2 	b	3481be0c <udelay>
34818b40:	3482a8f0 	.word	0x3482a8f0
34818b44:	34826b5e 	.word	0x34826b5e

34818b48 <otg_phy_off>:
{
34818b48:	e92d4070 	push	{r4, r5, r6, lr}
34818b4c:	e1a05000 	mov	r5, r0
	writel(PHY_SW_RST0, &phy->rstcon);
34818b50:	e3a02001 	mov	r2, #1
	udelay(20);
34818b54:	e3a00014 	mov	r0, #20
	writel(PHY_SW_RST0, &phy->rstcon);
34818b58:	e59f407c 	ldr	r4, [pc, #124]	; 34818bdc <otg_phy_off+0x94>
34818b5c:	e5943010 	ldr	r3, [r4, #16]
34818b60:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34818b64:	eb000ca8 	bl	3481be0c <udelay>
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34818b68:	e5943010 	ldr	r3, [r4, #16]
34818b6c:	e5933000 	ldr	r3, [r3]
34818b70:	e3c33001 	bic	r3, r3, #1
34818b74:	e5942010 	ldr	r2, [r4, #16]
	udelay(20);
34818b78:	e3a00014 	mov	r0, #20
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34818b7c:	e5823008 	str	r3, [r2, #8]
	udelay(20);
34818b80:	eb000ca1 	bl	3481be0c <udelay>
	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
34818b84:	e5943010 	ldr	r3, [r4, #16]
34818b88:	e5933000 	ldr	r3, [r3]
34818b8c:	e3833019 	orr	r3, r3, #25
34818b90:	e5942010 	ldr	r2, [r4, #16]
34818b94:	e5823000 	str	r3, [r2]
	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);
34818b98:	e594300c 	ldr	r3, [r4, #12]
34818b9c:	e5933000 	ldr	r3, [r3]
34818ba0:	e3c33001 	bic	r3, r3, #1
34818ba4:	e594200c 	ldr	r2, [r4, #12]
34818ba8:	e5823000 	str	r3, [r2]
	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34818bac:	e5943010 	ldr	r3, [r4, #16]
34818bb0:	e5933004 	ldr	r3, [r3, #4]
34818bb4:	e3c33014 	bic	r3, r3, #20
34818bb8:	e5942010 	ldr	r2, [r4, #16]
	udelay(10000);
34818bbc:	e3020710 	movw	r0, #10000	; 0x2710
	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34818bc0:	e5823004 	str	r3, [r2, #4]
	udelay(10000);
34818bc4:	eb000c90 	bl	3481be0c <udelay>
	dev->pdata->phy_control(0);
34818bc8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34818bcc:	e3a00000 	mov	r0, #0
}
34818bd0:	e8bd4070 	pop	{r4, r5, r6, lr}
	dev->pdata->phy_control(0);
34818bd4:	e5933000 	ldr	r3, [r3]
34818bd8:	e12fff13 	bx	r3
34818bdc:	3482a8f0 	.word	0x3482a8f0

34818be0 <s3c_udc_pre_setup>:
{
34818be0:	e92d4010 	push	{r4, lr}
				(unsigned long) usb_ctrl_dma_addr
34818be4:	e59f4034 	ldr	r4, [pc, #52]	; 34818c20 <s3c_udc_pre_setup+0x40>
34818be8:	e5940008 	ldr	r0, [r4, #8]
	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
34818bec:	e2801901 	add	r1, r0, #16384	; 0x4000
34818bf0:	ebffa07b 	bl	34800de4 <invalidate_dcache_range>
	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34818bf4:	e59f2028 	ldr	r2, [pc, #40]	; 34818c24 <s3c_udc_pre_setup+0x44>
34818bf8:	e5943000 	ldr	r3, [r4]
34818bfc:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
34818c00:	e5942008 	ldr	r2, [r4, #8]
34818c04:	e5943000 	ldr	r3, [r4]
34818c08:	e5832b14 	str	r2, [r3, #2836]	; 0xb14
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34818c0c:	e5933b00 	ldr	r3, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA, &reg->out_endp[EP0_CON].doepctl);
34818c10:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
34818c14:	e5942000 	ldr	r2, [r4]
34818c18:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
34818c1c:	e8bd8010 	pop	{r4, pc}
34818c20:	3482a8f0 	.word	0x3482a8f0
34818c24:	00080008 	.word	0x00080008

34818c28 <s3c_udc_ep0_set_stall.isra.3>:
{
	struct s3c_udc *dev;
	u32		ep_ctrl = 0;

	dev = ep->dev;
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818c28:	e59f2024 	ldr	r2, [pc, #36]	; 34818c54 <s3c_udc_ep0_set_stall.isra.3+0x2c>
34818c2c:	e5923000 	ldr	r3, [r2]
34818c30:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

	/* set the disable and stall bits */
	if (ep_ctrl & DEPCTL_EPENA)
34818c34:	e3530000 	cmp	r3, #0
		ep_ctrl |= DEPCTL_EPDIS;
34818c38:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

	ep_ctrl |= DEPCTL_STALL;
34818c3c:	e3833602 	orr	r3, r3, #2097152	; 0x200000

	writel(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
34818c40:	e5922000 	ldr	r2, [r2]
34818c44:	e5823900 	str	r3, [r2, #2304]	; 0x900
		   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
	/*
	 * The application can only set this bit, and the core clears it,
	 * when a SETUP token is received for this endpoint
	 */
	dev->ep0state = WAIT_FOR_SETUP;
34818c48:	e3a03000 	mov	r3, #0
34818c4c:	e5803054 	str	r3, [r0, #84]	; 0x54

	s3c_udc_pre_setup();
34818c50:	eaffffe2 	b	34818be0 <s3c_udc_pre_setup>
34818c54:	3482a8f0 	.word	0x3482a8f0

34818c58 <setdma_tx>:
{
34818c58:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34818c5c:	e1a06000 	mov	r6, r0
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818c60:	e59f7110 	ldr	r7, [pc, #272]	; 34818d78 <setdma_tx+0x120>
	u32 ep_num = ep_index(ep);
34818c64:	e5d05035 	ldrb	r5, [r0, #53]	; 0x35
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818c68:	e5973004 	ldr	r3, [r7, #4]
	buf = req->req.buf + req->req.actual;
34818c6c:	e5912024 	ldr	r2, [r1, #36]	; 0x24
	u32 ep_num = ep_index(ep);
34818c70:	e205500f 	and	r5, r5, #15
	length = req->req.length - req->req.actual;
34818c74:	e5914004 	ldr	r4, [r1, #4]
	if (ep_num == EP0_CON)
34818c78:	e3550000 	cmp	r5, #0
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818c7c:	e0833105 	add	r3, r3, r5, lsl #2
	length = req->req.length - req->req.actual;
34818c80:	e0624004 	rsb	r4, r2, r4
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818c84:	e5939030 	ldr	r9, [r3, #48]	; 0x30
	buf = req->req.buf + req->req.actual;
34818c88:	e5913000 	ldr	r3, [r1]
34818c8c:	e0833002 	add	r3, r3, r2
	if (ep_num == EP0_CON)
34818c90:	1a000002 	bne	34818ca0 <setdma_tx+0x48>
		length = min(length, (u32)ep_maxpacket(ep));
34818c94:	e1d021b4 	ldrh	r2, [r0, #20]
34818c98:	e1540002 	cmp	r4, r2
34818c9c:	21a04002 	movcs	r4, r2
	memcpy(p, ep->dma_buf, length);
34818ca0:	e1a01003 	mov	r1, r3
	ep->dma_buf = buf;
34818ca4:	e5863030 	str	r3, [r6, #48]	; 0x30
	memcpy(p, ep->dma_buf, length);
34818ca8:	e1a02004 	mov	r2, r4
	ep->len = length;
34818cac:	e586402c 	str	r4, [r6, #44]	; 0x2c
	memcpy(p, ep->dma_buf, length);
34818cb0:	e1a00009 	mov	r0, r9
34818cb4:	eb000bd0 	bl	3481bbfc <memcpy>
	flush_dcache_range((unsigned long) p ,
34818cb8:	e1a00009 	mov	r0, r9
34818cbc:	e2891901 	add	r1, r9, #16384	; 0x4000
34818cc0:	ebffa035 	bl	34800d9c <flush_dcache_range>
	if (length == 0)
34818cc4:	e3540000 	cmp	r4, #0
		pktcnt = 1;
34818cc8:	03a00001 	moveq	r0, #1
	if (length == 0)
34818ccc:	0a000003 	beq	34818ce0 <setdma_tx+0x88>
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
34818cd0:	e1d611b4 	ldrh	r1, [r6, #20]
34818cd4:	e2440001 	sub	r0, r4, #1
34818cd8:	fa0018d0 	blx	3481f020 <__udivsi3>
34818cdc:	e2800001 	add	r0, r0, #1
	writel(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
34818ce0:	e596303c 	ldr	r3, [r6, #60]	; 0x3c
34818ce4:	e1a03303 	lsl	r3, r3, #6
34818ce8:	e5972000 	ldr	r2, [r7]
34818cec:	e5823010 	str	r3, [r2, #16]
	writel(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
34818cf0:	e596303c 	ldr	r3, [r6, #60]	; 0x3c
34818cf4:	e1a03303 	lsl	r3, r3, #6
34818cf8:	e3833020 	orr	r3, r3, #32
34818cfc:	e5972000 	ldr	r2, [r7]
34818d00:	e5823010 	str	r3, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34818d04:	e5973000 	ldr	r3, [r7]
34818d08:	e59f2068 	ldr	r2, [pc, #104]	; 34818d78 <setdma_tx+0x120>
34818d0c:	e5933010 	ldr	r3, [r3, #16]
34818d10:	e3130020 	tst	r3, #32
34818d14:	1afffffa 	bne	34818d04 <setdma_tx+0xac>
	writel(the_controller->dma_addr[ep_index(ep)+1],
34818d18:	e5d63035 	ldrb	r3, [r6, #53]	; 0x35
34818d1c:	e5921004 	ldr	r1, [r2, #4]
34818d20:	e203300f 	and	r3, r3, #15
34818d24:	e2833011 	add	r3, r3, #17
34818d28:	e791c103 	ldr	ip, [r1, r3, lsl #2]
34818d2c:	e5921000 	ldr	r1, [r2]
34818d30:	e1a03285 	lsl	r3, r5, #5
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34818d34:	e1840980 	orr	r0, r4, r0, lsl #19
	writel(the_controller->dma_addr[ep_index(ep)+1],
34818d38:	e0811003 	add	r1, r1, r3
34818d3c:	e581c914 	str	ip, [r1, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34818d40:	e5921000 	ldr	r1, [r2]
	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34818d44:	e2855048 	add	r5, r5, #72	; 0x48
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34818d48:	e0813003 	add	r3, r1, r3
34818d4c:	e5830910 	str	r0, [r3, #2320]	; 0x910
	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34818d50:	e7913285 	ldr	r3, [r1, r5, lsl #5]
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34818d54:	e596103c 	ldr	r1, [r6, #60]	; 0x3c
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
34818d58:	e3c3350f 	bic	r3, r3, #62914560	; 0x3c00000
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34818d5c:	e1833b01 	orr	r3, r3, r1, lsl #22
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
34818d60:	e3c33b1e 	bic	r3, r3, #30720	; 0x7800
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34818d64:	e3833321 	orr	r3, r3, #-2080374784	; 0x84000000
34818d68:	e5922000 	ldr	r2, [r2]
}
34818d6c:	e1a00004 	mov	r0, r4
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34818d70:	e7823285 	str	r3, [r2, r5, lsl #5]
}
34818d74:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34818d78:	3482a8f0 	.word	0x3482a8f0

34818d7c <write_fifo_ep0>:
{
34818d7c:	e92d4070 	push	{r4, r5, r6, lr}
34818d80:	e1a05000 	mov	r5, r0
	max = ep_maxpacket(ep);
34818d84:	e1d061b4 	ldrh	r6, [r0, #20]
{
34818d88:	e1a04001 	mov	r4, r1
	count = setdma_tx(ep, req);
34818d8c:	ebffffb1 	bl	34818c58 <setdma_tx>
	if (likely(count != max))
34818d90:	e1500006 	cmp	r0, r6
34818d94:	1a000009 	bne	34818dc0 <write_fifo_ep0+0x44>
		if (likely(req->req.length != req->req.actual + count)
34818d98:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34818d9c:	e0800003 	add	r0, r0, r3
34818da0:	e5943004 	ldr	r3, [r4, #4]
34818da4:	e1530000 	cmp	r3, r0
34818da8:	1a000002 	bne	34818db8 <write_fifo_ep0+0x3c>
		    || req->req.zero)
34818dac:	e5d4300c 	ldrb	r3, [r4, #12]
34818db0:	e3130002 	tst	r3, #2
34818db4:	0a000001 	beq	34818dc0 <write_fifo_ep0+0x44>
	return 0;
34818db8:	e3a00000 	mov	r0, #0
34818dbc:	e8bd8070 	pop	{r4, r5, r6, pc}
		ep->dev->ep0state = WAIT_FOR_SETUP;
34818dc0:	e5953018 	ldr	r3, [r5, #24]
34818dc4:	e3a02000 	mov	r2, #0
		return 1;
34818dc8:	e3a00001 	mov	r0, #1
		ep->dev->ep0state = WAIT_FOR_SETUP;
34818dcc:	e5832054 	str	r2, [r3, #84]	; 0x54
}
34818dd0:	e8bd8070 	pop	{r4, r5, r6, pc}

34818dd4 <s3c_queue>:
	if (unlikely(!_req || !_req->complete || !_req->buf
34818dd4:	e3510000 	cmp	r1, #0
34818dd8:	0a000005 	beq	34818df4 <s3c_queue+0x20>
34818ddc:	e5913010 	ldr	r3, [r1, #16]
34818de0:	e3530000 	cmp	r3, #0
34818de4:	0a000002 	beq	34818df4 <s3c_queue+0x20>
34818de8:	e5913000 	ldr	r3, [r1]
34818dec:	e3530000 	cmp	r3, #0
34818df0:	1a000001 	bne	34818dfc <s3c_queue+0x28>
		return -EINVAL;
34818df4:	e3e00015 	mvn	r0, #21
34818df8:	e12fff1e 	bx	lr
	if (unlikely(!_req || !_req->complete || !_req->buf
34818dfc:	e5913028 	ldr	r3, [r1, #40]	; 0x28
{
34818e00:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	if (unlikely(!_req || !_req->complete || !_req->buf
34818e04:	e2817028 	add	r7, r1, #40	; 0x28
34818e08:	e0533007 	subs	r3, r3, r7
34818e0c:	13a03001 	movne	r3, #1
	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
34818e10:	e3500000 	cmp	r0, #0
34818e14:	03833001 	orreq	r3, r3, #1
34818e18:	e3530000 	cmp	r3, #0
34818e1c:	1a000006 	bne	34818e3c <s3c_queue+0x68>
34818e20:	e590301c 	ldr	r3, [r0, #28]
34818e24:	e3530000 	cmp	r3, #0
34818e28:	1a000005 	bne	34818e44 <s3c_queue+0x70>
34818e2c:	e5902004 	ldr	r2, [r0, #4]
34818e30:	e59f3194 	ldr	r3, [pc, #404]	; 34818fcc <s3c_queue+0x1f8>
34818e34:	e1520003 	cmp	r2, r3
34818e38:	0a000001 	beq	34818e44 <s3c_queue+0x70>
		return -EINVAL;
34818e3c:	e3e00015 	mvn	r0, #21
34818e40:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	dev = ep->dev;
34818e44:	e5906018 	ldr	r6, [r0, #24]
	ep_num = ep_index(ep);
34818e48:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
34818e4c:	e5962024 	ldr	r2, [r6, #36]	; 0x24
34818e50:	e3520000 	cmp	r2, #0
34818e54:	0a000053 	beq	34818fa8 <s3c_queue+0x1d4>
34818e58:	e5962010 	ldr	r2, [r6, #16]
34818e5c:	e3520000 	cmp	r2, #0
34818e60:	0a000050 	beq	34818fa8 <s3c_queue+0x1d4>
	_req->status = -EINPROGRESS;
34818e64:	e3e02072 	mvn	r2, #114	; 0x72
34818e68:	e1a05001 	mov	r5, r1
34818e6c:	e5812020 	str	r2, [r1, #32]
	_req->actual = 0;
34818e70:	e3a02000 	mov	r2, #0
34818e74:	e5812024 	str	r2, [r1, #36]	; 0x24
	if (list_empty(&ep->queue) && !ep->stopped) {
34818e78:	e2809020 	add	r9, r0, #32
34818e7c:	e5901020 	ldr	r1, [r0, #32]
34818e80:	e1a04000 	mov	r4, r0
34818e84:	e1510009 	cmp	r1, r9
34818e88:	1a000048 	bne	34818fb0 <s3c_queue+0x1dc>
34818e8c:	e5d02034 	ldrb	r2, [r0, #52]	; 0x34
34818e90:	e3520000 	cmp	r2, #0
34818e94:	1a000045 	bne	34818fb0 <s3c_queue+0x1dc>
		if (ep_num == 0) {
34818e98:	e213300f 	ands	r3, r3, #15
34818e9c:	1a000035 	bne	34818f78 <s3c_queue+0x1a4>
	__list_add(new, head->prev, head);
34818ea0:	e5902024 	ldr	r2, [r0, #36]	; 0x24
	next->prev = new;
34818ea4:	e5807024 	str	r7, [r0, #36]	; 0x24
	new->next = next;
34818ea8:	e5851028 	str	r1, [r5, #40]	; 0x28
34818eac:	e1a01006 	mov	r1, r6
	new->prev = prev;
34818eb0:	e585202c 	str	r2, [r5, #44]	; 0x2c
	prev->next = new;
34818eb4:	e5827000 	str	r7, [r2]

static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
34818eb8:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
34818ebc:	e2860058 	add	r0, r6, #88	; 0x58
34818ec0:	e3520000 	cmp	r2, #0
34818ec4:	e5b12078 	ldr	r2, [r1, #120]!	; 0x78
34818ec8:	aa000015 	bge	34818f24 <s3c_queue+0x150>
	if (list_empty(&ep->queue))
34818ecc:	e1520001 	cmp	r2, r1
		dev->ep0state = DATA_STATE_XMIT;
34818ed0:	e3a05001 	mov	r5, #1
34818ed4:	e5865054 	str	r5, [r6, #84]	; 0x54
	if (list_empty(&ep->queue))
34818ed8:	0a000039 	beq	34818fc4 <s3c_queue+0x1f0>
	if (!req) {
34818edc:	e2521028 	subs	r1, r2, #40	; 0x28
34818ee0:	0a000037 	beq	34818fc4 <s3c_queue+0x1f0>
	if (req->req.length - req->req.actual == ep0_fifo_size) {
34818ee4:	e5123024 	ldr	r3, [r2, #-36]	; 0xffffffdc
34818ee8:	e5124004 	ldr	r4, [r2, #-4]
34818eec:	e0644003 	rsb	r4, r4, r3
34818ef0:	e59f30d8 	ldr	r3, [pc, #216]	; 34818fd0 <s3c_queue+0x1fc>
34818ef4:	e5937000 	ldr	r7, [r3]
	ret = write_fifo_ep0(ep, req);
34818ef8:	ebffff9f 	bl	34818d7c <write_fifo_ep0>
	if ((ret == 1) && !need_zlp) {
34818efc:	e0650000 	rsb	r0, r5, r0
34818f00:	e16f0f10 	clz	r0, r0
34818f04:	e1540007 	cmp	r4, r7
34818f08:	e1a002a0 	lsr	r0, r0, #5
34818f0c:	03a00000 	moveq	r0, #0
34818f10:	e3500000 	cmp	r0, #0
		dev->ep0state = WAIT_FOR_COMPLETE;
34818f14:	13a03005 	movne	r3, #5
		dev->ep0state = DATA_STATE_XMIT;
34818f18:	05865054 	streq	r5, [r6, #84]	; 0x54
		dev->ep0state = WAIT_FOR_COMPLETE;
34818f1c:	15863054 	strne	r3, [r6, #84]	; 0x54
34818f20:	ea000027 	b	34818fc4 <s3c_queue+0x1f0>
	if (!list_empty(&ep->queue)) {
34818f24:	e1520001 	cmp	r2, r1
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34818f28:	e3a03004 	mov	r3, #4
34818f2c:	e5863054 	str	r3, [r6, #84]	; 0x54
	if (!list_empty(&ep->queue)) {
34818f30:	0a000006 	beq	34818f50 <s3c_queue+0x17c>
	if (req->req.length == 0) {
34818f34:	e5123024 	ldr	r3, [r2, #-36]	; 0xffffffdc
34818f38:	e3530000 	cmp	r3, #0
34818f3c:	1a00000a 	bne	34818f6c <s3c_queue+0x198>
		ep->len = 0;
34818f40:	e5863084 	str	r3, [r6, #132]	; 0x84
		s3c_udc_ep0_zlp(dev);
34818f44:	e2860054 	add	r0, r6, #84	; 0x54
34818f48:	ebfffe5f 	bl	348188cc <s3c_udc_ep0_zlp.isra.2>
34818f4c:	ea00001c 	b	34818fc4 <s3c_queue+0x1f0>
		BUG();
34818f50:	e59f307c 	ldr	r3, [pc, #124]	; 34818fd4 <s3c_queue+0x200>
34818f54:	e3002332 	movw	r2, #818	; 0x332
34818f58:	e59f1078 	ldr	r1, [pc, #120]	; 34818fd8 <s3c_queue+0x204>
34818f5c:	e59f0078 	ldr	r0, [pc, #120]	; 34818fdc <s3c_queue+0x208>
34818f60:	ebffc20d 	bl	3480979c <printf>
34818f64:	e59f0074 	ldr	r0, [pc, #116]	; 34818fe0 <s3c_queue+0x20c>
34818f68:	eb000eb0 	bl	3481ca30 <panic>
	setdma_rx(ep, req);
34818f6c:	e2421028 	sub	r1, r2, #40	; 0x28
34818f70:	ebfffd4c 	bl	348184a8 <setdma_rx>
34818f74:	ea000012 	b	34818fc4 <s3c_queue+0x1f0>
		} else if (ep_is_in(ep)) {
34818f78:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
34818f7c:	e3530000 	cmp	r3, #0
34818f80:	e59f305c 	ldr	r3, [pc, #92]	; 34818fe4 <s3c_queue+0x210>
			gintsts = readl(&reg->gintsts);
34818f84:	e5933000 	ldr	r3, [r3]
34818f88:	e5933014 	ldr	r3, [r3, #20]
		} else if (ep_is_in(ep)) {
34818f8c:	aa000002 	bge	34818f9c <s3c_queue+0x1c8>
			setdma_tx(ep, req);
34818f90:	e1a01005 	mov	r1, r5
34818f94:	ebffff2f 	bl	34818c58 <setdma_tx>
34818f98:	ea000004 	b	34818fb0 <s3c_queue+0x1dc>
			setdma_rx(ep, req);
34818f9c:	e1a01005 	mov	r1, r5
34818fa0:	ebfffd40 	bl	348184a8 <setdma_rx>
34818fa4:	ea000001 	b	34818fb0 <s3c_queue+0x1dc>
		return -ESHUTDOWN;
34818fa8:	e3e0006b 	mvn	r0, #107	; 0x6b
34818fac:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	__list_add(new, head->prev, head);
34818fb0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
	next->prev = new;
34818fb4:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
34818fb8:	e5859028 	str	r9, [r5, #40]	; 0x28
	new->prev = prev;
34818fbc:	e585302c 	str	r3, [r5, #44]	; 0x2c
	prev->next = new;
34818fc0:	e5837000 	str	r7, [r3]
	return 0;
34818fc4:	e3a00000 	mov	r0, #0
}
34818fc8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
34818fcc:	348201f4 	.word	0x348201f4
34818fd0:	34827fe4 	.word	0x34827fe4
34818fd4:	34820200 	.word	0x34820200
34818fd8:	34826b6f 	.word	0x34826b6f
34818fdc:	348260f2 	.word	0x348260f2
34818fe0:	3482610f 	.word	0x3482610f
34818fe4:	3482a8f0 	.word	0x3482a8f0

34818fe8 <s3c_fifo_read>:
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
34818fe8:	e5902018 	ldr	r2, [r0, #24]
{
34818fec:	e92d4010 	push	{r4, lr}
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
34818ff0:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
34818ff4:	e203300f 	and	r3, r3, #15
34818ff8:	e0823103 	add	r3, r2, r3, lsl #2
34818ffc:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
34819000:	e2801901 	add	r1, r0, #16384	; 0x4000
34819004:	ebff9f76 	bl	34800de4 <invalidate_dcache_range>
}
34819008:	e3a00008 	mov	r0, #8
3481900c:	e8bd8010 	pop	{r4, pc}

34819010 <s3c_udc_get_status>:
{
34819010:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
34819014:	e1a06001 	mov	r6, r1
	u8 ep_num = crq->wIndex & 0x7F;
34819018:	e5d13004 	ldrb	r3, [r1, #4]
{
3481901c:	e1a07000 	mov	r7, r0
	u8 ep_num = crq->wIndex & 0x7F;
34819020:	e5d15005 	ldrb	r5, [r1, #5]
	u32 *p = the_controller->dma_buf[1];
34819024:	e59f40cc 	ldr	r4, [pc, #204]	; 348190f8 <s3c_udc_get_status+0xe8>
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819028:	e5d11000 	ldrb	r1, [r1]
3481902c:	e59f00c8 	ldr	r0, [pc, #200]	; 348190fc <s3c_udc_get_status+0xec>
	u8 ep_num = crq->wIndex & 0x7F;
34819030:	e1835405 	orr	r5, r3, r5, lsl #8
	u32 *p = the_controller->dma_buf[1];
34819034:	e5943004 	ldr	r3, [r4, #4]
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819038:	e201101f 	and	r1, r1, #31
	u32 *p = the_controller->dma_buf[1];
3481903c:	e5939030 	ldr	r9, [r3, #48]	; 0x30
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819040:	ebffc1d5 	bl	3480979c <printf>
	switch (crq->bRequestType & USB_RECIP_MASK) {
34819044:	e5d63000 	ldrb	r3, [r6]
34819048:	e203301f 	and	r3, r3, #31
3481904c:	e3530001 	cmp	r3, #1
34819050:	0a000003 	beq	34819064 <s3c_udc_get_status+0x54>
34819054:	3a000004 	bcc	3481906c <s3c_udc_get_status+0x5c>
34819058:	e3530002 	cmp	r3, #2
3481905c:	0a000004 	beq	34819074 <s3c_udc_get_status+0x64>
34819060:	ea000022 	b	348190f0 <s3c_udc_get_status+0xe0>
		g_status = 0;
34819064:	e3a03000 	mov	r3, #0
34819068:	ea000009 	b	34819094 <s3c_udc_get_status+0x84>
		g_status = 0x1; /* Self powered */
3481906c:	e3a03001 	mov	r3, #1
34819070:	ea000007 	b	34819094 <s3c_udc_get_status+0x84>
		if (crq->wLength > 2) {
34819074:	e5d63006 	ldrb	r3, [r6, #6]
34819078:	e5d62007 	ldrb	r2, [r6, #7]
3481907c:	e1833402 	orr	r3, r3, r2, lsl #8
34819080:	e3530002 	cmp	r3, #2
34819084:	8a000019 	bhi	348190f0 <s3c_udc_get_status+0xe0>
		g_status = dev->ep[ep_num].stopped;
34819088:	e205507f 	and	r5, r5, #127	; 0x7f
3481908c:	e0875305 	add	r5, r7, r5, lsl #6
34819090:	e5d5308c 	ldrb	r3, [r5, #140]	; 0x8c
	memcpy(p, &g_status, sizeof(g_status));
34819094:	e3a02002 	mov	r2, #2
34819098:	e59f1060 	ldr	r1, [pc, #96]	; 34819100 <s3c_udc_get_status+0xf0>
3481909c:	e1a00009 	mov	r0, r9
		g_status = dev->ep[ep_num].stopped;
348190a0:	e1c431b4 	strh	r3, [r4, #20]
	memcpy(p, &g_status, sizeof(g_status));
348190a4:	eb000ad4 	bl	3481bbfc <memcpy>
	flush_dcache_range((unsigned long) p,
348190a8:	e2891901 	add	r1, r9, #16384	; 0x4000
348190ac:	e1a00009 	mov	r0, r9
348190b0:	ebff9f39 	bl	34800d9c <flush_dcache_range>
	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
348190b4:	e5943004 	ldr	r3, [r4, #4]
348190b8:	e5932044 	ldr	r2, [r3, #68]	; 0x44
348190bc:	e5943000 	ldr	r3, [r4]
348190c0:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
348190c4:	e59f2038 	ldr	r2, [pc, #56]	; 34819104 <s3c_udc_get_status+0xf4>
348190c8:	e5943000 	ldr	r3, [r4]
348190cc:	e5832910 	str	r2, [r3, #2320]	; 0x910
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348190d0:	e5933900 	ldr	r3, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348190d4:	e3833321 	orr	r3, r3, #-2080374784	; 0x84000000
348190d8:	e5942000 	ldr	r2, [r4]
	return 0;
348190dc:	e3a00000 	mov	r0, #0
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348190e0:	e5823900 	str	r3, [r2, #2304]	; 0x900
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
348190e4:	e3a03008 	mov	r3, #8
348190e8:	e5873054 	str	r3, [r7, #84]	; 0x54
	return 0;
348190ec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			return 1;
348190f0:	e3a00001 	mov	r0, #1
}
348190f4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348190f8:	3482a8f0 	.word	0x3482a8f0
348190fc:	34826b86 	.word	0x34826b86
34819100:	3482a904 	.word	0x3482a904
34819104:	00080002 	.word	0x00080002

34819108 <s3c_udc_ep_set_stall>:
	ep_num = ep_index(ep);
34819108:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
3481910c:	e59f1038 	ldr	r1, [pc, #56]	; 3481914c <s3c_udc_ep_set_stall+0x44>
	if (ep_is_in(ep)) {
34819110:	e3120080 	tst	r2, #128	; 0x80
	ep_num = ep_index(ep);
34819114:	e202300f 	and	r3, r2, #15
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819118:	e5912000 	ldr	r2, [r1]
	if (ep_is_in(ep)) {
3481911c:	0a000004 	beq	34819134 <s3c_udc_ep_set_stall+0x2c>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819120:	e2833048 	add	r3, r3, #72	; 0x48
34819124:	e7922283 	ldr	r2, [r2, r3, lsl #5]
		if (ep_ctrl & DEPCTL_EPENA)
34819128:	e3520000 	cmp	r2, #0
			ep_ctrl |= DEPCTL_EPDIS;
3481912c:	b3822101 	orrlt	r2, r2, #1073741824	; 0x40000000
34819130:	ea000001 	b	3481913c <s3c_udc_ep_set_stall+0x34>
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819134:	e2833058 	add	r3, r3, #88	; 0x58
34819138:	e7922283 	ldr	r2, [r2, r3, lsl #5]
		ep_ctrl |= DEPCTL_STALL;
3481913c:	e3822602 	orr	r2, r2, #2097152	; 0x200000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819140:	e5911000 	ldr	r1, [r1]
34819144:	e7812283 	str	r2, [r1, r3, lsl #5]
34819148:	e12fff1e 	bx	lr
3481914c:	3482a8f0 	.word	0x3482a8f0

34819150 <s3c_udc_ep_clear_stall>:
	ep_num = ep_index(ep);
34819150:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
34819154:	e59f1034 	ldr	r1, [pc, #52]	; 34819190 <s3c_udc_ep_clear_stall+0x40>
34819158:	e202300f 	and	r3, r2, #15
	if (ep_is_in(ep)) {
3481915c:	e3120080 	tst	r2, #128	; 0x80
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819160:	e5912000 	ldr	r2, [r1]
34819164:	12833048 	addne	r3, r3, #72	; 0x48
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819168:	02833058 	addeq	r3, r3, #88	; 0x58
3481916c:	e7922283 	ldr	r2, [r2, r3, lsl #5]
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819170:	e5d00036 	ldrb	r0, [r0, #54]	; 0x36
		ep_ctrl &= ~DEPCTL_STALL;
34819174:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819178:	e2400002 	sub	r0, r0, #2
3481917c:	e3500001 	cmp	r0, #1
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819180:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819184:	e5911000 	ldr	r1, [r1]
34819188:	e7812283 	str	r2, [r1, r3, lsl #5]
3481918c:	e12fff1e 	bx	lr
34819190:	3482a8f0 	.word	0x3482a8f0

34819194 <s3c_udc_set_halt>:
	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819194:	e590201c 	ldr	r2, [r0, #28]
{
34819198:	e92d4010 	push	{r4, lr}
	ep_num = ep_index(ep);
3481919c:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
348191a0:	e3520000 	cmp	r2, #0
	ep_num = ep_index(ep);
348191a4:	e203c00f 	and	ip, r3, #15
	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
348191a8:	0a000004 	beq	348191c0 <s3c_udc_set_halt+0x2c>
348191ac:	e35c0000 	cmp	ip, #0
348191b0:	0a000002 	beq	348191c0 <s3c_udc_set_halt+0x2c>
348191b4:	e5d22003 	ldrb	r2, [r2, #3]
348191b8:	e3520001 	cmp	r2, #1
348191bc:	1a000001 	bne	348191c8 <s3c_udc_set_halt+0x34>
		return -EINVAL;
348191c0:	e3e00015 	mvn	r0, #21
348191c4:	e8bd8010 	pop	{r4, pc}
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
348191c8:	e3510000 	cmp	r1, #0
348191cc:	0a000007 	beq	348191f0 <s3c_udc_set_halt+0x5c>
348191d0:	e3130080 	tst	r3, #128	; 0x80
348191d4:	0a000003 	beq	348191e8 <s3c_udc_set_halt+0x54>
348191d8:	e5902020 	ldr	r2, [r0, #32]
348191dc:	e2803020 	add	r3, r0, #32
348191e0:	e1520003 	cmp	r2, r3
348191e4:	1a00000a 	bne	34819214 <s3c_udc_set_halt+0x80>
	if (value == 0) {
348191e8:	e3510000 	cmp	r1, #0
348191ec:	1a000003 	bne	34819200 <s3c_udc_set_halt+0x6c>
		ep->stopped = 0;
348191f0:	e3a04000 	mov	r4, #0
348191f4:	e5c04034 	strb	r4, [r0, #52]	; 0x34
		s3c_udc_ep_clear_stall(ep);
348191f8:	ebffffd4 	bl	34819150 <s3c_udc_ep_clear_stall>
348191fc:	ea000002 	b	3481920c <s3c_udc_set_halt+0x78>
		ep->stopped = 1;
34819200:	e3a03001 	mov	r3, #1
34819204:	e5c03034 	strb	r3, [r0, #52]	; 0x34
		s3c_udc_ep_set_stall(ep);
34819208:	ebffffbe 	bl	34819108 <s3c_udc_ep_set_stall>
	return 0;
3481920c:	e3a00000 	mov	r0, #0
34819210:	e8bd8010 	pop	{r4, pc}
		return -EAGAIN;
34819214:	e3e0000a 	mvn	r0, #10
34819218:	e8bd8010 	pop	{r4, pc}

3481921c <s3c_udc_ep_activate>:
	ep_num = ep_index(ep);
3481921c:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
34819220:	e59fc08c 	ldr	ip, [pc, #140]	; 348192b4 <s3c_udc_ep_activate+0x98>
{
34819224:	e92d4010 	push	{r4, lr}
	if (ep_is_in(ep)) {
34819228:	e3130080 	tst	r3, #128	; 0x80
	ep_num = ep_index(ep);
3481922c:	e203100f 	and	r1, r3, #15
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819230:	e59c3000 	ldr	r3, [ip]
	if (ep_is_in(ep)) {
34819234:	0a000003 	beq	34819248 <s3c_udc_ep_activate+0x2c>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819238:	e2812048 	add	r2, r1, #72	; 0x48
3481923c:	e7933282 	ldr	r3, [r3, r2, lsl #5]
		daintmsk = 1 << ep_num;
34819240:	e3a0e001 	mov	lr, #1
34819244:	ea000002 	b	34819254 <s3c_udc_ep_activate+0x38>
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819248:	e2812058 	add	r2, r1, #88	; 0x58
3481924c:	e7933282 	ldr	r3, [r3, r2, lsl #5]
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819250:	e3a0e801 	mov	lr, #65536	; 0x10000
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819254:	e3130902 	tst	r3, #32768	; 0x8000
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819258:	e1a0e11e 	lsl	lr, lr, r1
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
3481925c:	1a00000e 	bne	3481929c <s3c_udc_ep_activate+0x80>
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
34819260:	e3c32703 	bic	r2, r3, #786432	; 0xc0000
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
34819264:	e1d031b4 	ldrh	r3, [r0, #20]
34819268:	e3834306 	orr	r4, r3, #402653184	; 0x18000000
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
3481926c:	e5d03036 	ldrb	r3, [r0, #54]	; 0x36
34819270:	e3844902 	orr	r4, r4, #32768	; 0x8000
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
34819274:	e1822903 	orr	r2, r2, r3, lsl #18
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
34819278:	e3c23e7f 	bic	r3, r2, #2032	; 0x7f0
		if (ep_is_in(ep)) {
3481927c:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
34819280:	e3c3300f 	bic	r3, r3, #15
		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
34819284:	e1843003 	orr	r3, r4, r3
		if (ep_is_in(ep)) {
34819288:	e3520000 	cmp	r2, #0
			writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
3481928c:	e59c2000 	ldr	r2, [ip]
34819290:	b2811048 	addlt	r1, r1, #72	; 0x48
			writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819294:	a2811058 	addge	r1, r1, #88	; 0x58
34819298:	e7823281 	str	r3, [r2, r1, lsl #5]
	writel(readl(&reg->daintmsk)|daintmsk, &reg->daintmsk);
3481929c:	e59c3000 	ldr	r3, [ip]
348192a0:	e593381c 	ldr	r3, [r3, #2076]	; 0x81c
348192a4:	e18ee003 	orr	lr, lr, r3
348192a8:	e59c3000 	ldr	r3, [ip]
348192ac:	e583e81c 	str	lr, [r3, #2076]	; 0x81c
348192b0:	e8bd8010 	pop	{r4, pc}
348192b4:	3482a8f0 	.word	0x3482a8f0

348192b8 <s3c_ep_enable>:
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
348192b8:	e3510000 	cmp	r1, #0
348192bc:	13500000 	cmpne	r0, #0
348192c0:	0a000048 	beq	348193e8 <s3c_ep_enable+0x130>
348192c4:	e590301c 	ldr	r3, [r0, #28]
348192c8:	e3530000 	cmp	r3, #0
348192cc:	1a000045 	bne	348193e8 <s3c_ep_enable+0x130>
348192d0:	e5902004 	ldr	r2, [r0, #4]
348192d4:	e59f312c 	ldr	r3, [pc, #300]	; 34819408 <s3c_ep_enable+0x150>
348192d8:	e1520003 	cmp	r2, r3
348192dc:	0a000041 	beq	348193e8 <s3c_ep_enable+0x130>
	    || desc->bDescriptorType != USB_DT_ENDPOINT
348192e0:	e5d13001 	ldrb	r3, [r1, #1]
348192e4:	e3530005 	cmp	r3, #5
348192e8:	1a00003e 	bne	348193e8 <s3c_ep_enable+0x130>
{
348192ec:	e92d4070 	push	{r4, r5, r6, lr}
	    || ep->bEndpointAddress != desc->bEndpointAddress
348192f0:	e5d0e035 	ldrb	lr, [r0, #53]	; 0x35
348192f4:	e5d13002 	ldrb	r3, [r1, #2]
348192f8:	e153000e 	cmp	r3, lr
348192fc:	1a00003b 	bne	348193f0 <s3c_ep_enable+0x138>
	return p[0] | p[1] << 8;
34819300:	e5d12005 	ldrb	r2, [r1, #5]
34819304:	e5d13004 	ldrb	r3, [r1, #4]
	    || ep_maxpacket(ep) <
34819308:	e1d051b4 	ldrh	r5, [r0, #20]
3481930c:	e1832402 	orr	r2, r3, r2, lsl #8
34819310:	e6ffc072 	uxth	ip, r2
34819314:	e155000c 	cmp	r5, ip
34819318:	3a000034 	bcc	348193f0 <s3c_ep_enable+0x138>
	if (ep->bmAttributes != desc->bmAttributes
3481931c:	e5d03036 	ldrb	r3, [r0, #54]	; 0x36
34819320:	e5d14003 	ldrb	r4, [r1, #3]
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
34819324:	e1530004 	cmp	r3, r4
34819328:	13530002 	cmpne	r3, #2
3481932c:	13a03001 	movne	r3, #1
34819330:	03a03000 	moveq	r3, #0
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
34819334:	e3540003 	cmp	r4, #3
34819338:	03a03000 	moveq	r3, #0
3481933c:	12033001 	andne	r3, r3, #1
34819340:	e3530000 	cmp	r3, #0
34819344:	1a000029 	bne	348193f0 <s3c_ep_enable+0x138>
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
34819348:	e05cc005 	subs	ip, ip, r5
3481934c:	13a0c001 	movne	ip, #1
34819350:	e3540002 	cmp	r4, #2
34819354:	13a0c000 	movne	ip, #0
34819358:	e35c0000 	cmp	ip, #0
3481935c:	1a000025 	bne	348193f8 <s3c_ep_enable+0x140>
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {
34819360:	e3520000 	cmp	r2, #0
34819364:	0a000023 	beq	348193f8 <s3c_ep_enable+0x140>
	dev = ep->dev;
34819368:	e5903018 	ldr	r3, [r0, #24]
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
3481936c:	e5932024 	ldr	r2, [r3, #36]	; 0x24
34819370:	e3520000 	cmp	r2, #0
34819374:	0a000021 	beq	34819400 <s3c_ep_enable+0x148>
34819378:	e5933010 	ldr	r3, [r3, #16]
3481937c:	e3530000 	cmp	r3, #0
34819380:	0a00001e 	beq	34819400 <s3c_ep_enable+0x148>
	ep->stopped = 0;
34819384:	e3a03000 	mov	r3, #0
	ep->desc = desc;
34819388:	e580101c 	str	r1, [r0, #28]
	ep->stopped = 0;
3481938c:	e5c03034 	strb	r3, [r0, #52]	; 0x34
	if (ep_is_in(ep)) {
34819390:	e31e0080 	tst	lr, #128	; 0x80
	ep->pio_irqs = 0;
34819394:	e5803028 	str	r3, [r0, #40]	; 0x28
34819398:	e5d12005 	ldrb	r2, [r1, #5]
3481939c:	e5d13004 	ldrb	r3, [r1, #4]
348193a0:	e1833402 	orr	r3, r3, r2, lsl #8
348193a4:	e59f2060 	ldr	r2, [pc, #96]	; 3481940c <s3c_ep_enable+0x154>
	ep->ep.maxpacket = le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
348193a8:	e1c031b4 	strh	r3, [r0, #20]
	ep_num = ep_index(ep);
348193ac:	e20e300f 	and	r3, lr, #15
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
348193b0:	e5921000 	ldr	r1, [r2]
348193b4:	12833048 	addne	r3, r3, #72	; 0x48
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
348193b8:	02833058 	addeq	r3, r3, #88	; 0x58
348193bc:	e7911283 	ldr	r1, [r1, r3, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
348193c0:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
348193c4:	e5922000 	ldr	r2, [r2]
348193c8:	e1a04000 	mov	r4, r0
348193cc:	e7821283 	str	r1, [r2, r3, lsl #5]
	s3c_udc_set_halt(_ep, 0);
348193d0:	e3a01000 	mov	r1, #0
348193d4:	ebffff6e 	bl	34819194 <s3c_udc_set_halt>
	s3c_udc_ep_activate(ep);
348193d8:	e1a00004 	mov	r0, r4
348193dc:	ebffff8e 	bl	3481921c <s3c_udc_ep_activate>
	return 0;
348193e0:	e3a00000 	mov	r0, #0
348193e4:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -EINVAL;
348193e8:	e3e00015 	mvn	r0, #21
}
348193ec:	e12fff1e 	bx	lr
		return -EINVAL;
348193f0:	e3e00015 	mvn	r0, #21
348193f4:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -ERANGE;
348193f8:	e3e00021 	mvn	r0, #33	; 0x21
348193fc:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -ESHUTDOWN;
34819400:	e3e0006b 	mvn	r0, #107	; 0x6b
}
34819404:	e8bd8070 	pop	{r4, r5, r6, pc}
34819408:	348201f4 	.word	0x348201f4
3481940c:	3482a8f0 	.word	0x3482a8f0

34819410 <s3c_ep0_setup>:
{
34819410:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	struct s3c_ep *ep = &dev->ep[0];
34819414:	e2805058 	add	r5, r0, #88	; 0x58
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34819418:	e59f62a0 	ldr	r6, [pc, #672]	; 348196c0 <s3c_ep0_setup+0x2b0>
	nuke(ep, -EPROTO);
3481941c:	e3e01046 	mvn	r1, #70	; 0x46
{
34819420:	e1a04000 	mov	r4, r0
	nuke(ep, -EPROTO);
34819424:	e1a00005 	mov	r0, r5
34819428:	ebfffc6e 	bl	348185e8 <nuke>
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
3481942c:	e5961018 	ldr	r1, [r6, #24]
34819430:	e3a02008 	mov	r2, #8
34819434:	e1a00005 	mov	r0, r5
34819438:	ebfffeea 	bl	34818fe8 <s3c_fifo_read>
	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
3481943c:	e5961018 	ldr	r1, [r6, #24]
34819440:	e5d13001 	ldrb	r3, [r1, #1]
34819444:	e35300fe 	cmp	r3, #254	; 0xfe
34819448:	1a000005 	bne	34819464 <s3c_ep0_setup+0x54>
	    usb_ctrl->wLength != 1) {
3481944c:	e5d13006 	ldrb	r3, [r1, #6]
34819450:	e5d12007 	ldrb	r2, [r1, #7]
	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
34819454:	e1833402 	orr	r3, r3, r2, lsl #8
34819458:	e3530001 	cmp	r3, #1
3481945c:	0a000006 	beq	3481947c <s3c_ep0_setup+0x6c>
34819460:	ea00008c 	b	34819698 <s3c_ep0_setup+0x288>
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819464:	e35300ff 	cmp	r3, #255	; 0xff
34819468:	1a000003 	bne	3481947c <s3c_ep0_setup+0x6c>
		 usb_ctrl->wLength != 0) {
3481946c:	e5d13006 	ldrb	r3, [r1, #6]
34819470:	e5d12007 	ldrb	r2, [r1, #7]
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819474:	e1933402 	orrs	r3, r3, r2, lsl #8
34819478:	1a000086 	bne	34819698 <s3c_ep0_setup+0x288>
	if (likely(usb_ctrl->bRequestType & USB_DIR_IN)) {
3481947c:	e1d130d0 	ldrsb	r3, [r1]
34819480:	e3530000 	cmp	r3, #0
34819484:	e5d4308d 	ldrb	r3, [r4, #141]	; 0x8d
		ep->bEndpointAddress &= ~USB_DIR_IN;
34819488:	a203307f 	andge	r3, r3, #127	; 0x7f
		ep->bEndpointAddress |= USB_DIR_IN;
3481948c:	b1e03c83 	mvnlt	r3, r3, lsl #25
34819490:	b1e03ca3 	mvnlt	r3, r3, lsr #25
		ep->bEndpointAddress &= ~USB_DIR_IN;
34819494:	e5c4308d 	strb	r3, [r4, #141]	; 0x8d
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
34819498:	e5d13000 	ldrb	r3, [r1]
		== USB_TYPE_STANDARD;
3481949c:	e3130060 	tst	r3, #96	; 0x60
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348194a0:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
		== USB_TYPE_STANDARD;
348194a4:	03a02001 	moveq	r2, #1
348194a8:	13a02000 	movne	r2, #0
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348194ac:	e7c13092 	bfi	r3, r2, #1, #1
	dev->req_pending = 1;
348194b0:	e6ef3073 	uxtb	r3, r3
348194b4:	e3833001 	orr	r3, r3, #1
	if (dev->req_std) {
348194b8:	e3130002 	tst	r3, #2
	dev->req_pending = 1;
348194bc:	e5c43159 	strb	r3, [r4, #345]	; 0x159
	if (dev->req_std) {
348194c0:	0a00006b 	beq	34819674 <s3c_ep0_setup+0x264>
		switch (usb_ctrl->bRequest) {
348194c4:	e5d13001 	ldrb	r3, [r1, #1]
348194c8:	e353000b 	cmp	r3, #11
348194cc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
348194d0:	ea000067 	b	34819674 <s3c_ep0_setup+0x264>
348194d4:	3481955c 	.word	0x3481955c
348194d8:	34819570 	.word	0x34819570
348194dc:	34819674 	.word	0x34819674
348194e0:	348195fc 	.word	0x348195fc
348194e4:	34819674 	.word	0x34819674
348194e8:	34819504 	.word	0x34819504
348194ec:	34819674 	.word	0x34819674
348194f0:	34819674 	.word	0x34819674
348194f4:	34819674 	.word	0x34819674
348194f8:	34819538 	.word	0x34819538
348194fc:	34819674 	.word	0x34819674
34819500:	34819550 	.word	0x34819550
			if (usb_ctrl->bRequestType
34819504:	e5d13000 	ldrb	r3, [r1]
34819508:	e3530000 	cmp	r3, #0
3481950c:	1a000058 	bne	34819674 <s3c_ep0_setup+0x264>
	u32 ctrl = readl(&reg->dcfg);
34819510:	e5963000 	ldr	r3, [r6]
			udc_set_address(dev, usb_ctrl->wValue);
34819514:	e5d15002 	ldrb	r5, [r1, #2]
	u32 ctrl = readl(&reg->dcfg);
34819518:	e5933800 	ldr	r3, [r3, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
3481951c:	e1833205 	orr	r3, r3, r5, lsl #4
34819520:	e5962000 	ldr	r2, [r6]
	s3c_udc_ep0_zlp(dev);
34819524:	e2840054 	add	r0, r4, #84	; 0x54
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34819528:	e5823800 	str	r3, [r2, #2048]	; 0x800
	s3c_udc_ep0_zlp(dev);
3481952c:	ebfffce6 	bl	348188cc <s3c_udc_ep0_zlp.isra.2>
	dev->usb_address = address;
34819530:	e5c45158 	strb	r5, [r4, #344]	; 0x158
34819534:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			if (usb_ctrl->bRequestType == USB_RECIP_DEVICE)
34819538:	e5d13000 	ldrb	r3, [r1]
3481953c:	e3530000 	cmp	r3, #0
				reset_available = 1;
34819540:	059f317c 	ldreq	r3, [pc, #380]	; 348196c4 <s3c_ep0_setup+0x2b4>
34819544:	03a02001 	moveq	r2, #1
34819548:	0583200c 	streq	r2, [r3, #12]
3481954c:	ea000048 	b	34819674 <s3c_ep0_setup+0x264>
			if (usb_ctrl->bRequestType == USB_RECIP_INTERFACE)
34819550:	e5d13000 	ldrb	r3, [r1]
34819554:	e3530001 	cmp	r3, #1
34819558:	eafffff8 	b	34819540 <s3c_ep0_setup+0x130>
			if (!s3c_udc_get_status(dev, usb_ctrl))
3481955c:	e1a00004 	mov	r0, r4
34819560:	ebfffeaa 	bl	34819010 <s3c_udc_get_status>
34819564:	e3500000 	cmp	r0, #0
34819568:	1a000041 	bne	34819674 <s3c_ep0_setup+0x264>
3481956c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			ep_num = usb_ctrl->wIndex & 0x7f;
34819570:	e5d15004 	ldrb	r5, [r1, #4]
	if (usb_ctrl->wLength != 0) {
34819574:	e5d12006 	ldrb	r2, [r1, #6]
34819578:	e5d1c007 	ldrb	ip, [r1, #7]
			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
3481957c:	e205507f 	and	r5, r5, #127	; 0x7f
34819580:	e0845305 	add	r5, r4, r5, lsl #6
	if (usb_ctrl->wLength != 0) {
34819584:	e192240c 	orrs	r2, r2, ip, lsl #8
			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
34819588:	e2855058 	add	r5, r5, #88	; 0x58
	ep_num = ep_index(ep);
3481958c:	e5d53035 	ldrb	r3, [r5, #53]	; 0x35
	dev = ep->dev;
34819590:	e5950018 	ldr	r0, [r5, #24]
	if (usb_ctrl->wLength != 0) {
34819594:	1a000036 	bne	34819674 <s3c_ep0_setup+0x264>
	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819598:	e5d12000 	ldrb	r2, [r1]
3481959c:	e212201f 	ands	r2, r2, #31
348195a0:	0a000002 	beq	348195b0 <s3c_ep0_setup+0x1a0>
348195a4:	e3520002 	cmp	r2, #2
348195a8:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
348195ac:	ea000001 	b	348195b8 <s3c_ep0_setup+0x1a8>
		s3c_udc_ep0_zlp(dev);
348195b0:	e2800054 	add	r0, r0, #84	; 0x54
348195b4:	ea00002c 	b	3481966c <s3c_ep0_setup+0x25c>
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
348195b8:	e5d12002 	ldrb	r2, [r1, #2]
348195bc:	e5d17003 	ldrb	r7, [r1, #3]
348195c0:	e1927407 	orrs	r7, r2, r7, lsl #8
348195c4:	18bd82f0 	popne	{r4, r5, r6, r7, r9, pc}
			if (ep_num == 0) {
348195c8:	e213400f 	ands	r4, r3, #15
348195cc:	0a000020 	beq	34819654 <s3c_ep0_setup+0x244>
			s3c_udc_ep0_zlp(dev);
348195d0:	e2800054 	add	r0, r0, #84	; 0x54
348195d4:	ebfffcbc 	bl	348188cc <s3c_udc_ep0_zlp.isra.2>
			s3c_udc_ep_clear_stall(ep);
348195d8:	e1a00005 	mov	r0, r5
348195dc:	ebfffedb 	bl	34819150 <s3c_udc_ep_clear_stall>
			s3c_udc_ep_activate(ep);
348195e0:	e1a00005 	mov	r0, r5
348195e4:	ebffff0c 	bl	3481921c <s3c_udc_ep_activate>
			clear_feature_flag = 1;
348195e8:	e3a03001 	mov	r3, #1
			ep->stopped = 0;
348195ec:	e5c57034 	strb	r7, [r5, #52]	; 0x34
			clear_feature_num = ep_num;
348195f0:	e5c6401c 	strb	r4, [r6, #28]
			clear_feature_flag = 1;
348195f4:	e5863020 	str	r3, [r6, #32]
348195f8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
			ep_num = usb_ctrl->wIndex & 0x7f;
348195fc:	e5d10004 	ldrb	r0, [r1, #4]
	if (usb_ctrl->wLength != 0) {
34819600:	e5d13006 	ldrb	r3, [r1, #6]
34819604:	e5d1c007 	ldrb	ip, [r1, #7]
			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819608:	e200007f 	and	r0, r0, #127	; 0x7f
3481960c:	e0840300 	add	r0, r4, r0, lsl #6
	if (usb_ctrl->wLength != 0) {
34819610:	e193340c 	orrs	r3, r3, ip, lsl #8
			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819614:	e2800058 	add	r0, r0, #88	; 0x58
	ep_num = ep_index(ep);
34819618:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	dev = ep->dev;
3481961c:	e5905018 	ldr	r5, [r0, #24]
	if (usb_ctrl->wLength != 0) {
34819620:	1a000013 	bne	34819674 <s3c_ep0_setup+0x264>
	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819624:	e5d13000 	ldrb	r3, [r1]
34819628:	e213301f 	ands	r3, r3, #31
3481962c:	0a00000d 	beq	34819668 <s3c_ep0_setup+0x258>
34819630:	e3530002 	cmp	r3, #2
34819634:	1a00000e 	bne	34819674 <s3c_ep0_setup+0x264>
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
34819638:	e5d13002 	ldrb	r3, [r1, #2]
3481963c:	e5d11003 	ldrb	r1, [r1, #3]
34819640:	e1933401 	orrs	r3, r3, r1, lsl #8
34819644:	1a000007 	bne	34819668 <s3c_ep0_setup+0x258>
			if (ep_num == 0) {
34819648:	e312000f 	tst	r2, #15
3481964c:	1a000002 	bne	3481965c <s3c_ep0_setup+0x24c>
				s3c_udc_ep0_set_stall(ep);
34819650:	e1a00005 	mov	r0, r5
}
34819654:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
				s3c_udc_ep0_set_stall(ep);
34819658:	eafffd72 	b	34818c28 <s3c_udc_ep0_set_stall.isra.3>
			ep->stopped = 1;
3481965c:	e3a03001 	mov	r3, #1
34819660:	e5c03034 	strb	r3, [r0, #52]	; 0x34
			s3c_udc_ep_set_stall(ep);
34819664:	ebfffea7 	bl	34819108 <s3c_udc_ep_set_stall>
		s3c_udc_ep0_zlp(dev);
34819668:	e2850054 	add	r0, r5, #84	; 0x54
}
3481966c:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
		s3c_udc_ep0_zlp(dev);
34819670:	eafffc95 	b	348188cc <s3c_udc_ep0_zlp.isra.2>
	if (likely(dev->driver)) {
34819674:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819678:	e3530000 	cmp	r3, #0
3481967c:	08bd82f0 	popeq	{r4, r5, r6, r7, r9, pc}
		i = dev->driver->setup(&dev->gadget, usb_ctrl);
34819680:	e593300c 	ldr	r3, [r3, #12]
34819684:	e1a00004 	mov	r0, r4
34819688:	e5961018 	ldr	r1, [r6, #24]
3481968c:	e12fff33 	blx	r3
		if (i < 0) {
34819690:	e3500000 	cmp	r0, #0
34819694:	aa000004 	bge	348196ac <s3c_ep0_setup+0x29c>
			s3c_udc_ep0_set_stall(ep);
34819698:	e5940070 	ldr	r0, [r4, #112]	; 0x70
3481969c:	ebfffd61 	bl	34818c28 <s3c_udc_ep0_set_stall.isra.3>
			dev->ep0state = WAIT_FOR_SETUP;
348196a0:	e3a03000 	mov	r3, #0
348196a4:	e5843054 	str	r3, [r4, #84]	; 0x54
348196a8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		} else if (dev->req_pending) {
348196ac:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
348196b0:	e3130001 	tst	r3, #1
			dev->req_pending = 0;
348196b4:	17c0301f 	bfcne	r3, #0, #1
348196b8:	15c43159 	strbne	r3, [r4, #345]	; 0x159
348196bc:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348196c0:	3482a8f0 	.word	0x3482a8f0
348196c4:	34827fe4 	.word	0x34827fe4

348196c8 <usb_gadget_register_driver>:
	struct s3c_udc *dev = the_controller;
348196c8:	e59f309c 	ldr	r3, [pc, #156]	; 3481976c <usb_gadget_register_driver+0xa4>
	if (!driver
348196cc:	e3500000 	cmp	r0, #0
{
348196d0:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_udc *dev = the_controller;
348196d4:	e5935004 	ldr	r5, [r3, #4]
	if (!driver
348196d8:	0a00001d 	beq	34819754 <usb_gadget_register_driver+0x8c>
		&& driver->speed != USB_SPEED_HIGH)
348196dc:	e5903000 	ldr	r3, [r0]
348196e0:	e2433002 	sub	r3, r3, #2
	    || (driver->speed != USB_SPEED_FULL
348196e4:	e3530001 	cmp	r3, #1
348196e8:	8a000019 	bhi	34819754 <usb_gadget_register_driver+0x8c>
	    || !driver->bind || !driver->disconnect || !driver->setup)
348196ec:	e5903004 	ldr	r3, [r0, #4]
348196f0:	e3530000 	cmp	r3, #0
348196f4:	0a000016 	beq	34819754 <usb_gadget_register_driver+0x8c>
348196f8:	e5902010 	ldr	r2, [r0, #16]
348196fc:	e3520000 	cmp	r2, #0
34819700:	0a000013 	beq	34819754 <usb_gadget_register_driver+0x8c>
34819704:	e590200c 	ldr	r2, [r0, #12]
34819708:	e3520000 	cmp	r2, #0
3481970c:	0a000010 	beq	34819754 <usb_gadget_register_driver+0x8c>
	if (!dev)
34819710:	e3550000 	cmp	r5, #0
34819714:	0a000010 	beq	3481975c <usb_gadget_register_driver+0x94>
	if (dev->driver)
34819718:	e5956024 	ldr	r6, [r5, #36]	; 0x24
3481971c:	e3560000 	cmp	r6, #0
34819720:	1a00000f 	bne	34819764 <usb_gadget_register_driver+0x9c>
	dev->driver = driver;
34819724:	e5850024 	str	r0, [r5, #36]	; 0x24
	retval = driver->bind(&dev->gadget);
34819728:	e1a00005 	mov	r0, r5
3481972c:	e12fff33 	blx	r3
	if (retval) {
34819730:	e2504000 	subs	r4, r0, #0
		dev->driver = 0;
34819734:	15856024 	strne	r6, [r5, #36]	; 0x24
	if (retval) {
34819738:	1a000003 	bne	3481974c <usb_gadget_register_driver+0x84>
	otg_phy_init(dev);
3481973c:	e1a00005 	mov	r0, r5
34819740:	ebfffcd2 	bl	34818a90 <otg_phy_init>
	reconfig_usbd();
34819744:	ebfffbde 	bl	348186c4 <reconfig_usbd>
	dev->gadget.speed = USB_SPEED_UNKNOWN;
34819748:	e5854010 	str	r4, [r5, #16]
	return 0;
3481974c:	e1a00004 	mov	r0, r4
34819750:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -EINVAL;
34819754:	e3e00015 	mvn	r0, #21
34819758:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -ENODEV;
3481975c:	e3e00012 	mvn	r0, #18
34819760:	e8bd8070 	pop	{r4, r5, r6, pc}
		return -EBUSY;
34819764:	e3e0000f 	mvn	r0, #15
}
34819768:	e8bd8070 	pop	{r4, r5, r6, pc}
3481976c:	3482a8f0 	.word	0x3482a8f0

34819770 <usb_gadget_unregister_driver>:
{
34819770:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_udc *dev = the_controller;
34819774:	e59f70d4 	ldr	r7, [pc, #212]	; 34819850 <usb_gadget_unregister_driver+0xe0>
34819778:	e5974004 	ldr	r4, [r7, #4]
	if (!dev)
3481977c:	e3540000 	cmp	r4, #0
34819780:	0a00002e 	beq	34819840 <usb_gadget_unregister_driver+0xd0>
	if (!driver || driver != dev->driver)
34819784:	e3500000 	cmp	r0, #0
34819788:	0a00002e 	beq	34819848 <usb_gadget_unregister_driver+0xd8>
3481978c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819790:	e1500003 	cmp	r0, r3
34819794:	1a00002b 	bne	34819848 <usb_gadget_unregister_driver+0xd8>
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
34819798:	e5942010 	ldr	r2, [r4, #16]
	dev->driver = 0;
3481979c:	e3a03000 	mov	r3, #0
348197a0:	e1a06000 	mov	r6, r0
348197a4:	e2845058 	add	r5, r4, #88	; 0x58
348197a8:	e284af56 	add	sl, r4, #344	; 0x158
		ep->stopped = 1;
348197ac:	e3a0b001 	mov	fp, #1
		driver = 0;
348197b0:	e1520003 	cmp	r2, r3
	dev->driver = 0;
348197b4:	e5843024 	str	r3, [r4, #36]	; 0x24
		driver = 0;
348197b8:	11a09000 	movne	r9, r0
348197bc:	01a09003 	moveq	r9, r3
	dev->gadget.speed = USB_SPEED_UNKNOWN;
348197c0:	e5843010 	str	r3, [r4, #16]
		ep->stopped = 1;
348197c4:	e5c5b034 	strb	fp, [r5, #52]	; 0x34
		nuke(ep, -ESHUTDOWN);
348197c8:	e1a00005 	mov	r0, r5
348197cc:	e3e0106b 	mvn	r1, #107	; 0x6b
348197d0:	e2855040 	add	r5, r5, #64	; 0x40
348197d4:	ebfffb83 	bl	348185e8 <nuke>
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348197d8:	e155000a 	cmp	r5, sl
348197dc:	1afffff8 	bne	348197c4 <usb_gadget_unregister_driver+0x54>
	if (driver) {
348197e0:	e3590000 	cmp	r9, #0
348197e4:	0a000002 	beq	348197f4 <usb_gadget_unregister_driver+0x84>
		driver->disconnect(&dev->gadget);
348197e8:	e5993010 	ldr	r3, [r9, #16]
348197ec:	e1a00004 	mov	r0, r4
348197f0:	e12fff33 	blx	r3
	udc_reinit(dev);
348197f4:	e1a00004 	mov	r0, r4
348197f8:	ebfffae6 	bl	34818398 <udc_reinit>
	driver->unbind(&dev->gadget);
348197fc:	e5963008 	ldr	r3, [r6, #8]
34819800:	e1a00004 	mov	r0, r4
34819804:	e12fff33 	blx	r3
	u32 ctrl = readl(&reg->dcfg);
34819808:	e5973000 	ldr	r3, [r7]
3481980c:	e5932800 	ldr	r2, [r3, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34819810:	e5973000 	ldr	r3, [r7]
	dev->usb_address = address;
34819814:	e3a05000 	mov	r5, #0
	s3c_udc_ep0_zlp(dev);
34819818:	e2840054 	add	r0, r4, #84	; 0x54
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
3481981c:	e5832800 	str	r2, [r3, #2048]	; 0x800
	s3c_udc_ep0_zlp(dev);
34819820:	ebfffc29 	bl	348188cc <s3c_udc_ep0_zlp.isra.2>
	otg_phy_off(dev);
34819824:	e1a00004 	mov	r0, r4
	dev->usb_address = address;
34819828:	e5c45158 	strb	r5, [r4, #344]	; 0x158
	dev->ep0state = WAIT_FOR_SETUP;
3481982c:	e5845054 	str	r5, [r4, #84]	; 0x54
	dev->gadget.speed = USB_SPEED_UNKNOWN;
34819830:	e5845010 	str	r5, [r4, #16]
	otg_phy_off(dev);
34819834:	ebfffcc3 	bl	34818b48 <otg_phy_off>
	return 0;
34819838:	e1a00005 	mov	r0, r5
3481983c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -ENODEV;
34819840:	e3e00012 	mvn	r0, #18
34819844:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -EINVAL;
34819848:	e3e00015 	mvn	r0, #21
}
3481984c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34819850:	3482a8f0 	.word	0x3482a8f0

34819854 <s3c_udc_probe>:

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
34819854:	e59f2090 	ldr	r2, [pc, #144]	; 348198ec <s3c_udc_probe+0x98>
34819858:	e5901004 	ldr	r1, [r0, #4]
{
3481985c:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	dev->pdata = pdata;
34819860:	e59f3088 	ldr	r3, [pc, #136]	; 348198f0 <s3c_udc_probe+0x9c>
34819864:	e1a05002 	mov	r5, r2
	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
34819868:	e5821010 	str	r1, [r2, #16]
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
3481986c:	e5901008 	ldr	r1, [r0, #8]
34819870:	e2836038 	add	r6, r3, #56	; 0x38
34819874:	e283704c 	add	r7, r3, #76	; 0x4c
34819878:	e1a04003 	mov	r4, r3
	dev->pdata = pdata;
3481987c:	e5830038 	str	r0, [r3, #56]	; 0x38
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
34819880:	e5821000 	str	r1, [r2]
	usb_phy_ctrl = pdata->usb_phy_ctrl;
34819884:	e590100c 	ldr	r1, [r0, #12]
34819888:	e582100c 	str	r1, [r2, #12]

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
3481988c:	e5d31024 	ldrb	r1, [r3, #36]	; 0x24
	dev->gadget.is_otg = 0;
34819890:	e3811001 	orr	r1, r1, #1
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;
34819894:	e20110e1 	and	r1, r1, #225	; 0xe1
34819898:	e7c5129f 	bfc	r1, #5, #1
3481989c:	e5c31024 	strb	r1, [r3, #36]	; 0x24

	the_controller = dev;
348198a0:	e2831010 	add	r1, r3, #16
348198a4:	e5821004 	str	r1, [r2, #4]

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
348198a8:	e3a01901 	mov	r1, #16384	; 0x4000
348198ac:	e3a00040 	mov	r0, #64	; 0x40
348198b0:	ebffc461 	bl	3480aa3c <memalign>
348198b4:	e5a60004 	str	r0, [r6, #4]!
					   DMA_BUFFER_SIZE);
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
348198b8:	e2801901 	add	r1, r0, #16384	; 0x4000
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
348198bc:	e5860014 	str	r0, [r6, #20]
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
348198c0:	ebff9d47 	bl	34800de4 <invalidate_dcache_range>
	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
348198c4:	e1560007 	cmp	r6, r7
348198c8:	1afffff6 	bne	348198a8 <s3c_udc_probe+0x54>
					(unsigned long) (dev->dma_buf[i]
							 + DMA_BUFFER_SIZE));
	}
	usb_ctrl = dev->dma_buf[0];
348198cc:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
	usb_ctrl_dma_addr = dev->dma_addr[0];

	udc_reinit(dev);
348198d0:	e59f001c 	ldr	r0, [pc, #28]	; 348198f4 <s3c_udc_probe+0xa0>
	usb_ctrl = dev->dma_buf[0];
348198d4:	e5853018 	str	r3, [r5, #24]
	usb_ctrl_dma_addr = dev->dma_addr[0];
348198d8:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348198dc:	e5853008 	str	r3, [r5, #8]
	udc_reinit(dev);
348198e0:	ebfffaac 	bl	34818398 <udc_reinit>

	return retval;
}
348198e4:	e3a00000 	mov	r0, #0
348198e8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
348198ec:	3482a8f0 	.word	0x3482a8f0
348198f0:	34827fe4 	.word	0x34827fe4
348198f4:	34827ff4 	.word	0x34827ff4

348198f8 <usb_gadget_handle_interrupts>:

int usb_gadget_handle_interrupts()
{
348198f8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	u32 intr_status = readl(&reg->gintsts);
348198fc:	e59f5440 	ldr	r5, [pc, #1088]	; 34819d44 <usb_gadget_handle_interrupts+0x44c>
34819900:	e5953000 	ldr	r3, [r5]
34819904:	e5930014 	ldr	r0, [r3, #20]
	u32 gintmsk = readl(&reg->gintmsk);
34819908:	e5953000 	ldr	r3, [r5]
3481990c:	e5933018 	ldr	r3, [r3, #24]

	if (intr_status & gintmsk)
34819910:	e0130000 	ands	r0, r3, r0
34819914:	0a000108 	beq	34819d3c <usb_gadget_handle_interrupts+0x444>
	intr_status = readl(&reg->gintsts);
34819918:	e8950018 	ldm	r5, {r3, r4}
3481991c:	e5937014 	ldr	r7, [r3, #20]
	gintmsk = readl(&reg->gintmsk);
34819920:	e5953000 	ldr	r3, [r5]
34819924:	e5933018 	ldr	r3, [r3, #24]
	if (!intr_status) {
34819928:	e3570000 	cmp	r7, #0
3481992c:	1a000001 	bne	34819938 <usb_gadget_handle_interrupts+0x40>
		return s3c_udc_irq(1, (void *)the_controller);
34819930:	e3a00001 	mov	r0, #1
34819934:	ea000100 	b	34819d3c <usb_gadget_handle_interrupts+0x444>
	if (intr_status & INT_ENUMDONE) {
34819938:	e3170a02 	tst	r7, #8192	; 0x2000
3481993c:	0a000008 	beq	34819964 <usb_gadget_handle_interrupts+0x6c>
		writel(INT_ENUMDONE, &reg->gintsts);
34819940:	e5953000 	ldr	r3, [r5]
34819944:	e3a02a02 	mov	r2, #8192	; 0x2000
34819948:	e5832014 	str	r2, [r3, #20]
		usb_status = (readl(&reg->dsts) & 0x6);
3481994c:	e5933808 	ldr	r3, [r3, #2056]	; 0x808
		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
34819950:	e3130006 	tst	r3, #6
			set_max_pktsize(dev, USB_SPEED_HIGH);
34819954:	e1a00004 	mov	r0, r4
			set_max_pktsize(dev, USB_SPEED_FULL);
34819958:	13a01002 	movne	r1, #2
			set_max_pktsize(dev, USB_SPEED_HIGH);
3481995c:	03a01003 	moveq	r1, #3
34819960:	ebfffaa8 	bl	34818408 <set_max_pktsize>
	if (intr_status & INT_EARLY_SUSPEND) {
34819964:	e3170b01 	tst	r7, #1024	; 0x400
34819968:	0a000002 	beq	34819978 <usb_gadget_handle_interrupts+0x80>
		writel(INT_EARLY_SUSPEND, &reg->gintsts);
3481996c:	e5953000 	ldr	r3, [r5]
34819970:	e3a02b01 	mov	r2, #1024	; 0x400
34819974:	e5832014 	str	r2, [r3, #20]
	if (intr_status & INT_SUSPEND) {
34819978:	e3170b02 	tst	r7, #2048	; 0x800
3481997c:	0a000015 	beq	348199d8 <usb_gadget_handle_interrupts+0xe0>
		usb_status = readl(&reg->dsts);
34819980:	e5953000 	ldr	r3, [r5]
34819984:	e5933808 	ldr	r3, [r3, #2056]	; 0x808
		writel(INT_SUSPEND, &reg->gintsts);
34819988:	e5953000 	ldr	r3, [r5]
3481998c:	e3a02b02 	mov	r2, #2048	; 0x800
34819990:	e5832014 	str	r2, [r3, #20]
		if (dev->gadget.speed != USB_SPEED_UNKNOWN
34819994:	e5943010 	ldr	r3, [r4, #16]
34819998:	e3530000 	cmp	r3, #0
3481999c:	0a00000d 	beq	348199d8 <usb_gadget_handle_interrupts+0xe0>
		    && dev->driver) {
348199a0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
348199a4:	e3530000 	cmp	r3, #0
348199a8:	0a00000a 	beq	348199d8 <usb_gadget_handle_interrupts+0xe0>
			if (dev->driver->suspend)
348199ac:	e5933014 	ldr	r3, [r3, #20]
348199b0:	e3530000 	cmp	r3, #0
348199b4:	0a000001 	beq	348199c0 <usb_gadget_handle_interrupts+0xc8>
				dev->driver->suspend(&dev->gadget);
348199b8:	e1a00004 	mov	r0, r4
348199bc:	e12fff33 	blx	r3
			if (dev->driver->disconnect) {
348199c0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
348199c4:	e5933010 	ldr	r3, [r3, #16]
348199c8:	e3530000 	cmp	r3, #0
348199cc:	0a000001 	beq	348199d8 <usb_gadget_handle_interrupts+0xe0>
				dev->driver->disconnect(&dev->gadget);
348199d0:	e1a00004 	mov	r0, r4
348199d4:	e12fff33 	blx	r3
	if (intr_status & INT_RESUME) {
348199d8:	e3570000 	cmp	r7, #0
348199dc:	aa00000d 	bge	34819a18 <usb_gadget_handle_interrupts+0x120>
		writel(INT_RESUME, &reg->gintsts);
348199e0:	e5953000 	ldr	r3, [r5]
348199e4:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
348199e8:	e5832014 	str	r2, [r3, #20]
		if (dev->gadget.speed != USB_SPEED_UNKNOWN
348199ec:	e5943010 	ldr	r3, [r4, #16]
348199f0:	e3530000 	cmp	r3, #0
348199f4:	0a000007 	beq	34819a18 <usb_gadget_handle_interrupts+0x120>
		    && dev->driver
348199f8:	e5943024 	ldr	r3, [r4, #36]	; 0x24
348199fc:	e3530000 	cmp	r3, #0
34819a00:	0a000004 	beq	34819a18 <usb_gadget_handle_interrupts+0x120>
		    && dev->driver->resume) {
34819a04:	e5933018 	ldr	r3, [r3, #24]
34819a08:	e3530000 	cmp	r3, #0
34819a0c:	0a000001 	beq	34819a18 <usb_gadget_handle_interrupts+0x120>
			dev->driver->resume(&dev->gadget);
34819a10:	e1a00004 	mov	r0, r4
34819a14:	e12fff33 	blx	r3
	if (intr_status & INT_RESET) {
34819a18:	e3170a01 	tst	r7, #4096	; 0x1000
34819a1c:	0a000013 	beq	34819a70 <usb_gadget_handle_interrupts+0x178>
		usb_status = readl(&reg->gotgctl);
34819a20:	e5953000 	ldr	r3, [r5]
34819a24:	e5933000 	ldr	r3, [r3]
		writel(INT_RESET, &reg->gintsts);
34819a28:	e5952000 	ldr	r2, [r5]
		if ((usb_status & 0xc0000) == (0x3 << 18)) {
34819a2c:	e2033703 	and	r3, r3, #786432	; 0xc0000
34819a30:	e3530703 	cmp	r3, #786432	; 0xc0000
		writel(INT_RESET, &reg->gintsts);
34819a34:	e3a01a01 	mov	r1, #4096	; 0x1000
34819a38:	e59f6308 	ldr	r6, [pc, #776]	; 34819d48 <usb_gadget_handle_interrupts+0x450>
34819a3c:	e5821014 	str	r1, [r2, #20]
		if ((usb_status & 0xc0000) == (0x3 << 18)) {
34819a40:	1a000008 	bne	34819a68 <usb_gadget_handle_interrupts+0x170>
			if (reset_available) {
34819a44:	e596300c 	ldr	r3, [r6, #12]
34819a48:	e3530000 	cmp	r3, #0
34819a4c:	0a000005 	beq	34819a68 <usb_gadget_handle_interrupts+0x170>
				reconfig_usbd();
34819a50:	ebfffb1b 	bl	348186c4 <reconfig_usbd>
				dev->ep0state = WAIT_FOR_SETUP;
34819a54:	e3a03000 	mov	r3, #0
34819a58:	e5843054 	str	r3, [r4, #84]	; 0x54
				reset_available = 0;
34819a5c:	e586300c 	str	r3, [r6, #12]
				s3c_udc_pre_setup();
34819a60:	ebfffc5e 	bl	34818be0 <s3c_udc_pre_setup>
34819a64:	ea000001 	b	34819a70 <usb_gadget_handle_interrupts+0x178>
				reset_available = 1;
34819a68:	e3a03001 	mov	r3, #1
34819a6c:	e586300c 	str	r3, [r6, #12]
	if (intr_status & INT_IN_EP)
34819a70:	e3170701 	tst	r7, #262144	; 0x40000
34819a74:	1a000007 	bne	34819a98 <usb_gadget_handle_interrupts+0x1a0>
	if (intr_status & INT_OUT_EP)
34819a78:	e3170702 	tst	r7, #524288	; 0x80000
34819a7c:	0affffab 	beq	34819930 <usb_gadget_handle_interrupts+0x38>
	ep_intr = readl(&reg->daint);
34819a80:	e59f32bc 	ldr	r3, [pc, #700]	; 34819d44 <usb_gadget_handle_interrupts+0x44c>
34819a84:	e5933000 	ldr	r3, [r3]
34819a88:	e5936818 	ldr	r6, [r3, #2072]	; 0x818
	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
34819a8c:	e3a07000 	mov	r7, #0
34819a90:	e1a06826 	lsr	r6, r6, #16
34819a94:	ea000083 	b	34819ca8 <usb_gadget_handle_interrupts+0x3b0>
	ep_intr = readl(&reg->daint);
34819a98:	e5953000 	ldr	r3, [r5]
34819a9c:	e5939818 	ldr	r9, [r3, #2072]	; 0x818
	ep_intr &= DAINT_MASK;
34819aa0:	e6ff9079 	uxth	r9, r9
34819aa4:	e3a0a000 	mov	sl, #0
	while (ep_intr) {
34819aa8:	e3590000 	cmp	r9, #0
34819aac:	e6ef607a 	uxtb	r6, sl
34819ab0:	0afffff0 	beq	34819a78 <usb_gadget_handle_interrupts+0x180>
		if (ep_intr & DAINT_IN_EP_INT(1)) {
34819ab4:	e3190001 	tst	r9, #1
34819ab8:	0a000073 	beq	34819c8c <usb_gadget_handle_interrupts+0x394>
			ep_intr_status = readl(&reg->in_endp[ep_num].diepint);
34819abc:	e5953000 	ldr	r3, [r5]
34819ac0:	e1a02286 	lsl	r2, r6, #5
34819ac4:	e0833002 	add	r3, r3, r2
34819ac8:	e5933908 	ldr	r3, [r3, #2312]	; 0x908
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34819acc:	e5950000 	ldr	r0, [r5]
			if (ep_intr_status & TRANSFER_DONE) {
34819ad0:	e3130001 	tst	r3, #1
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34819ad4:	e0800002 	add	r0, r0, r2
34819ad8:	e5803908 	str	r3, [r0, #2312]	; 0x908
			if (ep_intr_status & TRANSFER_DONE) {
34819adc:	0a00006a 	beq	34819c8c <usb_gadget_handle_interrupts+0x394>
	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
34819ae0:	e5941054 	ldr	r1, [r4, #84]	; 0x54
	struct s3c_ep *ep = &dev->ep[ep_num];
34819ae4:	e1a02306 	lsl	r2, r6, #6
34819ae8:	e2823058 	add	r3, r2, #88	; 0x58
	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
34819aec:	e3510008 	cmp	r1, #8
	struct s3c_ep *ep = &dev->ep[ep_num];
34819af0:	e0843003 	add	r3, r4, r3
	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
34819af4:	1a000003 	bne	34819b08 <usb_gadget_handle_interrupts+0x210>
		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34819af8:	e3a03006 	mov	r3, #6
34819afc:	e5843054 	str	r3, [r4, #84]	; 0x54
		s3c_ep0_complete_out();
34819b00:	ebfffa92 	bl	34818550 <s3c_ep0_complete_out>
34819b04:	ea00003d 	b	34819c00 <usb_gadget_handle_interrupts+0x308>
	if (list_empty(&ep->queue)) {
34819b08:	e2821078 	add	r1, r2, #120	; 0x78
	return head->next == head;
34819b0c:	e0842002 	add	r2, r4, r2
34819b10:	e5922078 	ldr	r2, [r2, #120]	; 0x78
34819b14:	e0841001 	add	r1, r4, r1
34819b18:	e58d1000 	str	r1, [sp]
34819b1c:	e1520001 	cmp	r2, r1
34819b20:	0a000036 	beq	34819c00 <usb_gadget_handle_interrupts+0x308>
	req = list_entry(ep->queue.next, struct s3c_request, queue);
34819b24:	e2421028 	sub	r1, r2, #40	; 0x28
	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);
34819b28:	e5900910 	ldr	r0, [r0, #2320]	; 0x910
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819b2c:	e512c004 	ldr	ip, [r2, #-4]
34819b30:	e5120024 	ldr	r0, [r2, #-36]	; 0xffffffdc
34819b34:	e512b004 	ldr	fp, [r2, #-4]
34819b38:	e06ce000 	rsb	lr, ip, r0
	xfer_size = ep->len;
34819b3c:	e084c306 	add	ip, r4, r6, lsl #6
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819b40:	e59cc084 	ldr	ip, [ip, #132]	; 0x84
34819b44:	e15e000c 	cmp	lr, ip
34819b48:	908bb00e 	addls	fp, fp, lr
34819b4c:	808bb00c 	addhi	fp, fp, ip
	if (ep_num == 0) {
34819b50:	e3560000 	cmp	r6, #0
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819b54:	e502b004 	str	fp, [r2, #-4]
	if (ep_num == 0) {
34819b58:	1a000018 	bne	34819bc0 <usb_gadget_handle_interrupts+0x2c8>
		if (dev->ep0state == DATA_STATE_XMIT) {
34819b5c:	e5942054 	ldr	r2, [r4, #84]	; 0x54
34819b60:	e3520001 	cmp	r2, #1
34819b64:	1a000005 	bne	34819b80 <usb_gadget_handle_interrupts+0x288>
			last = write_fifo_ep0(ep, req);
34819b68:	e1a00003 	mov	r0, r3
34819b6c:	ebfffc82 	bl	34818d7c <write_fifo_ep0>
			if (last)
34819b70:	e3500000 	cmp	r0, #0
				dev->ep0state = WAIT_FOR_COMPLETE;
34819b74:	13a03005 	movne	r3, #5
34819b78:	15843054 	strne	r3, [r4, #84]	; 0x54
34819b7c:	ea000021 	b	34819c08 <usb_gadget_handle_interrupts+0x310>
		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
34819b80:	e3520007 	cmp	r2, #7
34819b84:	1a000004 	bne	34819b9c <usb_gadget_handle_interrupts+0x2a4>
			done(ep, req, 0);
34819b88:	e1a02006 	mov	r2, r6
34819b8c:	e1a00003 	mov	r0, r3
34819b90:	ebfffa80 	bl	34818598 <done>
			dev->ep0state = WAIT_FOR_SETUP;
34819b94:	e5846054 	str	r6, [r4, #84]	; 0x54
34819b98:	ea00001a 	b	34819c08 <usb_gadget_handle_interrupts+0x310>
		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
34819b9c:	e3520005 	cmp	r2, #5
34819ba0:	1a000018 	bne	34819c08 <usb_gadget_handle_interrupts+0x310>
			done(ep, req, 0);
34819ba4:	e1a00003 	mov	r0, r3
34819ba8:	e1a02006 	mov	r2, r6
34819bac:	ebfffa79 	bl	34818598 <done>
			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34819bb0:	e3a03006 	mov	r3, #6
34819bb4:	e5843054 	str	r3, [r4, #84]	; 0x54
			s3c_ep0_complete_out();
34819bb8:	ebfffa64 	bl	34818550 <s3c_ep0_complete_out>
34819bbc:	ea000011 	b	34819c08 <usb_gadget_handle_interrupts+0x310>
	if (req->req.actual == req->req.length)
34819bc0:	e15b0000 	cmp	fp, r0
34819bc4:	1a000004 	bne	34819bdc <usb_gadget_handle_interrupts+0x2e4>
		done(ep, req, 0);
34819bc8:	e1a00003 	mov	r0, r3
34819bcc:	e3a02000 	mov	r2, #0
34819bd0:	e58d3004 	str	r3, [sp, #4]
34819bd4:	ebfffa6f 	bl	34818598 <done>
34819bd8:	e59d3004 	ldr	r3, [sp, #4]
34819bdc:	e0846306 	add	r6, r4, r6, lsl #6
	if (!list_empty(&ep->queue)) {
34819be0:	e59d2000 	ldr	r2, [sp]
34819be4:	e5961078 	ldr	r1, [r6, #120]	; 0x78
34819be8:	e1510002 	cmp	r1, r2
34819bec:	0a000026 	beq	34819c8c <usb_gadget_handle_interrupts+0x394>
		setdma_tx(ep, req);
34819bf0:	e2411028 	sub	r1, r1, #40	; 0x28
34819bf4:	e1a00003 	mov	r0, r3
34819bf8:	ebfffc16 	bl	34818c58 <setdma_tx>
34819bfc:	ea000022 	b	34819c8c <usb_gadget_handle_interrupts+0x394>
				if (ep_num == 0) {
34819c00:	e3560000 	cmp	r6, #0
34819c04:	1a000020 	bne	34819c8c <usb_gadget_handle_interrupts+0x394>
					if (dev->ep0state ==
34819c08:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819c0c:	e3530007 	cmp	r3, #7
						dev->ep0state = WAIT_FOR_SETUP;
34819c10:	03a03000 	moveq	r3, #0
34819c14:	05843054 	streq	r3, [r4, #84]	; 0x54
					if (dev->ep0state == WAIT_FOR_SETUP)
34819c18:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819c1c:	e3530000 	cmp	r3, #0
34819c20:	1a000000 	bne	34819c28 <usb_gadget_handle_interrupts+0x330>
						s3c_udc_pre_setup();
34819c24:	ebfffbed 	bl	34818be0 <s3c_udc_pre_setup>
					if (clear_feature_flag == 1) {
34819c28:	e59f3114 	ldr	r3, [pc, #276]	; 34819d44 <usb_gadget_handle_interrupts+0x44c>
34819c2c:	e5933020 	ldr	r3, [r3, #32]
34819c30:	e3530001 	cmp	r3, #1
34819c34:	1a000014 	bne	34819c8c <usb_gadget_handle_interrupts+0x394>
	struct s3c_ep *ep = &dev->ep[ep_num];
34819c38:	e59f3104 	ldr	r3, [pc, #260]	; 34819d44 <usb_gadget_handle_interrupts+0x44c>
34819c3c:	e5d3301c 	ldrb	r3, [r3, #28]
34819c40:	e1a03303 	lsl	r3, r3, #6
34819c44:	e0842003 	add	r2, r4, r3
34819c48:	e2830058 	add	r0, r3, #88	; 0x58
34819c4c:	e5921078 	ldr	r1, [r2, #120]	; 0x78
	if (!list_empty(&ep->queue)) {
34819c50:	e2833078 	add	r3, r3, #120	; 0x78
34819c54:	e0843003 	add	r3, r4, r3
	struct s3c_ep *ep = &dev->ep[ep_num];
34819c58:	e0840000 	add	r0, r4, r0
	if (!list_empty(&ep->queue)) {
34819c5c:	e1510003 	cmp	r1, r3
34819c60:	0a000006 	beq	34819c80 <usb_gadget_handle_interrupts+0x388>
		if (ep_is_in(ep))
34819c64:	e1d238dd 	ldrsb	r3, [r2, #141]	; 0x8d
		req = list_entry(ep->queue.next, struct s3c_request, queue);
34819c68:	e2411028 	sub	r1, r1, #40	; 0x28
		if (ep_is_in(ep))
34819c6c:	e3530000 	cmp	r3, #0
34819c70:	aa000001 	bge	34819c7c <usb_gadget_handle_interrupts+0x384>
			setdma_tx(ep, req);
34819c74:	ebfffbf7 	bl	34818c58 <setdma_tx>
34819c78:	ea000000 	b	34819c80 <usb_gadget_handle_interrupts+0x388>
			setdma_rx(ep, req);
34819c7c:	ebfffa09 	bl	348184a8 <setdma_rx>
						clear_feature_flag = 0;
34819c80:	e59f20bc 	ldr	r2, [pc, #188]	; 34819d44 <usb_gadget_handle_interrupts+0x44c>
34819c84:	e3a03000 	mov	r3, #0
34819c88:	e5823020 	str	r3, [r2, #32]
		ep_intr >>= 1;
34819c8c:	e1a090a9 	lsr	r9, r9, #1
34819c90:	e28aa001 	add	sl, sl, #1
34819c94:	eaffff83 	b	34819aa8 <usb_gadget_handle_interrupts+0x1b0>
		if (ep_intr & 0x1) {
34819c98:	e3160001 	tst	r6, #1
34819c9c:	1a000005 	bne	34819cb8 <usb_gadget_handle_interrupts+0x3c0>
		ep_intr >>= 1;
34819ca0:	e1a060a6 	lsr	r6, r6, #1
34819ca4:	e2877001 	add	r7, r7, #1
	while (ep_intr) {
34819ca8:	e3560000 	cmp	r6, #0
34819cac:	e6ef1077 	uxtb	r1, r7
34819cb0:	1afffff8 	bne	34819c98 <usb_gadget_handle_interrupts+0x3a0>
34819cb4:	eaffff1d 	b	34819930 <usb_gadget_handle_interrupts+0x38>
			ep_intr_status = readl(&reg->out_endp[ep_num].doepint);
34819cb8:	e5952000 	ldr	r2, [r5]
34819cbc:	e1a00281 	lsl	r0, r1, #5
34819cc0:	e0822000 	add	r2, r2, r0
34819cc4:	e5929b08 	ldr	r9, [r2, #2824]	; 0xb08
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34819cc8:	e5953000 	ldr	r3, [r5]
			if (ep_num == 0) {
34819ccc:	e3510000 	cmp	r1, #0
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34819cd0:	e0833000 	add	r3, r3, r0
34819cd4:	e5839b08 	str	r9, [r3, #2824]	; 0xb08
34819cd8:	e2093001 	and	r3, r9, #1
			if (ep_num == 0) {
34819cdc:	1a000011 	bne	34819d28 <usb_gadget_handle_interrupts+0x430>
				if (ep_intr_status & TRANSFER_DONE) {
34819ce0:	e3530000 	cmp	r3, #0
34819ce4:	0a000007 	beq	34819d08 <usb_gadget_handle_interrupts+0x410>
					if (dev->ep0state !=
34819ce8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819cec:	e3530006 	cmp	r3, #6
34819cf0:	0a000002 	beq	34819d00 <usb_gadget_handle_interrupts+0x408>
						complete_rx(dev, ep_num);
34819cf4:	e1a00004 	mov	r0, r4
34819cf8:	ebfffb07 	bl	3481891c <complete_rx>
34819cfc:	ea000001 	b	34819d08 <usb_gadget_handle_interrupts+0x410>
						dev->ep0state = WAIT_FOR_SETUP;
34819d00:	e5841054 	str	r1, [r4, #84]	; 0x54
						s3c_udc_pre_setup();
34819d04:	ebfffbb5 	bl	34818be0 <s3c_udc_pre_setup>
				if (ep_intr_status &
34819d08:	e3190008 	tst	r9, #8
34819d0c:	0affffe3 	beq	34819ca0 <usb_gadget_handle_interrupts+0x3a8>
	if (dev->ep0state == WAIT_FOR_SETUP) {
34819d10:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819d14:	e3530000 	cmp	r3, #0
34819d18:	1affffe0 	bne	34819ca0 <usb_gadget_handle_interrupts+0x3a8>
		s3c_ep0_setup(dev);
34819d1c:	e1a00004 	mov	r0, r4
34819d20:	ebfffdba 	bl	34819410 <s3c_ep0_setup>
34819d24:	eaffffdd 	b	34819ca0 <usb_gadget_handle_interrupts+0x3a8>
				if (ep_intr_status & TRANSFER_DONE)
34819d28:	e3530000 	cmp	r3, #0
34819d2c:	0affffdb 	beq	34819ca0 <usb_gadget_handle_interrupts+0x3a8>
					complete_rx(dev, ep_num);
34819d30:	e1a00004 	mov	r0, r4
34819d34:	ebfffaf8 	bl	3481891c <complete_rx>
34819d38:	eaffffd8 	b	34819ca0 <usb_gadget_handle_interrupts+0x3a8>
	return 0;
}
34819d3c:	e28dd008 	add	sp, sp, #8
34819d40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34819d44:	3482a8f0 	.word	0x3482a8f0
34819d48:	34827fe4 	.word	0x34827fe4

34819d4c <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
34819d4c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
34819d50:	e1a0c000 	mov	ip, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
34819d54:	e59fe030 	ldr	lr, [pc, #48]	; 34819d8c <cyg_crc16+0x40>
    cksum = 0;
34819d58:	e3a03000 	mov	r3, #0
34819d5c:	e060200c 	rsb	r2, r0, ip
    for (i = 0;  i < len;  i++) {
34819d60:	e1520001 	cmp	r2, r1
34819d64:	aa000006 	bge	34819d84 <cyg_crc16+0x38>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
34819d68:	e4dc2001 	ldrb	r2, [ip], #1
34819d6c:	e0222423 	eor	r2, r2, r3, lsr #8
34819d70:	e1a02082 	lsl	r2, r2, #1
34819d74:	e19e20b2 	ldrh	r2, [lr, r2]
34819d78:	e0223403 	eor	r3, r2, r3, lsl #8
34819d7c:	e6ff3073 	uxth	r3, r3
34819d80:	eafffff5 	b	34819d5c <cyg_crc16+0x10>
    }
    return cksum;
}
34819d84:	e1a00003 	mov	r0, r3
34819d88:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
34819d8c:	34820234 	.word	0x34820234

34819d90 <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
34819d90:	e3110003 	tst	r1, #3
{
34819d94:	e92d4030 	push	{r4, r5, lr}
    if (((long)b) & 3 && len) {
34819d98:	0a00000b 	beq	34819dcc <crc32_no_comp+0x3c>
34819d9c:	e3520000 	cmp	r2, #0
34819da0:	0a000009 	beq	34819dcc <crc32_no_comp+0x3c>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
34819da4:	e59fc0b8 	ldr	ip, [pc, #184]	; 34819e64 <crc32_no_comp+0xd4>
34819da8:	e4d13001 	ldrb	r3, [r1], #1
	 } while ((--len) && ((long)p)&3);
34819dac:	e2522001 	subs	r2, r2, #1
	      DO_CRC(*p++);
34819db0:	e0233000 	eor	r3, r3, r0
34819db4:	e6ef3073 	uxtb	r3, r3
34819db8:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
34819dbc:	e0230420 	eor	r0, r3, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
34819dc0:	0a000001 	beq	34819dcc <crc32_no_comp+0x3c>
34819dc4:	e3110003 	tst	r1, #3
34819dc8:	1afffff6 	bne	34819da8 <crc32_no_comp+0x18>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
34819dcc:	e202c003 	and	ip, r2, #3
    len = len >> 2;
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
34819dd0:	e59f308c 	ldr	r3, [pc, #140]	; 34819e64 <crc32_no_comp+0xd4>
    len = len >> 2;
34819dd4:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
34819dd8:	e2411004 	sub	r1, r1, #4
34819ddc:	e1a05001 	mov	r5, r1
    len = len >> 2;
34819de0:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
34819de4:	e3540000 	cmp	r4, #0
34819de8:	0a00000f 	beq	34819e2c <crc32_no_comp+0x9c>
	 crc ^= *++b; /* use pre increment for speed */
34819dec:	e5b5e004 	ldr	lr, [r5, #4]!
    for (--b; len; --len) {
34819df0:	e2444001 	sub	r4, r4, #1
	 crc ^= *++b; /* use pre increment for speed */
34819df4:	e020000e 	eor	r0, r0, lr
	 DO_CRC(0);
34819df8:	e6efe070 	uxtb	lr, r0
34819dfc:	e793e10e 	ldr	lr, [r3, lr, lsl #2]
34819e00:	e02e0420 	eor	r0, lr, r0, lsr #8
	 DO_CRC(0);
34819e04:	e6efe070 	uxtb	lr, r0
34819e08:	e793e10e 	ldr	lr, [r3, lr, lsl #2]
34819e0c:	e02e0420 	eor	r0, lr, r0, lsr #8
	 DO_CRC(0);
34819e10:	e6efe070 	uxtb	lr, r0
34819e14:	e793e10e 	ldr	lr, [r3, lr, lsl #2]
34819e18:	e02e0420 	eor	r0, lr, r0, lsr #8
	 DO_CRC(0);
34819e1c:	e6efe070 	uxtb	lr, r0
34819e20:	e793e10e 	ldr	lr, [r3, lr, lsl #2]
34819e24:	e02e0420 	eor	r0, lr, r0, lsr #8
34819e28:	eaffffed 	b	34819de4 <crc32_no_comp+0x54>
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
34819e2c:	e35c0000 	cmp	ip, #0
34819e30:	e1a02102 	lsl	r2, r2, #2
34819e34:	08bd8030 	popeq	{r4, r5, pc}
34819e38:	e2822003 	add	r2, r2, #3
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
34819e3c:	e0812002 	add	r2, r1, r2
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
34819e40:	e59f101c 	ldr	r1, [pc, #28]	; 34819e64 <crc32_no_comp+0xd4>
34819e44:	e5f23001 	ldrb	r3, [r2, #1]!
	 } while (--len);
34819e48:	e25cc001 	subs	ip, ip, #1
	      DO_CRC(*++p); /* use pre increment for speed */
34819e4c:	e0233000 	eor	r3, r3, r0
34819e50:	e6ef3073 	uxtb	r3, r3
34819e54:	e7913103 	ldr	r3, [r1, r3, lsl #2]
34819e58:	e0230420 	eor	r0, r3, r0, lsr #8
	 } while (--len);
34819e5c:	1afffff8 	bne	34819e44 <crc32_no_comp+0xb4>
    }

    return le32_to_cpu(crc);
}
34819e60:	e8bd8030 	pop	{r4, r5, pc}
34819e64:	34820434 	.word	0x34820434

34819e68 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
34819e68:	e92d4010 	push	{r4, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
34819e6c:	e1e00000 	mvn	r0, r0
34819e70:	ebffffc6 	bl	34819d90 <crc32_no_comp>
}
34819e74:	e1e00000 	mvn	r0, r0
34819e78:	e8bd8010 	pop	{r4, pc}

34819e7c <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
34819e7c:	eafffff9 	b	34819e68 <crc32>

34819e80 <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
34819e80:	e59fc018 	ldr	ip, [pc, #24]	; 34819ea0 <crc7+0x20>
34819e84:	e0812002 	add	r2, r1, r2
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
34819e88:	e1510002 	cmp	r1, r2
34819e8c:	14d13001 	ldrbne	r3, [r1], #1
34819e90:	10230080 	eorne	r0, r3, r0, lsl #1
34819e94:	17dc0000 	ldrbne	r0, [ip, r0]
34819e98:	1afffffa 	bne	34819e88 <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
34819e9c:	e12fff1e 	bx	lr
34819ea0:	34820834 	.word	0x34820834

34819ea4 <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
34819ea4:	e92d4010 	push	{r4, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
34819ea8:	e59f100c 	ldr	r1, [pc, #12]	; 34819ebc <display_options+0x18>
34819eac:	e59f000c 	ldr	r0, [pc, #12]	; 34819ec0 <display_options+0x1c>
34819eb0:	ebffbe39 	bl	3480979c <printf>
#endif
	return 0;
}
34819eb4:	e3a00000 	mov	r0, #0
34819eb8:	e8bd8010 	pop	{r4, pc}
34819ebc:	3481f76c 	.word	0x3481f76c
34819ec0:	3482164d 	.word	0x3482164d

34819ec4 <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
34819ec4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34819ec8:	e1a06000 	mov	r6, r0
34819ecc:	e1a07001 	mov	r7, r1
34819ed0:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
34819ed4:	e3a0b000 	mov	fp, #0
	unsigned long d = 10 * ARRAY_SIZE(names);
34819ed8:	e3a0a03c 	mov	sl, #60	; 0x3c
		if (size >> d) {
34819edc:	e1a0200a 	mov	r2, sl
34819ee0:	e1a00006 	mov	r0, r6
34819ee4:	e1a01007 	mov	r1, r7
34819ee8:	fa001596 	blx	3481f548 <__lshrdi3>
34819eec:	e1a04000 	mov	r4, r0
34819ef0:	e1a05001 	mov	r5, r1
34819ef4:	e1943005 	orrs	r3, r4, r5
34819ef8:	0a000005 	beq	34819f14 <print_size+0x50>
			c = names[i];
34819efc:	e59f30dc 	ldr	r3, [pc, #220]	; 34819fe0 <print_size+0x11c>
34819f00:	e7d3300b 	ldrb	r3, [r3, fp]
			break;
		}
	}

	if (!c) {
34819f04:	e3530000 	cmp	r3, #0
			c = names[i];
34819f08:	e58d300c 	str	r3, [sp, #12]
	if (!c) {
34819f0c:	1a00000a 	bne	34819f3c <print_size+0x78>
34819f10:	ea000002 	b	34819f20 <print_size+0x5c>
	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
34819f14:	e25aa00a 	subs	sl, sl, #10
34819f18:	e28bb001 	add	fp, fp, #1
34819f1c:	1affffee 	bne	34819edc <print_size+0x18>
		printf("%llu Bytes%s", size, s);
34819f20:	e58d9000 	str	r9, [sp]
34819f24:	e1a02006 	mov	r2, r6
34819f28:	e1a03007 	mov	r3, r7
34819f2c:	e59f00b0 	ldr	r0, [pc, #176]	; 34819fe4 <print_size+0x120>
34819f30:	ebffbe19 	bl	3480979c <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
34819f34:	e28dd010 	add	sp, sp, #16
34819f38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	n = size >> d;
34819f3c:	e1a0b000 	mov	fp, r0
	f = size & ((1ULL << d) - 1);
34819f40:	e1a0200a 	mov	r2, sl
34819f44:	e3a00001 	mov	r0, #1
34819f48:	e3a01000 	mov	r1, #0
34819f4c:	fa00158a 	blx	3481f57c <__ashldi3>
34819f50:	e2500001 	subs	r0, r0, #1
34819f54:	e2c11000 	sbc	r1, r1, #0
34819f58:	e0000006 	and	r0, r0, r6
34819f5c:	e0011007 	and	r1, r1, r7
	if (f) {
34819f60:	e1903001 	orrs	r3, r0, r1
	unsigned long m = 0, n;
34819f64:	03a06000 	moveq	r6, #0
	if (f) {
34819f68:	0a00000e 	beq	34819fa8 <print_size+0xe4>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
34819f6c:	e3a0300a 	mov	r3, #10
34819f70:	e24a2001 	sub	r2, sl, #1
34819f74:	e0876390 	umull	r6, r7, r0, r3
34819f78:	e3a00001 	mov	r0, #1
34819f7c:	e0277193 	mla	r7, r3, r1, r7
34819f80:	e3a01000 	mov	r1, #0
34819f84:	fa00157c 	blx	3481f57c <__ashldi3>
34819f88:	e0900006 	adds	r0, r0, r6
34819f8c:	e1a0200a 	mov	r2, sl
34819f90:	e0a11007 	adc	r1, r1, r7
34819f94:	fa00156b 	blx	3481f548 <__lshrdi3>
		if (m >= 10) {
34819f98:	e3500009 	cmp	r0, #9
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
34819f9c:	e1a06000 	mov	r6, r0
			n += 1;
34819fa0:	8284b001 	addhi	fp, r4, #1
			m -= 10;
34819fa4:	8240600a 	subhi	r6, r0, #10
	printf ("%lu", n);
34819fa8:	e1a0100b 	mov	r1, fp
34819fac:	e59f0034 	ldr	r0, [pc, #52]	; 34819fe8 <print_size+0x124>
34819fb0:	ebffbdf9 	bl	3480979c <printf>
	if (m) {
34819fb4:	e3560000 	cmp	r6, #0
34819fb8:	0a000002 	beq	34819fc8 <print_size+0x104>
		printf (".%ld", m);
34819fbc:	e1a01006 	mov	r1, r6
34819fc0:	e59f0024 	ldr	r0, [pc, #36]	; 34819fec <print_size+0x128>
34819fc4:	ebffbdf4 	bl	3480979c <printf>
	printf (" %ciB%s", c, s);
34819fc8:	e1a02009 	mov	r2, r9
34819fcc:	e59d100c 	ldr	r1, [sp, #12]
34819fd0:	e59f0018 	ldr	r0, [pc, #24]	; 34819ff0 <print_size+0x12c>
}
34819fd4:	e28dd010 	add	sp, sp, #16
34819fd8:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
	printf (" %ciB%s", c, s);
34819fdc:	eaffbdee 	b	3480979c <printf>
34819fe0:	34820a34 	.word	0x34820a34
34819fe4:	34826bbb 	.word	0x34826bbb
34819fe8:	34826bc8 	.word	0x34826bc8
34819fec:	34826bcc 	.word	0x34826bcc
34819ff0:	34826bd1 	.word	0x34826bd1

34819ff4 <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
34819ff4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34819ff8:	e24dd050 	sub	sp, sp, #80	; 0x50
34819ffc:	e59d4070 	ldr	r4, [sp, #112]	; 0x70
3481a000:	e1a05003 	mov	r5, r3
3481a004:	e1a09000 	mov	r9, r0
3481a008:	e1a0a001 	mov	sl, r1
3481a00c:	e1a06002 	mov	r6, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481a010:	e0030492 	mul	r3, r2, r4
3481a014:	e3530040 	cmp	r3, #64	; 0x40
3481a018:	9a000003 	bls	3481a02c <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
3481a01c:	e1a01002 	mov	r1, r2
3481a020:	e3a00040 	mov	r0, #64	; 0x40
3481a024:	fa0013fd 	blx	3481f020 <__udivsi3>
3481a028:	e1a04000 	mov	r4, r0
	if (linelen < 1)
3481a02c:	e3540000 	cmp	r4, #0
3481a030:	1a000003 	bne	3481a044 <print_buffer+0x50>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
3481a034:	e1a01006 	mov	r1, r6
3481a038:	e3a00010 	mov	r0, #16
3481a03c:	fa0013f7 	blx	3481f020 <__udivsi3>
3481a040:	e1a04000 	mov	r4, r0
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
3481a044:	e59fb100 	ldr	fp, [pc, #256]	; 3481a14c <print_buffer+0x158>
			printf(" %0*x", width * 2, x);
3481a048:	e1a03086 	lsl	r3, r6, #1
3481a04c:	e58d3000 	str	r3, [sp]
	while (count) {
3481a050:	e3550000 	cmp	r5, #0
3481a054:	0a000039 	beq	3481a140 <print_buffer+0x14c>
		printf("%08lx:", addr);
3481a058:	e1a01009 	mov	r1, r9
3481a05c:	e59f00ec 	ldr	r0, [pc, #236]	; 3481a150 <print_buffer+0x15c>
3481a060:	ebffbdcd 	bl	3480979c <printf>
3481a064:	e1540005 	cmp	r4, r5
		for (i = 0; i < linelen; i++) {
3481a068:	e1a0300a 	mov	r3, sl
3481a06c:	21a04005 	movcs	r4, r5
3481a070:	e3a07000 	mov	r7, #0
3481a074:	e1570004 	cmp	r7, r4
3481a078:	e28d100c 	add	r1, sp, #12
3481a07c:	0a000013 	beq	3481a0d0 <print_buffer+0xdc>
			if (width == 4)
3481a080:	e3560004 	cmp	r6, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
3481a084:	05932000 	ldreq	r2, [r3]
3481a088:	07812107 	streq	r2, [r1, r7, lsl #2]
			if (width == 4)
3481a08c:	0a000007 	beq	3481a0b0 <print_buffer+0xbc>
			else if (width == 2)
3481a090:	e3560002 	cmp	r6, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
3481a094:	01d320b0 	ldrheq	r2, [r3]
3481a098:	01a00087 	lsleq	r0, r7, #1
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481a09c:	15d32000 	ldrbne	r2, [r3]
				x = lb.us[i] = *(volatile uint16_t *)data;
3481a0a0:	06ff2072 	uxtheq	r2, r2
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481a0a4:	16ef2072 	uxtbne	r2, r2
				x = lb.us[i] = *(volatile uint16_t *)data;
3481a0a8:	018120b0 	strheq	r2, [r1, r0]
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481a0ac:	17c12007 	strbne	r2, [r1, r7]
			printf(" %0*x", width * 2, x);
3481a0b0:	e59d1000 	ldr	r1, [sp]
		for (i = 0; i < linelen; i++) {
3481a0b4:	e2877001 	add	r7, r7, #1
			printf(" %0*x", width * 2, x);
3481a0b8:	e59f0094 	ldr	r0, [pc, #148]	; 3481a154 <print_buffer+0x160>
3481a0bc:	e58d3004 	str	r3, [sp, #4]
3481a0c0:	ebffbdb5 	bl	3480979c <printf>
			data += width;
3481a0c4:	e59d3004 	ldr	r3, [sp, #4]
3481a0c8:	e0833006 	add	r3, r3, r6
3481a0cc:	eaffffe8 	b	3481a074 <print_buffer+0x80>
3481a0d0:	e0070496 	mul	r7, r6, r4
		for (i = 0; i < linelen; i++) {
3481a0d4:	e1a03001 	mov	r3, r1
				lb.uc[i] = '.';
3481a0d8:	e3a0002e 	mov	r0, #46	; 0x2e
3481a0dc:	e08aa007 	add	sl, sl, r7
3481a0e0:	e0612003 	rsb	r2, r1, r3
		for (i = 0; i < linelen * width; i++) {
3481a0e4:	e1520007 	cmp	r2, r7
3481a0e8:	2a000007 	bcs	3481a10c <print_buffer+0x118>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
3481a0ec:	e4d32001 	ldrb	r2, [r3], #1
3481a0f0:	e7dbc002 	ldrb	ip, [fp, r2]
3481a0f4:	e31c0097 	tst	ip, #151	; 0x97
3481a0f8:	0a000001 	beq	3481a104 <print_buffer+0x110>
3481a0fc:	e3120080 	tst	r2, #128	; 0x80
3481a100:	0afffff6 	beq	3481a0e0 <print_buffer+0xec>
				lb.uc[i] = '.';
3481a104:	e5430001 	strb	r0, [r3, #-1]
3481a108:	eafffff4 	b	3481a0e0 <print_buffer+0xec>
		}
		lb.uc[i] = '\0';
3481a10c:	e28d3050 	add	r3, sp, #80	; 0x50
3481a110:	e3a02000 	mov	r2, #0
3481a114:	e0833007 	add	r3, r3, r7
		printf("    %s\n", lb.uc);
3481a118:	e59f0038 	ldr	r0, [pc, #56]	; 3481a158 <print_buffer+0x164>
		lb.uc[i] = '\0';
3481a11c:	e5432044 	strb	r2, [r3, #-68]	; 0xffffffbc

		/* update references */
		addr += linelen * width;
3481a120:	e0899007 	add	r9, r9, r7
		printf("    %s\n", lb.uc);
3481a124:	ebffbd9c 	bl	3480979c <printf>
		count -= linelen;

		if (ctrlc())
3481a128:	ebffbdbd 	bl	34809824 <ctrlc>
3481a12c:	e3500000 	cmp	r0, #0
		count -= linelen;
3481a130:	e0645005 	rsb	r5, r4, r5
		if (ctrlc())
3481a134:	0affffc5 	beq	3481a050 <print_buffer+0x5c>
			return -1;
3481a138:	e3e00000 	mvn	r0, #0
3481a13c:	ea000000 	b	3481a144 <print_buffer+0x150>
	}

	return 0;
3481a140:	e1a00005 	mov	r0, r5
}
3481a144:	e28dd050 	add	sp, sp, #80	; 0x50
3481a148:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a14c:	34820934 	.word	0x34820934
3481a150:	34822b60 	.word	0x34822b60
3481a154:	34826bd9 	.word	0x34826bd9
3481a158:	34826bdf 	.word	0x34826bdf

3481a15c <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481a15c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
3481a160:	e1a03000 	mov	r3, r0
3481a164:	e1c040d0 	ldrd	r4, [r0]
{
3481a168:	e1a09001 	mov	r9, r1
	uint64_t b = base;
3481a16c:	e1a06001 	mov	r6, r1
3481a170:	e3a07000 	mov	r7, #0
{
3481a174:	e58d0004 	str	r0, [sp, #4]
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481a178:	e1550001 	cmp	r5, r1
	res = 0;
3481a17c:	33a02000 	movcc	r2, #0
3481a180:	33a03000 	movcc	r3, #0
	if (high >= base) {
3481a184:	3a000006 	bcc	3481a1a4 <__div64_32+0x48>
		high /= base;
3481a188:	e1a00005 	mov	r0, r5
3481a18c:	fa0013a3 	blx	3481f020 <__udivsi3>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
3481a190:	e00b0099 	mul	fp, r9, r0
		res = (uint64_t) high << 32;
3481a194:	e3a02000 	mov	r2, #0
		rem -= (uint64_t) (high*base) << 32;
3481a198:	e0544002 	subs	r4, r4, r2
		res = (uint64_t) high << 32;
3481a19c:	e1a03000 	mov	r3, r0
		rem -= (uint64_t) (high*base) << 32;
3481a1a0:	e0c5500b 	sbc	r5, r5, fp
	res = 0;
3481a1a4:	e3a00001 	mov	r0, #1
3481a1a8:	e3a01000 	mov	r1, #0
	}

	while ((int64_t)b > 0 && b < rem) {
3481a1ac:	e3560001 	cmp	r6, #1
3481a1b0:	e2d7c000 	sbcs	ip, r7, #0
3481a1b4:	a3a0c001 	movge	ip, #1
3481a1b8:	b3a0c000 	movlt	ip, #0
3481a1bc:	e1570005 	cmp	r7, r5
3481a1c0:	01560004 	cmpeq	r6, r4
3481a1c4:	23a0c000 	movcs	ip, #0
3481a1c8:	320cc001 	andcc	ip, ip, #1
3481a1cc:	e35c0000 	cmp	ip, #0
3481a1d0:	0a000004 	beq	3481a1e8 <__div64_32+0x8c>
		b = b+b;
3481a1d4:	e0966006 	adds	r6, r6, r6
3481a1d8:	e0a77007 	adc	r7, r7, r7
		d = d+d;
3481a1dc:	e0900000 	adds	r0, r0, r0
3481a1e0:	e0a11001 	adc	r1, r1, r1
3481a1e4:	eafffff0 	b	3481a1ac <__div64_32+0x50>
	}

	do {
		if (rem >= b) {
3481a1e8:	e1550007 	cmp	r5, r7
3481a1ec:	01540006 	cmpeq	r4, r6
3481a1f0:	3a000003 	bcc	3481a204 <__div64_32+0xa8>
			rem -= b;
3481a1f4:	e0544006 	subs	r4, r4, r6
3481a1f8:	e0c55007 	sbc	r5, r5, r7
			res += d;
3481a1fc:	e0922000 	adds	r2, r2, r0
3481a200:	e0a33001 	adc	r3, r3, r1
		}
		b >>= 1;
		d >>= 1;
3481a204:	e1b010a1 	lsrs	r1, r1, #1
3481a208:	e1a00060 	rrx	r0, r0
		b >>= 1;
3481a20c:	e1b070a7 	lsrs	r7, r7, #1
3481a210:	e1a06066 	rrx	r6, r6
	} while (d);
3481a214:	e190c001 	orrs	ip, r0, r1
3481a218:	1afffff2 	bne	3481a1e8 <__div64_32+0x8c>

	*n = res;
3481a21c:	e59d1004 	ldr	r1, [sp, #4]
	return rem;
}
3481a220:	e1a00004 	mov	r0, r4
	*n = res;
3481a224:	e1c120f0 	strd	r2, [r1]
}
3481a228:	e28dd008 	add	sp, sp, #8
3481a22c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481a230 <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
3481a230:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
3481a234:	e282000f 	add	r0, r2, #15

	p = malloc (size);
3481a238:	e3c0000f 	bic	r0, r0, #15
3481a23c:	eaffbf25 	b	34809ed8 <malloc>

3481a240 <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
3481a240:	e1a00001 	mov	r0, r1
3481a244:	eaffbe99 	b	34809cb0 <free>

3481a248 <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481a248:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
3481a24c:	e1a05003 	mov	r5, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481a250:	e59f30f0 	ldr	r3, [pc, #240]	; 3481a348 <zunzip+0x100>
{
3481a254:	e24dd044 	sub	sp, sp, #68	; 0x44
3481a258:	e1a06000 	mov	r6, r0
3481a25c:	e1a09001 	mov	r9, r1
3481a260:	e1a04002 	mov	r4, r2
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481a264:	e3e0100e 	mvn	r1, #14
	s.zalloc = gzalloc;
3481a268:	e58d3024 	str	r3, [sp, #36]	; 0x24
	r = inflateInit2(&s, -MAX_WBITS);
3481a26c:	e28d0004 	add	r0, sp, #4
	s.zfree = gzfree;
3481a270:	e59f30d4 	ldr	r3, [pc, #212]	; 3481a34c <zunzip+0x104>
	r = inflateInit2(&s, -MAX_WBITS);
3481a274:	e59f20d4 	ldr	r2, [pc, #212]	; 3481a350 <zunzip+0x108>
{
3481a278:	e59da060 	ldr	sl, [sp, #96]	; 0x60
	s.zfree = gzfree;
3481a27c:	e58d3028 	str	r3, [sp, #40]	; 0x28
	r = inflateInit2(&s, -MAX_WBITS);
3481a280:	e3a0303c 	mov	r3, #60	; 0x3c
{
3481a284:	e59d7064 	ldr	r7, [sp, #100]	; 0x64
	r = inflateInit2(&s, -MAX_WBITS);
3481a288:	eb000cec 	bl	3481d640 <inflateInit2_>
	if (r != Z_OK) {
3481a28c:	e2501000 	subs	r1, r0, #0
3481a290:	0a000002 	beq	3481a2a0 <zunzip+0x58>
		printf ("Error: inflateInit2() returned %d\n", r);
3481a294:	e59f00b8 	ldr	r0, [pc, #184]	; 3481a354 <zunzip+0x10c>
3481a298:	ebffbd3f 	bl	3480979c <printf>
3481a29c:	ea000017 	b	3481a300 <zunzip+0xb8>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
3481a2a0:	e5953000 	ldr	r3, [r5]
	s.next_in = src + offset;
3481a2a4:	e0844007 	add	r4, r4, r7
3481a2a8:	e58d4004 	str	r4, [sp, #4]
	s.next_out = dst;
3481a2ac:	e58d6010 	str	r6, [sp, #16]
	s.avail_in = *lenp - offset;
3481a2b0:	e0673003 	rsb	r3, r7, r3
	s.avail_out = dstlen;
3481a2b4:	e58d9014 	str	r9, [sp, #20]
	s.avail_in = *lenp - offset;
3481a2b8:	e58d3008 	str	r3, [sp, #8]
	do {
		r = inflate(&s, Z_FINISH);
3481a2bc:	e3a01004 	mov	r1, #4
3481a2c0:	e08d0001 	add	r0, sp, r1
3481a2c4:	eb000e0a 	bl	3481daf4 <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481a2c8:	e3500001 	cmp	r0, #1
3481a2cc:	13700005 	cmnne	r0, #5
		r = inflate(&s, Z_FINISH);
3481a2d0:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481a2d4:	13a00001 	movne	r0, #1
3481a2d8:	03a00000 	moveq	r0, #0
3481a2dc:	e35a0001 	cmp	sl, #1
3481a2e0:	13a04000 	movne	r4, #0
3481a2e4:	02004001 	andeq	r4, r0, #1
3481a2e8:	e3540000 	cmp	r4, #0
3481a2ec:	0a000005 	beq	3481a308 <zunzip+0xc0>
			printf("Error: inflate() returned %d\n", r);
3481a2f0:	e59f0060 	ldr	r0, [pc, #96]	; 3481a358 <zunzip+0x110>
3481a2f4:	ebffbd28 	bl	3480979c <printf>
			inflateEnd(&s);
3481a2f8:	e28d0004 	add	r0, sp, #4
3481a2fc:	eb000d14 	bl	3481d754 <inflateEnd>
			return -1;
3481a300:	e3e00000 	mvn	r0, #0
3481a304:	ea00000d 	b	3481a340 <zunzip+0xf8>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481a308:	e59d2010 	ldr	r2, [sp, #16]
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
3481a30c:	e3710005 	cmn	r1, #5
3481a310:	e5950000 	ldr	r0, [r5]
		s.avail_out = dstlen;
3481a314:	e58d9014 	str	r9, [sp, #20]
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481a318:	e0623006 	rsb	r3, r2, r6
3481a31c:	e0833000 	add	r3, r3, r0
3481a320:	e0673003 	rsb	r3, r7, r3
3481a324:	e58d3008 	str	r3, [sp, #8]
	} while (r == Z_BUF_ERROR);
3481a328:	0affffe3 	beq	3481a2bc <zunzip+0x74>
	*lenp = s.next_out - (unsigned char *) dst;
3481a32c:	e0666002 	rsb	r6, r6, r2
	inflateEnd(&s);
3481a330:	e28d0004 	add	r0, sp, #4
	*lenp = s.next_out - (unsigned char *) dst;
3481a334:	e5856000 	str	r6, [r5]
	inflateEnd(&s);
3481a338:	eb000d05 	bl	3481d754 <inflateEnd>

	return 0;
3481a33c:	e1a00004 	mov	r0, r4
}
3481a340:	e28dd044 	add	sp, sp, #68	; 0x44
3481a344:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3481a348:	3481a230 	.word	0x3481a230
3481a34c:	3481a240 	.word	0x3481a240
3481a350:	34826be7 	.word	0x34826be7
3481a354:	34826bed 	.word	0x34826bed
3481a358:	34826c10 	.word	0x34826c10

3481a35c <gunzip>:
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481a35c:	e5d2c002 	ldrb	ip, [r2, #2]
{
3481a360:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	flags = src[3];
3481a364:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481a368:	e35c0008 	cmp	ip, #8
3481a36c:	1a000001 	bne	3481a378 <gunzip+0x1c>
3481a370:	e31e00e0 	tst	lr, #224	; 0xe0
3481a374:	0a000001 	beq	3481a380 <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
3481a378:	e59f008c 	ldr	r0, [pc, #140]	; 3481a40c <gunzip+0xb0>
3481a37c:	ea000019 	b	3481a3e8 <gunzip+0x8c>
	if ((flags & EXTRA_FIELD) != 0)
3481a380:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
3481a384:	15d2c00a 	ldrbne	ip, [r2, #10]
	i = 10;
3481a388:	03a0c00a 	moveq	ip, #10
		i = 12 + src[10] + (src[11] << 8);
3481a38c:	15d2400b 	ldrbne	r4, [r2, #11]
3481a390:	128cc00c 	addne	ip, ip, #12
3481a394:	108cc404 	addne	ip, ip, r4, lsl #8
	if ((flags & ORIG_NAME) != 0)
3481a398:	e31e0008 	tst	lr, #8
3481a39c:	0a000004 	beq	3481a3b4 <gunzip+0x58>
3481a3a0:	e082400c 	add	r4, r2, ip
		while (src[i++] != 0)
3481a3a4:	e4d45001 	ldrb	r5, [r4], #1
3481a3a8:	e28cc001 	add	ip, ip, #1
3481a3ac:	e3550000 	cmp	r5, #0
3481a3b0:	1afffffb 	bne	3481a3a4 <gunzip+0x48>
	if ((flags & COMMENT) != 0)
3481a3b4:	e31e0010 	tst	lr, #16
3481a3b8:	0a000004 	beq	3481a3d0 <gunzip+0x74>
3481a3bc:	e082400c 	add	r4, r2, ip
		while (src[i++] != 0)
3481a3c0:	e4d45001 	ldrb	r5, [r4], #1
3481a3c4:	e28cc001 	add	ip, ip, #1
3481a3c8:	e3550000 	cmp	r5, #0
3481a3cc:	1afffffb 	bne	3481a3c0 <gunzip+0x64>
	if ((flags & HEAD_CRC) != 0)
3481a3d0:	e31e0002 	tst	lr, #2
	if (i >= *lenp) {
3481a3d4:	e593e000 	ldr	lr, [r3]
		i += 2;
3481a3d8:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
3481a3dc:	e15c000e 	cmp	ip, lr
3481a3e0:	3a000003 	bcc	3481a3f4 <gunzip+0x98>
		puts ("Error: gunzip out of data in header\n");
3481a3e4:	e59f0024 	ldr	r0, [pc, #36]	; 3481a410 <gunzip+0xb4>
3481a3e8:	ebffbcdf 	bl	3480976c <puts>
		return (-1);
3481a3ec:	e3e00000 	mvn	r0, #0
3481a3f0:	ea000003 	b	3481a404 <gunzip+0xa8>
	return zunzip(dst, dstlen, src, lenp, 1, i);
3481a3f4:	e58dc004 	str	ip, [sp, #4]
3481a3f8:	e3a0c001 	mov	ip, #1
3481a3fc:	e58dc000 	str	ip, [sp]
3481a400:	ebffff90 	bl	3481a248 <zunzip>
}
3481a404:	e28dd00c 	add	sp, sp, #12
3481a408:	e8bd8030 	pop	{r4, r5, pc}
3481a40c:	34826c2e 	.word	0x34826c2e
3481a410:	34826c47 	.word	0x34826c47

3481a414 <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
3481a414:	e5912000 	ldr	r2, [r1]
3481a418:	e5903000 	ldr	r3, [r0]
3481a41c:	e5921000 	ldr	r1, [r2]
3481a420:	e5930000 	ldr	r0, [r3]
3481a424:	ea0004fd 	b	3481b820 <strcmp>

3481a428 <drop_var_from_set.part.0>:

/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
3481a428:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
		if (vars[i] == NULL)
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
			vars[i] = NULL;
			res = 1;
3481a42c:	e3a04000 	mov	r4, #0
static int drop_var_from_set(const char *name, int nvars, char * vars[])
3481a430:	e1a09000 	mov	r9, r0
3481a434:	e1a07001 	mov	r7, r1
3481a438:	e2426004 	sub	r6, r2, #4
			res = 1;
3481a43c:	e1a05004 	mov	r5, r4
	for (i = 0; i < nvars; i++) {
3481a440:	e1550007 	cmp	r5, r7
3481a444:	aa000009 	bge	3481a470 <drop_var_from_set.part.0+0x48>
		if (vars[i] == NULL)
3481a448:	e5b61004 	ldr	r1, [r6, #4]!
3481a44c:	e3510000 	cmp	r1, #0
3481a450:	0a000004 	beq	3481a468 <drop_var_from_set.part.0+0x40>
		if (!strcmp(name, vars[i])) {
3481a454:	e1a00009 	mov	r0, r9
3481a458:	eb0004f0 	bl	3481b820 <strcmp>
3481a45c:	e3500000 	cmp	r0, #0
			res = 1;
3481a460:	03a04001 	moveq	r4, #1
			vars[i] = NULL;
3481a464:	05860000 	streq	r0, [r6]
	for (i = 0; i < nvars; i++) {
3481a468:	e2855001 	add	r5, r5, #1
3481a46c:	eafffff3 	b	3481a440 <drop_var_from_set.part.0+0x18>
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
3481a470:	e1a00004 	mov	r0, r4
3481a474:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

3481a478 <hcreate_r>:
	if (htab == NULL) {
3481a478:	e3510000 	cmp	r1, #0
3481a47c:	1a000004 	bne	3481a494 <hcreate_r+0x1c>
		__set_errno(EINVAL);
3481a480:	e59f309c 	ldr	r3, [pc, #156]	; 3481a524 <hcreate_r+0xac>
3481a484:	e3a02016 	mov	r2, #22
		return 0;
3481a488:	e1a00001 	mov	r0, r1
		__set_errno(EINVAL);
3481a48c:	e5832000 	str	r2, [r3]
}
3481a490:	e12fff1e 	bx	lr
	if (htab->table != NULL)
3481a494:	e5913000 	ldr	r3, [r1]
3481a498:	e3530000 	cmp	r3, #0
3481a49c:	1a00001e 	bne	3481a51c <hcreate_r+0xa4>
{
3481a4a0:	e92d4070 	push	{r4, r5, r6, lr}
3481a4a4:	e1a06001 	mov	r6, r1
	nel |= 1;		/* make odd */
3481a4a8:	e3804001 	orr	r4, r0, #1
	unsigned int div = 3;
3481a4ac:	e3a05003 	mov	r5, #3
	while (div * div < number && number % div != 0)
3481a4b0:	e0030595 	mul	r3, r5, r5
3481a4b4:	e1530004 	cmp	r3, r4
3481a4b8:	3a000006 	bcc	3481a4d8 <hcreate_r+0x60>
	return number % div != 0;
3481a4bc:	e1a01005 	mov	r1, r5
3481a4c0:	e1a00004 	mov	r0, r4
3481a4c4:	fa00136c 	blx	3481f27c <__aeabi_uidivmod>
	while (!isprime(nel))
3481a4c8:	e3510000 	cmp	r1, #0
3481a4cc:	1a000008 	bne	3481a4f4 <hcreate_r+0x7c>
		nel += 2;
3481a4d0:	e2844002 	add	r4, r4, #2
3481a4d4:	eafffff4 	b	3481a4ac <hcreate_r+0x34>
	while (div * div < number && number % div != 0)
3481a4d8:	e1a01005 	mov	r1, r5
3481a4dc:	e1a00004 	mov	r0, r4
3481a4e0:	fa001365 	blx	3481f27c <__aeabi_uidivmod>
3481a4e4:	e3510000 	cmp	r1, #0
3481a4e8:	0afffff3 	beq	3481a4bc <hcreate_r+0x44>
		div += 2;
3481a4ec:	e2855002 	add	r5, r5, #2
3481a4f0:	eaffffee 	b	3481a4b0 <hcreate_r+0x38>
	htab->filled = 0;
3481a4f4:	e3a03000 	mov	r3, #0
	htab->size = nel;
3481a4f8:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
3481a4fc:	e5863008 	str	r3, [r6, #8]
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
3481a500:	e3a0100c 	mov	r1, #12
3481a504:	e2840001 	add	r0, r4, #1
3481a508:	ebffbfe8 	bl	3480a4b0 <calloc>
3481a50c:	e5860000 	str	r0, [r6]
	if (htab->table == NULL)
3481a510:	e2900000 	adds	r0, r0, #0
3481a514:	13a00001 	movne	r0, #1
3481a518:	e8bd8070 	pop	{r4, r5, r6, pc}
		return 0;
3481a51c:	e3a00000 	mov	r0, #0
3481a520:	e12fff1e 	bx	lr
3481a524:	3482a918 	.word	0x3482a918

3481a528 <hdestroy_r>:
	if (htab == NULL) {
3481a528:	e3500000 	cmp	r0, #0
3481a52c:	1a000003 	bne	3481a540 <hdestroy_r+0x18>
		__set_errno(EINVAL);
3481a530:	e59f3090 	ldr	r3, [pc, #144]	; 3481a5c8 <hdestroy_r+0xa0>
3481a534:	e3a02016 	mov	r2, #22
3481a538:	e5832000 	str	r2, [r3]
3481a53c:	e12fff1e 	bx	lr
{
3481a540:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a544:	e1a04000 	mov	r4, r0
3481a548:	e1a07001 	mov	r7, r1
3481a54c:	e3a05001 	mov	r5, #1
3481a550:	e3a0900c 	mov	r9, #12
	for (i = 1; i <= htab->size; ++i) {
3481a554:	e5943004 	ldr	r3, [r4, #4]
3481a558:	e1550003 	cmp	r5, r3
3481a55c:	8a000014 	bhi	3481a5b4 <hdestroy_r+0x8c>
3481a560:	e0030599 	mul	r3, r9, r5
		if (htab->table[i].used > 0) {
3481a564:	e5942000 	ldr	r2, [r4]
3481a568:	e0826003 	add	r6, r2, r3
3481a56c:	e7923003 	ldr	r3, [r2, r3]
3481a570:	e3530000 	cmp	r3, #0
3481a574:	da00000c 	ble	3481a5ac <hdestroy_r+0x84>
			if (do_apply && htab->apply != NULL) {
3481a578:	e3570000 	cmp	r7, #0
3481a57c:	0a000006 	beq	3481a59c <hdestroy_r+0x74>
3481a580:	e594a00c 	ldr	sl, [r4, #12]
3481a584:	e35a0000 	cmp	sl, #0
3481a588:	0a000003 	beq	3481a59c <hdestroy_r+0x74>
				htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481a58c:	e3a03002 	mov	r3, #2
3481a590:	e3a02000 	mov	r2, #0
3481a594:	e9960003 	ldmib	r6, {r0, r1}
3481a598:	e12fff3a 	blx	sl
			free((void *)ep->key);
3481a59c:	e5960004 	ldr	r0, [r6, #4]
3481a5a0:	ebffbdc2 	bl	34809cb0 <free>
			free(ep->data);
3481a5a4:	e5960008 	ldr	r0, [r6, #8]
3481a5a8:	ebffbdc0 	bl	34809cb0 <free>
	for (i = 1; i <= htab->size; ++i) {
3481a5ac:	e2855001 	add	r5, r5, #1
3481a5b0:	eaffffe7 	b	3481a554 <hdestroy_r+0x2c>
	free(htab->table);
3481a5b4:	e5940000 	ldr	r0, [r4]
3481a5b8:	ebffbdbc 	bl	34809cb0 <free>
	htab->table = NULL;
3481a5bc:	e3a03000 	mov	r3, #0
3481a5c0:	e5843000 	str	r3, [r4]
3481a5c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a5c8:	3482a918 	.word	0x3482a918

3481a5cc <hstrstr_r>:
{
3481a5cc:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a5d0:	e2814001 	add	r4, r1, #1
3481a5d4:	e3a0500c 	mov	r5, #12
{
3481a5d8:	e1a09000 	mov	r9, r0
3481a5dc:	e0050495 	mul	r5, r5, r4
3481a5e0:	e1a06002 	mov	r6, r2
3481a5e4:	e1a07003 	mov	r7, r3
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a5e8:	e5973004 	ldr	r3, [r7, #4]
3481a5ec:	e1540003 	cmp	r4, r3
3481a5f0:	2a000019 	bcs	3481a65c <hstrstr_r+0x90>
		if (htab->table[idx].used <= 0)
3481a5f4:	e5973000 	ldr	r3, [r7]
3481a5f8:	e0832005 	add	r2, r3, r5
3481a5fc:	e7933005 	ldr	r3, [r3, r5]
3481a600:	e3530000 	cmp	r3, #0
3481a604:	da000011 	ble	3481a650 <hstrstr_r+0x84>
		if (strstr(htab->table[idx].entry.key, match) ||
3481a608:	e1a01009 	mov	r1, r9
3481a60c:	e5920004 	ldr	r0, [r2, #4]
3481a610:	eb0005bd 	bl	3481bd0c <strstr>
3481a614:	e3500000 	cmp	r0, #0
3481a618:	0a000005 	beq	3481a634 <hstrstr_r+0x68>
			*retval = &htab->table[idx].entry;
3481a61c:	e5973000 	ldr	r3, [r7]
			return idx;
3481a620:	e1a00004 	mov	r0, r4
			*retval = &htab->table[idx].entry;
3481a624:	e0835005 	add	r5, r3, r5
3481a628:	e2855004 	add	r5, r5, #4
3481a62c:	e5865000 	str	r5, [r6]
			return idx;
3481a630:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		    strstr(htab->table[idx].entry.data, match)) {
3481a634:	e5973000 	ldr	r3, [r7]
3481a638:	e1a01009 	mov	r1, r9
3481a63c:	e0833005 	add	r3, r3, r5
3481a640:	e5930008 	ldr	r0, [r3, #8]
3481a644:	eb0005b0 	bl	3481bd0c <strstr>
		if (strstr(htab->table[idx].entry.key, match) ||
3481a648:	e3500000 	cmp	r0, #0
3481a64c:	1afffff2 	bne	3481a61c <hstrstr_r+0x50>
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a650:	e2844001 	add	r4, r4, #1
3481a654:	e285500c 	add	r5, r5, #12
3481a658:	eaffffe2 	b	3481a5e8 <hstrstr_r+0x1c>
	__set_errno(ESRCH);
3481a65c:	e59f3010 	ldr	r3, [pc, #16]	; 3481a674 <hstrstr_r+0xa8>
3481a660:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481a664:	e3a00000 	mov	r0, #0
	__set_errno(ESRCH);
3481a668:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481a66c:	e5860000 	str	r0, [r6]
}
3481a670:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3481a674:	3482a918 	.word	0x3482a918

3481a678 <hmatch_r>:
{
3481a678:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a67c:	e1a04001 	mov	r4, r1
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a680:	e2844001 	add	r4, r4, #1
3481a684:	e3a0500c 	mov	r5, #12
3481a688:	e0050495 	mul	r5, r5, r4
{
3481a68c:	e1a09000 	mov	r9, r0
3481a690:	e1a06002 	mov	r6, r2
3481a694:	e1a07003 	mov	r7, r3
	size_t key_len = strlen(match);
3481a698:	eb00048e 	bl	3481b8d8 <strlen>
3481a69c:	e1a0a000 	mov	sl, r0
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a6a0:	e5973004 	ldr	r3, [r7, #4]
3481a6a4:	e1540003 	cmp	r4, r3
3481a6a8:	2a000013 	bcs	3481a6fc <hmatch_r+0x84>
		if (htab->table[idx].used <= 0)
3481a6ac:	e5973000 	ldr	r3, [r7]
3481a6b0:	e0831005 	add	r1, r3, r5
3481a6b4:	e7933005 	ldr	r3, [r3, r5]
3481a6b8:	e3530000 	cmp	r3, #0
3481a6bc:	da00000b 	ble	3481a6f0 <hmatch_r+0x78>
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
3481a6c0:	e1a0200a 	mov	r2, sl
3481a6c4:	e5911004 	ldr	r1, [r1, #4]
3481a6c8:	e1a00009 	mov	r0, r9
3481a6cc:	eb00045d 	bl	3481b848 <strncmp>
3481a6d0:	e3500000 	cmp	r0, #0
3481a6d4:	1a000005 	bne	3481a6f0 <hmatch_r+0x78>
			*retval = &htab->table[idx].entry;
3481a6d8:	e5973000 	ldr	r3, [r7]
			return idx;
3481a6dc:	e1a00004 	mov	r0, r4
			*retval = &htab->table[idx].entry;
3481a6e0:	e0835005 	add	r5, r3, r5
3481a6e4:	e2855004 	add	r5, r5, #4
3481a6e8:	e5865000 	str	r5, [r6]
			return idx;
3481a6ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a6f0:	e2844001 	add	r4, r4, #1
3481a6f4:	e285500c 	add	r5, r5, #12
3481a6f8:	eaffffe8 	b	3481a6a0 <hmatch_r+0x28>
	__set_errno(ESRCH);
3481a6fc:	e59f3010 	ldr	r3, [pc, #16]	; 3481a714 <hmatch_r+0x9c>
3481a700:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481a704:	e3a00000 	mov	r0, #0
	__set_errno(ESRCH);
3481a708:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481a70c:	e5860000 	str	r0, [r6]
}
3481a710:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a714:	3482a918 	.word	0x3482a918

3481a718 <hsearch_r>:
{
3481a718:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a71c:	e24dd018 	sub	sp, sp, #24
3481a720:	e28dc018 	add	ip, sp, #24
3481a724:	e58d2004 	str	r2, [sp, #4]
3481a728:	e1a09003 	mov	r9, r3
3481a72c:	e90c0003 	stmdb	ip, {r0, r1}
3481a730:	e59db010 	ldr	fp, [sp, #16]
3481a734:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
3481a738:	e59da014 	ldr	sl, [sp, #20]
	unsigned int len = strlen(item.key);
3481a73c:	e1a0000b 	mov	r0, fp
3481a740:	eb000464 	bl	3481b8d8 <strlen>
3481a744:	e08b2000 	add	r2, fp, r0
	while (count-- > 0) {
3481a748:	e152000b 	cmp	r2, fp
		hval += item.key[count];
3481a74c:	15723001 	ldrbne	r3, [r2, #-1]!
3481a750:	10830200 	addne	r0, r3, r0, lsl #4
3481a754:	1afffffb 	bne	3481a748 <hsearch_r+0x30>
	hval %= htab->size;
3481a758:	e5941004 	ldr	r1, [r4, #4]
	if (htab->table[idx].used) {
3481a75c:	e3a0600c 	mov	r6, #12
3481a760:	e58d2008 	str	r2, [sp, #8]
	hval %= htab->size;
3481a764:	fa0012c4 	blx	3481f27c <__aeabi_uidivmod>
		++hval;
3481a768:	e3510000 	cmp	r1, #0
	if (htab->table[idx].used) {
3481a76c:	e59d2008 	ldr	r2, [sp, #8]
		++hval;
3481a770:	11a07001 	movne	r7, r1
3481a774:	03a07001 	moveq	r7, #1
	if (htab->table[idx].used) {
3481a778:	e0060796 	mul	r6, r6, r7
3481a77c:	e5941000 	ldr	r1, [r4]
3481a780:	e7915006 	ldr	r5, [r1, r6]
3481a784:	e0810006 	add	r0, r1, r6
3481a788:	e3550000 	cmp	r5, #0
3481a78c:	0a000063 	beq	3481a920 <hsearch_r+0x208>
		if (htab->table[idx].used == -1
3481a790:	e3750001 	cmn	r5, #1
3481a794:	01a03007 	moveq	r3, r7
3481a798:	13a03000 	movne	r3, #0
		if (htab->table[idx].used == hval
3481a79c:	e1550007 	cmp	r5, r7
		if (htab->table[idx].used == -1
3481a7a0:	e58d3008 	str	r3, [sp, #8]
		if (htab->table[idx].used == hval
3481a7a4:	1a000021 	bne	3481a830 <hsearch_r+0x118>
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481a7a8:	e5901004 	ldr	r1, [r0, #4]
3481a7ac:	e1a00002 	mov	r0, r2
3481a7b0:	eb00041a 	bl	3481b820 <strcmp>
3481a7b4:	e3500000 	cmp	r0, #0
3481a7b8:	1a00001c 	bne	3481a830 <hsearch_r+0x118>
			if ((action == ENTER) && (item.data != NULL)) {
3481a7bc:	e59d7004 	ldr	r7, [sp, #4]
3481a7c0:	e35a0000 	cmp	sl, #0
3481a7c4:	e2477001 	sub	r7, r7, #1
3481a7c8:	e16f7f17 	clz	r7, r7
3481a7cc:	e1a072a7 	lsr	r7, r7, #5
3481a7d0:	03a07000 	moveq	r7, #0
3481a7d4:	e3570000 	cmp	r7, #0
3481a7d8:	0a00000f 	beq	3481a81c <hsearch_r+0x104>
				free(htab->table[idx].entry.data);
3481a7dc:	e5943000 	ldr	r3, [r4]
3481a7e0:	e0833006 	add	r3, r3, r6
3481a7e4:	e5930008 	ldr	r0, [r3, #8]
3481a7e8:	ebffbd30 	bl	34809cb0 <free>
					strdup(item.data);
3481a7ec:	e1a0000a 	mov	r0, sl
				htab->table[idx].entry.data =
3481a7f0:	e5947000 	ldr	r7, [r4]
					strdup(item.data);
3481a7f4:	eb000471 	bl	3481b9c0 <strdup>
				if (!htab->table[idx].entry.data) {
3481a7f8:	e5943000 	ldr	r3, [r4]
				htab->table[idx].entry.data =
3481a7fc:	e0877006 	add	r7, r7, r6
3481a800:	e5870008 	str	r0, [r7, #8]
				if (!htab->table[idx].entry.data) {
3481a804:	e0833006 	add	r3, r3, r6
3481a808:	e5933008 	ldr	r3, [r3, #8]
3481a80c:	e3530000 	cmp	r3, #0
3481a810:	1a000001 	bne	3481a81c <hsearch_r+0x104>
					__set_errno(ENOMEM);
3481a814:	e3a0200c 	mov	r2, #12
3481a818:	ea000069 	b	3481a9c4 <hsearch_r+0x2ac>
			*retval = &htab->table[idx].entry;
3481a81c:	e5943000 	ldr	r3, [r4]
3481a820:	e0836006 	add	r6, r3, r6
3481a824:	e2866004 	add	r6, r6, #4
3481a828:	e5896000 	str	r6, [r9]
			return idx;
3481a82c:	ea000068 	b	3481a9d4 <hsearch_r+0x2bc>
		hval2 = 1 + hval % (htab->size - 2);
3481a830:	e5941004 	ldr	r1, [r4, #4]
3481a834:	e1a00007 	mov	r0, r7
3481a838:	e1a06007 	mov	r6, r7
3481a83c:	e2411002 	sub	r1, r1, #2
3481a840:	fa00128d 	blx	3481f27c <__aeabi_uidivmod>
3481a844:	e2812001 	add	r2, r1, #1
			if (idx <= hval2)
3481a848:	e1560002 	cmp	r6, r2
3481a84c:	95941004 	ldrls	r1, [r4, #4]
				idx -= hval2;
3481a850:	80626006 	rsbhi	r6, r2, r6
3481a854:	90621001 	rsbls	r1, r2, r1
				idx = htab->size + idx - hval2;
3481a858:	90866001 	addls	r6, r6, r1
			if (idx == hval)
3481a85c:	e1560007 	cmp	r6, r7
3481a860:	0a000030 	beq	3481a928 <hsearch_r+0x210>
			if ((htab->table[idx].used == hval)
3481a864:	e3a0300c 	mov	r3, #12
3481a868:	e5941000 	ldr	r1, [r4]
3481a86c:	e0050693 	mul	r5, r3, r6
3481a870:	e0810005 	add	r0, r1, r5
3481a874:	e7911005 	ldr	r1, [r1, r5]
3481a878:	e1510007 	cmp	r1, r7
3481a87c:	1a000022 	bne	3481a90c <hsearch_r+0x1f4>
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481a880:	e5901004 	ldr	r1, [r0, #4]
3481a884:	e1a0000b 	mov	r0, fp
3481a888:	e58d200c 	str	r2, [sp, #12]
3481a88c:	eb0003e3 	bl	3481b820 <strcmp>
3481a890:	e3500000 	cmp	r0, #0
3481a894:	e59d200c 	ldr	r2, [sp, #12]
3481a898:	1a00001b 	bne	3481a90c <hsearch_r+0x1f4>
				if ((action == ENTER) && (item.data != NULL)) {
3481a89c:	e59d7004 	ldr	r7, [sp, #4]
3481a8a0:	e35a0000 	cmp	sl, #0
3481a8a4:	e2477001 	sub	r7, r7, #1
3481a8a8:	e16f7f17 	clz	r7, r7
3481a8ac:	e1a072a7 	lsr	r7, r7, #5
3481a8b0:	03a07000 	moveq	r7, #0
3481a8b4:	e3570000 	cmp	r7, #0
3481a8b8:	0a00000d 	beq	3481a8f4 <hsearch_r+0x1dc>
					free(htab->table[idx].entry.data);
3481a8bc:	e5943000 	ldr	r3, [r4]
3481a8c0:	e0833005 	add	r3, r3, r5
3481a8c4:	e5930008 	ldr	r0, [r3, #8]
3481a8c8:	ebffbcf8 	bl	34809cb0 <free>
						strdup(item.data);
3481a8cc:	e1a0000a 	mov	r0, sl
					htab->table[idx].entry.data =
3481a8d0:	e5947000 	ldr	r7, [r4]
						strdup(item.data);
3481a8d4:	eb000439 	bl	3481b9c0 <strdup>
					if (!htab->table[idx].entry.data) {
3481a8d8:	e5943000 	ldr	r3, [r4]
					htab->table[idx].entry.data =
3481a8dc:	e0877005 	add	r7, r7, r5
3481a8e0:	e5870008 	str	r0, [r7, #8]
					if (!htab->table[idx].entry.data) {
3481a8e4:	e0833005 	add	r3, r3, r5
3481a8e8:	e5933008 	ldr	r3, [r3, #8]
3481a8ec:	e3530000 	cmp	r3, #0
3481a8f0:	0affffc7 	beq	3481a814 <hsearch_r+0xfc>
				*retval = &htab->table[idx].entry;
3481a8f4:	e5943000 	ldr	r3, [r4]
3481a8f8:	e0835005 	add	r5, r3, r5
3481a8fc:	e2855004 	add	r5, r5, #4
3481a900:	e5895000 	str	r5, [r9]
				return idx;
3481a904:	e1a05006 	mov	r5, r6
3481a908:	ea000031 	b	3481a9d4 <hsearch_r+0x2bc>
		while (htab->table[idx].used);
3481a90c:	e5941000 	ldr	r1, [r4]
3481a910:	e7911005 	ldr	r1, [r1, r5]
3481a914:	e3510000 	cmp	r1, #0
3481a918:	1affffca 	bne	3481a848 <hsearch_r+0x130>
3481a91c:	ea000001 	b	3481a928 <hsearch_r+0x210>
3481a920:	e1a06007 	mov	r6, r7
	unsigned int first_deleted = 0;
3481a924:	e58d5008 	str	r5, [sp, #8]
	if (action == ENTER) {
3481a928:	e59d3004 	ldr	r3, [sp, #4]
3481a92c:	e3530001 	cmp	r3, #1
	__set_errno(ESRCH);
3481a930:	13a02003 	movne	r2, #3
	if (action == ENTER) {
3481a934:	1a000022 	bne	3481a9c4 <hsearch_r+0x2ac>
		if (htab->filled == htab->size) {
3481a938:	e5941008 	ldr	r1, [r4, #8]
3481a93c:	e5942004 	ldr	r2, [r4, #4]
3481a940:	e1510002 	cmp	r1, r2
3481a944:	0affffb2 	beq	3481a814 <hsearch_r+0xfc>
		if (first_deleted)
3481a948:	e59d3008 	ldr	r3, [sp, #8]
		htab->table[idx].used = hval;
3481a94c:	e3a0200c 	mov	r2, #12
		htab->table[idx].entry.key = strdup(item.key);
3481a950:	e1a0000b 	mov	r0, fp
		if (first_deleted)
3481a954:	e3530000 	cmp	r3, #0
3481a958:	01a03006 	moveq	r3, r6
		htab->table[idx].used = hval;
3481a95c:	e0060392 	mul	r6, r2, r3
3481a960:	e5942000 	ldr	r2, [r4]
3481a964:	e0825006 	add	r5, r2, r6
3481a968:	e7827006 	str	r7, [r2, r6]
		htab->table[idx].entry.key = strdup(item.key);
3481a96c:	eb000413 	bl	3481b9c0 <strdup>
3481a970:	e5850004 	str	r0, [r5, #4]
		htab->table[idx].entry.data = strdup(item.data);
3481a974:	e1a0000a 	mov	r0, sl
3481a978:	e5945000 	ldr	r5, [r4]
3481a97c:	eb00040f 	bl	3481b9c0 <strdup>
		if (!htab->table[idx].entry.key ||
3481a980:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.data = strdup(item.data);
3481a984:	e0855006 	add	r5, r5, r6
3481a988:	e5850008 	str	r0, [r5, #8]
		if (!htab->table[idx].entry.key ||
3481a98c:	e0836006 	add	r6, r3, r6
3481a990:	e5963004 	ldr	r3, [r6, #4]
3481a994:	e3530000 	cmp	r3, #0
3481a998:	0affff9d 	beq	3481a814 <hsearch_r+0xfc>
3481a99c:	e5963008 	ldr	r3, [r6, #8]
3481a9a0:	e3530000 	cmp	r3, #0
3481a9a4:	0affff9a 	beq	3481a814 <hsearch_r+0xfc>
		++htab->filled;
3481a9a8:	e5943008 	ldr	r3, [r4, #8]
		*retval = &htab->table[idx].entry;
3481a9ac:	e2866004 	add	r6, r6, #4
		return 1;
3481a9b0:	e59d5004 	ldr	r5, [sp, #4]
		++htab->filled;
3481a9b4:	e2833001 	add	r3, r3, #1
3481a9b8:	e5843008 	str	r3, [r4, #8]
		*retval = &htab->table[idx].entry;
3481a9bc:	e5896000 	str	r6, [r9]
		return 1;
3481a9c0:	ea000003 	b	3481a9d4 <hsearch_r+0x2bc>
	__set_errno(ESRCH);
3481a9c4:	e59f3014 	ldr	r3, [pc, #20]	; 3481a9e0 <hsearch_r+0x2c8>
	*retval = NULL;
3481a9c8:	e3a05000 	mov	r5, #0
	__set_errno(ESRCH);
3481a9cc:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481a9d0:	e5895000 	str	r5, [r9]
}
3481a9d4:	e1a00005 	mov	r0, r5
3481a9d8:	e28dd018 	add	sp, sp, #24
3481a9dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a9e0:	3482a918 	.word	0x3482a918

3481a9e4 <hdelete_r>:
{
3481a9e4:	e92d4070 	push	{r4, r5, r6, lr}
3481a9e8:	e24dd018 	sub	sp, sp, #24
	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481a9ec:	e58d1000 	str	r1, [sp]
{
3481a9f0:	e1a05001 	mov	r5, r1
	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481a9f4:	e28d1018 	add	r1, sp, #24
{
3481a9f8:	e1a06002 	mov	r6, r2
	e.key = (char *)key;
3481a9fc:	e58d0010 	str	r0, [sp, #16]
	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481aa00:	e28d300c 	add	r3, sp, #12
3481aa04:	e3a02000 	mov	r2, #0
3481aa08:	e9110003 	ldmdb	r1, {r0, r1}
3481aa0c:	ebffff41 	bl	3481a718 <hsearch_r>
3481aa10:	e2504000 	subs	r4, r0, #0
		__set_errno(ESRCH);
3481aa14:	059f3078 	ldreq	r3, [pc, #120]	; 3481aa94 <hdelete_r+0xb0>
3481aa18:	03a02003 	moveq	r2, #3
		return 0;	/* not found */
3481aa1c:	01a00004 	moveq	r0, r4
		__set_errno(ESRCH);
3481aa20:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
3481aa24:	0a000018 	beq	3481aa8c <hdelete_r+0xa8>
	if (do_apply && htab->apply != NULL)
3481aa28:	e3560000 	cmp	r6, #0
3481aa2c:	0a000007 	beq	3481aa50 <hdelete_r+0x6c>
3481aa30:	e595600c 	ldr	r6, [r5, #12]
3481aa34:	e3560000 	cmp	r6, #0
3481aa38:	0a000004 	beq	3481aa50 <hdelete_r+0x6c>
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481aa3c:	e59d000c 	ldr	r0, [sp, #12]
3481aa40:	e3a03002 	mov	r3, #2
3481aa44:	e3a02000 	mov	r2, #0
3481aa48:	e8900003 	ldm	r0, {r0, r1}
3481aa4c:	e12fff36 	blx	r6
	free((void *)ep->key);
3481aa50:	e59d300c 	ldr	r3, [sp, #12]
3481aa54:	e5930000 	ldr	r0, [r3]
3481aa58:	ebffbc94 	bl	34809cb0 <free>
	free(ep->data);
3481aa5c:	e59d300c 	ldr	r3, [sp, #12]
3481aa60:	e5930004 	ldr	r0, [r3, #4]
3481aa64:	ebffbc91 	bl	34809cb0 <free>
	htab->table[idx].used = -1;
3481aa68:	e3a0000c 	mov	r0, #12
3481aa6c:	e5953000 	ldr	r3, [r5]
3481aa70:	e0040490 	mul	r4, r0, r4
3481aa74:	e3e02000 	mvn	r2, #0
	return 1;
3481aa78:	e3a00001 	mov	r0, #1
	htab->table[idx].used = -1;
3481aa7c:	e7832004 	str	r2, [r3, r4]
	--htab->filled;
3481aa80:	e5953008 	ldr	r3, [r5, #8]
3481aa84:	e0833002 	add	r3, r3, r2
3481aa88:	e5853008 	str	r3, [r5, #8]
}
3481aa8c:	e28dd018 	add	sp, sp, #24
3481aa90:	e8bd8070 	pop	{r4, r5, r6, pc}
3481aa94:	3482a918 	.word	0x3482a918

3481aa98 <hexport_r>:
{
3481aa98:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481aa9c:	e1a05003 	mov	r5, r3
3481aaa0:	e28db01c 	add	fp, sp, #28
3481aaa4:	e24dd010 	sub	sp, sp, #16
3481aaa8:	e1a0a000 	mov	sl, r0
	ENTRY *list[htab->size];
3481aaac:	e5903004 	ldr	r3, [r0, #4]
3481aab0:	e1a03103 	lsl	r3, r3, #2
3481aab4:	e283300a 	add	r3, r3, #10
3481aab8:	e3c33007 	bic	r3, r3, #7
3481aabc:	e04dd003 	sub	sp, sp, r3
	if ((resp == NULL) || (htab == NULL)) {
3481aac0:	e2523000 	subs	r3, r2, #0
	ENTRY *list[htab->size];
3481aac4:	e50bd020 	str	sp, [fp, #-32]	; 0xffffffe0
		__set_errno(EINVAL);
3481aac8:	03a02016 	moveq	r2, #22
	if ((resp == NULL) || (htab == NULL)) {
3481aacc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
3481aad0:	0a000054 	beq	3481ac28 <hexport_r+0x190>
3481aad4:	e3a06000 	mov	r6, #0
3481aad8:	e1a07001 	mov	r7, r1
3481aadc:	e3a09001 	mov	r9, #1
3481aae0:	e1a04006 	mov	r4, r6
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
3481aae4:	e59a3004 	ldr	r3, [sl, #4]
3481aae8:	e1590003 	cmp	r9, r3
3481aaec:	8a00003f 	bhi	3481abf0 <hexport_r+0x158>
3481aaf0:	e3a0300c 	mov	r3, #12
		if (htab->table[i].used > 0) {
3481aaf4:	e59a1000 	ldr	r1, [sl]
3481aaf8:	e0020993 	mul	r2, r3, r9
3481aafc:	e0813002 	add	r3, r1, r2
3481ab00:	e7912002 	ldr	r2, [r1, r2]
3481ab04:	e3520000 	cmp	r2, #0
3481ab08:	c3a02000 	movgt	r2, #0
3481ab0c:	da000035 	ble	3481abe8 <hexport_r+0x150>
			for (arg = 0; arg < argc; ++arg) {
3481ab10:	e59b1004 	ldr	r1, [fp, #4]
3481ab14:	e1520001 	cmp	r2, r1
3481ab18:	aa00000b 	bge	3481ab4c <hexport_r+0xb4>
				if (strcmp(argv[arg], ep->key) == 0) {
3481ab1c:	e5931004 	ldr	r1, [r3, #4]
3481ab20:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
3481ab24:	e59b3008 	ldr	r3, [fp, #8]
3481ab28:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
3481ab2c:	e7930102 	ldr	r0, [r3, r2, lsl #2]
3481ab30:	eb00033a 	bl	3481b820 <strcmp>
3481ab34:	e3500000 	cmp	r0, #0
3481ab38:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
3481ab3c:	0a000004 	beq	3481ab54 <hexport_r+0xbc>
			for (arg = 0; arg < argc; ++arg) {
3481ab40:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
3481ab44:	e2822001 	add	r2, r2, #1
3481ab48:	eafffff0 	b	3481ab10 <hexport_r+0x78>
			int arg, found = 0;
3481ab4c:	e3a02000 	mov	r2, #0
3481ab50:	ea000000 	b	3481ab58 <hexport_r+0xc0>
					found = 1;
3481ab54:	e3a02001 	mov	r2, #1
			if ((argc > 0) && (found == 0))
3481ab58:	e59b1004 	ldr	r1, [fp, #4]
3481ab5c:	e2222001 	eor	r2, r2, #1
3481ab60:	e3510000 	cmp	r1, #0
3481ab64:	d3a02000 	movle	r2, #0
3481ab68:	c2022001 	andgt	r2, r2, #1
3481ab6c:	e3520000 	cmp	r2, #0
3481ab70:	1a00001c 	bne	3481abe8 <hexport_r+0x150>
			list[n++] = ep;
3481ab74:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
3481ab78:	e2862001 	add	r2, r6, #1
3481ab7c:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
			ENTRY *ep = &htab->table[i].entry;
3481ab80:	e2832004 	add	r2, r3, #4
			totlen += strlen(ep->key) + 2;
3481ab84:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
3481ab88:	e2844002 	add	r4, r4, #2
			list[n++] = ep;
3481ab8c:	e7812106 	str	r2, [r1, r6, lsl #2]
			totlen += strlen(ep->key) + 2;
3481ab90:	e5930004 	ldr	r0, [r3, #4]
3481ab94:	eb00034f 	bl	3481b8d8 <strlen>
			if (sep == '\0') {
3481ab98:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
3481ab9c:	e3570000 	cmp	r7, #0
			totlen += strlen(ep->key) + 2;
3481aba0:	e0844000 	add	r4, r4, r0
3481aba4:	15933008 	ldrne	r3, [r3, #8]
3481aba8:	12433001 	subne	r3, r3, #1
			if (sep == '\0') {
3481abac:	1a000003 	bne	3481abc0 <hexport_r+0x128>
				totlen += strlen(ep->data);
3481abb0:	e5930008 	ldr	r0, [r3, #8]
3481abb4:	eb000347 	bl	3481b8d8 <strlen>
3481abb8:	e0844000 	add	r4, r4, r0
3481abbc:	ea000007 	b	3481abe0 <hexport_r+0x148>
				while (*s) {
3481abc0:	e5f32001 	ldrb	r2, [r3, #1]!
3481abc4:	e3520000 	cmp	r2, #0
3481abc8:	0a000004 	beq	3481abe0 <hexport_r+0x148>
					if ((*s == sep) || (*s == '\\'))
3481abcc:	e352005c 	cmp	r2, #92	; 0x5c
3481abd0:	11520007 	cmpne	r2, r7
					++totlen;
3481abd4:	12844001 	addne	r4, r4, #1
						++totlen;
3481abd8:	02844002 	addeq	r4, r4, #2
3481abdc:	eafffff7 	b	3481abc0 <hexport_r+0x128>
			list[n++] = ep;
3481abe0:	e51b6028 	ldr	r6, [fp, #-40]	; 0xffffffd8
			totlen += 2;	/* for '=' and 'sep' char */
3481abe4:	e2844002 	add	r4, r4, #2
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
3481abe8:	e2899001 	add	r9, r9, #1
3481abec:	eaffffbc 	b	3481aae4 <hexport_r+0x4c>
	qsort(list, n, sizeof(ENTRY *), cmpkey);
3481abf0:	e3a02004 	mov	r2, #4
3481abf4:	e59f3124 	ldr	r3, [pc, #292]	; 3481ad20 <hexport_r+0x288>
3481abf8:	e1a01006 	mov	r1, r6
3481abfc:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
3481ac00:	eb00029b 	bl	3481b674 <qsort>
	if (size) {
3481ac04:	e3550000 	cmp	r5, #0
3481ac08:	e2842001 	add	r2, r4, #1
3481ac0c:	0a000009 	beq	3481ac38 <hexport_r+0x1a0>
		if (size < totlen + 1) {	/* provided buffer too small */
3481ac10:	e1550002 	cmp	r5, r2
3481ac14:	2a000008 	bcs	3481ac3c <hexport_r+0x1a4>
			printf("Env export buffer too small: %zu, "
3481ac18:	e1a01005 	mov	r1, r5
3481ac1c:	e59f0100 	ldr	r0, [pc, #256]	; 3481ad24 <hexport_r+0x28c>
3481ac20:	ebffbadd 	bl	3480979c <printf>
			__set_errno(ENOMEM);
3481ac24:	e3a0200c 	mov	r2, #12
3481ac28:	e59f30f8 	ldr	r3, [pc, #248]	; 3481ad28 <hexport_r+0x290>
			return (-1);
3481ac2c:	e3e00000 	mvn	r0, #0
			__set_errno(ENOMEM);
3481ac30:	e5832000 	str	r2, [r3]
			return (-1);
3481ac34:	ea000037 	b	3481ad18 <hexport_r+0x280>
		size = totlen + 1;
3481ac38:	e1a05002 	mov	r5, r2
	if (*resp) {
3481ac3c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
3481ac40:	e5934000 	ldr	r4, [r3]
3481ac44:	e3540000 	cmp	r4, #0
3481ac48:	0a000008 	beq	3481ac70 <hexport_r+0x1d8>
		memset(res, '\0', size);
3481ac4c:	e1a02005 	mov	r2, r5
3481ac50:	e3a01000 	mov	r1, #0
3481ac54:	e1a00004 	mov	r0, r4
3481ac58:	eb0003c7 	bl	3481bb7c <memset>
3481ac5c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
			*p++ = *s++;
3481ac60:	e3a00000 	mov	r0, #0
		*p++ = '=';
3481ac64:	e3a0c03d 	mov	ip, #61	; 0x3d
				*p++ = '\\';	/* escape */
3481ac68:	e3a0e05c 	mov	lr, #92	; 0x5c
3481ac6c:	ea00000a 	b	3481ac9c <hexport_r+0x204>
		*resp = res = calloc(1, size);
3481ac70:	e1a01005 	mov	r1, r5
3481ac74:	e3a00001 	mov	r0, #1
3481ac78:	ebffbe0c 	bl	3480a4b0 <calloc>
3481ac7c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
		if (res == NULL) {
3481ac80:	e3500000 	cmp	r0, #0
		*resp = res = calloc(1, size);
3481ac84:	e1a04000 	mov	r4, r0
3481ac88:	e5830000 	str	r0, [r3]
		if (res == NULL) {
3481ac8c:	1afffff2 	bne	3481ac5c <hexport_r+0x1c4>
3481ac90:	eaffffe3 	b	3481ac24 <hexport_r+0x18c>
	for (i = 0, p = res; i < n; ++i) {
3481ac94:	e2800001 	add	r0, r0, #1
		*p++ = sep;
3481ac98:	e5c37000 	strb	r7, [r3]
	for (i = 0, p = res; i < n; ++i) {
3481ac9c:	e1500006 	cmp	r0, r6
3481aca0:	0a000019 	beq	3481ad0c <hexport_r+0x274>
		s = list[i]->key;
3481aca4:	e5923000 	ldr	r3, [r2]
3481aca8:	e1a09002 	mov	r9, r2
3481acac:	e5931000 	ldr	r1, [r3]
3481acb0:	e2411001 	sub	r1, r1, #1
		while (*s)
3481acb4:	e5f1a001 	ldrb	sl, [r1, #1]!
3481acb8:	e2843001 	add	r3, r4, #1
3481acbc:	e35a0000 	cmp	sl, #0
			*p++ = *s++;
3481acc0:	11a04003 	movne	r4, r3
3481acc4:	1543a001 	strbne	sl, [r3, #-1]
3481acc8:	1afffff9 	bne	3481acb4 <hexport_r+0x21c>
		*p++ = '=';
3481accc:	e5c4c000 	strb	ip, [r4]
3481acd0:	e2822004 	add	r2, r2, #4
		s = list[i]->data;
3481acd4:	e5991000 	ldr	r1, [r9]
3481acd8:	e5919004 	ldr	r9, [r1, #4]
		while (*s) {
3481acdc:	e5d91000 	ldrb	r1, [r9]
3481ace0:	e2834001 	add	r4, r3, #1
3481ace4:	e3510000 	cmp	r1, #0
3481ace8:	0affffe9 	beq	3481ac94 <hexport_r+0x1fc>
			if ((*s == sep) || (*s == '\\'))
3481acec:	e351005c 	cmp	r1, #92	; 0x5c
3481acf0:	11510007 	cmpne	r1, r7
				*p++ = '\\';	/* escape */
3481acf4:	05c3e000 	strbeq	lr, [r3]
3481acf8:	01a03004 	moveq	r3, r4
			*p++ = *s++;
3481acfc:	e4d91001 	ldrb	r1, [r9], #1
3481ad00:	e2833001 	add	r3, r3, #1
3481ad04:	e5431001 	strb	r1, [r3, #-1]
3481ad08:	eafffff3 	b	3481acdc <hexport_r+0x244>
	return size;
3481ad0c:	e1a00005 	mov	r0, r5
	*p = '\0';		/* terminate result */
3481ad10:	e3a03000 	mov	r3, #0
3481ad14:	e5c43000 	strb	r3, [r4]
}
3481ad18:	e24bd01c 	sub	sp, fp, #28
3481ad1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ad20:	3481a414 	.word	0x3481a414
3481ad24:	34826c6c 	.word	0x34826c6c
3481ad28:	3482a918 	.word	0x3482a918

3481ad2c <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481ad2c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481ad30:	e28db01c 	add	fp, sp, #28
3481ad34:	e24dd020 	sub	sp, sp, #32
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481ad38:	e3500000 	cmp	r0, #0
	char *localvars[nvars];
3481ad3c:	e59bc008 	ldr	ip, [fp, #8]
3481ad40:	e1a0510c 	lsl	r5, ip, #2
3481ad44:	e285c00a 	add	ip, r5, #10
3481ad48:	e3ccc007 	bic	ip, ip, #7
3481ad4c:	e04dd00c 	sub	sp, sp, ip
3481ad50:	e28dc008 	add	ip, sp, #8
3481ad54:	e50bc030 	str	ip, [fp, #-48]	; 0xffffffd0
		__set_errno(EINVAL);
3481ad58:	059f3360 	ldreq	r3, [pc, #864]	; 3481b0c0 <himport_r+0x394>
3481ad5c:	03a02016 	moveq	r2, #22
		return 0;
3481ad60:	01a05000 	moveq	r5, r0
		__set_errno(EINVAL);
3481ad64:	05832000 	streq	r2, [r3]
		return 0;
3481ad68:	0a0000d1 	beq	3481b0b4 <himport_r+0x388>
3481ad6c:	e1a06000 	mov	r6, r0
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
3481ad70:	e1a00002 	mov	r0, r2
3481ad74:	e1a07003 	mov	r7, r3
3481ad78:	e1a04002 	mov	r4, r2
3481ad7c:	e1a0a001 	mov	sl, r1
3481ad80:	ebffbc54 	bl	34809ed8 <malloc>
3481ad84:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
3481ad88:	059f3330 	ldreq	r3, [pc, #816]	; 3481b0c0 <himport_r+0x394>
3481ad8c:	03a0200c 	moveq	r2, #12
		return 0;
3481ad90:	01a05009 	moveq	r5, r9
		__set_errno(ENOMEM);
3481ad94:	05832000 	streq	r2, [r3]
		return 0;
3481ad98:	0a0000c5 	beq	3481b0b4 <himport_r+0x388>
	}
	memcpy(data, env, size);
3481ad9c:	e1a02004 	mov	r2, r4
3481ada0:	e1a0100a 	mov	r1, sl
3481ada4:	eb000394 	bl	3481bbfc <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
3481ada8:	e59b3008 	ldr	r3, [fp, #8]
3481adac:	e3530000 	cmp	r3, #0
3481adb0:	0a000003 	beq	3481adc4 <himport_r+0x98>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
3481adb4:	e1a02005 	mov	r2, r5
3481adb8:	e59b100c 	ldr	r1, [fp, #12]
3481adbc:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
3481adc0:	eb00038d 	bl	3481bbfc <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
3481adc4:	e59b3004 	ldr	r3, [fp, #4]
3481adc8:	e3130001 	tst	r3, #1
3481adcc:	1a000005 	bne	3481ade8 <himport_r+0xbc>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
3481add0:	e5963000 	ldr	r3, [r6]
3481add4:	e3530000 	cmp	r3, #0
3481add8:	0a000002 	beq	3481ade8 <himport_r+0xbc>
			hdestroy_r(htab, do_apply);
3481addc:	e59b1010 	ldr	r1, [fp, #16]
3481ade0:	e1a00006 	mov	r0, r6
3481ade4:	ebfffdcf 	bl	3481a528 <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
3481ade8:	e5963000 	ldr	r3, [r6]
3481adec:	e3530000 	cmp	r3, #0
3481adf0:	0a000003 	beq	3481ae04 <himport_r+0xd8>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481adf4:	e0893004 	add	r3, r9, r4
			nent = CONFIG_ENV_MAX_ENTRIES;
3481adf8:	e1a05009 	mov	r5, r9
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481adfc:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
3481ae00:	ea000019 	b	3481ae6c <himport_r+0x140>
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
3481ae04:	e1a001a4 	lsr	r0, r4, #3
		if (hcreate_r(nent, htab) == 0) {
3481ae08:	e1a01006 	mov	r1, r6
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
3481ae0c:	e2800040 	add	r0, r0, #64	; 0x40
		if (hcreate_r(nent, htab) == 0) {
3481ae10:	e3500c02 	cmp	r0, #512	; 0x200
3481ae14:	23a00c02 	movcs	r0, #512	; 0x200
3481ae18:	ebfffd96 	bl	3481a478 <hcreate_r>
3481ae1c:	e2505000 	subs	r5, r0, #0
3481ae20:	1afffff3 	bne	3481adf4 <himport_r+0xc8>
			free(data);
3481ae24:	e1a00009 	mov	r0, r9
3481ae28:	ebffbba0 	bl	34809cb0 <free>
			return 0;
3481ae2c:	ea0000a0 	b	3481b0b4 <himport_r+0x388>
		if (*dp == '#') {
3481ae30:	e3530023 	cmp	r3, #35	; 0x23
3481ae34:	11a00005 	movne	r0, r5
3481ae38:	1a000011 	bne	3481ae84 <himport_r+0x158>
			while (*dp && (*dp != sep))
3481ae3c:	e4d53001 	ldrb	r3, [r5], #1
3481ae40:	e3530000 	cmp	r3, #0
3481ae44:	11530007 	cmpne	r3, r7
3481ae48:	1afffffb 	bne	3481ae3c <himport_r+0x110>
			++dp;
3481ae4c:	e1a04005 	mov	r4, r5
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481ae50:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
3481ae54:	e1540003 	cmp	r4, r3
3481ae58:	2a00007f 	bcs	3481b05c <himport_r+0x330>
3481ae5c:	e5d43000 	ldrb	r3, [r4]
3481ae60:	e3530000 	cmp	r3, #0
3481ae64:	0a00007c 	beq	3481b05c <himport_r+0x330>
			nent = CONFIG_ENV_MAX_ENTRIES;
3481ae68:	e1a05004 	mov	r5, r4
		while (isblank(*dp))
3481ae6c:	e5d53000 	ldrb	r3, [r5]
3481ae70:	e3530020 	cmp	r3, #32
3481ae74:	13530009 	cmpne	r3, #9
3481ae78:	1affffec 	bne	3481ae30 <himport_r+0x104>
			++dp;
3481ae7c:	e2854001 	add	r4, r5, #1
3481ae80:	eafffff8 	b	3481ae68 <himport_r+0x13c>
3481ae84:	e1a03000 	mov	r3, r0
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481ae88:	e4d02001 	ldrb	r2, [r0], #1
3481ae8c:	e3520000 	cmp	r2, #0
3481ae90:	1352003d 	cmpne	r2, #61	; 0x3d
3481ae94:	13a01001 	movne	r1, #1
3481ae98:	03a01000 	moveq	r1, #0
3481ae9c:	e1520007 	cmp	r2, r7
3481aea0:	03a01000 	moveq	r1, #0
3481aea4:	12011001 	andne	r1, r1, #1
3481aea8:	e3510000 	cmp	r1, #0
3481aeac:	1afffff4 	bne	3481ae84 <himport_r+0x158>
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481aeb0:	e3520000 	cmp	r2, #0
3481aeb4:	e1a00003 	mov	r0, r3
3481aeb8:	0a00000b 	beq	3481aeec <himport_r+0x1c0>
3481aebc:	e5d31001 	ldrb	r1, [r3, #1]
3481aec0:	e3510000 	cmp	r1, #0
3481aec4:	0a000004 	beq	3481aedc <himport_r+0x1b0>
		    *dp == sep || *(dp + 1) == sep) {
3481aec8:	e1520007 	cmp	r2, r7
3481aecc:	11510007 	cmpne	r1, r7
3481aed0:	03a01001 	moveq	r1, #1
3481aed4:	13a01000 	movne	r1, #0
3481aed8:	1a000015 	bne	3481af34 <himport_r+0x208>
			if (*dp == '=')
3481aedc:	e352003d 	cmp	r2, #61	; 0x3d
				*dp++ = '\0';
3481aee0:	02833001 	addeq	r3, r3, #1
3481aee4:	03a02000 	moveq	r2, #0
3481aee8:	05c02000 	strbeq	r2, [r0]
			*dp++ = '\0';	/* terminate name */
3481aeec:	e3a02000 	mov	r2, #0
3481aef0:	e2834001 	add	r4, r3, #1
3481aef4:	e5c32000 	strb	r2, [r3]
	if (nvars == 0)
3481aef8:	e59b3008 	ldr	r3, [fp, #8]
3481aefc:	e3530000 	cmp	r3, #0
3481af00:	1a000004 	bne	3481af18 <himport_r+0x1ec>
			if (hdelete_r(name, htab, do_apply) == 0)
3481af04:	e59b2010 	ldr	r2, [fp, #16]
3481af08:	e1a01006 	mov	r1, r6
3481af0c:	e1a00005 	mov	r0, r5
3481af10:	ebfffeb3 	bl	3481a9e4 <hdelete_r>
			continue;
3481af14:	eaffffcd 	b	3481ae50 <himport_r+0x124>
3481af18:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
3481af1c:	e1a00005 	mov	r0, r5
3481af20:	e59b1008 	ldr	r1, [fp, #8]
3481af24:	ebfffd3f 	bl	3481a428 <drop_var_from_set.part.0>
			if (!drop_var_from_set(name, nvars, localvars))
3481af28:	e3500000 	cmp	r0, #0
3481af2c:	0affffc7 	beq	3481ae50 <himport_r+0x124>
3481af30:	eafffff3 	b	3481af04 <himport_r+0x1d8>
		*dp++ = '\0';	/* terminate name */
3481af34:	e283a001 	add	sl, r3, #1
3481af38:	e5c31000 	strb	r1, [r3]
3481af3c:	e1a0400a 	mov	r4, sl
3481af40:	e1a0200a 	mov	r2, sl
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481af44:	e5d43000 	ldrb	r3, [r4]
3481af48:	e3530000 	cmp	r3, #0
3481af4c:	11530007 	cmpne	r3, r7
3481af50:	13a01001 	movne	r1, #1
3481af54:	03a01000 	moveq	r1, #0
3481af58:	0a000007 	beq	3481af7c <himport_r+0x250>
			if ((*dp == '\\') && *(dp + 1))
3481af5c:	e353005c 	cmp	r3, #92	; 0x5c
3481af60:	1a000002 	bne	3481af70 <himport_r+0x244>
3481af64:	e5d43001 	ldrb	r3, [r4, #1]
3481af68:	e3530000 	cmp	r3, #0
				++dp;
3481af6c:	12844001 	addne	r4, r4, #1
			*sp++ = *dp;
3481af70:	e4d43001 	ldrb	r3, [r4], #1
3481af74:	e4c23001 	strb	r3, [r2], #1
3481af78:	eafffff1 	b	3481af44 <himport_r+0x218>
	if (nvars == 0)
3481af7c:	e59b3008 	ldr	r3, [fp, #8]
		++dp;
3481af80:	e2844001 	add	r4, r4, #1
		*sp++ = '\0';	/* terminate value */
3481af84:	e5c21000 	strb	r1, [r2]
	if (nvars == 0)
3481af88:	e3530000 	cmp	r3, #0
3481af8c:	1a000005 	bne	3481afa8 <himport_r+0x27c>
		if (do_apply && htab->apply != NULL) {
3481af90:	e59b3010 	ldr	r3, [fp, #16]
		e.key = name;
3481af94:	e50b5024 	str	r5, [fp, #-36]	; 0xffffffdc
		e.data = value;
3481af98:	e50ba020 	str	sl, [fp, #-32]	; 0xffffffe0
		if (do_apply && htab->apply != NULL) {
3481af9c:	e3530000 	cmp	r3, #0
3481afa0:	1a000007 	bne	3481afc4 <himport_r+0x298>
3481afa4:	ea000009 	b	3481afd0 <himport_r+0x2a4>
3481afa8:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
3481afac:	e1a00005 	mov	r0, r5
3481afb0:	e59b1008 	ldr	r1, [fp, #8]
3481afb4:	ebfffd1b 	bl	3481a428 <drop_var_from_set.part.0>
		if (!drop_var_from_set(name, nvars, localvars))
3481afb8:	e3500000 	cmp	r0, #0
3481afbc:	0affffa3 	beq	3481ae50 <himport_r+0x124>
3481afc0:	eafffff2 	b	3481af90 <himport_r+0x264>
		if (do_apply && htab->apply != NULL) {
3481afc4:	e596300c 	ldr	r3, [r6, #12]
3481afc8:	e3530000 	cmp	r3, #0
3481afcc:	1a000010 	bne	3481b014 <himport_r+0x2e8>
		hsearch_r(e, ENTER, &rv, htab);
3481afd0:	e24b101c 	sub	r1, fp, #28
3481afd4:	e58d6000 	str	r6, [sp]
3481afd8:	e24b3028 	sub	r3, fp, #40	; 0x28
3481afdc:	e3a02001 	mov	r2, #1
3481afe0:	e9110003 	ldmdb	r1, {r0, r1}
3481afe4:	ebfffdcb 	bl	3481a718 <hsearch_r>
		if (rv == NULL) {
3481afe8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
3481afec:	e3530000 	cmp	r3, #0
3481aff0:	1affff96 	bne	3481ae50 <himport_r+0x124>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
3481aff4:	e1a01005 	mov	r1, r5
3481aff8:	e1a0200a 	mov	r2, sl
3481affc:	e59f00c0 	ldr	r0, [pc, #192]	; 3481b0c4 <himport_r+0x398>
3481b000:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
3481b004:	ebffb9e4 	bl	3480979c <printf>
			return 0;
3481b008:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
3481b00c:	e1a05003 	mov	r5, r3
3481b010:	ea000027 	b	3481b0b4 <himport_r+0x388>
			hsearch_r(e, FIND, &rv, htab);
3481b014:	e24b101c 	sub	r1, fp, #28
3481b018:	e58d6000 	str	r6, [sp]
3481b01c:	e24b3028 	sub	r3, fp, #40	; 0x28
3481b020:	e3a02000 	mov	r2, #0
3481b024:	e9110003 	ldmdb	r1, {r0, r1}
3481b028:	ebfffdba 	bl	3481a718 <hsearch_r>
			if (htab->apply(name, rv ? rv->data : NULL,
3481b02c:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
3481b030:	e1a0200a 	mov	r2, sl
3481b034:	e596300c 	ldr	r3, [r6, #12]
3481b038:	e1a00005 	mov	r0, r5
3481b03c:	e3510000 	cmp	r1, #0
3481b040:	e1a0c003 	mov	ip, r3
3481b044:	15911004 	ldrne	r1, [r1, #4]
3481b048:	e59b3004 	ldr	r3, [fp, #4]
3481b04c:	e12fff3c 	blx	ip
3481b050:	e3500000 	cmp	r0, #0
3481b054:	1affff7d 	bne	3481ae50 <himport_r+0x124>
3481b058:	eaffffdc 	b	3481afd0 <himport_r+0x2a4>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481b05c:	e1a00009 	mov	r0, r9

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481b060:	e3a05000 	mov	r5, #0
	free(data);
3481b064:	ebffbb11 	bl	34809cb0 <free>
3481b068:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
3481b06c:	e2434004 	sub	r4, r3, #4
	for (i = 0; i < nvars; i++) {
3481b070:	e59b3008 	ldr	r3, [fp, #8]
3481b074:	e1550003 	cmp	r5, r3
3481b078:	aa00000c 	bge	3481b0b0 <himport_r+0x384>
		if (localvars[i] == NULL)
3481b07c:	e5b40004 	ldr	r0, [r4, #4]!
3481b080:	e3500000 	cmp	r0, #0
3481b084:	0a000007 	beq	3481b0a8 <himport_r+0x37c>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, do_apply) == 0)
3481b088:	e1a01006 	mov	r1, r6
3481b08c:	e59b2010 	ldr	r2, [fp, #16]
3481b090:	ebfffe53 	bl	3481a9e4 <hdelete_r>
3481b094:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
3481b098:	e5941000 	ldr	r1, [r4]
3481b09c:	059f0024 	ldreq	r0, [pc, #36]	; 3481b0c8 <himport_r+0x39c>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
3481b0a0:	159f0024 	ldrne	r0, [pc, #36]	; 3481b0cc <himport_r+0x3a0>
3481b0a4:	ebffb9bc 	bl	3480979c <printf>
	for (i = 0; i < nvars; i++) {
3481b0a8:	e2855001 	add	r5, r5, #1
3481b0ac:	eaffffef 	b	3481b070 <himport_r+0x344>
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
3481b0b0:	e3a05001 	mov	r5, #1
}
3481b0b4:	e1a00005 	mov	r0, r5
3481b0b8:	e24bd01c 	sub	sp, fp, #28
3481b0bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b0c0:	3482a918 	.word	0x3482a918
3481b0c4:	34826c9c 	.word	0x34826c9c
3481b0c8:	34826ccd 	.word	0x34826ccd
3481b0cc:	34826d04 	.word	0x34826d04

3481b0d0 <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481b0d0:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
3481b0d4:	e1a04001 	mov	r4, r1
3481b0d8:	e1a05000 	mov	r5, r0
  ldiv_t result;

  result.quot = numer / denom;
3481b0dc:	e1a01002 	mov	r1, r2
3481b0e0:	e1a00004 	mov	r0, r4
{
3481b0e4:	e1a07002 	mov	r7, r2
  result.quot = numer / denom;
3481b0e8:	fa00106a 	blx	3481f298 <__divsi3>
3481b0ec:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
3481b0f0:	e1a00004 	mov	r0, r4
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
3481b0f4:	e1e04004 	mvn	r4, r4
  result.rem = numer % denom;
3481b0f8:	e1a01007 	mov	r1, r7
  if (numer >= 0 && result.rem < 0)
3481b0fc:	e1a04fa4 	lsr	r4, r4, #31
  result.rem = numer % denom;
3481b100:	fa001109 	blx	3481f52c <__aeabi_idivmod>
  if (numer >= 0 && result.rem < 0)
3481b104:	e0143fa1 	ands	r3, r4, r1, lsr #31
      ++result.quot;
      result.rem -= denom;
    }

  return result;
}
3481b108:	e1a00005 	mov	r0, r5
      ++result.quot;
3481b10c:	12866001 	addne	r6, r6, #1
      result.rem -= denom;
3481b110:	10671001 	rsbne	r1, r7, r1
  return result;
3481b114:	e5856000 	str	r6, [r5]
3481b118:	e5851004 	str	r1, [r5, #4]
}
3481b11c:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

3481b120 <lmb_add_region>:
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
3481b120:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481b124:	e5905000 	ldr	r5, [r0]
3481b128:	e3550001 	cmp	r5, #1
3481b12c:	1a000005 	bne	3481b148 <lmb_add_region+0x28>
3481b130:	e590300c 	ldr	r3, [r0, #12]
3481b134:	e3530000 	cmp	r3, #0
		rgn->region[0].base = base;
3481b138:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
3481b13c:	0580200c 	streq	r2, [r0, #12]
		return 0;
3481b140:	01a00003 	moveq	r0, r3
	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481b144:	0a00005c 	beq	3481b2bc <lmb_add_region+0x19c>
3481b148:	e1a07000 	mov	r7, r0
3481b14c:	e1a0c005 	mov	ip, r5
3481b150:	e3a0e000 	mov	lr, #0
	if (base2 == base1 + size1)
3481b154:	e0816002 	add	r6, r1, r2
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481b158:	e15e0005 	cmp	lr, r5
3481b15c:	0a000010 	beq	3481b1a4 <lmb_add_region+0x84>
		phys_addr_t rgnbase = rgn->region[i].base;
3481b160:	e5974008 	ldr	r4, [r7, #8]
		phys_size_t rgnsize = rgn->region[i].size;
3481b164:	e597300c 	ldr	r3, [r7, #12]

		if ((rgnbase == base) && (rgnsize == size))
3481b168:	e1530002 	cmp	r3, r2
3481b16c:	01540001 	cmpeq	r4, r1
3481b170:	0a000036 	beq	3481b250 <lmb_add_region+0x130>
	if (base2 == base1 + size1)
3481b174:	e1540006 	cmp	r4, r6
3481b178:	0a000038 	beq	3481b260 <lmb_add_region+0x140>
	else if (base1 == base2 + size2)
3481b17c:	e0834004 	add	r4, r3, r4
3481b180:	e2877008 	add	r7, r7, #8
			rgn->region[i].base -= size;
			rgn->region[i].size += size;
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
3481b184:	e1510004 	cmp	r1, r4
3481b188:	e28e4001 	add	r4, lr, #1
			rgn->region[i].size += size;
3481b18c:	00804184 	addeq	r4, r0, r4, lsl #3
3481b190:	00833002 	addeq	r3, r3, r2
3481b194:	05843004 	streq	r3, [r4, #4]
3481b198:	0a000036 	beq	3481b278 <lmb_add_region+0x158>
	for (i=0; i < rgn->cnt; i++) {
3481b19c:	e1a0e004 	mov	lr, r4
3481b1a0:	eaffffec 	b	3481b158 <lmb_add_region+0x38>
	unsigned long coalesced = 0;
3481b1a4:	e3a03000 	mov	r3, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
3481b1a8:	e2454001 	sub	r4, r5, #1
3481b1ac:	e15e0004 	cmp	lr, r4
3481b1b0:	2a00000e 	bcs	3481b1f0 <lmb_add_region+0xd0>
3481b1b4:	e080e18e 	add	lr, r0, lr, lsl #3
3481b1b8:	e28c9001 	add	r9, ip, #1
3481b1bc:	e080c18c 	add	ip, r0, ip, lsl #3
	phys_addr_t base1 = rgn->region[r1].base;
3481b1c0:	e59ea008 	ldr	sl, [lr, #8]
	phys_size_t size2 = rgn->region[r2].size;
3481b1c4:	e59c6014 	ldr	r6, [ip, #20]
	phys_size_t size1 = rgn->region[r1].size;
3481b1c8:	e59eb00c 	ldr	fp, [lr, #12]
	phys_addr_t base2 = rgn->region[r2].base;
3481b1cc:	e59c7010 	ldr	r7, [ip, #16]
	phys_size_t size2 = rgn->region[r2].size;
3481b1d0:	e58d6004 	str	r6, [sp, #4]
	if (base2 == base1 + size1)
3481b1d4:	e08b600a 	add	r6, fp, sl
3481b1d8:	e1570006 	cmp	r7, r6
3481b1dc:	0a000028 	beq	3481b284 <lmb_add_region+0x164>
	else if (base1 == base2 + size2)
3481b1e0:	e59d6004 	ldr	r6, [sp, #4]
3481b1e4:	e0867007 	add	r7, r6, r7
3481b1e8:	e15a0007 	cmp	sl, r7
3481b1ec:	0a000024 	beq	3481b284 <lmb_add_region+0x164>
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
	}

	if (coalesced)
3481b1f0:	e3530000 	cmp	r3, #0
3481b1f4:	13a00001 	movne	r0, #1
3481b1f8:	1a00002f 	bne	3481b2bc <lmb_add_region+0x19c>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481b1fc:	e3550007 	cmp	r5, #7
3481b200:	90803185 	addls	r3, r0, r5, lsl #3
3481b204:	8a000013 	bhi	3481b258 <lmb_add_region+0x138>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481b208:	e3740001 	cmn	r4, #1
3481b20c:	0a000009 	beq	3481b238 <lmb_add_region+0x118>
		if (base < rgn->region[i].base) {
3481b210:	e413c008 	ldr	ip, [r3], #-8
3481b214:	e151000c 	cmp	r1, ip
			rgn->region[i+1].base = rgn->region[i].base;
3481b218:	3583c010 	strcc	ip, [r3, #16]
	for (i = rgn->cnt-1; i >= 0; i--) {
3481b21c:	32444001 	subcc	r4, r4, #1
			rgn->region[i+1].size = rgn->region[i].size;
3481b220:	3593c00c 	ldrcc	ip, [r3, #12]
3481b224:	3583c014 	strcc	ip, [r3, #20]
3481b228:	3afffff6 	bcc	3481b208 <lmb_add_region+0xe8>
3481b22c:	e0804184 	add	r4, r0, r4, lsl #3
		} else {
			rgn->region[i+1].base = base;
3481b230:	e5841010 	str	r1, [r4, #16]
			rgn->region[i+1].size = size;
3481b234:	e5842014 	str	r2, [r4, #20]
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481b238:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
3481b23c:	e2855001 	add	r5, r5, #1
3481b240:	e5805000 	str	r5, [r0]
	if (base < rgn->region[0].base) {
3481b244:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
3481b248:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
3481b24c:	3580200c 	strcc	r2, [r0, #12]
			return 0;
3481b250:	e3a00000 	mov	r0, #0
3481b254:	ea000018 	b	3481b2bc <lmb_add_region+0x19c>
		return -1;
3481b258:	e3e00000 	mvn	r0, #0
3481b25c:	ea000016 	b	3481b2bc <lmb_add_region+0x19c>
3481b260:	e080318e 	add	r3, r0, lr, lsl #3
			rgn->region[i].base -= size;
3481b264:	e0626006 	rsb	r6, r2, r6
			rgn->region[i].size += size;
3481b268:	e593c00c 	ldr	ip, [r3, #12]
			rgn->region[i].base -= size;
3481b26c:	e5836008 	str	r6, [r3, #8]
			rgn->region[i].size += size;
3481b270:	e08cc002 	add	ip, ip, r2
3481b274:	e583c00c 	str	ip, [r3, #12]
			break;
3481b278:	e1a0c00e 	mov	ip, lr
			coalesced++;
3481b27c:	e3a03001 	mov	r3, #1
			break;
3481b280:	eaffffc8 	b	3481b1a8 <lmb_add_region+0x88>
	rgn->region[r1].size += rgn->region[r2].size;
3481b284:	e59d2004 	ldr	r2, [sp, #4]
3481b288:	e082600b 	add	r6, r2, fp
3481b28c:	e58e600c 	str	r6, [lr, #12]
	for (i = r; i < rgn->cnt - 1; i++) {
3481b290:	e1590004 	cmp	r9, r4
3481b294:	e28cc008 	add	ip, ip, #8
3481b298:	2a000005 	bcs	3481b2b4 <lmb_add_region+0x194>
		rgn->region[i].base = rgn->region[i + 1].base;
3481b29c:	e59c2010 	ldr	r2, [ip, #16]
3481b2a0:	e2899001 	add	r9, r9, #1
3481b2a4:	e58c2008 	str	r2, [ip, #8]
		rgn->region[i].size = rgn->region[i + 1].size;
3481b2a8:	e59c2014 	ldr	r2, [ip, #20]
3481b2ac:	e58c200c 	str	r2, [ip, #12]
3481b2b0:	eafffff6 	b	3481b290 <lmb_add_region+0x170>
	rgn->cnt--;
3481b2b4:	e5804000 	str	r4, [r0]
		coalesced++;
3481b2b8:	e2830001 	add	r0, r3, #1

	return 0;
}
3481b2bc:	e28dd008 	add	sp, sp, #8
3481b2c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481b2c4 <lmb_dump_all>:
{
3481b2c4:	e12fff1e 	bx	lr

3481b2c8 <lmb_init>:
	lmb->memory.region[0].base = 0;
3481b2c8:	e3a03000 	mov	r3, #0
	lmb->memory.cnt = 1;
3481b2cc:	e3a02001 	mov	r2, #1
	lmb->memory.region[0].base = 0;
3481b2d0:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
3481b2d4:	e580300c 	str	r3, [r0, #12]
	lmb->memory.size = 0;
3481b2d8:	e880000c 	stm	r0, {r2, r3}
	lmb->reserved.region[0].base = 0;
3481b2dc:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
3481b2e0:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
3481b2e4:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
3481b2e8:	e5803054 	str	r3, [r0, #84]	; 0x54
3481b2ec:	e12fff1e 	bx	lr

3481b2f0 <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
3481b2f0:	eaffff8a 	b	3481b120 <lmb_add_region>

3481b2f4 <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
3481b2f4:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481b2f8:	e3a03000 	mov	r3, #0
3481b2fc:	e5905050 	ldr	r5, [r0, #80]	; 0x50
{
3481b300:	e1a0e001 	mov	lr, r1
3481b304:	e1a07000 	mov	r7, r0
	phys_addr_t end = base + size;
3481b308:	e0811002 	add	r1, r1, r2
	rgnbegin = rgnend = 0; /* supress gcc warnings */
3481b30c:	e1a04003 	mov	r4, r3
3481b310:	e1a0c003 	mov	ip, r3
	for (i=0; i < rgn->cnt; i++) {
3481b314:	e1530005 	cmp	r3, r5
3481b318:	e1a06003 	mov	r6, r3
3481b31c:	0a000007 	beq	3481b340 <lmb_free+0x4c>
		rgnbegin = rgn->region[i].base;
3481b320:	e597c058 	ldr	ip, [r7, #88]	; 0x58
3481b324:	e2877008 	add	r7, r7, #8
		rgnend = rgnbegin + rgn->region[i].size;
3481b328:	e5974054 	ldr	r4, [r7, #84]	; 0x54
3481b32c:	e08c4004 	add	r4, ip, r4

		if ((rgnbegin <= base) && (end <= rgnend))
3481b330:	e1510004 	cmp	r1, r4
3481b334:	915c000e 	cmpls	ip, lr
	for (i=0; i < rgn->cnt; i++) {
3481b338:	82833001 	addhi	r3, r3, #1
3481b33c:	8afffff4 	bhi	3481b314 <lmb_free+0x20>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
3481b340:	e1530005 	cmp	r3, r5
3481b344:	0a000029 	beq	3481b3f0 <lmb_free+0xfc>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
3481b348:	e06ec00c 	rsb	ip, lr, ip
3481b34c:	e0617004 	rsb	r7, r1, r4
3481b350:	e16fcf1c 	clz	ip, ip
3481b354:	e16f7f17 	clz	r7, r7
3481b358:	e1a0c2ac 	lsr	ip, ip, #5
3481b35c:	e1a072a7 	lsr	r7, r7, #5
3481b360:	e1a03183 	lsl	r3, r3, #3
3481b364:	e017900c 	ands	r9, r7, ip
3481b368:	10803003 	addne	r3, r0, r3
	for (i = r; i < rgn->cnt - 1; i++) {
3481b36c:	12452001 	subne	r2, r5, #1
	if ((rgnbegin == base) && (rgnend == end)) {
3481b370:	0a00000b 	beq	3481b3a4 <lmb_free+0xb0>
	for (i = r; i < rgn->cnt - 1; i++) {
3481b374:	e1560002 	cmp	r6, r2
3481b378:	e2833008 	add	r3, r3, #8
3481b37c:	2a000005 	bcs	3481b398 <lmb_free+0xa4>
		rgn->region[i].base = rgn->region[i + 1].base;
3481b380:	e5931058 	ldr	r1, [r3, #88]	; 0x58
3481b384:	e2866001 	add	r6, r6, #1
3481b388:	e5831050 	str	r1, [r3, #80]	; 0x50
		rgn->region[i].size = rgn->region[i + 1].size;
3481b38c:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
3481b390:	e5831054 	str	r1, [r3, #84]	; 0x54
3481b394:	eafffff6 	b	3481b374 <lmb_free+0x80>
	rgn->cnt--;
3481b398:	e5802050 	str	r2, [r0, #80]	; 0x50
		lmb_remove_region(rgn, i);
		return 0;
3481b39c:	e3a00000 	mov	r0, #0
3481b3a0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
3481b3a4:	e35c0000 	cmp	ip, #0
3481b3a8:	10803003 	addne	r3, r0, r3
		rgn->region[i].base = end;
3481b3ac:	15831058 	strne	r1, [r3, #88]	; 0x58
	if (rgnbegin == base) {
3481b3b0:	1a000002 	bne	3481b3c0 <lmb_free+0xcc>
		rgn->region[i].size -= size;
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
3481b3b4:	e3570000 	cmp	r7, #0
3481b3b8:	0a000004 	beq	3481b3d0 <lmb_free+0xdc>
3481b3bc:	e0803003 	add	r3, r0, r3
		rgn->region[i].size -= size;
3481b3c0:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
3481b3c4:	e0622001 	rsb	r2, r2, r1
3481b3c8:	e583205c 	str	r2, [r3, #92]	; 0x5c
3481b3cc:	eafffff2 	b	3481b39c <lmb_free+0xa8>
3481b3d0:	e080c003 	add	ip, r0, r3
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
3481b3d4:	e0612004 	rsb	r2, r1, r4
	rgn->region[i].size = base - rgn->region[i].base;
3481b3d8:	e59c3058 	ldr	r3, [ip, #88]	; 0x58
	return lmb_add_region(rgn, end, rgnend - end);
3481b3dc:	e2800050 	add	r0, r0, #80	; 0x50
	rgn->region[i].size = base - rgn->region[i].base;
3481b3e0:	e063e00e 	rsb	lr, r3, lr
3481b3e4:	e58ce05c 	str	lr, [ip, #92]	; 0x5c
}
3481b3e8:	e8bd42f0 	pop	{r4, r5, r6, r7, r9, lr}
	return lmb_add_region(rgn, end, rgnend - end);
3481b3ec:	eaffff4b 	b	3481b120 <lmb_add_region>
		return -1;
3481b3f0:	e3e00000 	mvn	r0, #0
}
3481b3f4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}

3481b3f8 <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
3481b3f8:	e2800050 	add	r0, r0, #80	; 0x50
3481b3fc:	eaffff47 	b	3481b120 <lmb_add_region>

3481b400 <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
3481b400:	e92d4010 	push	{r4, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481b404:	e3a03000 	mov	r3, #0
3481b408:	e590e000 	ldr	lr, [r0]
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481b40c:	e0812002 	add	r2, r1, r2
	for (i=0; i < rgn->cnt; i++) {
3481b410:	e153000e 	cmp	r3, lr
3481b414:	0a00000d 	beq	3481b450 <lmb_overlaps_region+0x50>
		phys_addr_t rgnbase = rgn->region[i].base;
3481b418:	e5904008 	ldr	r4, [r0, #8]
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481b41c:	e590c00c 	ldr	ip, [r0, #12]
3481b420:	e084c00c 	add	ip, r4, ip
3481b424:	e151000c 	cmp	r1, ip
3481b428:	2a000005 	bcs	3481b444 <lmb_overlaps_region+0x44>
3481b42c:	e1540002 	cmp	r4, r2
3481b430:	2a000003 	bcs	3481b444 <lmb_overlaps_region+0x44>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481b434:	e153000e 	cmp	r3, lr
3481b438:	31a00003 	movcc	r0, r3
3481b43c:	23e00000 	mvncs	r0, #0
3481b440:	e8bd8010 	pop	{r4, pc}
	for (i=0; i < rgn->cnt; i++) {
3481b444:	e2833001 	add	r3, r3, #1
3481b448:	e2800008 	add	r0, r0, #8
3481b44c:	eaffffef 	b	3481b410 <lmb_overlaps_region+0x10>
	return (i < rgn->cnt) ? i : -1;
3481b450:	e3e00000 	mvn	r0, #0
}
3481b454:	e8bd8010 	pop	{r4, pc}

3481b458 <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481b458:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481b45c:	e1a0b003 	mov	fp, r3
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b460:	e5905000 	ldr	r5, [r0]
{
3481b464:	e1a09000 	mov	r9, r0
3481b468:	e1a06001 	mov	r6, r1
3481b46c:	e1a07002 	mov	r7, r2
	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b470:	e2453001 	sub	r3, r5, #1
3481b474:	e58d3004 	str	r3, [sp, #4]
3481b478:	e0805185 	add	r5, r0, r5, lsl #3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481b47c:	e2803050 	add	r3, r0, #80	; 0x50
3481b480:	e58d3008 	str	r3, [sp, #8]
	return addr & ~(size - 1);
3481b484:	e2623000 	rsb	r3, r2, #0
	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b488:	e59d2004 	ldr	r2, [sp, #4]
3481b48c:	e3520000 	cmp	r2, #0
3481b490:	ba00002c 	blt	3481b548 <__lmb_alloc_base+0xf0>
		phys_size_t lmbsize = lmb->memory.region[i].size;
3481b494:	e5954004 	ldr	r4, [r5, #4]
		phys_addr_t lmbbase = lmb->memory.region[i].base;
3481b498:	e595a000 	ldr	sl, [r5]
		if (lmbsize < size)
3481b49c:	e1540006 	cmp	r4, r6
3481b4a0:	3a00002a 	bcc	3481b550 <__lmb_alloc_base+0xf8>
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481b4a4:	e35b0000 	cmp	fp, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
3481b4a8:	008a4004 	addeq	r4, sl, r4
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481b4ac:	0a00000a 	beq	3481b4dc <__lmb_alloc_base+0x84>
		else if (lmbbase < max_addr) {
3481b4b0:	e15a000b 	cmp	sl, fp
3481b4b4:	2a000025 	bcs	3481b550 <__lmb_alloc_base+0xf8>
			base = min(lmbbase + lmbsize, max_addr);
3481b4b8:	e084400a 	add	r4, r4, sl
			base = lmb_align_down(base - size, align);
3481b4bc:	e154000b 	cmp	r4, fp
3481b4c0:	90664004 	rsbls	r4, r6, r4
3481b4c4:	8066400b 	rsbhi	r4, r6, fp
3481b4c8:	ea000004 	b	3481b4e0 <__lmb_alloc_base+0x88>
							lmb_align_up(size,
								align)) < 0)
					return 0;
				return base;
			}
			res_base = lmb->reserved.region[j].base;
3481b4cc:	e280000b 	add	r0, r0, #11
3481b4d0:	e7994180 	ldr	r4, [r9, r0, lsl #3]
			if (res_base < size)
3481b4d4:	e1540006 	cmp	r4, r6
3481b4d8:	3a00001c 	bcc	3481b550 <__lmb_alloc_base+0xf8>
				break;
			base = lmb_align_down(res_base - size, align);
3481b4dc:	e0664004 	rsb	r4, r6, r4
	return addr & ~(size - 1);
3481b4e0:	e0044003 	and	r4, r4, r3
		while (base && lmbbase <= base) {
3481b4e4:	e15a0004 	cmp	sl, r4
3481b4e8:	83a02000 	movhi	r2, #0
3481b4ec:	93a02001 	movls	r2, #1
3481b4f0:	e3540000 	cmp	r4, #0
3481b4f4:	03a02000 	moveq	r2, #0
3481b4f8:	e3520000 	cmp	r2, #0
3481b4fc:	0a000013 	beq	3481b550 <__lmb_alloc_base+0xf8>
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481b500:	e1a02006 	mov	r2, r6
3481b504:	e1a01004 	mov	r1, r4
3481b508:	e59d0008 	ldr	r0, [sp, #8]
3481b50c:	e58d300c 	str	r3, [sp, #12]
3481b510:	ebffffba 	bl	3481b400 <lmb_overlaps_region>
			if (j < 0) {
3481b514:	e3500000 	cmp	r0, #0
3481b518:	e59d300c 	ldr	r3, [sp, #12]
3481b51c:	aaffffea 	bge	3481b4cc <__lmb_alloc_base+0x74>
3481b520:	e2472001 	sub	r2, r7, #1
				if (lmb_add_region(&lmb->reserved, base,
3481b524:	e1a01004 	mov	r1, r4
	return (addr + (size - 1)) & ~(size - 1);
3481b528:	e0826006 	add	r6, r2, r6
3481b52c:	e2672000 	rsb	r2, r7, #0
				if (lmb_add_region(&lmb->reserved, base,
3481b530:	e0022006 	and	r2, r2, r6
3481b534:	e59d0008 	ldr	r0, [sp, #8]
3481b538:	ebfffef8 	bl	3481b120 <lmb_add_region>
3481b53c:	e3500000 	cmp	r0, #0
3481b540:	a1a00004 	movge	r0, r4
3481b544:	aa000006 	bge	3481b564 <__lmb_alloc_base+0x10c>
					return 0;
3481b548:	e3a00000 	mov	r0, #0
3481b54c:	ea000004 	b	3481b564 <__lmb_alloc_base+0x10c>
	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b550:	e59d2004 	ldr	r2, [sp, #4]
3481b554:	e2455008 	sub	r5, r5, #8
3481b558:	e2422001 	sub	r2, r2, #1
3481b55c:	e58d2004 	str	r2, [sp, #4]
3481b560:	eaffffc8 	b	3481b488 <__lmb_alloc_base+0x30>
		}
	}
	return 0;
}
3481b564:	e28dd010 	add	sp, sp, #16
3481b568:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481b56c <lmb_alloc_base>:
{
3481b56c:	e92d4070 	push	{r4, r5, r6, lr}
3481b570:	e1a05001 	mov	r5, r1
3481b574:	e1a06003 	mov	r6, r3
	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
3481b578:	ebffffb6 	bl	3481b458 <__lmb_alloc_base>
	if (alloc == 0)
3481b57c:	e2504000 	subs	r4, r0, #0
3481b580:	1a000003 	bne	3481b594 <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
3481b584:	e1a02006 	mov	r2, r6
3481b588:	e1a01005 	mov	r1, r5
3481b58c:	e59f0008 	ldr	r0, [pc, #8]	; 3481b59c <lmb_alloc_base+0x30>
3481b590:	ebffb881 	bl	3480979c <printf>
}
3481b594:	e1a00004 	mov	r0, r4
3481b598:	e8bd8070 	pop	{r4, r5, r6, pc}
3481b59c:	34826d35 	.word	0x34826d35

3481b5a0 <lmb_alloc>:
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
3481b5a0:	e3a03000 	mov	r3, #0
3481b5a4:	eafffff0 	b	3481b56c <lmb_alloc_base>

3481b5a8 <lmb_is_reserved>:

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
3481b5a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481b5ac:	e3a02000 	mov	r2, #0
3481b5b0:	e590e050 	ldr	lr, [r0, #80]	; 0x50
3481b5b4:	e152000e 	cmp	r2, lr
3481b5b8:	0a00000d 	beq	3481b5f4 <lmb_is_reserved+0x4c>
		phys_addr_t upper = lmb->reserved.region[i].base +
3481b5bc:	e590c058 	ldr	ip, [r0, #88]	; 0x58
3481b5c0:	e2800008 	add	r0, r0, #8
3481b5c4:	e5903054 	ldr	r3, [r0, #84]	; 0x54
3481b5c8:	e08c3003 	add	r3, ip, r3
3481b5cc:	e2433001 	sub	r3, r3, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
3481b5d0:	e1510003 	cmp	r1, r3
3481b5d4:	83a03000 	movhi	r3, #0
3481b5d8:	93a03001 	movls	r3, #1
3481b5dc:	e151000c 	cmp	r1, ip
3481b5e0:	33a03000 	movcc	r3, #0
3481b5e4:	e3530000 	cmp	r3, #0
3481b5e8:	1a000003 	bne	3481b5fc <lmb_is_reserved+0x54>
	for (i = 0; i < lmb->reserved.cnt; i++) {
3481b5ec:	e2822001 	add	r2, r2, #1
3481b5f0:	eaffffef 	b	3481b5b4 <lmb_is_reserved+0xc>
			return 1;
	}
	return 0;
3481b5f4:	e3a00000 	mov	r0, #0
3481b5f8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
			return 1;
3481b5fc:	e3a00001 	mov	r0, #1
}
3481b600:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

3481b604 <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
3481b604:	e12fff1e 	bx	lr

3481b608 <__arch_lmb_reserve>:
	/* please define platform specific board_lmb_reserve() */
}
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
3481b608:	e12fff1e 	bx	lr

3481b60c <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
3481b60c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481b610:	e2504000 	subs	r4, r0, #0
		return(0);
3481b614:	01a00004 	moveq	r0, r4
	if (s == NULL)
3481b618:	0a000013 	beq	3481b66c <string_to_ip+0x60>
3481b61c:	e3a06004 	mov	r6, #4
3481b620:	e3a05000 	mov	r5, #0

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
3481b624:	e3540000 	cmp	r4, #0
3481b628:	01a00004 	moveq	r0, r4
3481b62c:	0a000003 	beq	3481b640 <string_to_ip+0x34>
3481b630:	e3a0200a 	mov	r2, #10
3481b634:	e28d1004 	add	r1, sp, #4
3481b638:	e1a00004 	mov	r0, r4
3481b63c:	eb000448 	bl	3481c764 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
3481b640:	e6ef0070 	uxtb	r0, r0
		if (s) {
3481b644:	e3540000 	cmp	r4, #0
		addr |= (val & 0xFF);
3481b648:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
3481b64c:	0a000003 	beq	3481b660 <string_to_ip+0x54>
			s = (*e) ? e+1 : e;
3481b650:	e59d4004 	ldr	r4, [sp, #4]
3481b654:	e5d43000 	ldrb	r3, [r4]
3481b658:	e3530000 	cmp	r3, #0
3481b65c:	12844001 	addne	r4, r4, #1
	for (addr=0, i=0; i<4; ++i) {
3481b660:	e2566001 	subs	r6, r6, #1
3481b664:	1affffee 	bne	3481b624 <string_to_ip+0x18>
3481b668:	e6bf0f35 	rev	r0, r5
		}
	}

	return (htonl(addr));
}
3481b66c:	e28dd008 	add	sp, sp, #8
3481b670:	e8bd8070 	pop	{r4, r5, r6, pc}

3481b674 <qsort>:
	   int (*comp)(const void *, const void *))
{
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481b674:	e3520000 	cmp	r2, #0
3481b678:	13510001 	cmpne	r1, #1
3481b67c:	912fff1e 	bxls	lr
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481b680:	e59fc0c8 	ldr	ip, [pc, #200]	; 3481b750 <qsort+0xdc>
{
3481b684:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
		} while (wgap < (nel-1)/3);
3481b688:	e2414001 	sub	r4, r1, #1
3481b68c:	e0854c94 	umull	r4, r5, r4, ip
3481b690:	e3a04000 	mov	r4, #0
3481b694:	e58dc004 	str	ip, [sp, #4]
3481b698:	e1a0e0a5 	lsr	lr, r5, #1
			wgap = 3 * wgap + 1;
3481b69c:	e0844084 	add	r4, r4, r4, lsl #1
3481b6a0:	e2844001 	add	r4, r4, #1
		} while (wgap < (nel-1)/3);
3481b6a4:	e154000e 	cmp	r4, lr
3481b6a8:	3afffffb 	bcc	3481b69c <qsort+0x28>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
3481b6ac:	e0040492 	mul	r4, r2, r4
3481b6b0:	e1a06002 	mov	r6, r2
3481b6b4:	e1a09000 	mov	r9, r0
		nel *= width;			/* Convert nel to 'wnel' */
3481b6b8:	e0070192 	mul	r7, r2, r1
		} while (wgap < (nel-1)/3);
3481b6bc:	e1a0b004 	mov	fp, r4
		do {
			i = wgap;
			do {
				j = i;
3481b6c0:	e1a0500b 	mov	r5, fp
				do {
					register char *a;
					register char *b;

					j -= wgap;
3481b6c4:	e0642005 	rsb	r2, r4, r5
3481b6c8:	e0895005 	add	r5, r9, r5
3481b6cc:	e089a002 	add	sl, r9, r2
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
3481b6d0:	e1a01005 	mov	r1, r5
3481b6d4:	e1a0000a 	mov	r0, sl
3481b6d8:	e58d200c 	str	r2, [sp, #12]
3481b6dc:	e58d3008 	str	r3, [sp, #8]
3481b6e0:	e12fff33 	blx	r3
3481b6e4:	e3500000 	cmp	r0, #0
3481b6e8:	e59d3008 	ldr	r3, [sp, #8]
3481b6ec:	e59d200c 	ldr	r2, [sp, #12]
3481b6f0:	ca000003 	bgt	3481b704 <qsort+0x90>
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
				i += width;
3481b6f4:	e08bb006 	add	fp, fp, r6
			} while (i < nel);
3481b6f8:	e15b0007 	cmp	fp, r7
3481b6fc:	3affffef 	bcc	3481b6c0 <qsort+0x4c>
3481b700:	ea00000b 	b	3481b734 <qsort+0xc0>
3481b704:	e0821006 	add	r1, r2, r6
3481b708:	e0891001 	add	r1, r9, r1
						*a++ = *b;
3481b70c:	e5d5c000 	ldrb	ip, [r5]
						tmp = *a;
3481b710:	e5da0000 	ldrb	r0, [sl]
						*a++ = *b;
3481b714:	e4cac001 	strb	ip, [sl], #1
					} while (--k);
3481b718:	e15a0001 	cmp	sl, r1
						*b++ = tmp;
3481b71c:	e4c50001 	strb	r0, [r5], #1
					} while (--k);
3481b720:	1afffff9 	bne	3481b70c <qsort+0x98>
				} while (j >= wgap);
3481b724:	e1520004 	cmp	r2, r4
3481b728:	e1a05002 	mov	r5, r2
3481b72c:	2affffe4 	bcs	3481b6c4 <qsort+0x50>
3481b730:	eaffffef 	b	3481b6f4 <qsort+0x80>
			wgap = (wgap - width)/3;
3481b734:	e59d2004 	ldr	r2, [sp, #4]
3481b738:	e0664004 	rsb	r4, r6, r4
3481b73c:	e0854294 	umull	r4, r5, r4, r2
		} while (wgap);
3481b740:	e1b040a5 	lsrs	r4, r5, #1
3481b744:	1affffdc 	bne	3481b6bc <qsort+0x48>
	}
}
3481b748:	e28dd010 	add	sp, sp, #16
3481b74c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b750:	aaaaaaab 	.word	0xaaaaaaab

3481b754 <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
3481b754:	e5911000 	ldr	r1, [r1]
3481b758:	e5900000 	ldr	r0, [r0]
3481b75c:	ea00002f 	b	3481b820 <strcmp>

3481b760 <strcpy>:
 * strcpy - Copy a %NUL terminated string
 * @dest: Where to copy the string to
 * @src: Where to copy the string from
 */
char * strcpy(char * dest,const char *src)
{
3481b760:	e2402001 	sub	r2, r0, #1
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
3481b764:	e4d13001 	ldrb	r3, [r1], #1
3481b768:	e3530000 	cmp	r3, #0
3481b76c:	e5e23001 	strb	r3, [r2, #1]!
3481b770:	1afffffb 	bne	3481b764 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
3481b774:	e12fff1e 	bx	lr

3481b778 <strncpy>:
 * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
 * However, the result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
char * strncpy(char * dest,const char *src,size_t count)
{
3481b778:	e240c001 	sub	ip, r0, #1
3481b77c:	e0812002 	add	r2, r1, r2
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
3481b780:	e1510002 	cmp	r1, r2
3481b784:	012fff1e 	bxeq	lr
3481b788:	e4d13001 	ldrb	r3, [r1], #1
3481b78c:	e3530000 	cmp	r3, #0
3481b790:	e5ec3001 	strb	r3, [ip, #1]!
3481b794:	1afffff9 	bne	3481b780 <strncpy+0x8>
		/* nothing */;

	return tmp;
}
3481b798:	e12fff1e 	bx	lr

3481b79c <strcat>:
 * strcat - Append one %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
char * strcat(char * dest, const char * src)
{
3481b79c:	e1a02000 	mov	r2, r0
3481b7a0:	e1a03002 	mov	r3, r2
3481b7a4:	e2822001 	add	r2, r2, #1
	char *tmp = dest;

	while (*dest)
3481b7a8:	e5d3c000 	ldrb	ip, [r3]
3481b7ac:	e35c0000 	cmp	ip, #0
3481b7b0:	1afffffa 	bne	3481b7a0 <strcat+0x4>
3481b7b4:	e2433001 	sub	r3, r3, #1
		dest++;
	while ((*dest++ = *src++) != '\0')
3481b7b8:	e4d12001 	ldrb	r2, [r1], #1
3481b7bc:	e3520000 	cmp	r2, #0
3481b7c0:	e5e32001 	strb	r2, [r3, #1]!
3481b7c4:	1afffffb 	bne	3481b7b8 <strcat+0x1c>
		;

	return tmp;
}
3481b7c8:	e12fff1e 	bx	lr

3481b7cc <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
3481b7cc:	e3520000 	cmp	r2, #0
3481b7d0:	012fff1e 	bxeq	lr
3481b7d4:	e1a0c000 	mov	ip, r0
{
3481b7d8:	e92d4010 	push	{r4, lr}
3481b7dc:	e1a0300c 	mov	r3, ip
3481b7e0:	e28cc001 	add	ip, ip, #1
		while (*dest)
3481b7e4:	e5d3e000 	ldrb	lr, [r3]
3481b7e8:	e35e0000 	cmp	lr, #0
3481b7ec:	1afffffa 	bne	3481b7dc <strncat+0x10>
3481b7f0:	e1a0c003 	mov	ip, r3
			dest++;
		while ((*dest++ = *src++)) {
3481b7f4:	e4d1e001 	ldrb	lr, [r1], #1
3481b7f8:	e1a0400c 	mov	r4, ip
3481b7fc:	e35e0000 	cmp	lr, #0
3481b800:	e4cce001 	strb	lr, [ip], #1
3481b804:	0a000004 	beq	3481b81c <strncat+0x50>
3481b808:	e06ce002 	rsb	lr, ip, r2
			if (--count == 0) {
3481b80c:	e093e00e 	adds	lr, r3, lr
3481b810:	1afffff7 	bne	3481b7f4 <strncat+0x28>
				*dest = '\0';
3481b814:	e5c4e001 	strb	lr, [r4, #1]
				break;
3481b818:	e8bd8010 	pop	{r4, pc}
			}
		}
	}

	return tmp;
}
3481b81c:	e8bd8010 	pop	{r4, pc}

3481b820 <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
3481b820:	e2400001 	sub	r0, r0, #1
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481b824:	e5f02001 	ldrb	r2, [r0, #1]!
3481b828:	e4d13001 	ldrb	r3, [r1], #1
3481b82c:	e0633002 	rsb	r3, r3, r2
3481b830:	e21330ff 	ands	r3, r3, #255	; 0xff
3481b834:	1a000001 	bne	3481b840 <strcmp+0x20>
3481b838:	e3520000 	cmp	r2, #0
3481b83c:	1afffff8 	bne	3481b824 <strcmp+0x4>
			break;
	}

	return __res;
}
3481b840:	e6af0073 	sxtb	r0, r3
3481b844:	e12fff1e 	bx	lr

3481b848 <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
3481b848:	e2400001 	sub	r0, r0, #1
3481b84c:	e0812002 	add	r2, r1, r2
	register signed char __res = 0;

	while (count) {
3481b850:	e1510002 	cmp	r1, r2
3481b854:	0a000007 	beq	3481b878 <strncmp+0x30>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481b858:	e5f0c001 	ldrb	ip, [r0, #1]!
3481b85c:	e4d13001 	ldrb	r3, [r1], #1
3481b860:	e063300c 	rsb	r3, r3, ip
3481b864:	e21330ff 	ands	r3, r3, #255	; 0xff
3481b868:	1a000003 	bne	3481b87c <strncmp+0x34>
3481b86c:	e35c0000 	cmp	ip, #0
3481b870:	1afffff6 	bne	3481b850 <strncmp+0x8>
3481b874:	ea000000 	b	3481b87c <strncmp+0x34>
3481b878:	e3a03000 	mov	r3, #0
			break;
		count--;
	}

	return __res;
}
3481b87c:	e6af0073 	sxtb	r0, r3
3481b880:	e12fff1e 	bx	lr

3481b884 <strchr>:
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481b884:	e6ef1071 	uxtb	r1, r1
3481b888:	e1a02000 	mov	r2, r0
3481b88c:	e4d03001 	ldrb	r3, [r0], #1
3481b890:	e1530001 	cmp	r3, r1
3481b894:	0a000003 	beq	3481b8a8 <strchr+0x24>
		if (*s == '\0')
3481b898:	e3530000 	cmp	r3, #0
3481b89c:	1afffff9 	bne	3481b888 <strchr+0x4>
			return NULL;
3481b8a0:	e1a00003 	mov	r0, r3
	return (char *) s;
}
3481b8a4:	e12fff1e 	bx	lr
3481b8a8:	e1a00002 	mov	r0, r2
3481b8ac:	e12fff1e 	bx	lr

3481b8b0 <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
3481b8b0:	e59f101c 	ldr	r1, [pc, #28]	; 3481b8d4 <skip_spaces+0x24>
{
3481b8b4:	e1a03000 	mov	r3, r0
3481b8b8:	e1a00003 	mov	r0, r3
3481b8bc:	e2833001 	add	r3, r3, #1
	while (isspace(*str))
3481b8c0:	e5d02000 	ldrb	r2, [r0]
3481b8c4:	e7d12002 	ldrb	r2, [r1, r2]
3481b8c8:	e3120020 	tst	r2, #32
3481b8cc:	1afffff9 	bne	3481b8b8 <skip_spaces+0x8>
		++str;
	return (char *)str;
}
3481b8d0:	e12fff1e 	bx	lr
3481b8d4:	34820934 	.word	0x34820934

3481b8d8 <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
3481b8d8:	e1a03000 	mov	r3, r0
3481b8dc:	e1a02003 	mov	r2, r3
3481b8e0:	e2833001 	add	r3, r3, #1
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
3481b8e4:	e5d21000 	ldrb	r1, [r2]
3481b8e8:	e3510000 	cmp	r1, #0
3481b8ec:	1afffffa 	bne	3481b8dc <strlen+0x4>
		/* nothing */;
	return sc - s;
}
3481b8f0:	e0600002 	rsb	r0, r0, r2
3481b8f4:	e12fff1e 	bx	lr

3481b8f8 <strrchr>:
{
3481b8f8:	e92d4070 	push	{r4, r5, r6, lr}
3481b8fc:	e1a04001 	mov	r4, r1
3481b900:	e1a05000 	mov	r5, r0
	   if (*p == (char)c)
3481b904:	e6ef4074 	uxtb	r4, r4
       const char *p = s + strlen(s);
3481b908:	ebfffff2 	bl	3481b8d8 <strlen>
3481b90c:	e0853000 	add	r3, r5, r0
3481b910:	e1a00003 	mov	r0, r3
3481b914:	e2433001 	sub	r3, r3, #1
	   if (*p == (char)c)
3481b918:	e5d02000 	ldrb	r2, [r0]
3481b91c:	e1520004 	cmp	r2, r4
3481b920:	08bd8070 	popeq	{r4, r5, r6, pc}
       } while (--p >= s);
3481b924:	e1550003 	cmp	r5, r3
3481b928:	9afffff8 	bls	3481b910 <strrchr+0x18>
       return NULL;
3481b92c:	e3a00000 	mov	r0, #0
}
3481b930:	e8bd8070 	pop	{r4, r5, r6, pc}

3481b934 <strim>:
{
3481b934:	e92d4010 	push	{r4, lr}
	s = skip_spaces(s);
3481b938:	ebffffdc 	bl	3481b8b0 <skip_spaces>
3481b93c:	e1a04000 	mov	r4, r0
	size = strlen(s);
3481b940:	ebffffe4 	bl	3481b8d8 <strlen>
	if (!size)
3481b944:	e3500000 	cmp	r0, #0
3481b948:	0a00000e 	beq	3481b988 <strim+0x54>
	while (end >= s && isspace(*end))
3481b94c:	e59f103c 	ldr	r1, [pc, #60]	; 3481b990 <strim+0x5c>
	end = s + size - 1;
3481b950:	e2400001 	sub	r0, r0, #1
3481b954:	e0840000 	add	r0, r4, r0
	while (end >= s && isspace(*end))
3481b958:	e1500004 	cmp	r0, r4
3481b95c:	e1a03000 	mov	r3, r0
3481b960:	2a000002 	bcs	3481b970 <strim+0x3c>
	*(end + 1) = '\0';
3481b964:	e3a02000 	mov	r2, #0
3481b968:	e5c32001 	strb	r2, [r3, #1]
	return s;
3481b96c:	ea000005 	b	3481b988 <strim+0x54>
	while (end >= s && isspace(*end))
3481b970:	e5d32000 	ldrb	r2, [r3]
3481b974:	e2400001 	sub	r0, r0, #1
3481b978:	e7d12002 	ldrb	r2, [r1, r2]
3481b97c:	e3120020 	tst	r2, #32
3481b980:	1afffff4 	bne	3481b958 <strim+0x24>
3481b984:	eafffff6 	b	3481b964 <strim+0x30>
}
3481b988:	e1a00004 	mov	r0, r4
3481b98c:	e8bd8010 	pop	{r4, pc}
3481b990:	34820934 	.word	0x34820934

3481b994 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
3481b994:	e1a02000 	mov	r2, r0
3481b998:	e0801001 	add	r1, r0, r1
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3481b99c:	e1520001 	cmp	r2, r1
3481b9a0:	e1a03002 	mov	r3, r2
3481b9a4:	0a000003 	beq	3481b9b8 <strnlen+0x24>
3481b9a8:	e5d3c000 	ldrb	ip, [r3]
3481b9ac:	e2822001 	add	r2, r2, #1
3481b9b0:	e35c0000 	cmp	ip, #0
3481b9b4:	1afffff8 	bne	3481b99c <strnlen+0x8>
		/* nothing */;
	return sc - s;
3481b9b8:	e0600003 	rsb	r0, r0, r3
}
3481b9bc:	e12fff1e 	bx	lr

3481b9c0 <strdup>:
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481b9c0:	e2501000 	subs	r1, r0, #0
3481b9c4:	0a000009 	beq	3481b9f0 <strdup+0x30>
{
3481b9c8:	e92d4070 	push	{r4, r5, r6, lr}
3481b9cc:	e1a05001 	mov	r5, r1
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
3481b9d0:	ebffffc0 	bl	3481b8d8 <strlen>
	if ((s == NULL)	||
3481b9d4:	e2800001 	add	r0, r0, #1
3481b9d8:	ebffb93e 	bl	34809ed8 <malloc>
3481b9dc:	e2504000 	subs	r4, r0, #0
3481b9e0:	0a000004 	beq	3481b9f8 <strdup+0x38>
		return NULL;
	}

	strcpy (new, s);
3481b9e4:	e1a01005 	mov	r1, r5
3481b9e8:	ebffff5c 	bl	3481b760 <strcpy>
3481b9ec:	ea000001 	b	3481b9f8 <strdup+0x38>
		return NULL;
3481b9f0:	e1a00001 	mov	r0, r1
	return new;
}
3481b9f4:	e12fff1e 	bx	lr
		return NULL;
3481b9f8:	e1a00004 	mov	r0, r4
}
3481b9fc:	e8bd8070 	pop	{r4, r5, r6, pc}

3481ba00 <strspn>:
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
3481ba00:	e1a03000 	mov	r3, r0
{
3481ba04:	e92d4010 	push	{r4, lr}
3481ba08:	e0604003 	rsb	r4, r0, r3
	for (p = s; *p != '\0'; ++p) {
3481ba0c:	e4d3c001 	ldrb	ip, [r3], #1
3481ba10:	e35c0000 	cmp	ip, #0
3481ba14:	0a000006 	beq	3481ba34 <strspn+0x34>
3481ba18:	e2412001 	sub	r2, r1, #1
		for (a = accept; *a != '\0'; ++a) {
3481ba1c:	e5f2e001 	ldrb	lr, [r2, #1]!
3481ba20:	e35e0000 	cmp	lr, #0
3481ba24:	0a000002 	beq	3481ba34 <strspn+0x34>
			if (*p == *a)
3481ba28:	e15c000e 	cmp	ip, lr
3481ba2c:	1afffffa 	bne	3481ba1c <strspn+0x1c>
3481ba30:	eafffff4 	b	3481ba08 <strspn+0x8>
			return count;
		++count;
	}

	return count;
}
3481ba34:	e1a00004 	mov	r0, r4
3481ba38:	e8bd8010 	pop	{r4, pc}

3481ba3c <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
3481ba3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
3481ba40:	e1a0e000 	mov	lr, r0
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481ba44:	e4d03001 	ldrb	r3, [r0], #1
3481ba48:	e3530000 	cmp	r3, #0
3481ba4c:	0a000007 	beq	3481ba70 <strpbrk+0x34>
3481ba50:	e2412001 	sub	r2, r1, #1
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3481ba54:	e5f2c001 	ldrb	ip, [r2, #1]!
3481ba58:	e35c0000 	cmp	ip, #0
3481ba5c:	0afffff7 	beq	3481ba40 <strpbrk+0x4>
			if (*sc1 == *sc2)
3481ba60:	e153000c 	cmp	r3, ip
3481ba64:	1afffffa 	bne	3481ba54 <strpbrk+0x18>
3481ba68:	e1a0000e 	mov	r0, lr
3481ba6c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
				return (char *) sc1;
		}
	}
	return NULL;
3481ba70:	e1a00003 	mov	r0, r3
}
3481ba74:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

3481ba78 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481ba78:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481ba7c:	e2504000 	subs	r4, r0, #0
{
3481ba80:	e1a07001 	mov	r7, r1
3481ba84:	e59f506c 	ldr	r5, [pc, #108]	; 3481baf8 <strtok+0x80>
	sbegin  = s ? s : ___strtok;
3481ba88:	1a000002 	bne	3481ba98 <strtok+0x20>
3481ba8c:	e5954000 	ldr	r4, [r5]
	if (!sbegin) {
3481ba90:	e3540000 	cmp	r4, #0
3481ba94:	0a000015 	beq	3481baf0 <strtok+0x78>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
3481ba98:	e1a01007 	mov	r1, r7
3481ba9c:	e1a00004 	mov	r0, r4
3481baa0:	ebffffd6 	bl	3481ba00 <strspn>
3481baa4:	e0846000 	add	r6, r4, r0
	if (*sbegin == '\0') {
3481baa8:	e7d40000 	ldrb	r0, [r4, r0]
3481baac:	e3500000 	cmp	r0, #0
3481bab0:	1a000001 	bne	3481babc <strtok+0x44>
		___strtok = NULL;
3481bab4:	e5850000 	str	r0, [r5]
		return( NULL );
3481bab8:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
	}
	send = strpbrk( sbegin, ct);
3481babc:	e1a01007 	mov	r1, r7
3481bac0:	e1a00006 	mov	r0, r6
3481bac4:	ebffffdc 	bl	3481ba3c <strpbrk>
	if (send && *send != '\0')
3481bac8:	e3500000 	cmp	r0, #0
3481bacc:	0a000004 	beq	3481bae4 <strtok+0x6c>
3481bad0:	e5d03000 	ldrb	r3, [r0]
3481bad4:	e3530000 	cmp	r3, #0
		*send++ = '\0';
3481bad8:	13a03000 	movne	r3, #0
3481badc:	15c03000 	strbne	r3, [r0]
3481bae0:	12800001 	addne	r0, r0, #1
	___strtok = send;
3481bae4:	e5850000 	str	r0, [r5]
	return (sbegin);
3481bae8:	e1a00006 	mov	r0, r6
3481baec:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
		return NULL;
3481baf0:	e1a00004 	mov	r0, r4
}
3481baf4:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3481baf8:	3482a91c 	.word	0x3482a91c

3481bafc <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481bafc:	e92d4070 	push	{r4, r5, r6, lr}
	char *sbegin = *s, *end;
3481bb00:	e5905000 	ldr	r5, [r0]

	if (sbegin == NULL)
3481bb04:	e3550000 	cmp	r5, #0
3481bb08:	0a000007 	beq	3481bb2c <strsep+0x30>
3481bb0c:	e1a04000 	mov	r4, r0
		return NULL;

	end = strpbrk(sbegin, ct);
3481bb10:	e1a00005 	mov	r0, r5
3481bb14:	ebffffc8 	bl	3481ba3c <strpbrk>
	if (end)
3481bb18:	e3500000 	cmp	r0, #0
		*end++ = '\0';
3481bb1c:	13a03000 	movne	r3, #0
3481bb20:	15c03000 	strbne	r3, [r0]
3481bb24:	12800001 	addne	r0, r0, #1
	*s = end;
3481bb28:	e5840000 	str	r0, [r4]

	return sbegin;
}
3481bb2c:	e1a00005 	mov	r0, r5
3481bb30:	e8bd8070 	pop	{r4, r5, r6, pc}

3481bb34 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
3481bb34:	e3500000 	cmp	r0, #0
3481bb38:	012fff1e 	bxeq	lr
3481bb3c:	e5d03000 	ldrb	r3, [r0]
3481bb40:	e3530000 	cmp	r3, #0
3481bb44:	12803002 	addne	r3, r0, #2
3481bb48:	0a000009 	beq	3481bb74 <strswab+0x40>
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
3481bb4c:	e5531002 	ldrb	r1, [r3, #-2]
3481bb50:	e3510000 	cmp	r1, #0
3481bb54:	012fff1e 	bxeq	lr
3481bb58:	e2833002 	add	r3, r3, #2
3481bb5c:	e5532003 	ldrb	r2, [r3, #-3]
3481bb60:	e3520000 	cmp	r2, #0
		char  tmp;

		tmp = *p;
		*p  = *q;
3481bb64:	15432004 	strbne	r2, [r3, #-4]
		*q  = tmp;
3481bb68:	15431003 	strbne	r1, [r3, #-3]
3481bb6c:	1afffff6 	bne	3481bb4c <strswab+0x18>
3481bb70:	e12fff1e 	bx	lr
		return (NULL);
3481bb74:	e1a00003 	mov	r0, r3
	}

	return (char *) s;
}
3481bb78:	e12fff1e 	bx	lr

3481bb7c <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481bb7c:	e2103003 	ands	r3, r0, #3
{
3481bb80:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	unsigned long *sl = (unsigned long *) s;
3481bb84:	11a03000 	movne	r3, r0
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481bb88:	1a00000d 	bne	3481bbc4 <memset+0x48>
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
3481bb8c:	e6efe071 	uxtb	lr, r1
3481bb90:	e3a0c005 	mov	ip, #5
		for (i = 0; i < sizeof(*sl); i++) {
3481bb94:	e25cc001 	subs	ip, ip, #1
			cl |= c & 0xff;
3481bb98:	118e3403 	orrne	r3, lr, r3, lsl #8
3481bb9c:	1afffffc 	bne	3481bb94 <memset+0x18>
		for (i = 0; i < sizeof(*sl); i++) {
3481bba0:	e1a0e000 	mov	lr, r0
3481bba4:	e06ec002 	rsb	ip, lr, r2
3481bba8:	e080c00c 	add	ip, r0, ip
		}
		while (count >= sizeof(*sl)) {
3481bbac:	e35c0003 	cmp	ip, #3
			*sl++ = cl;
3481bbb0:	848e3004 	strhi	r3, [lr], #4
3481bbb4:	8afffffa 	bhi	3481bba4 <memset+0x28>
3481bbb8:	e3c23003 	bic	r3, r2, #3
		while (count >= sizeof(*sl)) {
3481bbbc:	e2022003 	and	r2, r2, #3
3481bbc0:	e0803003 	add	r3, r0, r3
3481bbc4:	e0832002 	add	r2, r3, r2
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481bbc8:	e1530002 	cmp	r3, r2
		*s8++ = c;
3481bbcc:	14c31001 	strbne	r1, [r3], #1
3481bbd0:	1afffffc 	bne	3481bbc8 <memset+0x4c>

	return s;
}
3481bbd4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

3481bbd8 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
3481bbd8:	e1a03000 	mov	r3, r0
3481bbdc:	e2410001 	sub	r0, r1, #1
3481bbe0:	e0832002 	add	r2, r3, r2
	char *tmp = dest;

	while (count--)
3481bbe4:	e1530002 	cmp	r3, r2
		*tmp++ = *src++;
3481bbe8:	14d3c001 	ldrbne	ip, [r3], #1
3481bbec:	15e0c001 	strbne	ip, [r0, #1]!
3481bbf0:	1afffffb 	bne	3481bbe4 <bcopy+0xc>

	return dest;
}
3481bbf4:	e1a00001 	mov	r0, r1
3481bbf8:	e12fff1e 	bx	lr

3481bbfc <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481bbfc:	e1510000 	cmp	r1, r0
3481bc00:	012fff1e 	bxeq	lr
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481bc04:	e1803001 	orr	r3, r0, r1
{
3481bc08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481bc0c:	e3130003 	tst	r3, #3
3481bc10:	0240e004 	subeq	lr, r0, #4
3481bc14:	01a0c001 	moveq	ip, r1
3481bc18:	1a00000a 	bne	3481bc48 <memcpy+0x4c>
3481bc1c:	e06c3002 	rsb	r3, ip, r2
3481bc20:	e0813003 	add	r3, r1, r3
		while (count >= sizeof(*dl)) {
3481bc24:	e3530003 	cmp	r3, #3
			*dl++ = *sl++;
3481bc28:	849c3004 	ldrhi	r3, [ip], #4
3481bc2c:	85ae3004 	strhi	r3, [lr, #4]!
3481bc30:	8afffff9 	bhi	3481bc1c <memcpy+0x20>
3481bc34:	e3c2c003 	bic	ip, r2, #3
		while (count >= sizeof(*dl)) {
3481bc38:	e2022003 	and	r2, r2, #3
3481bc3c:	e080300c 	add	r3, r0, ip
3481bc40:	e081100c 	add	r1, r1, ip
3481bc44:	ea000000 	b	3481bc4c <memcpy+0x50>
3481bc48:	e1a03000 	mov	r3, r0
3481bc4c:	e2433001 	sub	r3, r3, #1
3481bc50:	e0812002 	add	r2, r1, r2
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481bc54:	e1510002 	cmp	r1, r2
		*d8++ = *s8++;
3481bc58:	14d1c001 	ldrbne	ip, [r1], #1
3481bc5c:	15e3c001 	strbne	ip, [r3, #1]!
3481bc60:	1afffffb 	bne	3481bc54 <memcpy+0x58>

	return dest;
}
3481bc64:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

3481bc68 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
3481bc68:	e1510000 	cmp	r1, r0
3481bc6c:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
3481bc70:	e1500001 	cmp	r0, r1
3481bc74:	e0813002 	add	r3, r1, r2
3481bc78:	92402001 	subls	r2, r0, #1
3481bc7c:	8a000004 	bhi	3481bc94 <memmove+0x2c>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
3481bc80:	e1510003 	cmp	r1, r3
			*tmp++ = *s++;
3481bc84:	14d1c001 	ldrbne	ip, [r1], #1
3481bc88:	15e2c001 	strbne	ip, [r2, #1]!
3481bc8c:	1afffffb 	bne	3481bc80 <memmove+0x18>
3481bc90:	e12fff1e 	bx	lr
		}
	else {
		tmp = (char *) dest + count;
3481bc94:	e0801002 	add	r1, r0, r2
3481bc98:	e0632002 	rsb	r2, r3, r2
		s = (char *) src + count;
		while (count--)
3481bc9c:	e1730002 	cmn	r3, r2
			*--tmp = *--s;
3481bca0:	1573c001 	ldrbne	ip, [r3, #-1]!
3481bca4:	1561c001 	strbne	ip, [r1, #-1]!
3481bca8:	1afffffb 	bne	3481bc9c <memmove+0x34>
		}

	return dest;
}
3481bcac:	e12fff1e 	bx	lr

3481bcb0 <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
3481bcb0:	e240c001 	sub	ip, r0, #1
3481bcb4:	e0812002 	add	r2, r1, r2
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481bcb8:	e1510002 	cmp	r1, r2
3481bcbc:	0a000005 	beq	3481bcd8 <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
3481bcc0:	e5fc3001 	ldrb	r3, [ip, #1]!
3481bcc4:	e5d10000 	ldrb	r0, [r1]
3481bcc8:	e0530000 	subs	r0, r3, r0
3481bccc:	112fff1e 	bxne	lr
	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481bcd0:	e2811001 	add	r1, r1, #1
3481bcd4:	eafffff7 	b	3481bcb8 <memcmp+0x8>
3481bcd8:	e3a00000 	mov	r0, #0
			break;
	return res;
}
3481bcdc:	e12fff1e 	bx	lr

3481bce0 <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
3481bce0:	e1a03000 	mov	r3, r0
3481bce4:	e0802002 	add	r2, r0, r2
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481bce8:	e1530002 	cmp	r3, r2
3481bcec:	e1a00003 	mov	r0, r3
3481bcf0:	0a000004 	beq	3481bd08 <memscan+0x28>
		if (*p == c)
3481bcf4:	e5d0c000 	ldrb	ip, [r0]
3481bcf8:	e2833001 	add	r3, r3, #1
3481bcfc:	e15c0001 	cmp	ip, r1
3481bd00:	1afffff8 	bne	3481bce8 <memscan+0x8>
3481bd04:	e12fff1e 	bx	lr
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
3481bd08:	e12fff1e 	bx	lr

3481bd0c <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481bd0c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481bd10:	e1a06000 	mov	r6, r0
	int l1, l2;

	l2 = strlen(s2);
3481bd14:	e1a00001 	mov	r0, r1
{
3481bd18:	e1a0a001 	mov	sl, r1
	l2 = strlen(s2);
3481bd1c:	ebfffeed 	bl	3481b8d8 <strlen>
	if (!l2)
3481bd20:	e2507000 	subs	r7, r0, #0
		return (char *) s1;
3481bd24:	e1a00006 	mov	r0, r6
	if (!l2)
3481bd28:	0a000011 	beq	3481bd74 <strstr+0x68>
	l1 = strlen(s1);
3481bd2c:	ebfffee9 	bl	3481b8d8 <strlen>
3481bd30:	e1a09000 	mov	r9, r0
3481bd34:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
3481bd38:	e1550007 	cmp	r5, r7
3481bd3c:	e0650009 	rsb	r0, r5, r9
3481bd40:	e0864000 	add	r4, r6, r0
3481bd44:	ba000008 	blt	3481bd6c <strstr+0x60>
		l1--;
		if (!memcmp(s1,s2,l2))
3481bd48:	e1a02007 	mov	r2, r7
3481bd4c:	e1a0100a 	mov	r1, sl
3481bd50:	e1a00004 	mov	r0, r4
		l1--;
3481bd54:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
3481bd58:	ebffffd4 	bl	3481bcb0 <memcmp>
3481bd5c:	e3500000 	cmp	r0, #0
3481bd60:	1afffff4 	bne	3481bd38 <strstr+0x2c>
			return (char *) s1;
3481bd64:	e1a00004 	mov	r0, r4
		s1++;
	}
	return NULL;
}
3481bd68:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	return NULL;
3481bd6c:	e3a00000 	mov	r0, #0
3481bd70:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481bd74:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481bd78 <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
3481bd78:	e6ef1071 	uxtb	r1, r1
3481bd7c:	e0802002 	add	r2, r0, r2
	while (n-- != 0) {
3481bd80:	e1500002 	cmp	r0, r2
3481bd84:	0a000005 	beq	3481bda0 <memchr+0x28>
		if ((unsigned char)c == *p++) {
3481bd88:	e1a03000 	mov	r3, r0
3481bd8c:	e4d3c001 	ldrb	ip, [r3], #1
3481bd90:	e15c0001 	cmp	ip, r1
3481bd94:	012fff1e 	bxeq	lr
3481bd98:	e1a00003 	mov	r0, r3
3481bd9c:	eafffff7 	b	3481bd80 <memchr+0x8>
			return (void *)(p-1);
		}
	}
	return NULL;
3481bda0:	e3a00000 	mov	r0, #0
}
3481bda4:	e12fff1e 	bx	lr

3481bda8 <strmhz>:
char *strmhz (char *buf, unsigned long hz)
{
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481bda8:	e59f2048 	ldr	r2, [pc, #72]	; 3481bdf8 <strmhz+0x50>
{
3481bdac:	e92d4070 	push	{r4, r5, r6, lr}
	n = DIV_ROUND(hz, 1000) / 1000L;
3481bdb0:	e2816f7d 	add	r6, r1, #500	; 0x1f4
	l = sprintf (buf, "%ld", n);
3481bdb4:	e59f1040 	ldr	r1, [pc, #64]	; 3481bdfc <strmhz+0x54>
{
3481bdb8:	e1a05000 	mov	r5, r0
	n = DIV_ROUND(hz, 1000) / 1000L;
3481bdbc:	e0832296 	umull	r2, r3, r6, r2
3481bdc0:	e1a04923 	lsr	r4, r3, #18
	l = sprintf (buf, "%ld", n);
3481bdc4:	e1a02004 	mov	r2, r4
3481bdc8:	eb00030e 	bl	3481ca08 <sprintf>

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
3481bdcc:	e59f202c 	ldr	r2, [pc, #44]	; 3481be00 <strmhz+0x58>
3481bdd0:	e0246492 	mla	r4, r2, r4, r6
3481bdd4:	e59f2028 	ldr	r2, [pc, #40]	; 3481be04 <strmhz+0x5c>
3481bdd8:	e0832294 	umull	r2, r3, r4, r2
	if (m != 0)
3481bddc:	e1b02323 	lsrs	r2, r3, #6
3481bde0:	0a000002 	beq	3481bdf0 <strmhz+0x48>
		sprintf (buf + l, ".%03ld", m);
3481bde4:	e59f101c 	ldr	r1, [pc, #28]	; 3481be08 <strmhz+0x60>
3481bde8:	e0850000 	add	r0, r5, r0
3481bdec:	eb000305 	bl	3481ca08 <sprintf>
	return (buf);
}
3481bdf0:	e1a00005 	mov	r0, r5
3481bdf4:	e8bd8070 	pop	{r4, r5, r6, pc}
3481bdf8:	431bde83 	.word	0x431bde83
3481bdfc:	34826bcd 	.word	0x34826bcd
3481be00:	fff0bdc0 	.word	0xfff0bdc0
3481be04:	10624dd3 	.word	0x10624dd3
3481be08:	34826d69 	.word	0x34826d69

3481be0c <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481be0c:	e92d4070 	push	{r4, r5, r6, lr}
3481be10:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481be14:	e59f601c 	ldr	r6, [pc, #28]	; 3481be38 <udelay+0x2c>
3481be18:	e1540006 	cmp	r4, r6
3481be1c:	31a05004 	movcc	r5, r4
3481be20:	21a05006 	movcs	r5, r6
		__udelay (kv);
3481be24:	e1a00005 	mov	r0, r5
3481be28:	ebff948f 	bl	3480106c <__udelay>
		usec -= kv;
	} while(usec);
3481be2c:	e0544005 	subs	r4, r4, r5
3481be30:	1afffff8 	bne	3481be18 <udelay+0xc>
}
3481be34:	e8bd8070 	pop	{r4, r5, r6, pc}
3481be38:	00989680 	.word	0x00989680

3481be3c <mdelay>:

void mdelay(unsigned long msec)
{
3481be3c:	e92d4010 	push	{r4, lr}
3481be40:	e1a04000 	mov	r4, r0
	while (msec--)
3481be44:	e3540000 	cmp	r4, #0
3481be48:	0a000003 	beq	3481be5c <mdelay+0x20>
		udelay(1000);
3481be4c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3481be50:	e2444001 	sub	r4, r4, #1
3481be54:	ebffffec 	bl	3481be0c <udelay>
3481be58:	eafffff9 	b	3481be44 <mdelay+0x8>
}
3481be5c:	e8bd8010 	pop	{r4, pc}

3481be60 <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
3481be60:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481be64:	e1a09000 	mov	r9, r0
	while (1) {
		unsigned rem;
		if (num < 100000)
3481be68:	e59f61e4 	ldr	r6, [pc, #484]	; 3481c054 <put_dec+0x1f4>
3481be6c:	e3a07000 	mov	r7, #0
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
3481be70:	e59fa1e0 	ldr	sl, [pc, #480]	; 3481c058 <put_dec+0x1f8>
{
3481be74:	e1cd20f8 	strd	r2, [sp, #8]
		if (num < 100000)
3481be78:	e1cd20d8 	ldrd	r2, [sp, #8]
3481be7c:	e1530007 	cmp	r3, r7
3481be80:	e1cd20f0 	strd	r2, [sp]
3481be84:	01520006 	cmpeq	r2, r6
3481be88:	8a000034 	bhi	3481bf60 <put_dec+0x100>
	d2 = (q>>8) & 0xf;
3481be8c:	e59d2000 	ldr	r2, [sp]
	d0 = d0 - 10*q;
3481be90:	e3a0c00a 	mov	ip, #10
	d1 = (q>>4) & 0xf;
3481be94:	e59d3000 	ldr	r3, [sp]
	d2 = (q>>8) & 0xf;
3481be98:	e7e3e452 	ubfx	lr, r2, #8, #4
	d3 = (q>>12);
3481be9c:	e1a00622 	lsr	r0, r2, #12
	d1 = (q>>4) & 0xf;
3481bea0:	e7e33253 	ubfx	r3, r3, #4, #4
3481bea4:	e083400e 	add	r4, r3, lr
	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481bea8:	e0841000 	add	r1, r4, r0
3481beac:	e202200f 	and	r2, r2, #15
3481beb0:	e3a04006 	mov	r4, #6
3481beb4:	e0242194 	mla	r4, r4, r1, r2
	q = (d0 * 0xcd) >> 11;
3481beb8:	e3a010cd 	mov	r1, #205	; 0xcd
	d1 = q + 9*d3 + 5*d2 + d1;
3481bebc:	e0802180 	add	r2, r0, r0, lsl #3
	q = (d0 * 0xcd) >> 11;
3481bec0:	e0050491 	mul	r5, r1, r4
3481bec4:	e0822003 	add	r2, r2, r3
	d1 = q + 9*d3 + 5*d2 + d1;
3481bec8:	e08e310e 	add	r3, lr, lr, lsl #2
3481becc:	e0823003 	add	r3, r2, r3
	q = (d0 * 0xcd) >> 11;
3481bed0:	e1a055a5 	lsr	r5, r5, #11
	d0 = d0 - 10*q;
3481bed4:	e064459c 	mls	r4, ip, r5, r4
	if (d1 != 0) {
3481bed8:	e0933005 	adds	r3, r3, r5
	*buf++ = d0 + '0'; /* least significant digit */
3481bedc:	02890001 	addeq	r0, r9, #1
3481bee0:	e2844030 	add	r4, r4, #48	; 0x30
3481bee4:	e5c94000 	strb	r4, [r9]
	if (d1 != 0) {
3481bee8:	0a000057 	beq	3481c04c <put_dec+0x1ec>
		q = (d1 * 0xcd) >> 11;
3481beec:	e0020391 	mul	r2, r1, r3
3481bef0:	e1a025a2 	lsr	r2, r2, #11
		d1 = d1 - 10*q;
3481bef4:	e063329c 	mls	r3, ip, r2, r3
		*buf++ = d1 + '0'; /* next digit */
3481bef8:	e2833030 	add	r3, r3, #48	; 0x30
3481befc:	e5c93001 	strb	r3, [r9, #1]
		d2 = q + 2*d2;
3481bf00:	e082308e 	add	r3, r2, lr, lsl #1
		if ((d2 != 0) || (d3 != 0)) {
3481bf04:	e1932000 	orrs	r2, r3, r0
		*buf++ = d1 + '0'; /* next digit */
3481bf08:	02890002 	addeq	r0, r9, #2
		if ((d2 != 0) || (d3 != 0)) {
3481bf0c:	0a00004e 	beq	3481c04c <put_dec+0x1ec>
			q = (d2 * 0xd) >> 7;
3481bf10:	e3a0200d 	mov	r2, #13
3481bf14:	e0020392 	mul	r2, r2, r3
3481bf18:	e1a023a2 	lsr	r2, r2, #7
			d2 = d2 - 10*q;
3481bf1c:	e063329c 	mls	r3, ip, r2, r3
			if (d3 != 0) {
3481bf20:	e0920100 	adds	r0, r2, r0, lsl #2
			*buf++ = d2 + '0'; /* next digit */
3481bf24:	e2833030 	add	r3, r3, #48	; 0x30
3481bf28:	02890003 	addeq	r0, r9, #3
3481bf2c:	e5c93002 	strb	r3, [r9, #2]
			if (d3 != 0) {
3481bf30:	0a000045 	beq	3481c04c <put_dec+0x1ec>
				q = (d3 * 0xcd) >> 11;
3481bf34:	e0010091 	mul	r1, r1, r0
3481bf38:	e1a015a1 	lsr	r1, r1, #11
				d3 = d3 - 10*q;
3481bf3c:	e060019c 	mls	r0, ip, r1, r0
				if (q != 0)
3481bf40:	e3510000 	cmp	r1, #0
					*buf++ = q + '0';  /* most sign. digit */
3481bf44:	12811030 	addne	r1, r1, #48	; 0x30
				*buf++ = d3 + '0';  /* next digit */
3481bf48:	e2800030 	add	r0, r0, #48	; 0x30
					*buf++ = q + '0';  /* most sign. digit */
3481bf4c:	15c91004 	strbne	r1, [r9, #4]
				*buf++ = d3 + '0';  /* next digit */
3481bf50:	e5c90003 	strb	r0, [r9, #3]
3481bf54:	02890004 	addeq	r0, r9, #4
					*buf++ = q + '0';  /* most sign. digit */
3481bf58:	12890005 	addne	r0, r9, #5
3481bf5c:	ea00003a 	b	3481c04c <put_dec+0x1ec>
		rem = do_div(num, 100000);
3481bf60:	e59d4004 	ldr	r4, [sp, #4]
3481bf64:	e3a05000 	mov	r5, #0
3481bf68:	e59f10ec 	ldr	r1, [pc, #236]	; 3481c05c <put_dec+0x1fc>
3481bf6c:	e1943005 	orrs	r3, r4, r5
3481bf70:	1a000009 	bne	3481bf9c <put_dec+0x13c>
3481bf74:	e59d0000 	ldr	r0, [sp]
3481bf78:	fa000cbf 	blx	3481f27c <__aeabi_uidivmod>
3481bf7c:	e59d3000 	ldr	r3, [sp]
3481bf80:	e1a00001 	mov	r0, r1
3481bf84:	e58d500c 	str	r5, [sp, #12]
3481bf88:	e1a022a3 	lsr	r2, r3, #5
3481bf8c:	e0832a92 	umull	r2, r3, r2, sl
3481bf90:	e1a033a3 	lsr	r3, r3, #7
3481bf94:	e58d3008 	str	r3, [sp, #8]
3481bf98:	ea000001 	b	3481bfa4 <put_dec+0x144>
3481bf9c:	e28d0008 	add	r0, sp, #8
3481bfa0:	ebfff86d 	bl	3481a15c <__div64_32>
	d2 = (q>>8) & 0xf;
3481bfa4:	e7e3b450 	ubfx	fp, r0, #8, #4
	d3 = (q>>12);
3481bfa8:	e1a0e620 	lsr	lr, r0, #12
	d1 = (q>>4) & 0xf;
3481bfac:	e7e32250 	ubfx	r2, r0, #4, #4
3481bfb0:	e082300b 	add	r3, r2, fp
	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481bfb4:	e200000f 	and	r0, r0, #15
3481bfb8:	e083300e 	add	r3, r3, lr
3481bfbc:	e3a01006 	mov	r1, #6
3481bfc0:	e0230391 	mla	r3, r1, r3, r0
	q = (d0 * 0xcd) >> 11;
3481bfc4:	e3a000cd 	mov	r0, #205	; 0xcd
	d0 = d0 - 10*q;
3481bfc8:	e3a0c00a 	mov	ip, #10
3481bfcc:	e2899005 	add	r9, r9, #5
	q = (d0 * 0xcd) >> 11;
3481bfd0:	e0010390 	mul	r1, r0, r3
3481bfd4:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
3481bfd8:	e063319c 	mls	r3, ip, r1, r3
	*buf++ = d0 + '0';
3481bfdc:	e2833030 	add	r3, r3, #48	; 0x30
3481bfe0:	e5493005 	strb	r3, [r9, #-5]
	d1 = q + 9*d3 + 5*d2 + d1;
3481bfe4:	e08e318e 	add	r3, lr, lr, lsl #3
3481bfe8:	e0832002 	add	r2, r3, r2
3481bfec:	e08b310b 	add	r3, fp, fp, lsl #2
3481bff0:	e0823003 	add	r3, r2, r3
3481bff4:	e0833001 	add	r3, r3, r1
		q = (d1 * 0xcd) >> 11;
3481bff8:	e0020390 	mul	r2, r0, r3
3481bffc:	e1a025a2 	lsr	r2, r2, #11
		d1 = d1 - 10*q;
3481c000:	e063329c 	mls	r3, ip, r2, r3
		d2 = q + 2*d2;
3481c004:	e082208b 	add	r2, r2, fp, lsl #1
		*buf++ = d1 + '0';
3481c008:	e2833030 	add	r3, r3, #48	; 0x30
3481c00c:	e5493004 	strb	r3, [r9, #-4]
			q = (d2 * 0xd) >> 7;
3481c010:	e3a0300d 	mov	r3, #13
3481c014:	e0030293 	mul	r3, r3, r2
3481c018:	e1a033a3 	lsr	r3, r3, #7
			d3 = q + 4*d3;
3481c01c:	e083e10e 	add	lr, r3, lr, lsl #2
				q = (d3 * 0xcd) >> 11; /* - shorter code */
3481c020:	e0000e90 	mul	r0, r0, lr
			d2 = d2 - 10*q;
3481c024:	e062239c 	mls	r2, ip, r3, r2
				q = (d3 * 0xcd) >> 11; /* - shorter code */
3481c028:	e1a005a0 	lsr	r0, r0, #11
				d3 = d3 - 10*q;
3481c02c:	e06ee09c 	mls	lr, ip, r0, lr
			*buf++ = d2 + '0';
3481c030:	e2822030 	add	r2, r2, #48	; 0x30
3481c034:	e5492003 	strb	r2, [r9, #-3]
					*buf++ = q + '0';
3481c038:	e2800030 	add	r0, r0, #48	; 0x30
				*buf++ = d3 + '0';
3481c03c:	e28ee030 	add	lr, lr, #48	; 0x30
3481c040:	e549e002 	strb	lr, [r9, #-2]
					*buf++ = q + '0';
3481c044:	e5490001 	strb	r0, [r9, #-1]
3481c048:	eaffff8a 	b	3481be78 <put_dec+0x18>
		buf = put_dec_full(buf, rem);
	}
}
3481c04c:	e28dd010 	add	sp, sp, #16
3481c050:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481c054:	0001869f 	.word	0x0001869f
3481c058:	0a7c5ac5 	.word	0x0a7c5ac5
3481c05c:	000186a0 	.word	0x000186a0

3481c060 <string.isra.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481c060:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == 0)
		s = "<NULL>";
3481c064:	e3510000 	cmp	r1, #0
3481c068:	e59f5080 	ldr	r5, [pc, #128]	; 3481c0f0 <string.isra.0+0x90>
3481c06c:	11a05001 	movne	r5, r1
static char *string(char *buf, char *end, char *s, int field_width,
3481c070:	e1a04000 	mov	r4, r0

	len = strnlen(s, precision);
3481c074:	e1a01003 	mov	r1, r3
static char *string(char *buf, char *end, char *s, int field_width,
3481c078:	e1a06002 	mov	r6, r2
	len = strnlen(s, precision);
3481c07c:	e1a00005 	mov	r0, r5
3481c080:	ebfffe43 	bl	3481b994 <strnlen>

	if (!(flags & LEFT))
3481c084:	e59d3010 	ldr	r3, [sp, #16]
3481c088:	e3130010 	tst	r3, #16
		while (len < field_width--)
			ADDCH(buf, ' ');
3481c08c:	03a02020 	moveq	r2, #32
	if (!(flags & LEFT))
3481c090:	1a000004 	bne	3481c0a8 <string.isra.0+0x48>
		while (len < field_width--)
3481c094:	e2466001 	sub	r6, r6, #1
3481c098:	e2863001 	add	r3, r6, #1
3481c09c:	e1500003 	cmp	r0, r3
			ADDCH(buf, ' ');
3481c0a0:	b4c42001 	strblt	r2, [r4], #1
3481c0a4:	bafffffa 	blt	3481c094 <string.isra.0+0x34>
3481c0a8:	e2442001 	sub	r2, r4, #1
		s = "<NULL>";
3481c0ac:	e1a03005 	mov	r3, r5
3481c0b0:	e0651003 	rsb	r1, r5, r3
	for (i = 0; i < len; ++i)
3481c0b4:	e1510000 	cmp	r1, r0
		ADDCH(buf, *s++);
3481c0b8:	b4d31001 	ldrblt	r1, [r3], #1
3481c0bc:	b5e21001 	strblt	r1, [r2, #1]!
3481c0c0:	bafffffa 	blt	3481c0b0 <string.isra.0+0x50>
3481c0c4:	e3500000 	cmp	r0, #0
3481c0c8:	a0844000 	addge	r4, r4, r0
	while (len < field_width--)
		ADDCH(buf, ' ');
3481c0cc:	e3a01020 	mov	r1, #32
	for (i = 0; i < len; ++i)
3481c0d0:	e1a03004 	mov	r3, r4
3481c0d4:	e0632006 	rsb	r2, r3, r6
3481c0d8:	e0842002 	add	r2, r4, r2
	while (len < field_width--)
3481c0dc:	e1520000 	cmp	r2, r0
		ADDCH(buf, ' ');
3481c0e0:	c4c31001 	strbgt	r1, [r3], #1
3481c0e4:	cafffffa 	bgt	3481c0d4 <string.isra.0+0x74>
	return buf;
}
3481c0e8:	e1a00003 	mov	r0, r3
3481c0ec:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c0f0:	34826d70 	.word	0x34826d70

3481c0f4 <number.isra.1>:
static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481c0f4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481c0f8:	e24dd058 	sub	sp, sp, #88	; 0x58
3481c0fc:	e59da078 	ldr	sl, [sp, #120]	; 0x78
3481c100:	e1a01003 	mov	r1, r3
3481c104:	e1a05000 	mov	r5, r0
3481c108:	e1a00002 	mov	r0, r2
3481c10c:	e59d7084 	ldr	r7, [sp, #132]	; 0x84
	int need_pfx = ((type & SPECIAL) && base != 10);
3481c110:	e25a300a 	subs	r3, sl, #10
static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481c114:	e59d407c 	ldr	r4, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
3481c118:	13a03001 	movne	r3, #1
	if (type & LEFT)
3481c11c:	e3170010 	tst	r7, #16
	locase = (type & SMALL);
3481c120:	e2072020 	and	r2, r7, #32
	int need_pfx = ((type & SPECIAL) && base != 10);
3481c124:	e003b327 	and	fp, r3, r7, lsr #6
		type &= ~ZEROPAD;
3481c128:	13c77001 	bicne	r7, r7, #1
	locase = (type & SMALL);
3481c12c:	e6ef2072 	uxtb	r2, r2
	if (type & SIGN) {
3481c130:	e2179002 	ands	r9, r7, #2
	locase = (type & SMALL);
3481c134:	e58d2004 	str	r2, [sp, #4]
	if (type & SIGN) {
3481c138:	0a00000e 	beq	3481c178 <number.isra.1+0x84>
		if ((signed NUM_TYPE) num < 0) {
3481c13c:	e3500000 	cmp	r0, #0
3481c140:	e2d12000 	sbcs	r2, r1, #0
3481c144:	aa000004 	bge	3481c15c <number.isra.1+0x68>
			num = - (signed NUM_TYPE) num;
3481c148:	e2700000 	rsbs	r0, r0, #0
			size--;
3481c14c:	e2444001 	sub	r4, r4, #1
			num = - (signed NUM_TYPE) num;
3481c150:	e2e11000 	rsc	r1, r1, #0
			sign = '-';
3481c154:	e3a0902d 	mov	r9, #45	; 0x2d
3481c158:	ea000006 	b	3481c178 <number.isra.1+0x84>
		} else if (type & PLUS) {
3481c15c:	e3170004 	tst	r7, #4
			size--;
3481c160:	12444001 	subne	r4, r4, #1
			sign = '+';
3481c164:	13a0902b 	movne	r9, #43	; 0x2b
		} else if (type & PLUS) {
3481c168:	1a000002 	bne	3481c178 <number.isra.1+0x84>
		} else if (type & SPACE) {
3481c16c:	e2179008 	ands	r9, r7, #8
			size--;
3481c170:	12444001 	subne	r4, r4, #1
			sign = ' ';
3481c174:	13a09020 	movne	r9, #32
	if (need_pfx) {
3481c178:	e35b0000 	cmp	fp, #0
3481c17c:	0a000006 	beq	3481c19c <number.isra.1+0xa8>
		if (base == 16)
3481c180:	e35a0010 	cmp	sl, #16
		size--;
3481c184:	12444001 	subne	r4, r4, #1
		if (base == 16)
3481c188:	1a000003 	bne	3481c19c <number.isra.1+0xa8>
	if (num == 0)
3481c18c:	e1903001 	orrs	r3, r0, r1
			size--;
3481c190:	e2444002 	sub	r4, r4, #2
	if (num == 0)
3481c194:	0a000002 	beq	3481c1a4 <number.isra.1+0xb0>
3481c198:	ea000007 	b	3481c1bc <number.isra.1+0xc8>
3481c19c:	e1902001 	orrs	r2, r0, r1
3481c1a0:	1a000003 	bne	3481c1b4 <number.isra.1+0xc0>
		tmp[i++] = '0';
3481c1a4:	e3a03030 	mov	r3, #48	; 0x30
3481c1a8:	e3a06001 	mov	r6, #1
3481c1ac:	e5cd3014 	strb	r3, [sp, #20]
3481c1b0:	ea00001e 	b	3481c230 <number.isra.1+0x13c>
	else if (base != 10) { /* 8 or 16 */
3481c1b4:	e3530000 	cmp	r3, #0
3481c1b8:	0a000016 	beq	3481c218 <number.isra.1+0x124>
		if (base == 16) shift = 4;
3481c1bc:	e35a0010 	cmp	sl, #16
		int mask = base - 1;
3481c1c0:	e24a3001 	sub	r3, sl, #1
		if (base == 16) shift = 4;
3481c1c4:	e3a06000 	mov	r6, #0
3481c1c8:	13a02003 	movne	r2, #3
3481c1cc:	03a02004 	moveq	r2, #4
3481c1d0:	e58d2008 	str	r2, [sp, #8]
3481c1d4:	e28d2014 	add	r2, sp, #20
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481c1d8:	e2866001 	add	r6, r6, #1
3481c1dc:	e082c006 	add	ip, r2, r6
3481c1e0:	e6ef2070 	uxtb	r2, r0
3481c1e4:	e58d300c 	str	r3, [sp, #12]
3481c1e8:	e0022003 	and	r2, r2, r3
3481c1ec:	e59f314c 	ldr	r3, [pc, #332]	; 3481c340 <number.isra.1+0x24c>
3481c1f0:	e7d32002 	ldrb	r2, [r3, r2]
3481c1f4:	e59d3004 	ldr	r3, [sp, #4]
3481c1f8:	e1832002 	orr	r2, r3, r2
3481c1fc:	e54c2001 	strb	r2, [ip, #-1]
			num >>= shift;
3481c200:	e59d2008 	ldr	r2, [sp, #8]
3481c204:	fa000ccf 	blx	3481f548 <__lshrdi3>
		} while (num);
3481c208:	e1903001 	orrs	r3, r0, r1
3481c20c:	e59d300c 	ldr	r3, [sp, #12]
3481c210:	1affffef 	bne	3481c1d4 <number.isra.1+0xe0>
3481c214:	ea000005 	b	3481c230 <number.isra.1+0x13c>
		i = put_dec(tmp, num) - tmp;
3481c218:	e28d6014 	add	r6, sp, #20
3481c21c:	e1a02000 	mov	r2, r0
3481c220:	e1a03001 	mov	r3, r1
3481c224:	e1a00006 	mov	r0, r6
3481c228:	ebffff0c 	bl	3481be60 <put_dec>
3481c22c:	e0666000 	rsb	r6, r6, r0
3481c230:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
3481c234:	e1560003 	cmp	r6, r3
3481c238:	a1a03006 	movge	r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
3481c23c:	e3170011 	tst	r7, #17
	size -= precision;
3481c240:	e0630004 	rsb	r0, r3, r4
	if (!(type & (ZEROPAD + LEFT))) {
3481c244:	01a01005 	moveq	r1, r5
3481c248:	01a02000 	moveq	r2, r0
			ADDCH(buf, ' ');
3481c24c:	03a0c020 	moveq	ip, #32
	if (!(type & (ZEROPAD + LEFT))) {
3481c250:	1a000006 	bne	3481c270 <number.isra.1+0x17c>
		while (--size >= 0)
3481c254:	e2522001 	subs	r2, r2, #1
			ADDCH(buf, ' ');
3481c258:	54c1c001 	strbpl	ip, [r1], #1
3481c25c:	5afffffc 	bpl	3481c254 <number.isra.1+0x160>
3481c260:	e1c02fc0 	bic	r2, r0, r0, asr #31
3481c264:	e2400001 	sub	r0, r0, #1
3481c268:	e0855002 	add	r5, r5, r2
3481c26c:	e0620000 	rsb	r0, r2, r0
	if (sign)
3481c270:	e3590000 	cmp	r9, #0
		ADDCH(buf, sign);
3481c274:	15c59000 	strbne	r9, [r5]
3481c278:	12855001 	addne	r5, r5, #1
	if (need_pfx) {
3481c27c:	e35b0000 	cmp	fp, #0
3481c280:	0a000007 	beq	3481c2a4 <number.isra.1+0x1b0>
		if (base == 16)
3481c284:	e35a0010 	cmp	sl, #16
		ADDCH(buf, '0');
3481c288:	e3a02030 	mov	r2, #48	; 0x30
3481c28c:	e5c52000 	strb	r2, [r5]
3481c290:	12855001 	addne	r5, r5, #1
			ADDCH(buf, 'X' | locase);
3481c294:	059d2004 	ldreq	r2, [sp, #4]
3481c298:	03822058 	orreq	r2, r2, #88	; 0x58
3481c29c:	05c52001 	strbeq	r2, [r5, #1]
3481c2a0:	02855002 	addeq	r5, r5, #2
	if (!(type & LEFT)) {
3481c2a4:	e3170010 	tst	r7, #16
3481c2a8:	1a00000b 	bne	3481c2dc <number.isra.1+0x1e8>
		char c = (type & ZEROPAD) ? '0' : ' ';
3481c2ac:	e3170001 	tst	r7, #1
3481c2b0:	e1a02000 	mov	r2, r0
3481c2b4:	13a0c030 	movne	ip, #48	; 0x30
3481c2b8:	03a0c020 	moveq	ip, #32
3481c2bc:	e1a01005 	mov	r1, r5
		while (--size >= 0)
3481c2c0:	e2522001 	subs	r2, r2, #1
			ADDCH(buf, c);
3481c2c4:	54c1c001 	strbpl	ip, [r1], #1
3481c2c8:	5afffffc 	bpl	3481c2c0 <number.isra.1+0x1cc>
3481c2cc:	e1c02fc0 	bic	r2, r0, r0, asr #31
3481c2d0:	e2400001 	sub	r0, r0, #1
3481c2d4:	e0855002 	add	r5, r5, r2
3481c2d8:	e0620000 	rsb	r0, r2, r0
		ADDCH(buf, '0');
3481c2dc:	e3a02030 	mov	r2, #48	; 0x30
	while (i <= --precision)
3481c2e0:	e2433001 	sub	r3, r3, #1
3481c2e4:	e1560003 	cmp	r6, r3
		ADDCH(buf, '0');
3481c2e8:	d4c52001 	strble	r2, [r5], #1
3481c2ec:	dafffffb 	ble	3481c2e0 <number.isra.1+0x1ec>
3481c2f0:	e2452001 	sub	r2, r5, #1
	while (i <= --precision)
3481c2f4:	e1a03006 	mov	r3, r6
	while (--i >= 0)
3481c2f8:	e2533001 	subs	r3, r3, #1
		ADDCH(buf, tmp[i]);
3481c2fc:	528d1014 	addpl	r1, sp, #20
3481c300:	57d31001 	ldrbpl	r1, [r3, r1]
3481c304:	55e21001 	strbpl	r1, [r2, #1]!
3481c308:	5afffffa 	bpl	3481c2f8 <number.isra.1+0x204>
3481c30c:	e3560000 	cmp	r6, #0
3481c310:	a0855006 	addge	r5, r5, r6
	while (--i >= 0)
3481c314:	e1a03000 	mov	r3, r0
3481c318:	e1a02005 	mov	r2, r5
		ADDCH(buf, ' ');
3481c31c:	e3a01020 	mov	r1, #32
	while (--size >= 0)
3481c320:	e2533001 	subs	r3, r3, #1
		ADDCH(buf, ' ');
3481c324:	54c21001 	strbpl	r1, [r2], #1
3481c328:	5afffffc 	bpl	3481c320 <number.isra.1+0x22c>
}
3481c32c:	e3500000 	cmp	r0, #0
3481c330:	a0850000 	addge	r0, r5, r0
3481c334:	b2850000 	addlt	r0, r5, #0
3481c338:	e28dd058 	add	sp, sp, #88	; 0x58
3481c33c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481c340:	34820a3a 	.word	0x34820a3a

3481c344 <vsnprintf_internal.isra.3>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481c344:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481c348:	e1a04001 	mov	r4, r1
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481c34c:	e59f9408 	ldr	r9, [pc, #1032]	; 3481c75c <vsnprintf_internal.isra.3+0x418>
static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481c350:	e1a05000 	mov	r5, r0
3481c354:	e1a01002 	mov	r1, r2
	for (; *fmt ; ++fmt) {
3481c358:	e5d43000 	ldrb	r3, [r4]
3481c35c:	e3530000 	cmp	r3, #0
3481c360:	0a0000f9 	beq	3481c74c <vsnprintf_internal.isra.3+0x408>
		if (*fmt != '%') {
3481c364:	e3530025 	cmp	r3, #37	; 0x25
3481c368:	03a0c000 	moveq	ip, #0
			ADDCH(str, *fmt);
3481c36c:	15c03000 	strbne	r3, [r0]
		if (*fmt != '%') {
3481c370:	1a0000bb 	bne	3481c664 <vsnprintf_internal.isra.3+0x320>
			switch (*fmt) {
3481c374:	e5f43001 	ldrb	r3, [r4, #1]!
3481c378:	e353002b 	cmp	r3, #43	; 0x2b
3481c37c:	0a00000e 	beq	3481c3bc <vsnprintf_internal.isra.3+0x78>
3481c380:	8a000005 	bhi	3481c39c <vsnprintf_internal.isra.3+0x58>
3481c384:	e3530020 	cmp	r3, #32
3481c388:	0a00000d 	beq	3481c3c4 <vsnprintf_internal.isra.3+0x80>
3481c38c:	e3530023 	cmp	r3, #35	; 0x23
3481c390:	1a00000d 	bne	3481c3cc <vsnprintf_internal.isra.3+0x88>
				case '#': flags |= SPECIAL; goto repeat;
3481c394:	e38cc040 	orr	ip, ip, #64	; 0x40
3481c398:	eafffff5 	b	3481c374 <vsnprintf_internal.isra.3+0x30>
			switch (*fmt) {
3481c39c:	e353002d 	cmp	r3, #45	; 0x2d
3481c3a0:	0a000003 	beq	3481c3b4 <vsnprintf_internal.isra.3+0x70>
3481c3a4:	e3530030 	cmp	r3, #48	; 0x30
3481c3a8:	1a000007 	bne	3481c3cc <vsnprintf_internal.isra.3+0x88>
				case '0': flags |= ZEROPAD; goto repeat;
3481c3ac:	e38cc001 	orr	ip, ip, #1
3481c3b0:	eaffffef 	b	3481c374 <vsnprintf_internal.isra.3+0x30>
				case '-': flags |= LEFT; goto repeat;
3481c3b4:	e38cc010 	orr	ip, ip, #16
3481c3b8:	eaffffed 	b	3481c374 <vsnprintf_internal.isra.3+0x30>
				case '+': flags |= PLUS; goto repeat;
3481c3bc:	e38cc004 	orr	ip, ip, #4
3481c3c0:	eaffffeb 	b	3481c374 <vsnprintf_internal.isra.3+0x30>
				case ' ': flags |= SPACE; goto repeat;
3481c3c4:	e38cc008 	orr	ip, ip, #8
3481c3c8:	eaffffe9 	b	3481c374 <vsnprintf_internal.isra.3+0x30>
		if (is_digit(*fmt))
3481c3cc:	e2432030 	sub	r2, r3, #48	; 0x30
3481c3d0:	e3520009 	cmp	r2, #9
3481c3d4:	91a0e004 	movls	lr, r4
3481c3d8:	93a02000 	movls	r2, #0
		i = i*10 + *((*s)++) - '0';
3481c3dc:	93a0700a 	movls	r7, #10
		if (is_digit(*fmt))
3481c3e0:	8a000007 	bhi	3481c404 <vsnprintf_internal.isra.3+0xc0>
3481c3e4:	e1a0400e 	mov	r4, lr
	while (is_digit(**s))
3481c3e8:	e4de3001 	ldrb	r3, [lr], #1
3481c3ec:	e2436030 	sub	r6, r3, #48	; 0x30
3481c3f0:	e3560009 	cmp	r6, #9
3481c3f4:	8a00000c 	bhi	3481c42c <vsnprintf_internal.isra.3+0xe8>
		i = i*10 + *((*s)++) - '0';
3481c3f8:	e0223297 	mla	r2, r7, r2, r3
3481c3fc:	e2422030 	sub	r2, r2, #48	; 0x30
3481c400:	eafffff7 	b	3481c3e4 <vsnprintf_internal.isra.3+0xa0>
		else if (*fmt == '*') {
3481c404:	e353002a 	cmp	r3, #42	; 0x2a
		field_width = -1;
3481c408:	13e02000 	mvnne	r2, #0
		else if (*fmt == '*') {
3481c40c:	1a000006 	bne	3481c42c <vsnprintf_internal.isra.3+0xe8>
			field_width = va_arg(args, int);
3481c410:	e5912000 	ldr	r2, [r1]
3481c414:	e2813004 	add	r3, r1, #4
			++fmt;
3481c418:	e2844001 	add	r4, r4, #1
			field_width = va_arg(args, int);
3481c41c:	e1a01003 	mov	r1, r3
			if (field_width < 0) {
3481c420:	e3520000 	cmp	r2, #0
				field_width = -field_width;
3481c424:	b2622000 	rsblt	r2, r2, #0
				flags |= LEFT;
3481c428:	b38cc010 	orrlt	ip, ip, #16
		if (*fmt == '.') {
3481c42c:	e5d43000 	ldrb	r3, [r4]
3481c430:	e353002e 	cmp	r3, #46	; 0x2e
3481c434:	11a06004 	movne	r6, r4
		precision = -1;
3481c438:	13e03000 	mvnne	r3, #0
		if (*fmt == '.') {
3481c43c:	1a00001c 	bne	3481c4b4 <vsnprintf_internal.isra.3+0x170>
			if (is_digit(*fmt))
3481c440:	e5d43001 	ldrb	r3, [r4, #1]
			++fmt;
3481c444:	e2846001 	add	r6, r4, #1
			if (is_digit(*fmt))
3481c448:	e243e030 	sub	lr, r3, #48	; 0x30
3481c44c:	e35e0009 	cmp	lr, #9
3481c450:	91a04006 	movls	r4, r6
3481c454:	93a03000 	movls	r3, #0
		i = i*10 + *((*s)++) - '0';
3481c458:	93a0a00a 	movls	sl, #10
			if (is_digit(*fmt))
3481c45c:	8a000009 	bhi	3481c488 <vsnprintf_internal.isra.3+0x144>
	while (is_digit(**s))
3481c460:	e5d4e000 	ldrb	lr, [r4]
3481c464:	e1a06004 	mov	r6, r4
3481c468:	e2844001 	add	r4, r4, #1
3481c46c:	e24e7030 	sub	r7, lr, #48	; 0x30
3481c470:	e3570009 	cmp	r7, #9
		i = i*10 + *((*s)++) - '0';
3481c474:	9023e39a 	mlals	r3, sl, r3, lr
3481c478:	92433030 	subls	r3, r3, #48	; 0x30
3481c47c:	9afffff7 	bls	3481c460 <vsnprintf_internal.isra.3+0x11c>
	while (is_digit(**s))
3481c480:	e1a0e001 	mov	lr, r1
3481c484:	ea000006 	b	3481c4a4 <vsnprintf_internal.isra.3+0x160>
			else if (*fmt == '*') {
3481c488:	e353002a 	cmp	r3, #42	; 0x2a
3481c48c:	1a000007 	bne	3481c4b0 <vsnprintf_internal.isra.3+0x16c>
				precision = va_arg(args, int);
3481c490:	e5913000 	ldr	r3, [r1]
				++fmt;
3481c494:	e2846002 	add	r6, r4, #2
				precision = va_arg(args, int);
3481c498:	e281e004 	add	lr, r1, #4
			if (precision < 0)
3481c49c:	e3530000 	cmp	r3, #0
3481c4a0:	ba000001 	blt	3481c4ac <vsnprintf_internal.isra.3+0x168>
		precision = -1;
3481c4a4:	e1a0100e 	mov	r1, lr
3481c4a8:	ea000001 	b	3481c4b4 <vsnprintf_internal.isra.3+0x170>
				precision = va_arg(args, int);
3481c4ac:	e1a0100e 	mov	r1, lr
				precision = 0;
3481c4b0:	e3a03000 	mov	r3, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
3481c4b4:	e5d6e000 	ldrb	lr, [r6]
3481c4b8:	e35e0068 	cmp	lr, #104	; 0x68
3481c4bc:	135e0074 	cmpne	lr, #116	; 0x74
3481c4c0:	e20e70df 	and	r7, lr, #223	; 0xdf
3481c4c4:	03a04001 	moveq	r4, #1
3481c4c8:	13a04000 	movne	r4, #0
3481c4cc:	e357004c 	cmp	r7, #76	; 0x4c
3481c4d0:	03844001 	orreq	r4, r4, #1
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481c4d4:	e357005a 	cmp	r7, #90	; 0x5a
3481c4d8:	03844001 	orreq	r4, r4, #1
3481c4dc:	e3540000 	cmp	r4, #0
3481c4e0:	01a04006 	moveq	r4, r6
		qualifier = -1;
3481c4e4:	03e0e000 	mvneq	lr, #0
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481c4e8:	0a000006 	beq	3481c508 <vsnprintf_internal.isra.3+0x1c4>
			if (qualifier == 'l' && *fmt == 'l') {
3481c4ec:	e35e006c 	cmp	lr, #108	; 0x6c
			++fmt;
3481c4f0:	e2864001 	add	r4, r6, #1
			if (qualifier == 'l' && *fmt == 'l') {
3481c4f4:	1a000003 	bne	3481c508 <vsnprintf_internal.isra.3+0x1c4>
3481c4f8:	e5d67001 	ldrb	r7, [r6, #1]
3481c4fc:	e357006c 	cmp	r7, #108	; 0x6c
				++fmt;
3481c500:	02864002 	addeq	r4, r6, #2
				qualifier = 'L';
3481c504:	03a0e04c 	moveq	lr, #76	; 0x4c
		switch (*fmt) {
3481c508:	e5d46000 	ldrb	r6, [r4]
3481c50c:	e356006e 	cmp	r6, #110	; 0x6e
3481c510:	0a00004c 	beq	3481c648 <vsnprintf_internal.isra.3+0x304>
3481c514:	8a00000c 	bhi	3481c54c <vsnprintf_internal.isra.3+0x208>
3481c518:	e3560063 	cmp	r6, #99	; 0x63
3481c51c:	0a000018 	beq	3481c584 <vsnprintf_internal.isra.3+0x240>
3481c520:	8a000004 	bhi	3481c538 <vsnprintf_internal.isra.3+0x1f4>
3481c524:	e3560025 	cmp	r6, #37	; 0x25
3481c528:	0a00004c 	beq	3481c660 <vsnprintf_internal.isra.3+0x31c>
3481c52c:	e3560058 	cmp	r6, #88	; 0x58
3481c530:	0a00004d 	beq	3481c66c <vsnprintf_internal.isra.3+0x328>
3481c534:	ea000050 	b	3481c67c <vsnprintf_internal.isra.3+0x338>
3481c538:	e3560064 	cmp	r6, #100	; 0x64
3481c53c:	0a00004c 	beq	3481c674 <vsnprintf_internal.isra.3+0x330>
3481c540:	e3560069 	cmp	r6, #105	; 0x69
3481c544:	0a00004a 	beq	3481c674 <vsnprintf_internal.isra.3+0x330>
3481c548:	ea00004b 	b	3481c67c <vsnprintf_internal.isra.3+0x338>
3481c54c:	e3560073 	cmp	r6, #115	; 0x73
3481c550:	0a00001c 	beq	3481c5c8 <vsnprintf_internal.isra.3+0x284>
3481c554:	8a000004 	bhi	3481c56c <vsnprintf_internal.isra.3+0x228>
3481c558:	e356006f 	cmp	r6, #111	; 0x6f
3481c55c:	0a000051 	beq	3481c6a8 <vsnprintf_internal.isra.3+0x364>
3481c560:	e3560070 	cmp	r6, #112	; 0x70
3481c564:	0a00001c 	beq	3481c5dc <vsnprintf_internal.isra.3+0x298>
3481c568:	ea000043 	b	3481c67c <vsnprintf_internal.isra.3+0x338>
3481c56c:	e3560075 	cmp	r6, #117	; 0x75
3481c570:	0a00004a 	beq	3481c6a0 <vsnprintf_internal.isra.3+0x35c>
3481c574:	e3560078 	cmp	r6, #120	; 0x78
		case 'o':
			base = 8;
			break;

		case 'x':
			flags |= SMALL;
3481c578:	038cc020 	orreq	ip, ip, #32
		switch (*fmt) {
3481c57c:	0a00003a 	beq	3481c66c <vsnprintf_internal.isra.3+0x328>
3481c580:	ea00003d 	b	3481c67c <vsnprintf_internal.isra.3+0x338>
			if (!(flags & LEFT)) {
3481c584:	e31c0010 	tst	ip, #16
					ADDCH(str, ' ');
3481c588:	03a03020 	moveq	r3, #32
			if (!(flags & LEFT)) {
3481c58c:	1a000003 	bne	3481c5a0 <vsnprintf_internal.isra.3+0x25c>
				while (--field_width > 0)
3481c590:	e2422001 	sub	r2, r2, #1
3481c594:	e3520000 	cmp	r2, #0
					ADDCH(str, ' ');
3481c598:	c4c03001 	strbgt	r3, [r0], #1
3481c59c:	cafffffb 	bgt	3481c590 <vsnprintf_internal.isra.3+0x24c>
			ADDCH(str, (unsigned char) va_arg(args, int));
3481c5a0:	e2813004 	add	r3, r1, #4
3481c5a4:	e5911000 	ldr	r1, [r1]
3481c5a8:	e2800001 	add	r0, r0, #1
3481c5ac:	e5401001 	strb	r1, [r0, #-1]
				ADDCH(str, ' ');
3481c5b0:	e3a01020 	mov	r1, #32
			while (--field_width > 0)
3481c5b4:	e2422001 	sub	r2, r2, #1
3481c5b8:	e3520000 	cmp	r2, #0
3481c5bc:	da000025 	ble	3481c658 <vsnprintf_internal.isra.3+0x314>
				ADDCH(str, ' ');
3481c5c0:	e4c01001 	strb	r1, [r0], #1
3481c5c4:	eafffffa 	b	3481c5b4 <vsnprintf_internal.isra.3+0x270>
			str = string(str, end, va_arg(args, char *),
3481c5c8:	e2816004 	add	r6, r1, #4
3481c5cc:	e58dc000 	str	ip, [sp]
3481c5d0:	e5911000 	ldr	r1, [r1]
3481c5d4:	ebfffea1 	bl	3481c060 <string.isra.0>
3481c5d8:	ea000018 	b	3481c640 <vsnprintf_internal.isra.3+0x2fc>
			str = pointer(fmt+1, str, end,
3481c5dc:	e2816004 	add	r6, r1, #4
3481c5e0:	e5911000 	ldr	r1, [r1]
	if (!ptr)
3481c5e4:	e3510000 	cmp	r1, #0
3481c5e8:	1a000003 	bne	3481c5fc <vsnprintf_internal.isra.3+0x2b8>
		return string(buf, end, "(null)", field_width, precision,
3481c5ec:	e58dc000 	str	ip, [sp]
3481c5f0:	e59f1168 	ldr	r1, [pc, #360]	; 3481c760 <vsnprintf_internal.isra.3+0x41c>
3481c5f4:	ebfffe99 	bl	3481c060 <string.isra.0>
3481c5f8:	ea000009 	b	3481c624 <vsnprintf_internal.isra.3+0x2e0>
	if (field_width == -1) {
3481c5fc:	e3720001 	cmn	r2, #1
		field_width = 2*sizeof(void *);
3481c600:	03a02008 	moveq	r2, #8
	flags |= SMALL;
3481c604:	138cc020 	orrne	ip, ip, #32
		flags |= ZEROPAD;
3481c608:	038cc021 	orreq	ip, ip, #33	; 0x21
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481c60c:	e98d100c 	stmib	sp, {r2, r3, ip}
3481c610:	e3a03010 	mov	r3, #16
3481c614:	e58d3000 	str	r3, [sp]
3481c618:	e1a02001 	mov	r2, r1
3481c61c:	e3a03000 	mov	r3, #0
3481c620:	ebfffeb3 	bl	3481c0f4 <number.isra.1>
3481c624:	e1a03004 	mov	r3, r4
3481c628:	e1a04003 	mov	r4, r3
3481c62c:	e2833001 	add	r3, r3, #1
			while (isalnum(fmt[1]))
3481c630:	e5d42001 	ldrb	r2, [r4, #1]
3481c634:	e7d92002 	ldrb	r2, [r9, r2]
3481c638:	e3120007 	tst	r2, #7
3481c63c:	1afffff9 	bne	3481c628 <vsnprintf_internal.isra.3+0x2e4>
			str = pointer(fmt+1, str, end,
3481c640:	e1a01006 	mov	r1, r6
3481c644:	ea00003e 	b	3481c744 <vsnprintf_internal.isra.3+0x400>
3481c648:	e2813004 	add	r3, r1, #4
				*ip = (str - buf);
3481c64c:	e5911000 	ldr	r1, [r1]
3481c650:	e0652000 	rsb	r2, r5, r0
3481c654:	e5812000 	str	r2, [r1]
				long * ip = va_arg(args, long *);
3481c658:	e1a01003 	mov	r1, r3
3481c65c:	ea000038 	b	3481c744 <vsnprintf_internal.isra.3+0x400>
			ADDCH(str, '%');
3481c660:	e5c06000 	strb	r6, [r0]
3481c664:	e2800001 	add	r0, r0, #1
3481c668:	ea000035 	b	3481c744 <vsnprintf_internal.isra.3+0x400>
		case 'X':
			base = 16;
3481c66c:	e3a0b010 	mov	fp, #16
3481c670:	ea00000d 	b	3481c6ac <vsnprintf_internal.isra.3+0x368>
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
3481c674:	e38cc002 	orr	ip, ip, #2
3481c678:	ea000008 	b	3481c6a0 <vsnprintf_internal.isra.3+0x35c>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
3481c67c:	e3a03025 	mov	r3, #37	; 0x25
3481c680:	e5c03000 	strb	r3, [r0]
			if (*fmt)
3481c684:	e5d43000 	ldrb	r3, [r4]
3481c688:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
3481c68c:	15c03001 	strbne	r3, [r0, #1]
			ADDCH(str, '%');
3481c690:	02800001 	addeq	r0, r0, #1
				ADDCH(str, *fmt);
3481c694:	12800002 	addne	r0, r0, #2
			else
				--fmt;
3481c698:	02444001 	subeq	r4, r4, #1
3481c69c:	ea000028 	b	3481c744 <vsnprintf_internal.isra.3+0x400>
		base = 10;
3481c6a0:	e3a0b00a 	mov	fp, #10
3481c6a4:	ea000000 	b	3481c6ac <vsnprintf_internal.isra.3+0x368>
			base = 8;
3481c6a8:	e3a0b008 	mov	fp, #8
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
3481c6ac:	e35e004c 	cmp	lr, #76	; 0x4c
			num = va_arg(args, unsigned long long);
3481c6b0:	02811007 	addeq	r1, r1, #7
3481c6b4:	03c11007 	biceq	r1, r1, #7
3481c6b8:	0281a008 	addeq	sl, r1, #8
3481c6bc:	01c160d0 	ldrdeq	r6, [r1]
3481c6c0:	0a000019 	beq	3481c72c <vsnprintf_internal.isra.3+0x3e8>
		else if (qualifier == 'l') {
3481c6c4:	e35e006c 	cmp	lr, #108	; 0x6c
3481c6c8:	e281a004 	add	sl, r1, #4
3481c6cc:	1a000003 	bne	3481c6e0 <vsnprintf_internal.isra.3+0x39c>
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
3481c6d0:	e31c0002 	tst	ip, #2
			num = va_arg(args, unsigned long);
3481c6d4:	e5916000 	ldr	r6, [r1]
			if (flags & SIGN)
3481c6d8:	1a000012 	bne	3481c728 <vsnprintf_internal.isra.3+0x3e4>
3481c6dc:	ea000003 	b	3481c6f0 <vsnprintf_internal.isra.3+0x3ac>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481c6e0:	e3ce6020 	bic	r6, lr, #32
3481c6e4:	e356005a 	cmp	r6, #90	; 0x5a
			num = va_arg(args, size_t);
3481c6e8:	e5916000 	ldr	r6, [r1]
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481c6ec:	1a000001 	bne	3481c6f8 <vsnprintf_internal.isra.3+0x3b4>
			num = va_arg(args, size_t);
3481c6f0:	e3a07000 	mov	r7, #0
3481c6f4:	ea00000c 	b	3481c72c <vsnprintf_internal.isra.3+0x3e8>
		} else if (qualifier == 't') {
3481c6f8:	e35e0074 	cmp	lr, #116	; 0x74
3481c6fc:	0a000009 	beq	3481c728 <vsnprintf_internal.isra.3+0x3e4>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
3481c700:	e35e0068 	cmp	lr, #104	; 0x68
3481c704:	e20ce002 	and	lr, ip, #2
3481c708:	1a000004 	bne	3481c720 <vsnprintf_internal.isra.3+0x3dc>
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
3481c70c:	e35e0000 	cmp	lr, #0
			num = (unsigned short) va_arg(args, int);
3481c710:	06ff6076 	uxtheq	r6, r6
				num = (signed short) num;
3481c714:	16bf6076 	sxthne	r6, r6
			if (flags & SIGN)
3481c718:	1a000002 	bne	3481c728 <vsnprintf_internal.isra.3+0x3e4>
3481c71c:	eafffff3 	b	3481c6f0 <vsnprintf_internal.isra.3+0x3ac>
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
3481c720:	e35e0000 	cmp	lr, #0
3481c724:	0afffff1 	beq	3481c6f0 <vsnprintf_internal.isra.3+0x3ac>
				num = (signed int) num;
3481c728:	e1a07fc6 	asr	r7, r6, #31
		}
		str = number(str, end, num, base, field_width, precision,
3481c72c:	e98d100c 	stmib	sp, {r2, r3, ip}
3481c730:	e58db000 	str	fp, [sp]
3481c734:	e1a02006 	mov	r2, r6
3481c738:	e1a03007 	mov	r3, r7
3481c73c:	ebfffe6c 	bl	3481c0f4 <number.isra.1>
3481c740:	e1a0100a 	mov	r1, sl
	for (; *fmt ; ++fmt) {
3481c744:	e2844001 	add	r4, r4, #1
3481c748:	eaffff02 	b	3481c358 <vsnprintf_internal.isra.3+0x14>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
3481c74c:	e5c03000 	strb	r3, [r0]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
}
3481c750:	e0650000 	rsb	r0, r5, r0
3481c754:	e28dd010 	add	sp, sp, #16
3481c758:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481c75c:	34820934 	.word	0x34820934
3481c760:	34826d77 	.word	0x34826d77

3481c764 <simple_strtoul>:
{
3481c764:	e92d4030 	push	{r4, r5, lr}
	if (*cp == '0') {
3481c768:	e5d03000 	ldrb	r3, [r0]
3481c76c:	e59f40a4 	ldr	r4, [pc, #164]	; 3481c818 <simple_strtoul+0xb4>
3481c770:	e3530030 	cmp	r3, #48	; 0x30
3481c774:	1a00000c 	bne	3481c7ac <simple_strtoul+0x48>
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481c778:	e5d0c001 	ldrb	ip, [r0, #1]
		cp++;
3481c77c:	e2803001 	add	r3, r0, #1
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481c780:	e35c0078 	cmp	ip, #120	; 0x78
3481c784:	1a000005 	bne	3481c7a0 <simple_strtoul+0x3c>
3481c788:	e5d0c002 	ldrb	ip, [r0, #2]
3481c78c:	e7d4c00c 	ldrb	ip, [r4, ip]
3481c790:	e31c0044 	tst	ip, #68	; 0x44
			cp++;
3481c794:	12803002 	addne	r3, r0, #2
			base = 16;
3481c798:	13a02010 	movne	r2, #16
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481c79c:	1a00001b 	bne	3481c810 <simple_strtoul+0xac>
			base = 8;
3481c7a0:	e3520000 	cmp	r2, #0
3481c7a4:	03a02008 	moveq	r2, #8
3481c7a8:	ea000018 	b	3481c810 <simple_strtoul+0xac>
		base = 10;
3481c7ac:	e3520000 	cmp	r2, #0
3481c7b0:	03a0200a 	moveq	r2, #10
3481c7b4:	e1a0c000 	mov	ip, r0
3481c7b8:	e3a00000 	mov	r0, #0
3481c7bc:	e1a0500c 	mov	r5, ip
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481c7c0:	e4dc3001 	ldrb	r3, [ip], #1
3481c7c4:	e7d4e003 	ldrb	lr, [r4, r3]
3481c7c8:	e31e0044 	tst	lr, #68	; 0x44
3481c7cc:	1a000002 	bne	3481c7dc <simple_strtoul+0x78>
	if (endp)
3481c7d0:	e3510000 	cmp	r1, #0
3481c7d4:	1a00000b 	bne	3481c808 <simple_strtoul+0xa4>
3481c7d8:	e8bd8030 	pop	{r4, r5, pc}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481c7dc:	e31e0004 	tst	lr, #4
3481c7e0:	12433030 	subne	r3, r3, #48	; 0x30
3481c7e4:	1a000003 	bne	3481c7f8 <simple_strtoul+0x94>
3481c7e8:	e31e0002 	tst	lr, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
3481c7ec:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
3481c7f0:	16ef3073 	uxtbne	r3, r3
3481c7f4:	e2433037 	sub	r3, r3, #55	; 0x37
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481c7f8:	e1530002 	cmp	r3, r2
3481c7fc:	2afffff3 	bcs	3481c7d0 <simple_strtoul+0x6c>
		result = result*base + value;
3481c800:	e0203092 	mla	r0, r2, r0, r3
3481c804:	eaffffec 	b	3481c7bc <simple_strtoul+0x58>
		*endp = (char *)cp;
3481c808:	e5815000 	str	r5, [r1]
3481c80c:	e8bd8030 	pop	{r4, r5, pc}
			base = 16;
3481c810:	e1a00003 	mov	r0, r3
3481c814:	eaffffe6 	b	3481c7b4 <simple_strtoul+0x50>
3481c818:	34820934 	.word	0x34820934

3481c81c <strict_strtoul>:
	*res = 0;
3481c81c:	e3a03000 	mov	r3, #0
{
3481c820:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*res = 0;
3481c824:	e5823000 	str	r3, [r2]
{
3481c828:	e1a04000 	mov	r4, r0
3481c82c:	e1a07001 	mov	r7, r1
3481c830:	e1a05002 	mov	r5, r2
	len = strlen(cp);
3481c834:	ebfffc27 	bl	3481b8d8 <strlen>
	if (len == 0)
3481c838:	e2506000 	subs	r6, r0, #0
3481c83c:	1a000001 	bne	3481c848 <strict_strtoul+0x2c>
		return -EINVAL;
3481c840:	e3e00015 	mvn	r0, #21
3481c844:	ea000010 	b	3481c88c <strict_strtoul+0x70>
	val = simple_strtoul(cp, &tail, base);
3481c848:	e1a02007 	mov	r2, r7
3481c84c:	e28d1004 	add	r1, sp, #4
3481c850:	e1a00004 	mov	r0, r4
3481c854:	ebffffc2 	bl	3481c764 <simple_strtoul>
	if (tail == cp)
3481c858:	e59d3004 	ldr	r3, [sp, #4]
3481c85c:	e1530004 	cmp	r3, r4
3481c860:	0afffff6 	beq	3481c840 <strict_strtoul+0x24>
	if ((*tail == '\0') ||
3481c864:	e5d32000 	ldrb	r2, [r3]
3481c868:	e3520000 	cmp	r2, #0
3481c86c:	0a000004 	beq	3481c884 <strict_strtoul+0x68>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481c870:	e0643003 	rsb	r3, r4, r3
3481c874:	e2833001 	add	r3, r3, #1
3481c878:	e1560003 	cmp	r6, r3
3481c87c:	0352000a 	cmpeq	r2, #10
3481c880:	1affffee 	bne	3481c840 <strict_strtoul+0x24>
		*res = val;
3481c884:	e5850000 	str	r0, [r5]
		return 0;
3481c888:	e3a00000 	mov	r0, #0
}
3481c88c:	e28dd00c 	add	sp, sp, #12
3481c890:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3481c894 <simple_strtol>:
	if(*cp=='-')
3481c894:	e5d0c000 	ldrb	ip, [r0]
3481c898:	e35c002d 	cmp	ip, #45	; 0x2d
3481c89c:	0a000000 	beq	3481c8a4 <simple_strtol+0x10>
	return simple_strtoul(cp,endp,base);
3481c8a0:	eaffffaf 	b	3481c764 <simple_strtoul>
{
3481c8a4:	e92d4010 	push	{r4, lr}
		return -simple_strtoul(cp+1,endp,base);
3481c8a8:	e2800001 	add	r0, r0, #1
3481c8ac:	ebffffac 	bl	3481c764 <simple_strtoul>
3481c8b0:	e2600000 	rsb	r0, r0, #0
}
3481c8b4:	e8bd8010 	pop	{r4, pc}

3481c8b8 <ustrtoul>:
{
3481c8b8:	e92d4010 	push	{r4, lr}
3481c8bc:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
3481c8c0:	ebffffa7 	bl	3481c764 <simple_strtoul>
	switch (**endp) {
3481c8c4:	e5943000 	ldr	r3, [r4]
3481c8c8:	e5d32000 	ldrb	r2, [r3]
3481c8cc:	e352004b 	cmp	r2, #75	; 0x4b
3481c8d0:	0a00000a 	beq	3481c900 <ustrtoul+0x48>
3481c8d4:	8a000003 	bhi	3481c8e8 <ustrtoul+0x30>
3481c8d8:	e3520047 	cmp	r2, #71	; 0x47
		result *= 1024;
3481c8dc:	01a00500 	lsleq	r0, r0, #10
	switch (**endp) {
3481c8e0:	0a000005 	beq	3481c8fc <ustrtoul+0x44>
3481c8e4:	e8bd8010 	pop	{r4, pc}
3481c8e8:	e352004d 	cmp	r2, #77	; 0x4d
3481c8ec:	0a000002 	beq	3481c8fc <ustrtoul+0x44>
3481c8f0:	e352006b 	cmp	r2, #107	; 0x6b
3481c8f4:	0a000001 	beq	3481c900 <ustrtoul+0x48>
3481c8f8:	e8bd8010 	pop	{r4, pc}
		result *= 1024;
3481c8fc:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
3481c900:	e5d32001 	ldrb	r2, [r3, #1]
		result *= 1024;
3481c904:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
3481c908:	e3520069 	cmp	r2, #105	; 0x69
3481c90c:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
3481c910:	e5d32002 	ldrb	r2, [r3, #2]
3481c914:	e3520042 	cmp	r2, #66	; 0x42
				(*endp) += 3;
3481c918:	02833003 	addeq	r3, r3, #3
				(*endp) += 2;
3481c91c:	12833002 	addne	r3, r3, #2
3481c920:	e5843000 	str	r3, [r4]
}
3481c924:	e8bd8010 	pop	{r4, pc}

3481c928 <simple_strtoull>:
{
3481c928:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481c92c:	e1a0c001 	mov	ip, r1
	if (*cp == '0') {
3481c930:	e5d03000 	ldrb	r3, [r0]
3481c934:	e59fe0c4 	ldr	lr, [pc, #196]	; 3481ca00 <simple_strtoull+0xd8>
3481c938:	e3530030 	cmp	r3, #48	; 0x30
3481c93c:	1a00000c 	bne	3481c974 <simple_strtoull+0x4c>
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481c940:	e5d01001 	ldrb	r1, [r0, #1]
		cp++;
3481c944:	e2803001 	add	r3, r0, #1
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481c948:	e3510078 	cmp	r1, #120	; 0x78
3481c94c:	1a000005 	bne	3481c968 <simple_strtoull+0x40>
3481c950:	e5d01002 	ldrb	r1, [r0, #2]
3481c954:	e7de1001 	ldrb	r1, [lr, r1]
3481c958:	e3110044 	tst	r1, #68	; 0x44
			cp++;
3481c95c:	12803002 	addne	r3, r0, #2
			base = 16;
3481c960:	13a02010 	movne	r2, #16
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481c964:	1a000023 	bne	3481c9f8 <simple_strtoull+0xd0>
			base = 8;
3481c968:	e3520000 	cmp	r2, #0
3481c96c:	03a02008 	moveq	r2, #8
3481c970:	ea000020 	b	3481c9f8 <simple_strtoull+0xd0>
		base = 10;
3481c974:	e3520000 	cmp	r2, #0
3481c978:	03a0200a 	moveq	r2, #10
3481c97c:	e1a03000 	mov	r3, r0
3481c980:	e3a01000 	mov	r1, #0
3481c984:	e3a00000 	mov	r0, #0
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481c988:	e1a06002 	mov	r6, r2
3481c98c:	e3a07000 	mov	r7, #0
3481c990:	e1a09003 	mov	r9, r3
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481c994:	e4d34001 	ldrb	r4, [r3], #1
3481c998:	e7de5004 	ldrb	r5, [lr, r4]
3481c99c:	e3150044 	tst	r5, #68	; 0x44
3481c9a0:	1a000002 	bne	3481c9b0 <simple_strtoull+0x88>
	if (endp)
3481c9a4:	e35c0000 	cmp	ip, #0
3481c9a8:	1a000010 	bne	3481c9f0 <simple_strtoull+0xc8>
3481c9ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481c9b0:	e3150004 	tst	r5, #4
3481c9b4:	12444030 	subne	r4, r4, #48	; 0x30
3481c9b8:	1a000003 	bne	3481c9cc <simple_strtoull+0xa4>
3481c9bc:	e3150002 	tst	r5, #2
3481c9c0:	12444020 	subne	r4, r4, #32
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481c9c4:	16ef4074 	uxtbne	r4, r4
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481c9c8:	e2444037 	sub	r4, r4, #55	; 0x37
3481c9cc:	e1a05fc4 	asr	r5, r4, #31
3481c9d0:	e1550007 	cmp	r5, r7
3481c9d4:	01540006 	cmpeq	r4, r6
3481c9d8:	2afffff1 	bcs	3481c9a4 <simple_strtoull+0x7c>
		result = result * base + value;
3481c9dc:	e08ba290 	umull	sl, fp, r0, r2
3481c9e0:	e02bb192 	mla	fp, r2, r1, fp
3481c9e4:	e094000a 	adds	r0, r4, sl
3481c9e8:	e0a5100b 	adc	r1, r5, fp
3481c9ec:	eaffffe7 	b	3481c990 <simple_strtoull+0x68>
		*endp = (char *) cp;
3481c9f0:	e58c9000 	str	r9, [ip]
3481c9f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			base = 16;
3481c9f8:	e1a00003 	mov	r0, r3
3481c9fc:	eaffffde 	b	3481c97c <simple_strtoull+0x54>
3481ca00:	34820934 	.word	0x34820934

3481ca04 <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481ca04:	eafffe4e 	b	3481c344 <vsnprintf_internal.isra.3>

3481ca08 <sprintf>:
}

int sprintf(char * buf, const char *fmt, ...)
{
3481ca08:	e92d000e 	push	{r1, r2, r3}
3481ca0c:	e92d4003 	push	{r0, r1, lr}
	va_list args;
	int i;

	va_start(args, fmt);
3481ca10:	e28d2010 	add	r2, sp, #16
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481ca14:	e59d100c 	ldr	r1, [sp, #12]
	va_start(args, fmt);
3481ca18:	e58d2004 	str	r2, [sp, #4]
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481ca1c:	ebfffe48 	bl	3481c344 <vsnprintf_internal.isra.3>
	i=vsprintf(buf,fmt,args);
	va_end(args);
	return i;
}
3481ca20:	e28dd008 	add	sp, sp, #8
3481ca24:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
3481ca28:	e28dd00c 	add	sp, sp, #12
3481ca2c:	e12fff1e 	bx	lr

3481ca30 <panic>:

void panic(const char *fmt, ...)
{
3481ca30:	e92d000f 	push	{r0, r1, r2, r3}
3481ca34:	e92d4007 	push	{r0, r1, r2, lr}
	va_list	args;
	va_start(args, fmt);
3481ca38:	e28d1014 	add	r1, sp, #20
	vprintf(fmt, args);
3481ca3c:	e59d0010 	ldr	r0, [sp, #16]
	va_start(args, fmt);
3481ca40:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
3481ca44:	ebffb367 	bl	348097e8 <vprintf>
	putc('\n');
3481ca48:	e3a0000a 	mov	r0, #10
3481ca4c:	ebffb33a 	bl	3480973c <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
3481ca50:	e59f0018 	ldr	r0, [pc, #24]	; 3481ca70 <panic+0x40>
3481ca54:	ebfffcec 	bl	3481be0c <udelay>
	do_reset (NULL, 0, 0, NULL);
3481ca58:	e3a03000 	mov	r3, #0
3481ca5c:	e1a02003 	mov	r2, r3
3481ca60:	e1a01003 	mov	r1, r3
3481ca64:	e1a00003 	mov	r0, r3
3481ca68:	ebff9520 	bl	34801ef0 <do_reset>
#endif
	while (1)
		;
3481ca6c:	eafffffe 	b	3481ca6c <panic+0x3c>
3481ca70:	000186a0 	.word	0x000186a0

3481ca74 <__assert_fail>:
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
3481ca74:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
3481ca78:	e58d0000 	str	r0, [sp]
3481ca7c:	e59f0000 	ldr	r0, [pc]	; 3481ca84 <__assert_fail+0x10>
3481ca80:	ebffffea 	bl	3481ca30 <panic>
3481ca84:	34826d7e 	.word	0x34826d7e

3481ca88 <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
3481ca88:	e92d42f0 	push	{r4, r5, r6, r7, r9, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481ca8c:	e3a03000 	mov	r3, #0
3481ca90:	e59f403c 	ldr	r4, [pc, #60]	; 3481cad4 <simple_itoa+0x4c>
{
3481ca94:	e1a05000 	mov	r5, r0
	do {
		*p-- = '0' + i % 10;
		i /= 10;
3481ca98:	e59f7038 	ldr	r7, [pc, #56]	; 3481cad8 <simple_itoa+0x50>
	*p-- = '\0';
3481ca9c:	e5c43015 	strb	r3, [r4, #21]
3481caa0:	e2844014 	add	r4, r4, #20
		*p-- = '0' + i % 10;
3481caa4:	e1a00005 	mov	r0, r5
3481caa8:	e3a0100a 	mov	r1, #10
3481caac:	fa0009f2 	blx	3481f27c <__aeabi_uidivmod>
3481cab0:	e1a06004 	mov	r6, r4
3481cab4:	e2811030 	add	r1, r1, #48	; 0x30
3481cab8:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
3481cabc:	e0810795 	umull	r0, r1, r5, r7
	} while (i > 0);
3481cac0:	e1b051a1 	lsrs	r5, r1, #3
3481cac4:	11a04006 	movne	r4, r6
3481cac8:	1afffff5 	bne	3481caa4 <simple_itoa+0x1c>
	return p + 1;
}
3481cacc:	e1a00004 	mov	r0, r4
3481cad0:	e8bd82f0 	pop	{r4, r5, r6, r7, r9, pc}
3481cad4:	3482a920 	.word	0x3482a920
3481cad8:	cccccccd 	.word	0xcccccccd

3481cadc <zcalloc>:
	unsigned items;
	unsigned size;
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
3481cadc:	e0000192 	mul	r0, r2, r1
3481cae0:	eaffb4fc 	b	34809ed8 <malloc>

3481cae4 <zcfree>:
void  zcfree (opaque, ptr, nb)
	voidpf opaque;
	voidpf ptr;
	unsigned nb;
{
	free(ptr);
3481cae4:	e1a00001 	mov	r0, r1
3481cae8:	eaffb470 	b	34809cb0 <free>

3481caec <inflate_fast>:
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
3481caec:	e590c004 	ldr	ip, [r0, #4]
    in = strm->next_in - OFF;
3481caf0:	e5902000 	ldr	r2, [r0]
{
3481caf4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481caf8:	e24dd038 	sub	sp, sp, #56	; 0x38
    last = in + (strm->avail_in - 5);
3481cafc:	e24c3005 	sub	r3, ip, #5
    state = (struct inflate_state FAR *)strm->state;
3481cb00:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
3481cb04:	e2422001 	sub	r2, r2, #1
    if (in > last && strm->avail_in > 5) {
3481cb08:	e0923003 	adds	r3, r2, r3
3481cb0c:	e58d3014 	str	r3, [sp, #20]
3481cb10:	23a03001 	movcs	r3, #1
3481cb14:	33a03000 	movcc	r3, #0
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
3481cb18:	e595e054 	ldr	lr, [r5, #84]	; 0x54
    if (in > last && strm->avail_in > 5) {
3481cb1c:	e35c0005 	cmp	ip, #5
3481cb20:	93a03000 	movls	r3, #0
3481cb24:	82033001 	andhi	r3, r3, #1
    beg = out - (start - strm->avail_out);
3481cb28:	e590c010 	ldr	ip, [r0, #16]
    if (in > last && strm->avail_in > 5) {
3481cb2c:	e3530000 	cmp	r3, #0
    window = state->window;
3481cb30:	e5954034 	ldr	r4, [r5, #52]	; 0x34
	strm->avail_in = 0xffffffff - (uintptr_t)in;
3481cb34:	11e03002 	mvnne	r3, r2
    hold = state->hold;
3481cb38:	e595b038 	ldr	fp, [r5, #56]	; 0x38
	strm->avail_in = 0xffffffff - (uintptr_t)in;
3481cb3c:	15803004 	strne	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
3481cb40:	12433005 	subne	r3, r3, #5
3481cb44:	10823003 	addne	r3, r2, r3
    beg = out - (start - strm->avail_out);
3481cb48:	e061100c 	rsb	r1, r1, ip
        last = in + (strm->avail_in - 5);
3481cb4c:	158d3014 	strne	r3, [sp, #20]
    out = strm->next_out - OFF;
3481cb50:	e590300c 	ldr	r3, [r0, #12]
3481cb54:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
3481cb58:	e0831001 	add	r1, r3, r1
3481cb5c:	e58d1024 	str	r1, [sp, #36]	; 0x24
    end = out + (strm->avail_out - 257);
3481cb60:	e24c1c01 	sub	r1, ip, #256	; 0x100
    lcode = state->lencode;
3481cb64:	e595c04c 	ldr	ip, [r5, #76]	; 0x4c
    end = out + (strm->avail_out - 257);
3481cb68:	e2411001 	sub	r1, r1, #1
3481cb6c:	e0831001 	add	r1, r3, r1
3481cb70:	e58d101c 	str	r1, [sp, #28]
    lcode = state->lencode;
3481cb74:	e58dc004 	str	ip, [sp, #4]
    dcode = state->distcode;
3481cb78:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    wsize = state->wsize;
3481cb7c:	e5951028 	ldr	r1, [r5, #40]	; 0x28
    dcode = state->distcode;
3481cb80:	e58dc008 	str	ip, [sp, #8]
    lmask = (1U << state->lenbits) - 1;
3481cb84:	e3a0c001 	mov	ip, #1
3481cb88:	e1a0ee1c 	lsl	lr, ip, lr
    wsize = state->wsize;
3481cb8c:	e58d1020 	str	r1, [sp, #32]
    whave = state->whave;
3481cb90:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
    lmask = (1U << state->lenbits) - 1;
3481cb94:	e24ee001 	sub	lr, lr, #1
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481cb98:	e58dc00c 	str	ip, [sp, #12]
    lmask = (1U << state->lenbits) - 1;
3481cb9c:	e58de02c 	str	lr, [sp, #44]	; 0x2c
    dmask = (1U << state->distbits) - 1;
3481cba0:	e595e058 	ldr	lr, [r5, #88]	; 0x58
    whave = state->whave;
3481cba4:	e58d1028 	str	r1, [sp, #40]	; 0x28
    write = state->write;
3481cba8:	e5951030 	ldr	r1, [r5, #48]	; 0x30
    dmask = (1U << state->distbits) - 1;
3481cbac:	e1a0ee1c 	lsl	lr, ip, lr
                    from = window - OFF;
3481cbb0:	e244c001 	sub	ip, r4, #1
    write = state->write;
3481cbb4:	e58d1000 	str	r1, [sp]
    dmask = (1U << state->distbits) - 1;
3481cbb8:	e24ee001 	sub	lr, lr, #1
                    from = window - OFF;
3481cbbc:	e58dc010 	str	ip, [sp, #16]
    dmask = (1U << state->distbits) - 1;
3481cbc0:	e58de030 	str	lr, [sp, #48]	; 0x30
                        from += wsize + write - op;
3481cbc4:	e59dc000 	ldr	ip, [sp]
3481cbc8:	e59de020 	ldr	lr, [sp, #32]
    bits = state->bits;
3481cbcc:	e595103c 	ldr	r1, [r5, #60]	; 0x3c
                        from += wsize + write - op;
3481cbd0:	e08cc00e 	add	ip, ip, lr
3481cbd4:	e58dc034 	str	ip, [sp, #52]	; 0x34
        if (bits < 15) {
3481cbd8:	e351000e 	cmp	r1, #14
3481cbdc:	8a000007 	bhi	3481cc00 <inflate_fast+0x114>
            hold += (unsigned long)(PUP(in)) << bits;
3481cbe0:	e5d2c002 	ldrb	ip, [r2, #2]
            bits += 8;
3481cbe4:	e2814008 	add	r4, r1, #8
            hold += (unsigned long)(PUP(in)) << bits;
3481cbe8:	e5d2e001 	ldrb	lr, [r2, #1]
            hold += (unsigned long)(PUP(in)) << bits;
3481cbec:	e2822002 	add	r2, r2, #2
3481cbf0:	e1a0c41c 	lsl	ip, ip, r4
3481cbf4:	e08cc11e 	add	ip, ip, lr, lsl r1
            bits += 8;
3481cbf8:	e2811010 	add	r1, r1, #16
            hold += (unsigned long)(PUP(in)) << bits;
3481cbfc:	e08bb00c 	add	fp, fp, ip
        this = lcode[hold & lmask];
3481cc00:	e59de004 	ldr	lr, [sp, #4]
3481cc04:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481cc08:	e00bc00c 	and	ip, fp, ip
3481cc0c:	e08e410c 	add	r4, lr, ip, lsl #2
3481cc10:	e7dee10c 	ldrb	lr, [lr, ip, lsl #2]
3481cc14:	e5d4c001 	ldrb	ip, [r4, #1]
3481cc18:	e1d440b2 	ldrh	r4, [r4, #2]
        if (op == 0) {                          /* literal */
3481cc1c:	e35e0000 	cmp	lr, #0
        hold >>= op;
3481cc20:	e1a0bc3b 	lsr	fp, fp, ip
        bits -= op;
3481cc24:	e06c1001 	rsb	r1, ip, r1
            PUP(out) = (unsigned char)(this.val);
3481cc28:	05c34001 	strbeq	r4, [r3, #1]
3481cc2c:	0a0000cb 	beq	3481cf60 <inflate_fast+0x474>
        else if (op & 16) {                     /* length base */
3481cc30:	e31e0010 	tst	lr, #16
3481cc34:	0a0000de 	beq	3481cfb4 <inflate_fast+0x4c8>
            if (op) {
3481cc38:	e21ee00f 	ands	lr, lr, #15
        hold >>= op;
3481cc3c:	e1a0a00b 	mov	sl, fp
            len = (unsigned)(this.val);
3481cc40:	e1a0c004 	mov	ip, r4
            if (op) {
3481cc44:	0a00000b 	beq	3481cc78 <inflate_fast+0x18c>
                if (bits < op) {
3481cc48:	e151000e 	cmp	r1, lr
                    hold += (unsigned long)(PUP(in)) << bits;
3481cc4c:	35d2c001 	ldrbcc	ip, [r2, #1]
3481cc50:	32822001 	addcc	r2, r2, #1
3481cc54:	308ba11c 	addcc	sl, fp, ip, lsl r1
                len += (unsigned)hold & ((1U << op) - 1);
3481cc58:	e59dc00c 	ldr	ip, [sp, #12]
                    bits += 8;
3481cc5c:	32811008 	addcc	r1, r1, #8
                bits -= op;
3481cc60:	e06e1001 	rsb	r1, lr, r1
                len += (unsigned)hold & ((1U << op) - 1);
3481cc64:	e1a0ce1c 	lsl	ip, ip, lr
3481cc68:	e24cc001 	sub	ip, ip, #1
3481cc6c:	e00cc00a 	and	ip, ip, sl
                hold >>= op;
3481cc70:	e1a0ae3a 	lsr	sl, sl, lr
                len += (unsigned)hold & ((1U << op) - 1);
3481cc74:	e084c00c 	add	ip, r4, ip
            if (bits < 15) {
3481cc78:	e351000e 	cmp	r1, #14
3481cc7c:	8a000007 	bhi	3481cca0 <inflate_fast+0x1b4>
                hold += (unsigned long)(PUP(in)) << bits;
3481cc80:	e5d2e002 	ldrb	lr, [r2, #2]
                bits += 8;
3481cc84:	e2816008 	add	r6, r1, #8
                hold += (unsigned long)(PUP(in)) << bits;
3481cc88:	e5d24001 	ldrb	r4, [r2, #1]
                hold += (unsigned long)(PUP(in)) << bits;
3481cc8c:	e2822002 	add	r2, r2, #2
3481cc90:	e1a0e61e 	lsl	lr, lr, r6
3481cc94:	e08ee114 	add	lr, lr, r4, lsl r1
                bits += 8;
3481cc98:	e2811010 	add	r1, r1, #16
                hold += (unsigned long)(PUP(in)) << bits;
3481cc9c:	e08aa00e 	add	sl, sl, lr
            this = dcode[hold & dmask];
3481cca0:	e59d4008 	ldr	r4, [sp, #8]
3481cca4:	e59de030 	ldr	lr, [sp, #48]	; 0x30
3481cca8:	e00ae00e 	and	lr, sl, lr
3481ccac:	e084610e 	add	r6, r4, lr, lsl #2
3481ccb0:	e7d4410e 	ldrb	r4, [r4, lr, lsl #2]
3481ccb4:	e1d690b2 	ldrh	r9, [r6, #2]
3481ccb8:	e5d6e001 	ldrb	lr, [r6, #1]
            if (op & 16) {                      /* distance base */
3481ccbc:	e3140010 	tst	r4, #16
            hold >>= op;
3481ccc0:	e1a0ae3a 	lsr	sl, sl, lr
            bits -= op;
3481ccc4:	e06e1001 	rsb	r1, lr, r1
            if (op & 16) {                      /* distance base */
3481ccc8:	0a0000a6 	beq	3481cf68 <inflate_fast+0x47c>
                op &= 15;                       /* number of extra bits */
3481cccc:	e204400f 	and	r4, r4, #15
            bits -= op;
3481ccd0:	e1a07001 	mov	r7, r1
                if (bits < op) {
3481ccd4:	e1510004 	cmp	r1, r4
            hold >>= op;
3481ccd8:	e1a0e00a 	mov	lr, sl
                if (bits < op) {
3481ccdc:	2a000008 	bcs	3481cd04 <inflate_fast+0x218>
                    hold += (unsigned long)(PUP(in)) << bits;
3481cce0:	e5d26001 	ldrb	r6, [r2, #1]
                    bits += 8;
3481cce4:	e2817008 	add	r7, r1, #8
                    if (bits < op) {
3481cce8:	e1570004 	cmp	r7, r4
                    hold += (unsigned long)(PUP(in)) << bits;
3481ccec:	22822001 	addcs	r2, r2, #1
3481ccf0:	e08ae116 	add	lr, sl, r6, lsl r1
                        hold += (unsigned long)(PUP(in)) << bits;
3481ccf4:	35d26002 	ldrbcc	r6, [r2, #2]
3481ccf8:	32822002 	addcc	r2, r2, #2
3481ccfc:	308ee716 	addcc	lr, lr, r6, lsl r7
                        bits += 8;
3481cd00:	32817010 	addcc	r7, r1, #16
                dist += (unsigned)hold & ((1U << op) - 1);
3481cd04:	e59d100c 	ldr	r1, [sp, #12]
                hold >>= op;
3481cd08:	e1a0b43e 	lsr	fp, lr, r4
                dist += (unsigned)hold & ((1U << op) - 1);
3481cd0c:	e1a06411 	lsl	r6, r1, r4
                bits -= op;
3481cd10:	e0641007 	rsb	r1, r4, r7
                dist += (unsigned)hold & ((1U << op) - 1);
3481cd14:	e2466001 	sub	r6, r6, #1
3481cd18:	e006600e 	and	r6, r6, lr
                op = (unsigned)(out - beg);     /* max distance in output */
3481cd1c:	e59de024 	ldr	lr, [sp, #36]	; 0x24
                dist += (unsigned)hold & ((1U << op) - 1);
3481cd20:	e0866009 	add	r6, r6, r9
                op = (unsigned)(out - beg);     /* max distance in output */
3481cd24:	e06e4003 	rsb	r4, lr, r3
                if (dist > op) {                /* see if copy from window */
3481cd28:	e1560004 	cmp	r6, r4
3481cd2c:	9a00005e 	bls	3481ceac <inflate_fast+0x3c0>
                    if (op > whave) {
3481cd30:	e59de028 	ldr	lr, [sp, #40]	; 0x28
                    op = dist - op;             /* distance back in window */
3481cd34:	e0644006 	rsb	r4, r4, r6
                    if (op > whave) {
3481cd38:	e154000e 	cmp	r4, lr
                        strm->msg = (char *)"invalid distance too far back";
3481cd3c:	859fc334 	ldrhi	ip, [pc, #820]	; 3481d078 <inflate_fast+0x58c>
3481cd40:	8a0000ae 	bhi	3481d000 <inflate_fast+0x514>
                    if (write == 0) {           /* very common case */
3481cd44:	e59d7000 	ldr	r7, [sp]
                    from = window - OFF;
3481cd48:	e59de010 	ldr	lr, [sp, #16]
                    if (write == 0) {           /* very common case */
3481cd4c:	e3570000 	cmp	r7, #0
3481cd50:	1a00000d 	bne	3481cd8c <inflate_fast+0x2a0>
                        from += wsize - op;
3481cd54:	e59de020 	ldr	lr, [sp, #32]
                        if (op < len) {         /* some from window */
3481cd58:	e154000c 	cmp	r4, ip
                        from += wsize - op;
3481cd5c:	e59d7010 	ldr	r7, [sp, #16]
3481cd60:	e064e00e 	rsb	lr, r4, lr
3481cd64:	e087e00e 	add	lr, r7, lr
                        if (op < len) {         /* some from window */
3481cd68:	2a000029 	bcs	3481ce14 <inflate_fast+0x328>
                            len -= op;
3481cd6c:	e064c00c 	rsb	ip, r4, ip
3481cd70:	e1a07003 	mov	r7, r3
3481cd74:	e08e9004 	add	r9, lr, r4
                                PUP(out) = PUP(from);
3481cd78:	e5fea001 	ldrb	sl, [lr, #1]!
                            } while (--op);
3481cd7c:	e15e0009 	cmp	lr, r9
                                PUP(out) = PUP(from);
3481cd80:	e5e7a001 	strb	sl, [r7, #1]!
                            } while (--op);
3481cd84:	1afffffb 	bne	3481cd78 <inflate_fast+0x28c>
3481cd88:	ea000030 	b	3481ce50 <inflate_fast+0x364>
                    else if (write < op) {      /* wrap around window */
3481cd8c:	e59d7000 	ldr	r7, [sp]
3481cd90:	e1570004 	cmp	r7, r4
3481cd94:	2a000020 	bcs	3481ce1c <inflate_fast+0x330>
                        from += wsize + write - op;
3481cd98:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
3481cd9c:	e59d9010 	ldr	r9, [sp, #16]
3481cda0:	e0647007 	rsb	r7, r4, r7
3481cda4:	e0897007 	add	r7, r9, r7
                        op -= write;
3481cda8:	e59d9000 	ldr	r9, [sp]
3481cdac:	e0694004 	rsb	r4, r9, r4
                        if (op < len) {         /* some from end of window */
3481cdb0:	e154000c 	cmp	r4, ip
                        from += wsize + write - op;
3481cdb4:	21a0e007 	movcs	lr, r7
                        if (op < len) {         /* some from end of window */
3481cdb8:	2a000015 	bcs	3481ce14 <inflate_fast+0x328>
                            len -= op;
3481cdbc:	e064c00c 	rsb	ip, r4, ip
3481cdc0:	e1a0a003 	mov	sl, r3
3481cdc4:	e0879004 	add	r9, r7, r4
3481cdc8:	e58d9018 	str	r9, [sp, #24]
                                PUP(out) = PUP(from);
3481cdcc:	e5f79001 	ldrb	r9, [r7, #1]!
3481cdd0:	e5ea9001 	strb	r9, [sl, #1]!
                            } while (--op);
3481cdd4:	e59d9018 	ldr	r9, [sp, #24]
3481cdd8:	e1570009 	cmp	r7, r9
3481cddc:	1afffffa 	bne	3481cdcc <inflate_fast+0x2e0>
3481cde0:	e0833004 	add	r3, r3, r4
                            if (write < len) {  /* some from start of window */
3481cde4:	e59d4000 	ldr	r4, [sp]
3481cde8:	e154000c 	cmp	r4, ip
3481cdec:	2a000008 	bcs	3481ce14 <inflate_fast+0x328>
3481cdf0:	e59d7000 	ldr	r7, [sp]
                                len -= op;
3481cdf4:	e064c00c 	rsb	ip, r4, ip
3481cdf8:	e1a04003 	mov	r4, r3
3481cdfc:	e0833007 	add	r3, r3, r7
                                    PUP(out) = PUP(from);
3481ce00:	e5fe7001 	ldrb	r7, [lr, #1]!
3481ce04:	e5e47001 	strb	r7, [r4, #1]!
                                } while (--op);
3481ce08:	e1540003 	cmp	r4, r3
3481ce0c:	1afffffb 	bne	3481ce00 <inflate_fast+0x314>
                            from = out - dist;  /* rest from output */
3481ce10:	e066e003 	rsb	lr, r6, r3
3481ce14:	e1a04003 	mov	r4, r3
3481ce18:	ea00000e 	b	3481ce58 <inflate_fast+0x36c>
                        from += write - op;
3481ce1c:	e59de000 	ldr	lr, [sp]
                        if (op < len) {         /* some from window */
3481ce20:	e154000c 	cmp	r4, ip
                        from += write - op;
3481ce24:	e59d7010 	ldr	r7, [sp, #16]
3481ce28:	e064e00e 	rsb	lr, r4, lr
3481ce2c:	e087e00e 	add	lr, r7, lr
                        if (op < len) {         /* some from window */
3481ce30:	2afffff7 	bcs	3481ce14 <inflate_fast+0x328>
                            len -= op;
3481ce34:	e064c00c 	rsb	ip, r4, ip
3481ce38:	e1a07003 	mov	r7, r3
3481ce3c:	e08e9004 	add	r9, lr, r4
                                PUP(out) = PUP(from);
3481ce40:	e5fea001 	ldrb	sl, [lr, #1]!
                            } while (--op);
3481ce44:	e15e0009 	cmp	lr, r9
                                PUP(out) = PUP(from);
3481ce48:	e5e7a001 	strb	sl, [r7, #1]!
                            } while (--op);
3481ce4c:	1afffffb 	bne	3481ce40 <inflate_fast+0x354>
3481ce50:	e0833004 	add	r3, r3, r4
3481ce54:	eaffffed 	b	3481ce10 <inflate_fast+0x324>
                    while (len > 2) {
3481ce58:	e35c0002 	cmp	ip, #2
3481ce5c:	e1a03004 	mov	r3, r4
3481ce60:	9a000007 	bls	3481ce84 <inflate_fast+0x398>
                        PUP(out) = PUP(from);
3481ce64:	e5de3001 	ldrb	r3, [lr, #1]
                        len -= 3;
3481ce68:	e24cc003 	sub	ip, ip, #3
                        PUP(out) = PUP(from);
3481ce6c:	e5c43001 	strb	r3, [r4, #1]
                        PUP(out) = PUP(from);
3481ce70:	e5de3002 	ldrb	r3, [lr, #2]
3481ce74:	e5c43002 	strb	r3, [r4, #2]
                        PUP(out) = PUP(from);
3481ce78:	e5fe3003 	ldrb	r3, [lr, #3]!
3481ce7c:	e5e43003 	strb	r3, [r4, #3]!
3481ce80:	eafffff4 	b	3481ce58 <inflate_fast+0x36c>
                    if (len) {
3481ce84:	e35c0000 	cmp	ip, #0
3481ce88:	0a00005f 	beq	3481d00c <inflate_fast+0x520>
                        PUP(out) = PUP(from);
3481ce8c:	e5de6001 	ldrb	r6, [lr, #1]
                        if (len > 1)
3481ce90:	e35c0002 	cmp	ip, #2
                            PUP(out) = PUP(from);
3481ce94:	02843002 	addeq	r3, r4, #2
                        PUP(out) = PUP(from);
3481ce98:	e5c46001 	strb	r6, [r4, #1]
                            PUP(out) = PUP(from);
3481ce9c:	05dec002 	ldrbeq	ip, [lr, #2]
3481cea0:	05c4c002 	strbeq	ip, [r4, #2]
                        if (len > 1)
3481cea4:	0a000058 	beq	3481d00c <inflate_fast+0x520>
3481cea8:	ea00002c 	b	3481cf60 <inflate_fast+0x474>
		    if (!((long)(out - 1 + OFF) & 1)) {
3481ceac:	e3130001 	tst	r3, #1
                    from = out - dist;          /* copy direct from output */
3481ceb0:	e0669003 	rsb	r9, r6, r3
			PUP(out) = PUP(from);
3481ceb4:	05d9e001 	ldrbeq	lr, [r9, #1]
			len--;
3481ceb8:	024cc001 	subeq	ip, ip, #1
			PUP(out) = PUP(from);
3481cebc:	02899001 	addeq	r9, r9, #1
3481cec0:	05c3e001 	strbeq	lr, [r3, #1]
3481cec4:	02833001 	addeq	r3, r3, #1
		    if (dist > 2 ) {
3481cec8:	e3560002 	cmp	r6, #2
		    sout = (unsigned short *)(out - OFF);
3481cecc:	e2434001 	sub	r4, r3, #1
		    if (dist > 2 ) {
3481ced0:	9a000012 	bls	3481cf20 <inflate_fast+0x434>
			sfrom = (unsigned short *)(from - OFF);
3481ced4:	e2499001 	sub	r9, r9, #1
			loops = len >> 1;
3481ced8:	e1a0e0ac 	lsr	lr, ip, #1
3481cedc:	e1a07009 	mov	r7, r9
3481cee0:	e1a0a004 	mov	sl, r4
3481cee4:	e58de018 	str	lr, [sp, #24]
3481cee8:	e5d76003 	ldrb	r6, [r7, #3]
3481ceec:	e1a03006 	mov	r3, r6
3481cef0:	e5f76002 	ldrb	r6, [r7, #2]!
3481cef4:	e1866403 	orr	r6, r6, r3, lsl #8
			while (--loops);
3481cef8:	e59d3018 	ldr	r3, [sp, #24]
			    PUP(sout) = get_unaligned(++sfrom);
3481cefc:	e1ea60b2 	strh	r6, [sl, #2]!
			while (--loops);
3481cf00:	e2533001 	subs	r3, r3, #1
3481cf04:	e58d3018 	str	r3, [sp, #24]
3481cf08:	1afffff6 	bne	3481cee8 <inflate_fast+0x3fc>
3481cf0c:	e1a0e08e 	lsl	lr, lr, #1
3481cf10:	e28ee001 	add	lr, lr, #1
			out = (unsigned char *)sout + OFF;
3481cf14:	e084300e 	add	r3, r4, lr
			from = (unsigned char *)sfrom + OFF;
3481cf18:	e089900e 	add	r9, r9, lr
3481cf1c:	ea00000b 	b	3481cf50 <inflate_fast+0x464>
			pat16 = *(sout-2+2*OFF);
3481cf20:	e153e0b1 	ldrh	lr, [r3, #-1]
			if (dist == 1)
3481cf24:	e3560001 	cmp	r6, #1
		    sout = (unsigned short *)(out - OFF);
3481cf28:	e1a07004 	mov	r7, r4
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
3481cf2c:	03ce30ff 	biceq	r3, lr, #255	; 0xff
3481cf30:	0183e42e 	orreq	lr, r3, lr, lsr #8
			loops = len >> 1;
3481cf34:	e1a030ac 	lsr	r3, ip, #1
3481cf38:	e1a06003 	mov	r6, r3
			while (--loops);
3481cf3c:	e2566001 	subs	r6, r6, #1
			    PUP(sout) = pat16;
3481cf40:	e1e7e0b2 	strh	lr, [r7, #2]!
			while (--loops);
3481cf44:	1afffffc 	bne	3481cf3c <inflate_fast+0x450>
3481cf48:	e0843083 	add	r3, r4, r3, lsl #1
			out = (unsigned char *)sout + OFF;
3481cf4c:	e2833001 	add	r3, r3, #1
		    if (len & 1)
3481cf50:	e31c0001 	tst	ip, #1
3481cf54:	0a00002c 	beq	3481d00c <inflate_fast+0x520>
			PUP(out) = PUP(from);
3481cf58:	e5d9c001 	ldrb	ip, [r9, #1]
3481cf5c:	e5c3c001 	strb	ip, [r3, #1]
3481cf60:	e2833001 	add	r3, r3, #1
3481cf64:	ea000028 	b	3481d00c <inflate_fast+0x520>
            else if ((op & 64) == 0) {          /* 2nd level distance code */
3481cf68:	e3140040 	tst	r4, #64	; 0x40
3481cf6c:	1a00000a 	bne	3481cf9c <inflate_fast+0x4b0>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
3481cf70:	e59de00c 	ldr	lr, [sp, #12]
3481cf74:	e1a0641e 	lsl	r6, lr, r4
3481cf78:	e59de008 	ldr	lr, [sp, #8]
3481cf7c:	e2466001 	sub	r6, r6, #1
3481cf80:	e006600a 	and	r6, r6, sl
3481cf84:	e0866009 	add	r6, r6, r9
3481cf88:	e08e7106 	add	r7, lr, r6, lsl #2
3481cf8c:	e7de4106 	ldrb	r4, [lr, r6, lsl #2]
3481cf90:	e1d790b2 	ldrh	r9, [r7, #2]
3481cf94:	e5d7e001 	ldrb	lr, [r7, #1]
                goto dodist;
3481cf98:	eaffff47 	b	3481ccbc <inflate_fast+0x1d0>
                strm->msg = (char *)"invalid distance code";
3481cf9c:	e59fc0d8 	ldr	ip, [pc, #216]	; 3481d07c <inflate_fast+0x590>
            hold >>= op;
3481cfa0:	e1a0b00a 	mov	fp, sl
                strm->msg = (char *)"invalid distance code";
3481cfa4:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
3481cfa8:	e3a0c01b 	mov	ip, #27
3481cfac:	e585c000 	str	ip, [r5]
                break;
3481cfb0:	ea00001a 	b	3481d020 <inflate_fast+0x534>
        else if ((op & 64) == 0) {              /* 2nd level length code */
3481cfb4:	e31e0040 	tst	lr, #64	; 0x40
3481cfb8:	1a00000a 	bne	3481cfe8 <inflate_fast+0x4fc>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481cfbc:	e59dc00c 	ldr	ip, [sp, #12]
3481cfc0:	e1a0ee1c 	lsl	lr, ip, lr
3481cfc4:	e59dc004 	ldr	ip, [sp, #4]
3481cfc8:	e24ee001 	sub	lr, lr, #1
3481cfcc:	e00ee00b 	and	lr, lr, fp
3481cfd0:	e08e4004 	add	r4, lr, r4
3481cfd4:	e08c6104 	add	r6, ip, r4, lsl #2
3481cfd8:	e7dce104 	ldrb	lr, [ip, r4, lsl #2]
3481cfdc:	e5d6c001 	ldrb	ip, [r6, #1]
3481cfe0:	e1d640b2 	ldrh	r4, [r6, #2]
            goto dolen;
3481cfe4:	eaffff0c 	b	3481cc1c <inflate_fast+0x130>
        }
        else if (op & 32) {                     /* end-of-block */
3481cfe8:	e31e0020 	tst	lr, #32
3481cfec:	0a000002 	beq	3481cffc <inflate_fast+0x510>
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
3481cff0:	e3a0c00b 	mov	ip, #11
3481cff4:	e585c000 	str	ip, [r5]
            break;
3481cff8:	ea000008 	b	3481d020 <inflate_fast+0x534>
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
3481cffc:	e59fc07c 	ldr	ip, [pc, #124]	; 3481d080 <inflate_fast+0x594>
3481d000:	e580c018 	str	ip, [r0, #24]
            state->mode = BAD;
3481d004:	e3a0c01b 	mov	ip, #27
3481d008:	eafffff9 	b	3481cff4 <inflate_fast+0x508>
            break;
        }
    } while (in < last && out < end);
3481d00c:	e59dc01c 	ldr	ip, [sp, #28]
3481d010:	e59de014 	ldr	lr, [sp, #20]
3481d014:	e153000c 	cmp	r3, ip
3481d018:	3152000e 	cmpcc	r2, lr
3481d01c:	3afffeed 	bcc	3481cbd8 <inflate_fast+0xec>

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
3481d020:	e1a0c1a1 	lsr	ip, r1, #3
    in -= len;
3481d024:	e06c2002 	rsb	r2, ip, r2
    bits -= len << 3;
3481d028:	e041118c 	sub	r1, r1, ip, lsl #3
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
3481d02c:	e282e001 	add	lr, r2, #1
3481d030:	e580e000 	str	lr, [r0]
    strm->next_out = out + OFF;
3481d034:	e283e001 	add	lr, r3, #1
3481d038:	e580e00c 	str	lr, [r0, #12]
    hold &= (1U << bits) - 1;
3481d03c:	e3e0c000 	mvn	ip, #0
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481d040:	e59de014 	ldr	lr, [sp, #20]
    hold &= (1U << bits) - 1;
3481d044:	e1cbc11c 	bic	ip, fp, ip, lsl r1
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481d048:	e062200e 	rsb	r2, r2, lr
3481d04c:	e2822005 	add	r2, r2, #5
3481d050:	e5802004 	str	r2, [r0, #4]
3481d054:	e59d201c 	ldr	r2, [sp, #28]
3481d058:	e0633002 	rsb	r3, r3, r2
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
3481d05c:	e2833c01 	add	r3, r3, #256	; 0x100
3481d060:	e2833001 	add	r3, r3, #1
    strm->avail_out = (unsigned)(out < end ?
3481d064:	e5803010 	str	r3, [r0, #16]
    state->hold = hold;
3481d068:	e585c038 	str	ip, [r5, #56]	; 0x38
    state->bits = bits;
3481d06c:	e585103c 	str	r1, [r5, #60]	; 0x3c
    return;
}
3481d070:	e28dd038 	add	sp, sp, #56	; 0x38
3481d074:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d078:	34826da0 	.word	0x34826da0
3481d07c:	34826dbe 	.word	0x34826dbe
3481d080:	34826dd4 	.word	0x34826dd4

3481d084 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481d084:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481d088:	e24dd080 	sub	sp, sp, #128	; 0x80
3481d08c:	e59d60a4 	ldr	r6, [sp, #164]	; 0xa4
3481d090:	e58d100c 	str	r1, [sp, #12]
3481d094:	e3a01000 	mov	r1, #0
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
3481d098:	e1a0c001 	mov	ip, r1
3481d09c:	e28de040 	add	lr, sp, #64	; 0x40
3481d0a0:	e18ec0b1 	strh	ip, [lr, r1]
3481d0a4:	e2811002 	add	r1, r1, #2
    for (len = 0; len <= MAXBITS; len++)
3481d0a8:	e3510020 	cmp	r1, #32
3481d0ac:	1afffffa 	bne	3481d09c <inflate_table+0x18>
3481d0b0:	e59dc00c 	ldr	ip, [sp, #12]
3481d0b4:	e08c4082 	add	r4, ip, r2, lsl #1
    for (sym = 0; sym < codes; sym++)
3481d0b8:	e15c0004 	cmp	ip, r4
3481d0bc:	0a000006 	beq	3481d0dc <inflate_table+0x58>
        count[lens[sym]]++;
3481d0c0:	e0dc10b2 	ldrh	r1, [ip], #2
3481d0c4:	e28de080 	add	lr, sp, #128	; 0x80
3481d0c8:	e08e1081 	add	r1, lr, r1, lsl #1
3481d0cc:	e151e4b0 	ldrh	lr, [r1, #-64]	; 0xffffffc0
3481d0d0:	e28ee001 	add	lr, lr, #1
3481d0d4:	e141e4b0 	strh	lr, [r1, #-64]	; 0xffffffc0
3481d0d8:	eafffff6 	b	3481d0b8 <inflate_table+0x34>

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
3481d0dc:	e59d10a0 	ldr	r1, [sp, #160]	; 0xa0
    for (max = MAXBITS; max >= 1; max--)
3481d0e0:	e3a0e00f 	mov	lr, #15
    root = *bits;
3481d0e4:	e591c000 	ldr	ip, [r1]
3481d0e8:	e1a0108e 	lsl	r1, lr, #1
        if (count[max] != 0) break;
3481d0ec:	e28d4040 	add	r4, sp, #64	; 0x40
3481d0f0:	e19410b1 	ldrh	r1, [r4, r1]
3481d0f4:	e3510000 	cmp	r1, #0
3481d0f8:	1a000002 	bne	3481d108 <inflate_table+0x84>
    for (max = MAXBITS; max >= 1; max--)
3481d0fc:	e25ee001 	subs	lr, lr, #1
3481d100:	1afffff8 	bne	3481d0e8 <inflate_table+0x64>
3481d104:	ea000128 	b	3481d5ac <inflate_table+0x528>
    if (root > max) root = max;
3481d108:	e15c000e 	cmp	ip, lr
3481d10c:	9a000000 	bls	3481d114 <inflate_table+0x90>
3481d110:	e1a0c00e 	mov	ip, lr
    if (max == 0) {                     /* no symbols to code at all */
3481d114:	e35e0000 	cmp	lr, #0
3481d118:	13a01001 	movne	r1, #1
3481d11c:	1a000014 	bne	3481d174 <inflate_table+0xf0>
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481d120:	e5932000 	ldr	r2, [r3]
3481d124:	e3a0c040 	mov	ip, #64	; 0x40
3481d128:	e3a00000 	mov	r0, #0
3481d12c:	e2821004 	add	r1, r2, #4
3481d130:	e5831000 	str	r1, [r3]
3481d134:	e3a01001 	mov	r1, #1
3481d138:	e5c2c000 	strb	ip, [r2]
3481d13c:	e5c21001 	strb	r1, [r2, #1]
3481d140:	e1c200b2 	strh	r0, [r2, #2]
        *(*table)++ = this;
3481d144:	e5932000 	ldr	r2, [r3]
3481d148:	e282e004 	add	lr, r2, #4
3481d14c:	e583e000 	str	lr, [r3]
        *bits = 1;
3481d150:	e59d30a0 	ldr	r3, [sp, #160]	; 0xa0
        *(*table)++ = this;
3481d154:	e5c2c000 	strb	ip, [r2]
3481d158:	e5c21001 	strb	r1, [r2, #1]
3481d15c:	e1c200b2 	strh	r0, [r2, #2]
        *bits = 1;
3481d160:	e5831000 	str	r1, [r3]
        return 0;     /* no symbols, but wait for decoding to report error */
3481d164:	ea000113 	b	3481d5b8 <inflate_table+0x534>
    }
    for (min = 1; min <= MAXBITS; min++)
3481d168:	e2811001 	add	r1, r1, #1
3481d16c:	e3510010 	cmp	r1, #16
3481d170:	0a000006 	beq	3481d190 <inflate_table+0x10c>
3481d174:	e1a04081 	lsl	r4, r1, #1
        if (count[min] != 0) break;
3481d178:	e28d5040 	add	r5, sp, #64	; 0x40
3481d17c:	e19540b4 	ldrh	r4, [r5, r4]
3481d180:	e3540000 	cmp	r4, #0
3481d184:	0afffff7 	beq	3481d168 <inflate_table+0xe4>
    if (root < min) root = min;
3481d188:	e15c0001 	cmp	ip, r1
3481d18c:	2a000000 	bcs	3481d194 <inflate_table+0x110>
3481d190:	e1a0c001 	mov	ip, r1
3481d194:	e3a05000 	mov	r5, #0

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
3481d198:	e3a04001 	mov	r4, #1
3481d19c:	e28d7040 	add	r7, sp, #64	; 0x40
3481d1a0:	e0877005 	add	r7, r7, r5
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
3481d1a4:	e1d770b2 	ldrh	r7, [r7, #2]
        if (left < 0) return -1;        /* over-subscribed */
3481d1a8:	e0774084 	rsbs	r4, r7, r4, lsl #1
3481d1ac:	4a0000fc 	bmi	3481d5a4 <inflate_table+0x520>
3481d1b0:	e2855002 	add	r5, r5, #2
    for (len = 1; len <= MAXBITS; len++) {
3481d1b4:	e355001e 	cmp	r5, #30
3481d1b8:	1afffff7 	bne	3481d19c <inflate_table+0x118>
    }
    if (left > 0 && (type == CODES || max != 1))
3481d1bc:	e3540000 	cmp	r4, #0
3481d1c0:	0a000005 	beq	3481d1dc <inflate_table+0x158>
3481d1c4:	e16f4f10 	clz	r4, r0
3481d1c8:	e1a042a4 	lsr	r4, r4, #5
3481d1cc:	e35e0001 	cmp	lr, #1
3481d1d0:	13844001 	orrne	r4, r4, #1
3481d1d4:	e3540000 	cmp	r4, #0
3481d1d8:	1a0000f1 	bne	3481d5a4 <inflate_table+0x520>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
3481d1dc:	e3a04000 	mov	r4, #0
3481d1e0:	e1cd46b2 	strh	r4, [sp, #98]	; 0x62
3481d1e4:	e28d5060 	add	r5, sp, #96	; 0x60
3481d1e8:	e0857004 	add	r7, r5, r4
3481d1ec:	e28d5040 	add	r5, sp, #64	; 0x40
3481d1f0:	e0855004 	add	r5, r5, r4
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
3481d1f4:	e1d790b2 	ldrh	r9, [r7, #2]
3481d1f8:	e1d550b2 	ldrh	r5, [r5, #2]
3481d1fc:	e2844002 	add	r4, r4, #2
    for (len = 1; len < MAXBITS; len++)
3481d200:	e354001c 	cmp	r4, #28
        offs[len + 1] = offs[len] + count[len];
3481d204:	e0855009 	add	r5, r5, r9
3481d208:	e1c750b4 	strh	r5, [r7, #4]
    for (len = 1; len < MAXBITS; len++)
3481d20c:	1afffff4 	bne	3481d1e4 <inflate_table+0x160>
3481d210:	e59d400c 	ldr	r4, [sp, #12]
3481d214:	e3a05000 	mov	r5, #0
3481d218:	e2449002 	sub	r9, r4, #2

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
3481d21c:	e1550002 	cmp	r5, r2
3481d220:	0a00000b 	beq	3481d254 <inflate_table+0x1d0>
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
3481d224:	e1f940b2 	ldrh	r4, [r9, #2]!
3481d228:	e3540000 	cmp	r4, #0
3481d22c:	0a000006 	beq	3481d24c <inflate_table+0x1c8>
3481d230:	e28d7080 	add	r7, sp, #128	; 0x80
3481d234:	e0874084 	add	r4, r7, r4, lsl #1
3481d238:	e15472b0 	ldrh	r7, [r4, #-32]	; 0xffffffe0
3481d23c:	e287a001 	add	sl, r7, #1
3481d240:	e1a07087 	lsl	r7, r7, #1
3481d244:	e144a2b0 	strh	sl, [r4, #-32]	; 0xffffffe0
3481d248:	e18650b7 	strh	r5, [r6, r7]
    for (sym = 0; sym < codes; sym++)
3481d24c:	e2855001 	add	r5, r5, #1
3481d250:	eafffff1 	b	3481d21c <inflate_table+0x198>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
3481d254:	e3500000 	cmp	r0, #0
3481d258:	0a000007 	beq	3481d27c <inflate_table+0x1f8>
3481d25c:	e3500001 	cmp	r0, #1
3481d260:	0a00000a 	beq	3481d290 <inflate_table+0x20c>
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
3481d264:	e3e02000 	mvn	r2, #0
3481d268:	e58d2018 	str	r2, [sp, #24]
        extra = dext;
3481d26c:	e59f234c 	ldr	r2, [pc, #844]	; 3481d5c0 <inflate_table+0x53c>
3481d270:	e58d2004 	str	r2, [sp, #4]
        base = dbase;
3481d274:	e2822040 	add	r2, r2, #64	; 0x40
3481d278:	ea000009 	b	3481d2a4 <inflate_table+0x220>
        end = 19;
3481d27c:	e3a02013 	mov	r2, #19
        base = extra = work;    /* dummy value--not used */
3481d280:	e58d6004 	str	r6, [sp, #4]
3481d284:	e58d6014 	str	r6, [sp, #20]
        end = 19;
3481d288:	e58d2018 	str	r2, [sp, #24]
3481d28c:	ea000005 	b	3481d2a8 <inflate_table+0x224>
        end = 256;
3481d290:	e3a02c01 	mov	r2, #256	; 0x100
3481d294:	e58d2018 	str	r2, [sp, #24]
        extra -= 257;
3481d298:	e59f2324 	ldr	r2, [pc, #804]	; 3481d5c4 <inflate_table+0x540>
3481d29c:	e58d2004 	str	r2, [sp, #4]
        base -= 257;
3481d2a0:	e282203e 	add	r2, r2, #62	; 0x3e
3481d2a4:	e58d2014 	str	r2, [sp, #20]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481d2a8:	e3a05001 	mov	r5, #1
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481d2ac:	e30045af 	movw	r4, #1455	; 0x5af
3481d2b0:	e0652000 	rsb	r2, r5, r0
    used = 1U << root;          /* use root table entries */
3481d2b4:	e1a0ac15 	lsl	sl, r5, ip
    if (type == LENS && used >= ENOUGH - MAXD)
3481d2b8:	e16f2f12 	clz	r2, r2
    next = *table;              /* current table to fill in */
3481d2bc:	e593b000 	ldr	fp, [r3]
    if (type == LENS && used >= ENOUGH - MAXD)
3481d2c0:	e1a022a2 	lsr	r2, r2, #5
3481d2c4:	e58d2034 	str	r2, [sp, #52]	; 0x34
3481d2c8:	e15a0004 	cmp	sl, r4
3481d2cc:	93a02000 	movls	r2, #0
3481d2d0:	82022001 	andhi	r2, r2, #1
3481d2d4:	e3520000 	cmp	r2, #0
3481d2d8:	1a000009 	bne	3481d304 <inflate_table+0x280>
    mask = used - 1;            /* mask for comparing low */
3481d2dc:	e24a0001 	sub	r0, sl, #1
3481d2e0:	e58d6020 	str	r6, [sp, #32]
3481d2e4:	e58d0030 	str	r0, [sp, #48]	; 0x30
3481d2e8:	e3e00000 	mvn	r0, #0
3481d2ec:	e58d0010 	str	r0, [sp, #16]
3481d2f0:	e1a0900c 	mov	r9, ip
3481d2f4:	e1a00002 	mov	r0, r2
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
3481d2f8:	e58d5008 	str	r5, [sp, #8]
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
3481d2fc:	e58d403c 	str	r4, [sp, #60]	; 0x3c
3481d300:	ea000010 	b	3481d348 <inflate_table+0x2c4>
        return 1;
3481d304:	e3a00001 	mov	r0, #1
3481d308:	ea0000aa 	b	3481d5b8 <inflate_table+0x534>
        if (incr != 0) {
3481d30c:	e3540000 	cmp	r4, #0
            huff &= incr - 1;
3481d310:	12445001 	subne	r5, r4, #1
            huff = 0;
3481d314:	01a02004 	moveq	r2, r4
            huff &= incr - 1;
3481d318:	10022005 	andne	r2, r2, r5
            huff += incr;
3481d31c:	10822004 	addne	r2, r2, r4
        if (--(count[len]) == 0) {
3481d320:	e28d4080 	add	r4, sp, #128	; 0x80
3481d324:	e0845081 	add	r5, r4, r1, lsl #1
3481d328:	e15544b0 	ldrh	r4, [r5, #-64]	; 0xffffffc0
3481d32c:	e2444001 	sub	r4, r4, #1
3481d330:	e6ff4074 	uxth	r4, r4
3481d334:	e3540000 	cmp	r4, #0
3481d338:	e14544b0 	strh	r4, [r5, #-64]	; 0xffffffc0
3481d33c:	0a00003a 	beq	3481d42c <inflate_table+0x3a8>
        if (len > root && (huff & mask) != low) {
3481d340:	e151000c 	cmp	r1, ip
3481d344:	8a000040 	bhi	3481d44c <inflate_table+0x3c8>
        this.bits = (unsigned char)(len - drop);
3481d348:	e0604001 	rsb	r4, r0, r1
3481d34c:	e6ef4074 	uxtb	r4, r4
3481d350:	e58d4024 	str	r4, [sp, #36]	; 0x24
        if ((int)(work[sym]) < end) {
3481d354:	e59d4020 	ldr	r4, [sp, #32]
3481d358:	e0d450b2 	ldrh	r5, [r4], #2
3481d35c:	e58d4020 	str	r4, [sp, #32]
3481d360:	e59d4018 	ldr	r4, [sp, #24]
3481d364:	e1550004 	cmp	r5, r4
3481d368:	ba000007 	blt	3481d38c <inflate_table+0x308>
        else if ((int)(work[sym]) > end) {
3481d36c:	da000008 	ble	3481d394 <inflate_table+0x310>
            this.op = (unsigned char)(extra[work[sym]]);
3481d370:	e59d4004 	ldr	r4, [sp, #4]
3481d374:	e1a05085 	lsl	r5, r5, #1
3481d378:	e7d44005 	ldrb	r4, [r4, r5]
3481d37c:	e58d4028 	str	r4, [sp, #40]	; 0x28
            this.val = base[work[sym]];
3481d380:	e59d4014 	ldr	r4, [sp, #20]
3481d384:	e19450b5 	ldrh	r5, [r4, r5]
3481d388:	ea000004 	b	3481d3a0 <inflate_table+0x31c>
            this.op = (unsigned char)0;
3481d38c:	e3a04000 	mov	r4, #0
3481d390:	ea000001 	b	3481d39c <inflate_table+0x318>
            this.val = 0;
3481d394:	e3a05000 	mov	r5, #0
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481d398:	e3a04060 	mov	r4, #96	; 0x60
3481d39c:	e58d4028 	str	r4, [sp, #40]	; 0x28
        incr = 1U << (len - drop);
3481d3a0:	e59d4008 	ldr	r4, [sp, #8]
3481d3a4:	e0606001 	rsb	r6, r0, r1
3481d3a8:	e1a04614 	lsl	r4, r4, r6
3481d3ac:	e1a07004 	mov	r7, r4
        fill = 1U << curr;
3481d3b0:	e59d4008 	ldr	r4, [sp, #8]
3481d3b4:	e1a04914 	lsl	r4, r4, r9
3481d3b8:	e58d401c 	str	r4, [sp, #28]
3481d3bc:	e3e04003 	mvn	r4, #3
3481d3c0:	e0040794 	mul	r4, r4, r7
3481d3c4:	e59d601c 	ldr	r6, [sp, #28]
3481d3c8:	e58d602c 	str	r6, [sp, #44]	; 0x2c
3481d3cc:	e58d4038 	str	r4, [sp, #56]	; 0x38
3481d3d0:	e59d401c 	ldr	r4, [sp, #28]
3481d3d4:	e0844032 	add	r4, r4, r2, lsr r0
3481d3d8:	e0674004 	rsb	r4, r7, r4
3481d3dc:	e08b4104 	add	r4, fp, r4, lsl #2
3481d3e0:	e2844001 	add	r4, r4, #1
            next[(huff >> drop) + fill] = this;
3481d3e4:	e5dd6028 	ldrb	r6, [sp, #40]	; 0x28
3481d3e8:	e1c450b1 	strh	r5, [r4, #1]
3481d3ec:	e5446001 	strb	r6, [r4, #-1]
3481d3f0:	e5dd6024 	ldrb	r6, [sp, #36]	; 0x24
3481d3f4:	e5c46000 	strb	r6, [r4]
3481d3f8:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
3481d3fc:	e0844006 	add	r4, r4, r6
        } while (fill != 0);
3481d400:	e59d602c 	ldr	r6, [sp, #44]	; 0x2c
3481d404:	e0566007 	subs	r6, r6, r7
3481d408:	e58d602c 	str	r6, [sp, #44]	; 0x2c
3481d40c:	1afffff4 	bne	3481d3e4 <inflate_table+0x360>
        incr = 1U << (len - 1);
3481d410:	e59d5008 	ldr	r5, [sp, #8]
3481d414:	e2414001 	sub	r4, r1, #1
3481d418:	e1a04415 	lsl	r4, r5, r4
        while (huff & incr)
3481d41c:	e1140002 	tst	r4, r2
3481d420:	0affffb9 	beq	3481d30c <inflate_table+0x288>
            incr >>= 1;
3481d424:	e1a040a4 	lsr	r4, r4, #1
3481d428:	eafffffb 	b	3481d41c <inflate_table+0x398>
            if (len == max) break;
3481d42c:	e151000e 	cmp	r1, lr
3481d430:	0a000035 	beq	3481d50c <inflate_table+0x488>
            len = lens[work[sym]];
3481d434:	e59d1020 	ldr	r1, [sp, #32]
3481d438:	e59d400c 	ldr	r4, [sp, #12]
3481d43c:	e1d110b0 	ldrh	r1, [r1]
3481d440:	e1a01081 	lsl	r1, r1, #1
3481d444:	e19410b1 	ldrh	r1, [r4, r1]
3481d448:	eaffffbc 	b	3481d340 <inflate_table+0x2bc>
        if (len > root && (huff & mask) != low) {
3481d44c:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
3481d450:	e0025004 	and	r5, r2, r4
3481d454:	e59d4010 	ldr	r4, [sp, #16]
3481d458:	e1550004 	cmp	r5, r4
3481d45c:	0affffb9 	beq	3481d348 <inflate_table+0x2c4>
            next += min;            /* here min is 1 << curr */
3481d460:	e59d401c 	ldr	r4, [sp, #28]
            if (drop == 0)
3481d464:	e3500000 	cmp	r0, #0
            left = (int)(1 << curr);
3481d468:	e59d6008 	ldr	r6, [sp, #8]
            if (drop == 0)
3481d46c:	01a0000c 	moveq	r0, ip
            next += min;            /* here min is 1 << curr */
3481d470:	e08bb104 	add	fp, fp, r4, lsl #2
            curr = len - drop;
3481d474:	e0604001 	rsb	r4, r0, r1
            left = (int)(1 << curr);
3481d478:	e1a07416 	lsl	r7, r6, r4
3481d47c:	e28d6040 	add	r6, sp, #64	; 0x40
3481d480:	e0869080 	add	r9, r6, r0, lsl #1
3481d484:	e0846000 	add	r6, r4, r0
            while (curr + drop < max) {
3481d488:	e156000e 	cmp	r6, lr
3481d48c:	2a000004 	bcs	3481d4a4 <inflate_table+0x420>
3481d490:	e1a06084 	lsl	r6, r4, #1
                left -= count[curr + drop];
3481d494:	e19960b6 	ldrh	r6, [r9, r6]
3481d498:	e0667007 	rsb	r7, r6, r7
                if (left <= 0) break;
3481d49c:	e3570000 	cmp	r7, #0
3481d4a0:	ca000016 	bgt	3481d500 <inflate_table+0x47c>
            used += 1U << curr;
3481d4a4:	e59d6008 	ldr	r6, [sp, #8]
3481d4a8:	e1a09004 	mov	r9, r4
            if (type == LENS && used >= ENOUGH - MAXD)
3481d4ac:	e59d703c 	ldr	r7, [sp, #60]	; 0x3c
            used += 1U << curr;
3481d4b0:	e08aa416 	add	sl, sl, r6, lsl r4
            if (type == LENS && used >= ENOUGH - MAXD)
3481d4b4:	e59d6034 	ldr	r6, [sp, #52]	; 0x34
3481d4b8:	e15a0007 	cmp	sl, r7
3481d4bc:	93a06000 	movls	r6, #0
3481d4c0:	82066001 	andhi	r6, r6, #1
3481d4c4:	e3560000 	cmp	r6, #0
3481d4c8:	1affff8d 	bne	3481d304 <inflate_table+0x280>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481d4cc:	e5937000 	ldr	r7, [r3]
3481d4d0:	e1a06105 	lsl	r6, r5, #2
            (*table)[low].bits = (unsigned char)root;
            (*table)[low].val = (unsigned short)(next - *table);
3481d4d4:	e58d5010 	str	r5, [sp, #16]
            (*table)[low].op = (unsigned char)curr;
3481d4d8:	e7c74105 	strb	r4, [r7, r5, lsl #2]
            (*table)[low].bits = (unsigned char)root;
3481d4dc:	e5934000 	ldr	r4, [r3]
3481d4e0:	e0844006 	add	r4, r4, r6
3481d4e4:	e5c4c001 	strb	ip, [r4, #1]
            (*table)[low].val = (unsigned short)(next - *table);
3481d4e8:	e5934000 	ldr	r4, [r3]
3481d4ec:	e0846006 	add	r6, r4, r6
3481d4f0:	e064400b 	rsb	r4, r4, fp
3481d4f4:	e1a04144 	asr	r4, r4, #2
3481d4f8:	e1c640b2 	strh	r4, [r6, #2]
3481d4fc:	eaffff91 	b	3481d348 <inflate_table+0x2c4>
                curr++;
3481d500:	e2844001 	add	r4, r4, #1
                left <<= 1;
3481d504:	e1a07087 	lsl	r7, r7, #1
3481d508:	eaffffdd 	b	3481d484 <inflate_table+0x400>
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
3481d50c:	e6ef607c 	uxtb	r6, ip
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481d510:	e3a07040 	mov	r7, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481d514:	e3a09001 	mov	r9, #1
    while (huff != 0) {
3481d518:	e3520000 	cmp	r2, #0
3481d51c:	0a000019 	beq	3481d588 <inflate_table+0x504>
        if (drop != 0 && (huff & mask) != low) {
3481d520:	e3500000 	cmp	r0, #0
3481d524:	0a000007 	beq	3481d548 <inflate_table+0x4c4>
3481d528:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3481d52c:	e59d5010 	ldr	r5, [sp, #16]
3481d530:	e0021001 	and	r1, r2, r1
3481d534:	e1510005 	cmp	r1, r5
            next = *table;
3481d538:	1593b000 	ldrne	fp, [r3]
            this.bits = (unsigned char)len;
3481d53c:	11a0e00c 	movne	lr, ip
            drop = 0;
3481d540:	13a00000 	movne	r0, #0
            this.bits = (unsigned char)len;
3481d544:	158d6024 	strne	r6, [sp, #36]	; 0x24
        next[huff >> drop] = this;
3481d548:	e1a05032 	lsr	r5, r2, r0
3481d54c:	e08b1105 	add	r1, fp, r5, lsl #2
3481d550:	e7cb7105 	strb	r7, [fp, r5, lsl #2]
3481d554:	e5dd5024 	ldrb	r5, [sp, #36]	; 0x24
3481d558:	e1c140b2 	strh	r4, [r1, #2]
3481d55c:	e5c15001 	strb	r5, [r1, #1]
        incr = 1U << (len - 1);
3481d560:	e24e1001 	sub	r1, lr, #1
3481d564:	e1a01119 	lsl	r1, r9, r1
        while (huff & incr)
3481d568:	e1110002 	tst	r1, r2
            incr >>= 1;
3481d56c:	11a010a1 	lsrne	r1, r1, #1
3481d570:	1afffffc 	bne	3481d568 <inflate_table+0x4e4>
        if (incr != 0) {
3481d574:	e3510000 	cmp	r1, #0
            huff &= incr - 1;
3481d578:	12415001 	subne	r5, r1, #1
3481d57c:	10022005 	andne	r2, r2, r5
            huff += incr;
3481d580:	10822001 	addne	r2, r2, r1
3481d584:	1affffe3 	bne	3481d518 <inflate_table+0x494>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481d588:	e5932000 	ldr	r2, [r3]
    *bits = root;
    return 0;
3481d58c:	e3a00000 	mov	r0, #0
    *table += used;
3481d590:	e082210a 	add	r2, r2, sl, lsl #2
3481d594:	e5832000 	str	r2, [r3]
    *bits = root;
3481d598:	e59d30a0 	ldr	r3, [sp, #160]	; 0xa0
3481d59c:	e583c000 	str	ip, [r3]
    return 0;
3481d5a0:	ea000004 	b	3481d5b8 <inflate_table+0x534>
        if (left < 0) return -1;        /* over-subscribed */
3481d5a4:	e3e00000 	mvn	r0, #0
3481d5a8:	ea000002 	b	3481d5b8 <inflate_table+0x534>
    if (root > max) root = max;
3481d5ac:	e35c0000 	cmp	ip, #0
3481d5b0:	1afffed6 	bne	3481d110 <inflate_table+0x8c>
3481d5b4:	eafffed9 	b	3481d120 <inflate_table+0x9c>
}
3481d5b8:	e28dd080 	add	sp, sp, #128	; 0x80
3481d5bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d5c0:	34820ad8 	.word	0x34820ad8
3481d5c4:	3482085a 	.word	0x3482085a

3481d5c8 <inflateReset>:
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481d5c8:	e2502000 	subs	r2, r0, #0
3481d5cc:	0a000019 	beq	3481d638 <inflateReset+0x70>
3481d5d0:	e592301c 	ldr	r3, [r2, #28]
3481d5d4:	e3530000 	cmp	r3, #0
3481d5d8:	0a000016 	beq	3481d638 <inflateReset+0x70>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481d5dc:	e3a00000 	mov	r0, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481d5e0:	e3a01001 	mov	r1, #1
    strm->total_in = strm->total_out = state->total = 0;
3481d5e4:	e583001c 	str	r0, [r3, #28]
3481d5e8:	e5820014 	str	r0, [r2, #20]
3481d5ec:	e5820008 	str	r0, [r2, #8]
    strm->msg = Z_NULL;
3481d5f0:	e5820018 	str	r0, [r2, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481d5f4:	e5821034 	str	r1, [r2, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481d5f8:	e3a02902 	mov	r2, #32768	; 0x8000
3481d5fc:	e5832014 	str	r2, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
3481d600:	e2832e53 	add	r2, r3, #1328	; 0x530
    state->mode = HEAD;
3481d604:	e5830000 	str	r0, [r3]
    state->last = 0;
3481d608:	e5830004 	str	r0, [r3, #4]
    state->havedict = 0;
3481d60c:	e583000c 	str	r0, [r3, #12]
    state->head = Z_NULL;
3481d610:	e5830020 	str	r0, [r3, #32]
    state->wsize = 0;
3481d614:	e5830028 	str	r0, [r3, #40]	; 0x28
    state->whave = 0;
3481d618:	e583002c 	str	r0, [r3, #44]	; 0x2c
    state->write = 0;
3481d61c:	e5830030 	str	r0, [r3, #48]	; 0x30
    state->hold = 0;
3481d620:	e5830038 	str	r0, [r3, #56]	; 0x38
    state->bits = 0;
3481d624:	e583003c 	str	r0, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
3481d628:	e583206c 	str	r2, [r3, #108]	; 0x6c
3481d62c:	e5832050 	str	r2, [r3, #80]	; 0x50
3481d630:	e583204c 	str	r2, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
3481d634:	e12fff1e 	bx	lr
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481d638:	e3e00001 	mvn	r0, #1
}
3481d63c:	e12fff1e 	bx	lr

3481d640 <inflateInit2_>:
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481d640:	e3520000 	cmp	r2, #0
3481d644:	0a000036 	beq	3481d724 <inflateInit2_+0xe4>
3481d648:	e5d22000 	ldrb	r2, [r2]
3481d64c:	e353003c 	cmp	r3, #60	; 0x3c
3481d650:	03520031 	cmpeq	r2, #49	; 0x31
3481d654:	13a02001 	movne	r2, #1
3481d658:	03a02000 	moveq	r2, #0
3481d65c:	1a000030 	bne	3481d724 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481d660:	e3500000 	cmp	r0, #0
{
3481d664:	e92d4070 	push	{r4, r5, r6, lr}
3481d668:	e1a04000 	mov	r4, r0
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481d66c:	0a00002e 	beq	3481d72c <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
3481d670:	e5903020 	ldr	r3, [r0, #32]
3481d674:	e1a05001 	mov	r5, r1
    strm->msg = Z_NULL;                 /* in case we return an error */
3481d678:	e5802018 	str	r2, [r0, #24]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
3481d67c:	e3a01001 	mov	r1, #1
    if (strm->zalloc == (alloc_func)0) {
3481d680:	e3530000 	cmp	r3, #0
        strm->opaque = (voidpf)0;
3481d684:	05803028 	streq	r3, [r0, #40]	; 0x28
        strm->zalloc = zcalloc;
3481d688:	059f20ac 	ldreq	r2, [pc, #172]	; 3481d73c <inflateInit2_+0xfc>
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481d68c:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        strm->zalloc = zcalloc;
3481d690:	05802020 	streq	r2, [r0, #32]
    state = (struct inflate_state FAR *)
3481d694:	e3022530 	movw	r2, #9520	; 0x2530
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481d698:	e3530000 	cmp	r3, #0
3481d69c:	059f309c 	ldreq	r3, [pc, #156]	; 3481d740 <inflateInit2_+0x100>
3481d6a0:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
3481d6a4:	e5903020 	ldr	r3, [r0, #32]
3481d6a8:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481d6ac:	e12fff33 	blx	r3
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
3481d6b0:	e2501000 	subs	r1, r0, #0
3481d6b4:	0a00001e 	beq	3481d734 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481d6b8:	e3550000 	cmp	r5, #0
    strm->state = (struct internal_state FAR *)state;
3481d6bc:	e584101c 	str	r1, [r4, #28]
        state->wrap = 0;
3481d6c0:	b3a03000 	movlt	r3, #0
        windowBits = -windowBits;
3481d6c4:	b2655000 	rsblt	r5, r5, #0
        state->wrap = 0;
3481d6c8:	b5813008 	strlt	r3, [r1, #8]
    if (windowBits < 0) {
3481d6cc:	ba000004 	blt	3481d6e4 <inflateInit2_+0xa4>
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481d6d0:	e1a03245 	asr	r3, r5, #4
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481d6d4:	e355002f 	cmp	r5, #47	; 0x2f
3481d6d8:	d205500f 	andle	r5, r5, #15
        state->wrap = (windowBits >> 4) + 1;
3481d6dc:	e2833001 	add	r3, r3, #1
3481d6e0:	e5813008 	str	r3, [r1, #8]
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
3481d6e4:	e2453008 	sub	r3, r5, #8
3481d6e8:	e3530007 	cmp	r3, #7
3481d6ec:	9a000006 	bls	3481d70c <inflateInit2_+0xcc>
        ZFREE(strm, state);
3481d6f0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481d6f4:	e3a02000 	mov	r2, #0
3481d6f8:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481d6fc:	e12fff33 	blx	r3
        strm->state = Z_NULL;
3481d700:	e3a03000 	mov	r3, #0
3481d704:	e584301c 	str	r3, [r4, #28]
3481d708:	ea000007 	b	3481d72c <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
3481d70c:	e3a03000 	mov	r3, #0
    state->wbits = (unsigned)windowBits;
3481d710:	e5815024 	str	r5, [r1, #36]	; 0x24
    return inflateReset(strm);
3481d714:	e1a00004 	mov	r0, r4
    state->window = Z_NULL;
3481d718:	e5813034 	str	r3, [r1, #52]	; 0x34
}
3481d71c:	e8bd4070 	pop	{r4, r5, r6, lr}
    return inflateReset(strm);
3481d720:	eaffffa8 	b	3481d5c8 <inflateReset>
        return Z_VERSION_ERROR;
3481d724:	e3e00005 	mvn	r0, #5
3481d728:	e12fff1e 	bx	lr
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481d72c:	e3e00001 	mvn	r0, #1
3481d730:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (state == Z_NULL) return Z_MEM_ERROR;
3481d734:	e3e00003 	mvn	r0, #3
}
3481d738:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d73c:	3481cadc 	.word	0x3481cadc
3481d740:	3481cae4 	.word	0x3481cae4

3481d744 <inflateInit_>:
int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
3481d744:	e1a03002 	mov	r3, r2
3481d748:	e1a02001 	mov	r2, r1
3481d74c:	e3a0100f 	mov	r1, #15
3481d750:	eaffffba 	b	3481d640 <inflateInit2_>

3481d754 <inflateEnd>:

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
3481d754:	e3500000 	cmp	r0, #0
3481d758:	0a000015 	beq	3481d7b4 <inflateEnd+0x60>
3481d75c:	e590201c 	ldr	r2, [r0, #28]
3481d760:	e3520000 	cmp	r2, #0
3481d764:	0a000012 	beq	3481d7b4 <inflateEnd+0x60>
3481d768:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3481d76c:	e3530000 	cmp	r3, #0
3481d770:	0a00000f 	beq	3481d7b4 <inflateEnd+0x60>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
3481d774:	e5921034 	ldr	r1, [r2, #52]	; 0x34
{
3481d778:	e92d4010 	push	{r4, lr}
3481d77c:	e1a04000 	mov	r4, r0
    if (state->window != Z_NULL) {
3481d780:	e3510000 	cmp	r1, #0
3481d784:	0a000002 	beq	3481d794 <inflateEnd+0x40>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
3481d788:	e3a02000 	mov	r2, #0
3481d78c:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481d790:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
3481d794:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481d798:	e3a02000 	mov	r2, #0
3481d79c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481d7a0:	e594101c 	ldr	r1, [r4, #28]
3481d7a4:	e12fff33 	blx	r3
    strm->state = Z_NULL;
3481d7a8:	e3a00000 	mov	r0, #0
3481d7ac:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
3481d7b0:	e8bd8010 	pop	{r4, pc}
        return Z_STREAM_ERROR;
3481d7b4:	e3e00001 	mvn	r0, #1
3481d7b8:	e12fff1e 	bx	lr

3481d7bc <adler32>:
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481d7bc:	e3520001 	cmp	r2, #1
{
3481d7c0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481d7c4:	e1a06001 	mov	r6, r1
3481d7c8:	e24dd020 	sub	sp, sp, #32
3481d7cc:	e1a07002 	mov	r7, r2
    sum2 = (adler >> 16) & 0xffff;
3481d7d0:	e1a05820 	lsr	r5, r0, #16
    adler &= 0xffff;
3481d7d4:	e6ff4070 	uxth	r4, r0
    if (len == 1) {
3481d7d8:	1a00000a 	bne	3481d808 <adler32+0x4c>
        adler += buf[0];
3481d7dc:	e5d10000 	ldrb	r0, [r1]
        if (adler >= BASE)
3481d7e0:	e30f3ff0 	movw	r3, #65520	; 0xfff0
        adler += buf[0];
3481d7e4:	e0844000 	add	r4, r4, r0
        if (adler >= BASE)
3481d7e8:	e1540003 	cmp	r4, r3
            adler -= BASE;
3481d7ec:	82444cff 	subhi	r4, r4, #65280	; 0xff00
3481d7f0:	824440f1 	subhi	r4, r4, #241	; 0xf1
        sum2 += adler;
3481d7f4:	e0845005 	add	r5, r4, r5
        if (sum2 >= BASE)
3481d7f8:	e1550003 	cmp	r5, r3
            sum2 -= BASE;
3481d7fc:	82455cff 	subhi	r5, r5, #65280	; 0xff00
3481d800:	824550f1 	subhi	r5, r5, #241	; 0xf1
3481d804:	ea0000b7 	b	3481dae8 <adler32+0x32c>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
3481d808:	e3510000 	cmp	r1, #0
        return 1L;
3481d80c:	03a00001 	moveq	r0, #1
    if (buf == Z_NULL)
3481d810:	0a0000b5 	beq	3481daec <adler32+0x330>

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
3481d814:	e352000f 	cmp	r2, #15
3481d818:	90817002 	addls	r7, r1, r2
3481d81c:	8a00005d 	bhi	3481d998 <adler32+0x1dc>
        while (len--) {
3481d820:	e1560007 	cmp	r6, r7
            adler += *buf++;
3481d824:	14d63001 	ldrbne	r3, [r6], #1
3481d828:	10844003 	addne	r4, r4, r3
            sum2 += adler;
3481d82c:	10855004 	addne	r5, r5, r4
3481d830:	1afffffa 	bne	3481d820 <adler32+0x64>
        }
        if (adler >= BASE)
3481d834:	e30f3ff0 	movw	r3, #65520	; 0xfff0
            adler -= BASE;
        MOD4(sum2);             /* only added so many BASE's */
3481d838:	e30f1ff1 	movw	r1, #65521	; 0xfff1
        if (adler >= BASE)
3481d83c:	e1540003 	cmp	r4, r3
        MOD4(sum2);             /* only added so many BASE's */
3481d840:	e1a00005 	mov	r0, r5
            adler -= BASE;
3481d844:	82444cff 	subhi	r4, r4, #65280	; 0xff00
3481d848:	824440f1 	subhi	r4, r4, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
3481d84c:	fa00068a 	blx	3481f27c <__aeabi_uidivmod>
        return adler | (sum2 << 16);
3481d850:	e1840801 	orr	r0, r4, r1, lsl #16
3481d854:	ea0000a4 	b	3481daec <adler32+0x330>
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
3481d858:	e55c0010 	ldrb	r0, [ip, #-16]
3481d85c:	e28cc010 	add	ip, ip, #16
3481d860:	e55c301f 	ldrb	r3, [ip, #-31]	; 0xffffffe1
3481d864:	e55c101e 	ldrb	r1, [ip, #-30]	; 0xffffffe2
3481d868:	e55c201d 	ldrb	r2, [ip, #-29]	; 0xffffffe3
3481d86c:	e0840000 	add	r0, r4, r0
3481d870:	e0803003 	add	r3, r0, r3
3481d874:	e55cb018 	ldrb	fp, [ip, #-24]	; 0xffffffe8
3481d878:	e0831001 	add	r1, r3, r1
3481d87c:	e0833000 	add	r3, r3, r0
3481d880:	e0812002 	add	r2, r1, r2
3481d884:	e0833001 	add	r3, r3, r1
3481d888:	e58d2000 	str	r2, [sp]
3481d88c:	e59de000 	ldr	lr, [sp]
3481d890:	e55c201c 	ldrb	r2, [ip, #-28]	; 0xffffffe4
3481d894:	e59d1000 	ldr	r1, [sp]
3481d898:	e55ca015 	ldrb	sl, [ip, #-21]	; 0xffffffeb
3481d89c:	e08e2002 	add	r2, lr, r2
3481d8a0:	e55c9014 	ldrb	r9, [ip, #-20]	; 0xffffffec
3481d8a4:	e58d2004 	str	r2, [sp, #4]
3481d8a8:	e0833001 	add	r3, r3, r1
3481d8ac:	e55c201b 	ldrb	r2, [ip, #-27]	; 0xffffffe5
3481d8b0:	e59de004 	ldr	lr, [sp, #4]
3481d8b4:	e59d1004 	ldr	r1, [sp, #4]
3481d8b8:	e55c4011 	ldrb	r4, [ip, #-17]	; 0xffffffef
3481d8bc:	e08e2002 	add	r2, lr, r2
3481d8c0:	e58d2008 	str	r2, [sp, #8]
3481d8c4:	e0833001 	add	r3, r3, r1
3481d8c8:	e55c201a 	ldrb	r2, [ip, #-26]	; 0xffffffe6
3481d8cc:	e59de008 	ldr	lr, [sp, #8]
3481d8d0:	e59d1008 	ldr	r1, [sp, #8]
3481d8d4:	e08e2002 	add	r2, lr, r2
3481d8d8:	e58d200c 	str	r2, [sp, #12]
3481d8dc:	e0833001 	add	r3, r3, r1
3481d8e0:	e55c2019 	ldrb	r2, [ip, #-25]	; 0xffffffe7
3481d8e4:	e59de00c 	ldr	lr, [sp, #12]
3481d8e8:	e59d100c 	ldr	r1, [sp, #12]
3481d8ec:	e08e2002 	add	r2, lr, r2
3481d8f0:	e55ce013 	ldrb	lr, [ip, #-19]	; 0xffffffed
3481d8f4:	e58d2010 	str	r2, [sp, #16]
3481d8f8:	e082200b 	add	r2, r2, fp
3481d8fc:	e55cb017 	ldrb	fp, [ip, #-23]	; 0xffffffe9
3481d900:	e0833001 	add	r3, r3, r1
3481d904:	e58d2014 	str	r2, [sp, #20]
3481d908:	e59d1010 	ldr	r1, [sp, #16]
3481d90c:	e082200b 	add	r2, r2, fp
3481d910:	e55cb016 	ldrb	fp, [ip, #-22]	; 0xffffffea
3481d914:	e58d2018 	str	r2, [sp, #24]
3481d918:	e0833001 	add	r3, r3, r1
3481d91c:	e082b00b 	add	fp, r2, fp
3481d920:	e55c2012 	ldrb	r2, [ip, #-18]	; 0xffffffee
3481d924:	e59d1014 	ldr	r1, [sp, #20]
3481d928:	e08ba00a 	add	sl, fp, sl
3481d92c:	e08a9009 	add	r9, sl, r9
3481d930:	e089e00e 	add	lr, r9, lr
3481d934:	e0833001 	add	r3, r3, r1
3481d938:	e59d1018 	ldr	r1, [sp, #24]
3481d93c:	e08e2002 	add	r2, lr, r2
3481d940:	e0824004 	add	r4, r2, r4
3481d944:	e0833001 	add	r3, r3, r1
3481d948:	e083b00b 	add	fp, r3, fp
            buf += 16;
        } while (--n);
3481d94c:	e59d301c 	ldr	r3, [sp, #28]
3481d950:	e08ba00a 	add	sl, fp, sl
3481d954:	e08a9009 	add	r9, sl, r9
3481d958:	e089e00e 	add	lr, r9, lr
3481d95c:	e15c0003 	cmp	ip, r3
3481d960:	e08e2002 	add	r2, lr, r2
3481d964:	e0822004 	add	r2, r2, r4
            DO16(buf);          /* 16 sums unrolled */
3481d968:	e0855002 	add	r5, r5, r2
        } while (--n);
3481d96c:	1affffb9 	bne	3481d858 <adler32+0x9c>
        MOD(adler);
3481d970:	e1a00004 	mov	r0, r4
3481d974:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481d978:	fa00063f 	blx	3481f27c <__aeabi_uidivmod>
3481d97c:	e2866d56 	add	r6, r6, #5504	; 0x1580
        MOD(sum2);
3481d980:	e1a00005 	mov	r0, r5
        MOD(adler);
3481d984:	e1a04001 	mov	r4, r1
        MOD(sum2);
3481d988:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481d98c:	fa00063a 	blx	3481f27c <__aeabi_uidivmod>
3481d990:	e2866030 	add	r6, r6, #48	; 0x30
3481d994:	e1a05001 	mov	r5, r1
    while (len >= NMAX) {
3481d998:	e30135af 	movw	r3, #5551	; 0x15af
3481d99c:	e1570003 	cmp	r7, r3
3481d9a0:	9a000005 	bls	3481d9bc <adler32+0x200>
        len -= NMAX;
3481d9a4:	e2477d56 	sub	r7, r7, #5504	; 0x1580
3481d9a8:	e2863d57 	add	r3, r6, #5568	; 0x15c0
3481d9ac:	e2477030 	sub	r7, r7, #48	; 0x30
3481d9b0:	e286c010 	add	ip, r6, #16
3481d9b4:	e58d301c 	str	r3, [sp, #28]
3481d9b8:	eaffffa6 	b	3481d858 <adler32+0x9c>
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
3481d9bc:	e3570000 	cmp	r7, #0
3481d9c0:	12862010 	addne	r2, r6, #16
3481d9c4:	1287c010 	addne	ip, r7, #16
3481d9c8:	0a000046 	beq	3481dae8 <adler32+0x32c>
3481d9cc:	e062300c 	rsb	r3, r2, ip
3481d9d0:	e0863003 	add	r3, r6, r3
        while (len >= 16) {
3481d9d4:	e353000f 	cmp	r3, #15
3481d9d8:	9a000031 	bls	3481daa4 <adler32+0x2e8>
            len -= 16;
            DO16(buf);
3481d9dc:	e5520010 	ldrb	r0, [r2, #-16]
3481d9e0:	e2822010 	add	r2, r2, #16
3481d9e4:	e552301f 	ldrb	r3, [r2, #-31]	; 0xffffffe1
3481d9e8:	e552101e 	ldrb	r1, [r2, #-30]	; 0xffffffe2
3481d9ec:	e0804004 	add	r4, r0, r4
3481d9f0:	e0843003 	add	r3, r4, r3
3481d9f4:	e0844003 	add	r4, r4, r3
3481d9f8:	e0833001 	add	r3, r3, r1
3481d9fc:	e552101d 	ldrb	r1, [r2, #-29]	; 0xffffffe3
3481da00:	e0845005 	add	r5, r4, r5
3481da04:	e0855003 	add	r5, r5, r3
3481da08:	e5524015 	ldrb	r4, [r2, #-21]	; 0xffffffeb
3481da0c:	e0833001 	add	r3, r3, r1
3481da10:	e552101c 	ldrb	r1, [r2, #-28]	; 0xffffffe4
3481da14:	e0855003 	add	r5, r5, r3
3481da18:	e0833001 	add	r3, r3, r1
3481da1c:	e552101b 	ldrb	r1, [r2, #-27]	; 0xffffffe5
3481da20:	e0855003 	add	r5, r5, r3
3481da24:	e0833001 	add	r3, r3, r1
3481da28:	e552101a 	ldrb	r1, [r2, #-26]	; 0xffffffe6
3481da2c:	e0855003 	add	r5, r5, r3
3481da30:	e0833001 	add	r3, r3, r1
3481da34:	e5521019 	ldrb	r1, [r2, #-25]	; 0xffffffe7
3481da38:	e0855003 	add	r5, r5, r3
3481da3c:	e0833001 	add	r3, r3, r1
3481da40:	e5521018 	ldrb	r1, [r2, #-24]	; 0xffffffe8
3481da44:	e0855003 	add	r5, r5, r3
3481da48:	e0833001 	add	r3, r3, r1
3481da4c:	e5521017 	ldrb	r1, [r2, #-23]	; 0xffffffe9
3481da50:	e0855003 	add	r5, r5, r3
3481da54:	e0833001 	add	r3, r3, r1
3481da58:	e5521016 	ldrb	r1, [r2, #-22]	; 0xffffffea
3481da5c:	e0855003 	add	r5, r5, r3
3481da60:	e0833001 	add	r3, r3, r1
3481da64:	e0855003 	add	r5, r5, r3
3481da68:	e0833004 	add	r3, r3, r4
3481da6c:	e5524014 	ldrb	r4, [r2, #-20]	; 0xffffffec
3481da70:	e0855003 	add	r5, r5, r3
3481da74:	e0833004 	add	r3, r3, r4
3481da78:	e5524013 	ldrb	r4, [r2, #-19]	; 0xffffffed
3481da7c:	e0855003 	add	r5, r5, r3
3481da80:	e0833004 	add	r3, r3, r4
3481da84:	e5524012 	ldrb	r4, [r2, #-18]	; 0xffffffee
3481da88:	e0855003 	add	r5, r5, r3
3481da8c:	e0833004 	add	r3, r3, r4
3481da90:	e5524011 	ldrb	r4, [r2, #-17]	; 0xffffffef
3481da94:	e0855003 	add	r5, r5, r3
3481da98:	e0834004 	add	r4, r3, r4
3481da9c:	e0855004 	add	r5, r5, r4
3481daa0:	eaffffc9 	b	3481d9cc <adler32+0x210>
3481daa4:	e3c7300f 	bic	r3, r7, #15
3481daa8:	e207700f 	and	r7, r7, #15
3481daac:	e0866003 	add	r6, r6, r3
3481dab0:	e0867007 	add	r7, r6, r7
            buf += 16;
        }
        while (len--) {
3481dab4:	e1560007 	cmp	r6, r7
            adler += *buf++;
3481dab8:	14d63001 	ldrbne	r3, [r6], #1
3481dabc:	10844003 	addne	r4, r4, r3
            sum2 += adler;
3481dac0:	10855004 	addne	r5, r5, r4
3481dac4:	1afffffa 	bne	3481dab4 <adler32+0x2f8>
        }
        MOD(adler);
3481dac8:	e1a00004 	mov	r0, r4
3481dacc:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481dad0:	fa0005e9 	blx	3481f27c <__aeabi_uidivmod>
        MOD(sum2);
3481dad4:	e1a00005 	mov	r0, r5
        MOD(adler);
3481dad8:	e1a04001 	mov	r4, r1
        MOD(sum2);
3481dadc:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481dae0:	fa0005e5 	blx	3481f27c <__aeabi_uidivmod>
3481dae4:	e1a05001 	mov	r5, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
3481dae8:	e1840805 	orr	r0, r4, r5, lsl #16
}
3481daec:	e28dd020 	add	sp, sp, #32
3481daf0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481daf4 <inflate>:
    if (strm == Z_NULL || strm->state == Z_NULL ||
3481daf4:	e3500000 	cmp	r0, #0
3481daf8:	0a000537 	beq	3481efdc <inflate+0x14e8>
{
3481dafc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481db00:	e24dd030 	sub	sp, sp, #48	; 0x30
    if (strm == Z_NULL || strm->state == Z_NULL ||
3481db04:	e590401c 	ldr	r4, [r0, #28]
3481db08:	e3540000 	cmp	r4, #0
3481db0c:	0a000534 	beq	3481efe4 <inflate+0x14f0>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481db10:	e590b000 	ldr	fp, [r0]
3481db14:	e5903004 	ldr	r3, [r0, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
3481db18:	e35b0000 	cmp	fp, #0
3481db1c:	e58d3020 	str	r3, [sp, #32]
3481db20:	1a000001 	bne	3481db2c <inflate+0x38>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481db24:	e3530000 	cmp	r3, #0
3481db28:	1a00052d 	bne	3481efe4 <inflate+0x14f0>
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481db2c:	e5943000 	ldr	r3, [r4]
3481db30:	e1a09000 	mov	r9, r0
    LOAD();
3481db34:	e5945038 	ldr	r5, [r4, #56]	; 0x38
3481db38:	e594603c 	ldr	r6, [r4, #60]	; 0x3c
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481db3c:	e353000b 	cmp	r3, #11
    LOAD();
3481db40:	e59d7020 	ldr	r7, [sp, #32]
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481db44:	03a0300c 	moveq	r3, #12
3481db48:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481db4c:	05843000 	streq	r3, [r4]
    LOAD();
3481db50:	e590300c 	ldr	r3, [r0, #12]
3481db54:	e58d3010 	str	r3, [sp, #16]
3481db58:	e5903010 	ldr	r3, [r0, #16]
3481db5c:	e58d300c 	str	r3, [sp, #12]
    out = left;
3481db60:	e58d3018 	str	r3, [sp, #24]
    ret = Z_OK;
3481db64:	e3a03000 	mov	r3, #0
3481db68:	e58d3014 	str	r3, [sp, #20]
        switch (state->mode) {
3481db6c:	e5943000 	ldr	r3, [r4]
3481db70:	e353001c 	cmp	r3, #28
3481db74:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481db78:	ea000519 	b	3481efe4 <inflate+0x14f0>
3481db7c:	3481dbf0 	.word	0x3481dbf0
3481db80:	3481dd44 	.word	0x3481dd44
3481db84:	3481ddd4 	.word	0x3481ddd4
3481db88:	3481de50 	.word	0x3481de50
3481db8c:	3481deac 	.word	0x3481deac
3481db90:	3481df3c 	.word	0x3481df3c
3481db94:	3481dff0 	.word	0x3481dff0
3481db98:	3481e0b0 	.word	0x3481e0b0
3481db9c:	3481e168 	.word	0x3481e168
3481dba0:	3481e1fc 	.word	0x3481e1fc
3481dba4:	3481e238 	.word	0x3481e238
3481dba8:	3481e280 	.word	0x3481e280
3481dbac:	3481e28c 	.word	0x3481e28c
3481dbb0:	3481e33c 	.word	0x3481e33c
3481dbb4:	3481e39c 	.word	0x3481e39c
3481dbb8:	3481e420 	.word	0x3481e420
3481dbbc:	3481e480 	.word	0x3481e480
3481dbc0:	3481e56c 	.word	0x3481e56c
3481dbc4:	3481e7f4 	.word	0x3481e7f4
3481dbc8:	3481e954 	.word	0x3481e954
3481dbcc:	3481e9a8 	.word	0x3481e9a8
3481dbd0:	3481ea84 	.word	0x3481ea84
3481dbd4:	3481eafc 	.word	0x3481eafc
3481dbd8:	3481ebb4 	.word	0x3481ebb4
3481dbdc:	3481ebec 	.word	0x3481ebec
3481dbe0:	3481ed28 	.word	0x3481ed28
3481dbe4:	3481ed90 	.word	0x3481ed90
3481dbe8:	3481ed88 	.word	0x3481ed88
3481dbec:	3481efec 	.word	0x3481efec
            if (state->wrap == 0) {
3481dbf0:	e5942008 	ldr	r2, [r4, #8]
3481dbf4:	e3520000 	cmp	r2, #0
                state->mode = TYPEDO;
3481dbf8:	03a0300c 	moveq	r3, #12
            if (state->wrap == 0) {
3481dbfc:	0a000031 	beq	3481dcc8 <inflate+0x1d4>
            NEEDBITS(16);
3481dc00:	e356000f 	cmp	r6, #15
3481dc04:	8a000006 	bhi	3481dc24 <inflate+0x130>
3481dc08:	e3570000 	cmp	r7, #0
3481dc0c:	0a000461 	beq	3481ed98 <inflate+0x12a4>
3481dc10:	e4db3001 	ldrb	r3, [fp], #1
3481dc14:	e2477001 	sub	r7, r7, #1
3481dc18:	e0855613 	add	r5, r5, r3, lsl r6
3481dc1c:	e2866008 	add	r6, r6, #8
3481dc20:	eafffff6 	b	3481dc00 <inflate+0x10c>
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
3481dc24:	e7e030d2 	ubfx	r3, r2, #1, #1
3481dc28:	e3081b1f 	movw	r1, #35615	; 0x8b1f
3481dc2c:	e1550001 	cmp	r5, r1
3481dc30:	13a03000 	movne	r3, #0
3481dc34:	02033001 	andeq	r3, r3, #1
3481dc38:	e3530000 	cmp	r3, #0
3481dc3c:	0a000010 	beq	3481dc84 <inflate+0x190>
                state->check = crc32(0L, Z_NULL, 0);
3481dc40:	e3a02000 	mov	r2, #0
                INITBITS();
3481dc44:	e3a06000 	mov	r6, #0
                state->check = crc32(0L, Z_NULL, 0);
3481dc48:	e1a01002 	mov	r1, r2
3481dc4c:	e1a00002 	mov	r0, r2
3481dc50:	ebfff084 	bl	34819e68 <crc32>
                CRC2(state->check, hold);
3481dc54:	e3a0301f 	mov	r3, #31
                state->check = crc32(0L, Z_NULL, 0);
3481dc58:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
3481dc5c:	e5cd302c 	strb	r3, [sp, #44]	; 0x2c
3481dc60:	e3a02002 	mov	r2, #2
3481dc64:	e3e03074 	mvn	r3, #116	; 0x74
3481dc68:	e28d102c 	add	r1, sp, #44	; 0x2c
3481dc6c:	e5cd302d 	strb	r3, [sp, #45]	; 0x2d
3481dc70:	ebfff07c 	bl	34819e68 <crc32>
                state->mode = FLAGS;
3481dc74:	e3a03001 	mov	r3, #1
                CRC2(state->check, hold);
3481dc78:	e5840018 	str	r0, [r4, #24]
                state->mode = FLAGS;
3481dc7c:	e5843000 	str	r3, [r4]
3481dc80:	ea000027 	b	3481dd24 <inflate+0x230>
            state->flags = 0;           /* expect zlib header */
3481dc84:	e5843010 	str	r3, [r4, #16]
            if (state->head != Z_NULL)
3481dc88:	e5943020 	ldr	r3, [r4, #32]
3481dc8c:	e3530000 	cmp	r3, #0
                state->head->done = -1;
3481dc90:	13e01000 	mvnne	r1, #0
3481dc94:	15831030 	strne	r1, [r3, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481dc98:	e3120001 	tst	r2, #1
3481dc9c:	0a000006 	beq	3481dcbc <inflate+0x1c8>
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
3481dca0:	e1a00405 	lsl	r0, r5, #8
3481dca4:	e3a0101f 	mov	r1, #31
3481dca8:	e6ff0070 	uxth	r0, r0
3481dcac:	e0800425 	add	r0, r0, r5, lsr #8
3481dcb0:	fa000571 	blx	3481f27c <__aeabi_uidivmod>
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481dcb4:	e3510000 	cmp	r1, #0
3481dcb8:	0a000004 	beq	3481dcd0 <inflate+0x1dc>
                strm->msg = (char *)"incorrect header check";
3481dcbc:	e59f3fa4 	ldr	r3, [pc, #4004]	; 3481ec68 <inflate+0x1174>
3481dcc0:	e5893018 	str	r3, [r9, #24]
                state->mode = BAD;
3481dcc4:	e3a0301b 	mov	r3, #27
3481dcc8:	e5843000 	str	r3, [r4]
                break;
3481dccc:	eaffffa6 	b	3481db6c <inflate+0x78>
            if (BITS(4) != Z_DEFLATED) {
3481dcd0:	e205300f 	and	r3, r5, #15
3481dcd4:	e3530008 	cmp	r3, #8
3481dcd8:	1a00001f 	bne	3481dd5c <inflate+0x268>
            DROPBITS(4);
3481dcdc:	e1a05225 	lsr	r5, r5, #4
            if (len > state->wbits) {
3481dce0:	e5942024 	ldr	r2, [r4, #36]	; 0x24
            len = BITS(4) + 8;
3481dce4:	e205300f 	and	r3, r5, #15
3481dce8:	e2833008 	add	r3, r3, #8
            if (len > state->wbits) {
3481dcec:	e1530002 	cmp	r3, r2
            DROPBITS(4);
3481dcf0:	82466004 	subhi	r6, r6, #4
                strm->msg = (char *)"invalid window size";
3481dcf4:	859f3f70 	ldrhi	r3, [pc, #3952]	; 3481ec6c <inflate+0x1178>
            if (len > state->wbits) {
3481dcf8:	8afffff0 	bhi	3481dcc0 <inflate+0x1cc>
            state->dmax = 1U << len;
3481dcfc:	e3a02001 	mov	r2, #1
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481dd00:	e3150c02 	tst	r5, #512	; 0x200
            state->dmax = 1U << len;
3481dd04:	e1a03312 	lsl	r3, r2, r3
            INITBITS();
3481dd08:	e1a06001 	mov	r6, r1
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481dd0c:	e5842018 	str	r2, [r4, #24]
            state->dmax = 1U << len;
3481dd10:	e5843014 	str	r3, [r4, #20]
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481dd14:	13a03009 	movne	r3, #9
3481dd18:	03a0300b 	moveq	r3, #11
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481dd1c:	e5892034 	str	r2, [r9, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481dd20:	e5843000 	str	r3, [r4]
            INITBITS();
3481dd24:	e1a05006 	mov	r5, r6
            break;
3481dd28:	eaffff8f 	b	3481db6c <inflate+0x78>
            NEEDBITS(16);
3481dd2c:	e3570000 	cmp	r7, #0
3481dd30:	0a000418 	beq	3481ed98 <inflate+0x12a4>
3481dd34:	e4db3001 	ldrb	r3, [fp], #1
3481dd38:	e2477001 	sub	r7, r7, #1
3481dd3c:	e0855613 	add	r5, r5, r3, lsl r6
3481dd40:	e2866008 	add	r6, r6, #8
3481dd44:	e356000f 	cmp	r6, #15
3481dd48:	9afffff7 	bls	3481dd2c <inflate+0x238>
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481dd4c:	e6ef3075 	uxtb	r3, r5
            state->flags = (int)(hold);
3481dd50:	e5845010 	str	r5, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481dd54:	e3530008 	cmp	r3, #8
3481dd58:	0a000001 	beq	3481dd64 <inflate+0x270>
                strm->msg = (char *)"unknown compression method";
3481dd5c:	e59f3f0c 	ldr	r3, [pc, #3852]	; 3481ec70 <inflate+0x117c>
3481dd60:	eaffffd6 	b	3481dcc0 <inflate+0x1cc>
            if (state->flags & 0xe000) {
3481dd64:	e3150a0e 	tst	r5, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
3481dd68:	159f3f04 	ldrne	r3, [pc, #3844]	; 3481ec74 <inflate+0x1180>
            if (state->flags & 0xe000) {
3481dd6c:	1affffd3 	bne	3481dcc0 <inflate+0x1cc>
            if (state->head != Z_NULL)
3481dd70:	e5943020 	ldr	r3, [r4, #32]
3481dd74:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
3481dd78:	17e02455 	ubfxne	r2, r5, #8, #1
3481dd7c:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481dd80:	e3150c02 	tst	r5, #512	; 0x200
3481dd84:	0a000007 	beq	3481dda8 <inflate+0x2b4>
3481dd88:	e5cd502c 	strb	r5, [sp, #44]	; 0x2c
3481dd8c:	e1a05425 	lsr	r5, r5, #8
3481dd90:	e3a02002 	mov	r2, #2
3481dd94:	e5940018 	ldr	r0, [r4, #24]
3481dd98:	e28d102c 	add	r1, sp, #44	; 0x2c
3481dd9c:	e5cd502d 	strb	r5, [sp, #45]	; 0x2d
3481dda0:	ebfff030 	bl	34819e68 <crc32>
3481dda4:	e5840018 	str	r0, [r4, #24]
            state->mode = TIME;
3481dda8:	e3a03002 	mov	r3, #2
            INITBITS();
3481ddac:	e3a06000 	mov	r6, #0
            state->mode = TIME;
3481ddb0:	e5843000 	str	r3, [r4]
            INITBITS();
3481ddb4:	e1a05006 	mov	r5, r6
3481ddb8:	ea000005 	b	3481ddd4 <inflate+0x2e0>
            NEEDBITS(32);
3481ddbc:	e3570000 	cmp	r7, #0
3481ddc0:	0a0003f4 	beq	3481ed98 <inflate+0x12a4>
3481ddc4:	e4db3001 	ldrb	r3, [fp], #1
3481ddc8:	e2477001 	sub	r7, r7, #1
3481ddcc:	e0855613 	add	r5, r5, r3, lsl r6
3481ddd0:	e2866008 	add	r6, r6, #8
3481ddd4:	e356001f 	cmp	r6, #31
3481ddd8:	9afffff7 	bls	3481ddbc <inflate+0x2c8>
            if (state->head != Z_NULL)
3481dddc:	e5943020 	ldr	r3, [r4, #32]
3481dde0:	e3530000 	cmp	r3, #0
                state->head->time = hold;
3481dde4:	15835004 	strne	r5, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
3481dde8:	e5943010 	ldr	r3, [r4, #16]
3481ddec:	e3130c02 	tst	r3, #512	; 0x200
3481ddf0:	0a00000b 	beq	3481de24 <inflate+0x330>
3481ddf4:	e1a03425 	lsr	r3, r5, #8
3481ddf8:	e5cd502c 	strb	r5, [sp, #44]	; 0x2c
3481ddfc:	e3a02004 	mov	r2, #4
3481de00:	e5940018 	ldr	r0, [r4, #24]
3481de04:	e5cd302d 	strb	r3, [sp, #45]	; 0x2d
3481de08:	e1a03825 	lsr	r3, r5, #16
3481de0c:	e1a05c25 	lsr	r5, r5, #24
3481de10:	e28d102c 	add	r1, sp, #44	; 0x2c
3481de14:	e5cd302e 	strb	r3, [sp, #46]	; 0x2e
3481de18:	e5cd502f 	strb	r5, [sp, #47]	; 0x2f
3481de1c:	ebfff011 	bl	34819e68 <crc32>
3481de20:	e5840018 	str	r0, [r4, #24]
            state->mode = OS;
3481de24:	e3a03003 	mov	r3, #3
            INITBITS();
3481de28:	e3a06000 	mov	r6, #0
            state->mode = OS;
3481de2c:	e5843000 	str	r3, [r4]
            INITBITS();
3481de30:	e1a05006 	mov	r5, r6
3481de34:	ea000005 	b	3481de50 <inflate+0x35c>
            NEEDBITS(16);
3481de38:	e3570000 	cmp	r7, #0
3481de3c:	0a0003d5 	beq	3481ed98 <inflate+0x12a4>
3481de40:	e4db3001 	ldrb	r3, [fp], #1
3481de44:	e2477001 	sub	r7, r7, #1
3481de48:	e0855613 	add	r5, r5, r3, lsl r6
3481de4c:	e2866008 	add	r6, r6, #8
3481de50:	e356000f 	cmp	r6, #15
3481de54:	9afffff7 	bls	3481de38 <inflate+0x344>
            if (state->head != Z_NULL) {
3481de58:	e5943020 	ldr	r3, [r4, #32]
3481de5c:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
3481de60:	16ef2075 	uxtbne	r2, r5
3481de64:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
3481de68:	11a02425 	lsrne	r2, r5, #8
3481de6c:	1583200c 	strne	r2, [r3, #12]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481de70:	e5943010 	ldr	r3, [r4, #16]
3481de74:	e3130c02 	tst	r3, #512	; 0x200
3481de78:	0a000007 	beq	3481de9c <inflate+0x3a8>
3481de7c:	e5cd502c 	strb	r5, [sp, #44]	; 0x2c
3481de80:	e1a05425 	lsr	r5, r5, #8
3481de84:	e3a02002 	mov	r2, #2
3481de88:	e5940018 	ldr	r0, [r4, #24]
3481de8c:	e28d102c 	add	r1, sp, #44	; 0x2c
3481de90:	e5cd502d 	strb	r5, [sp, #45]	; 0x2d
3481de94:	ebffeff3 	bl	34819e68 <crc32>
3481de98:	e5840018 	str	r0, [r4, #24]
            INITBITS();
3481de9c:	e3a06000 	mov	r6, #0
            state->mode = EXLEN;
3481dea0:	e3a03004 	mov	r3, #4
            INITBITS();
3481dea4:	e1a05006 	mov	r5, r6
            state->mode = EXLEN;
3481dea8:	e5843000 	str	r3, [r4]
            if (state->flags & 0x0400) {
3481deac:	e5943010 	ldr	r3, [r4, #16]
3481deb0:	e2132b01 	ands	r2, r3, #1024	; 0x400
3481deb4:	0a000019 	beq	3481df20 <inflate+0x42c>
                NEEDBITS(16);
3481deb8:	e356000f 	cmp	r6, #15
3481debc:	8a000006 	bhi	3481dedc <inflate+0x3e8>
3481dec0:	e3570000 	cmp	r7, #0
3481dec4:	0a0003b3 	beq	3481ed98 <inflate+0x12a4>
3481dec8:	e4db2001 	ldrb	r2, [fp], #1
3481decc:	e2477001 	sub	r7, r7, #1
3481ded0:	e0855612 	add	r5, r5, r2, lsl r6
3481ded4:	e2866008 	add	r6, r6, #8
3481ded8:	eafffff6 	b	3481deb8 <inflate+0x3c4>
                if (state->head != Z_NULL)
3481dedc:	e5942020 	ldr	r2, [r4, #32]
                state->length = (unsigned)(hold);
3481dee0:	e5845040 	str	r5, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
3481dee4:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
3481dee8:	15825014 	strne	r5, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481deec:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
3481def0:	01a05003 	moveq	r5, r3
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481def4:	0a00000d 	beq	3481df30 <inflate+0x43c>
3481def8:	e5cd502c 	strb	r5, [sp, #44]	; 0x2c
3481defc:	e1a05425 	lsr	r5, r5, #8
3481df00:	e3a02002 	mov	r2, #2
3481df04:	e5940018 	ldr	r0, [r4, #24]
3481df08:	e28d102c 	add	r1, sp, #44	; 0x2c
3481df0c:	e5cd502d 	strb	r5, [sp, #45]	; 0x2d
3481df10:	ebffefd4 	bl	34819e68 <crc32>
                INITBITS();
3481df14:	e3a05000 	mov	r5, #0
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481df18:	e5840018 	str	r0, [r4, #24]
3481df1c:	ea000003 	b	3481df30 <inflate+0x43c>
            else if (state->head != Z_NULL)
3481df20:	e5943020 	ldr	r3, [r4, #32]
3481df24:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
3481df28:	15832010 	strne	r2, [r3, #16]
3481df2c:	ea000000 	b	3481df34 <inflate+0x440>
                INITBITS();
3481df30:	e1a06005 	mov	r6, r5
            state->mode = EXTRA;
3481df34:	e3a03005 	mov	r3, #5
3481df38:	e5843000 	str	r3, [r4]
            if (state->flags & 0x0400) {
3481df3c:	e5943010 	ldr	r3, [r4, #16]
3481df40:	e3130b01 	tst	r3, #1024	; 0x400
3481df44:	0a000025 	beq	3481dfe0 <inflate+0x4ec>
                copy = state->length;
3481df48:	e5942040 	ldr	r2, [r4, #64]	; 0x40
3481df4c:	e1570002 	cmp	r7, r2
3481df50:	31a0a007 	movcc	sl, r7
3481df54:	21a0a002 	movcs	sl, r2
                if (copy) {
3481df58:	e35a0000 	cmp	sl, #0
3481df5c:	0a00001c 	beq	3481dfd4 <inflate+0x4e0>
                    if (state->head != Z_NULL &&
3481df60:	e5943020 	ldr	r3, [r4, #32]
3481df64:	e3530000 	cmp	r3, #0
3481df68:	0a00000c 	beq	3481dfa0 <inflate+0x4ac>
                        state->head->extra != Z_NULL) {
3481df6c:	e5930010 	ldr	r0, [r3, #16]
                    if (state->head != Z_NULL &&
3481df70:	e3500000 	cmp	r0, #0
3481df74:	0a000009 	beq	3481dfa0 <inflate+0x4ac>
                        len = state->head->extra_len - state->length;
3481df78:	e5931014 	ldr	r1, [r3, #20]
                                len + copy > state->head->extra_max ?
3481df7c:	e5933018 	ldr	r3, [r3, #24]
                        len = state->head->extra_len - state->length;
3481df80:	e0622001 	rsb	r2, r2, r1
                                len + copy > state->head->extra_max ?
3481df84:	e08a1002 	add	r1, sl, r2
                        zmemcpy(state->head->extra + len, next,
3481df88:	e0800002 	add	r0, r0, r2
3481df8c:	e1510003 	cmp	r1, r3
3481df90:	e1a0100b 	mov	r1, fp
3481df94:	80622003 	rsbhi	r2, r2, r3
3481df98:	91a0200a 	movls	r2, sl
3481df9c:	ebfff716 	bl	3481bbfc <memcpy>
                    if (state->flags & 0x0200)
3481dfa0:	e5943010 	ldr	r3, [r4, #16]
3481dfa4:	e3130c02 	tst	r3, #512	; 0x200
3481dfa8:	0a000004 	beq	3481dfc0 <inflate+0x4cc>
                        state->check = crc32(state->check, next, copy);
3481dfac:	e1a0200a 	mov	r2, sl
3481dfb0:	e1a0100b 	mov	r1, fp
3481dfb4:	e5940018 	ldr	r0, [r4, #24]
3481dfb8:	ebffefaa 	bl	34819e68 <crc32>
3481dfbc:	e5840018 	str	r0, [r4, #24]
                    state->length -= copy;
3481dfc0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    have -= copy;
3481dfc4:	e06a7007 	rsb	r7, sl, r7
                    next += copy;
3481dfc8:	e08bb00a 	add	fp, fp, sl
                    state->length -= copy;
3481dfcc:	e06aa003 	rsb	sl, sl, r3
3481dfd0:	e584a040 	str	sl, [r4, #64]	; 0x40
                if (state->length) goto inf_leave;
3481dfd4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481dfd8:	e3530000 	cmp	r3, #0
3481dfdc:	1a00036d 	bne	3481ed98 <inflate+0x12a4>
            state->length = 0;
3481dfe0:	e3a03000 	mov	r3, #0
3481dfe4:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
3481dfe8:	e3a03006 	mov	r3, #6
3481dfec:	e5843000 	str	r3, [r4]
            if (state->flags & 0x0800) {
3481dff0:	e5943010 	ldr	r3, [r4, #16]
3481dff4:	e2133b02 	ands	r3, r3, #2048	; 0x800
3481dff8:	0a000025 	beq	3481e094 <inflate+0x5a0>
                if (have == 0) goto inf_leave;
3481dffc:	e3570000 	cmp	r7, #0
3481e000:	0a000364 	beq	3481ed98 <inflate+0x12a4>
3481e004:	e24b1001 	sub	r1, fp, #1
3481e008:	e3a0a000 	mov	sl, #0
                    if (state->head != Z_NULL &&
3481e00c:	e5942020 	ldr	r2, [r4, #32]
                    len = (unsigned)(next[copy++]);
3481e010:	e28aa001 	add	sl, sl, #1
3481e014:	e5f13001 	ldrb	r3, [r1, #1]!
                    if (state->head != Z_NULL &&
3481e018:	e3520000 	cmp	r2, #0
                    len = (unsigned)(next[copy++]);
3481e01c:	e58d301c 	str	r3, [sp, #28]
                    if (state->head != Z_NULL &&
3481e020:	0a000009 	beq	3481e04c <inflate+0x558>
                            state->head->name != Z_NULL &&
3481e024:	e592001c 	ldr	r0, [r2, #28]
                    if (state->head != Z_NULL &&
3481e028:	e3500000 	cmp	r0, #0
3481e02c:	0a000006 	beq	3481e04c <inflate+0x558>
                            state->head->name != Z_NULL &&
3481e030:	e5922020 	ldr	r2, [r2, #32]
                            state->length < state->head->name_max)
3481e034:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                            state->head->name != Z_NULL &&
3481e038:	e1530002 	cmp	r3, r2
                        state->head->name[state->length++] = len;
3481e03c:	32832001 	addcc	r2, r3, #1
3481e040:	35842040 	strcc	r2, [r4, #64]	; 0x40
3481e044:	35dd201c 	ldrbcc	r2, [sp, #28]
3481e048:	37c02003 	strbcc	r2, [r0, r3]
                } while (len && copy < have);
3481e04c:	e59d301c 	ldr	r3, [sp, #28]
3481e050:	e3530000 	cmp	r3, #0
3481e054:	115a0007 	cmpne	sl, r7
3481e058:	3affffeb 	bcc	3481e00c <inflate+0x518>
                if (state->flags & 0x0200)
3481e05c:	e5943010 	ldr	r3, [r4, #16]
3481e060:	e3130c02 	tst	r3, #512	; 0x200
3481e064:	0a000004 	beq	3481e07c <inflate+0x588>
                    state->check = crc32(state->check, next, copy);
3481e068:	e1a0200a 	mov	r2, sl
3481e06c:	e1a0100b 	mov	r1, fp
3481e070:	e5940018 	ldr	r0, [r4, #24]
3481e074:	ebffef7b 	bl	34819e68 <crc32>
3481e078:	e5840018 	str	r0, [r4, #24]
                if (len) goto inf_leave;
3481e07c:	e59d301c 	ldr	r3, [sp, #28]
                have -= copy;
3481e080:	e06a7007 	rsb	r7, sl, r7
                next += copy;
3481e084:	e08bb00a 	add	fp, fp, sl
                if (len) goto inf_leave;
3481e088:	e3530000 	cmp	r3, #0
3481e08c:	0a000003 	beq	3481e0a0 <inflate+0x5ac>
3481e090:	ea000340 	b	3481ed98 <inflate+0x12a4>
            else if (state->head != Z_NULL)
3481e094:	e5942020 	ldr	r2, [r4, #32]
3481e098:	e3520000 	cmp	r2, #0
                state->head->name = Z_NULL;
3481e09c:	1582301c 	strne	r3, [r2, #28]
            state->length = 0;
3481e0a0:	e3a03000 	mov	r3, #0
3481e0a4:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = COMMENT;
3481e0a8:	e3a03007 	mov	r3, #7
3481e0ac:	e5843000 	str	r3, [r4]
            if (state->flags & 0x1000) {
3481e0b0:	e5943010 	ldr	r3, [r4, #16]
3481e0b4:	e2133a01 	ands	r3, r3, #4096	; 0x1000
3481e0b8:	0a000025 	beq	3481e154 <inflate+0x660>
                if (have == 0) goto inf_leave;
3481e0bc:	e3570000 	cmp	r7, #0
3481e0c0:	0a000334 	beq	3481ed98 <inflate+0x12a4>
3481e0c4:	e24b1001 	sub	r1, fp, #1
3481e0c8:	e3a0a000 	mov	sl, #0
                    if (state->head != Z_NULL &&
3481e0cc:	e5942020 	ldr	r2, [r4, #32]
                    len = (unsigned)(next[copy++]);
3481e0d0:	e28aa001 	add	sl, sl, #1
3481e0d4:	e5f13001 	ldrb	r3, [r1, #1]!
                    if (state->head != Z_NULL &&
3481e0d8:	e3520000 	cmp	r2, #0
                    len = (unsigned)(next[copy++]);
3481e0dc:	e58d301c 	str	r3, [sp, #28]
                    if (state->head != Z_NULL &&
3481e0e0:	0a000009 	beq	3481e10c <inflate+0x618>
                            state->head->comment != Z_NULL &&
3481e0e4:	e5920024 	ldr	r0, [r2, #36]	; 0x24
                    if (state->head != Z_NULL &&
3481e0e8:	e3500000 	cmp	r0, #0
3481e0ec:	0a000006 	beq	3481e10c <inflate+0x618>
                            state->head->comment != Z_NULL &&
3481e0f0:	e5922028 	ldr	r2, [r2, #40]	; 0x28
                            state->length < state->head->comm_max)
3481e0f4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                            state->head->comment != Z_NULL &&
3481e0f8:	e1530002 	cmp	r3, r2
                        state->head->comment[state->length++] = len;
3481e0fc:	32832001 	addcc	r2, r3, #1
3481e100:	35842040 	strcc	r2, [r4, #64]	; 0x40
3481e104:	35dd201c 	ldrbcc	r2, [sp, #28]
3481e108:	37c02003 	strbcc	r2, [r0, r3]
                } while (len && copy < have);
3481e10c:	e59d301c 	ldr	r3, [sp, #28]
3481e110:	e3530000 	cmp	r3, #0
3481e114:	115a0007 	cmpne	sl, r7
3481e118:	3affffeb 	bcc	3481e0cc <inflate+0x5d8>
                if (state->flags & 0x0200)
3481e11c:	e5943010 	ldr	r3, [r4, #16]
3481e120:	e3130c02 	tst	r3, #512	; 0x200
3481e124:	0a000004 	beq	3481e13c <inflate+0x648>
                    state->check = crc32(state->check, next, copy);
3481e128:	e1a0200a 	mov	r2, sl
3481e12c:	e1a0100b 	mov	r1, fp
3481e130:	e5940018 	ldr	r0, [r4, #24]
3481e134:	ebffef4b 	bl	34819e68 <crc32>
3481e138:	e5840018 	str	r0, [r4, #24]
                if (len) goto inf_leave;
3481e13c:	e59d301c 	ldr	r3, [sp, #28]
                have -= copy;
3481e140:	e06a7007 	rsb	r7, sl, r7
                next += copy;
3481e144:	e08bb00a 	add	fp, fp, sl
                if (len) goto inf_leave;
3481e148:	e3530000 	cmp	r3, #0
3481e14c:	0a000003 	beq	3481e160 <inflate+0x66c>
3481e150:	ea000310 	b	3481ed98 <inflate+0x12a4>
            else if (state->head != Z_NULL)
3481e154:	e5942020 	ldr	r2, [r4, #32]
3481e158:	e3520000 	cmp	r2, #0
                state->head->comment = Z_NULL;
3481e15c:	15823024 	strne	r3, [r2, #36]	; 0x24
            state->mode = HCRC;
3481e160:	e3a03008 	mov	r3, #8
3481e164:	e5843000 	str	r3, [r4]
            if (state->flags & 0x0200) {
3481e168:	e5943010 	ldr	r3, [r4, #16]
3481e16c:	e3130c02 	tst	r3, #512	; 0x200
3481e170:	0a00000e 	beq	3481e1b0 <inflate+0x6bc>
                NEEDBITS(16);
3481e174:	e356000f 	cmp	r6, #15
3481e178:	8a000006 	bhi	3481e198 <inflate+0x6a4>
3481e17c:	e3570000 	cmp	r7, #0
3481e180:	0a000304 	beq	3481ed98 <inflate+0x12a4>
3481e184:	e4db2001 	ldrb	r2, [fp], #1
3481e188:	e2477001 	sub	r7, r7, #1
3481e18c:	e0855612 	add	r5, r5, r2, lsl r6
3481e190:	e2866008 	add	r6, r6, #8
3481e194:	eafffff6 	b	3481e174 <inflate+0x680>
                if (hold != (state->check & 0xffff)) {
3481e198:	e1d421b8 	ldrh	r2, [r4, #24]
3481e19c:	e1550002 	cmp	r5, r2
                    strm->msg = (char *)"header crc mismatch";
3481e1a0:	159f3ad0 	ldrne	r3, [pc, #2768]	; 3481ec78 <inflate+0x1184>
                if (hold != (state->check & 0xffff)) {
3481e1a4:	1afffec5 	bne	3481dcc0 <inflate+0x1cc>
                INITBITS();
3481e1a8:	e3a06000 	mov	r6, #0
3481e1ac:	e1a05006 	mov	r5, r6
            if (state->head != Z_NULL) {
3481e1b0:	e5942020 	ldr	r2, [r4, #32]
3481e1b4:	e3520000 	cmp	r2, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481e1b8:	17e034d3 	ubfxne	r3, r3, #9, #1
3481e1bc:	1582302c 	strne	r3, [r2, #44]	; 0x2c
                state->head->done = 1;
3481e1c0:	13a03001 	movne	r3, #1
3481e1c4:	15823030 	strne	r3, [r2, #48]	; 0x30
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481e1c8:	e3a02000 	mov	r2, #0
3481e1cc:	e1a01002 	mov	r1, r2
3481e1d0:	e1a00002 	mov	r0, r2
3481e1d4:	ebffef23 	bl	34819e68 <crc32>
3481e1d8:	e5840018 	str	r0, [r4, #24]
3481e1dc:	e5890034 	str	r0, [r9, #52]	; 0x34
3481e1e0:	ea0001d2 	b	3481e930 <inflate+0xe3c>
            NEEDBITS(32);
3481e1e4:	e3570000 	cmp	r7, #0
3481e1e8:	0a0002ea 	beq	3481ed98 <inflate+0x12a4>
3481e1ec:	e4db3001 	ldrb	r3, [fp], #1
3481e1f0:	e2477001 	sub	r7, r7, #1
3481e1f4:	e0855613 	add	r5, r5, r3, lsl r6
3481e1f8:	e2866008 	add	r6, r6, #8
3481e1fc:	e356001f 	cmp	r6, #31
3481e200:	9afffff7 	bls	3481e1e4 <inflate+0x6f0>
            strm->adler = state->check = REVERSE(hold);
3481e204:	e1a03c25 	lsr	r3, r5, #24
3481e208:	e0832c05 	add	r2, r3, r5, lsl #24
3481e20c:	e1a03425 	lsr	r3, r5, #8
3481e210:	e2033cff 	and	r3, r3, #65280	; 0xff00
3481e214:	e2055cff 	and	r5, r5, #65280	; 0xff00
3481e218:	e0823003 	add	r3, r2, r3
3481e21c:	e0835405 	add	r5, r3, r5, lsl #8
            state->mode = DICT;
3481e220:	e3a0300a 	mov	r3, #10
            strm->adler = state->check = REVERSE(hold);
3481e224:	e5845018 	str	r5, [r4, #24]
3481e228:	e5895034 	str	r5, [r9, #52]	; 0x34
            INITBITS();
3481e22c:	e3a05000 	mov	r5, #0
3481e230:	e1a06005 	mov	r6, r5
            state->mode = DICT;
3481e234:	e5843000 	str	r3, [r4]
            if (state->havedict == 0) {
3481e238:	e594300c 	ldr	r3, [r4, #12]
3481e23c:	e3530000 	cmp	r3, #0
3481e240:	1a000009 	bne	3481e26c <inflate+0x778>
                RESTORE();
3481e244:	e59d3010 	ldr	r3, [sp, #16]
                return Z_NEED_DICT;
3481e248:	e3a00002 	mov	r0, #2
                RESTORE();
3481e24c:	e589b000 	str	fp, [r9]
3481e250:	e5897004 	str	r7, [r9, #4]
3481e254:	e589300c 	str	r3, [r9, #12]
3481e258:	e59d300c 	ldr	r3, [sp, #12]
3481e25c:	e5893010 	str	r3, [r9, #16]
3481e260:	e5845038 	str	r5, [r4, #56]	; 0x38
3481e264:	e584603c 	str	r6, [r4, #60]	; 0x3c
                return Z_NEED_DICT;
3481e268:	ea000360 	b	3481eff0 <inflate+0x14fc>
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e26c:	e3a03001 	mov	r3, #1
3481e270:	e5843018 	str	r3, [r4, #24]
3481e274:	e5893034 	str	r3, [r9, #52]	; 0x34
            state->mode = TYPE;
3481e278:	e3a0300b 	mov	r3, #11
3481e27c:	e5843000 	str	r3, [r4]
            if (flush == Z_BLOCK) goto inf_leave;
3481e280:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481e284:	e3530005 	cmp	r3, #5
3481e288:	0a0002c2 	beq	3481ed98 <inflate+0x12a4>
            if (state->last) {
3481e28c:	e5943004 	ldr	r3, [r4, #4]
3481e290:	e3530000 	cmp	r3, #0
3481e294:	0a00000a 	beq	3481e2c4 <inflate+0x7d0>
                BYTEBITS();
3481e298:	e2063007 	and	r3, r6, #7
3481e29c:	e3c66007 	bic	r6, r6, #7
3481e2a0:	e1a05335 	lsr	r5, r5, r3
                state->mode = CHECK;
3481e2a4:	e3a03018 	mov	r3, #24
3481e2a8:	eafffe86 	b	3481dcc8 <inflate+0x1d4>
            NEEDBITS(3);
3481e2ac:	e3570000 	cmp	r7, #0
3481e2b0:	0a0002b8 	beq	3481ed98 <inflate+0x12a4>
3481e2b4:	e4db3001 	ldrb	r3, [fp], #1
3481e2b8:	e2477001 	sub	r7, r7, #1
3481e2bc:	e0855613 	add	r5, r5, r3, lsl r6
3481e2c0:	e2866008 	add	r6, r6, #8
3481e2c4:	e3560002 	cmp	r6, #2
3481e2c8:	9afffff7 	bls	3481e2ac <inflate+0x7b8>
            state->last = BITS(1);
3481e2cc:	e2053001 	and	r3, r5, #1
            DROPBITS(1);
3481e2d0:	e1a050a5 	lsr	r5, r5, #1
            state->last = BITS(1);
3481e2d4:	e5843004 	str	r3, [r4, #4]
            switch (BITS(2)) {
3481e2d8:	e2053003 	and	r3, r5, #3
3481e2dc:	e3530002 	cmp	r3, #2
                state->mode = TABLE;
3481e2e0:	03a0300f 	moveq	r3, #15
            switch (BITS(2)) {
3481e2e4:	0a000010 	beq	3481e32c <inflate+0x838>
3481e2e8:	e3530003 	cmp	r3, #3
3481e2ec:	0a00000b 	beq	3481e320 <inflate+0x82c>
3481e2f0:	e3530001 	cmp	r3, #1
    state->lencode = lenfix;
3481e2f4:	059f3980 	ldreq	r3, [pc, #2432]	; 3481ec7c <inflate+0x1188>
    state->lenbits = 9;
3481e2f8:	03a02009 	moveq	r2, #9
                state->mode = STORED;
3481e2fc:	13a0300d 	movne	r3, #13
    state->lenbits = 9;
3481e300:	05842054 	streq	r2, [r4, #84]	; 0x54
    state->lencode = lenfix;
3481e304:	0584304c 	streq	r3, [r4, #76]	; 0x4c
    state->distcode = distfix;
3481e308:	02833b02 	addeq	r3, r3, #2048	; 0x800
3481e30c:	05843050 	streq	r3, [r4, #80]	; 0x50
    state->distbits = 5;
3481e310:	03a03005 	moveq	r3, #5
3481e314:	05843058 	streq	r3, [r4, #88]	; 0x58
                state->mode = LEN;              /* decode codes */
3481e318:	03a03012 	moveq	r3, #18
3481e31c:	ea000002 	b	3481e32c <inflate+0x838>
                strm->msg = (char *)"invalid block type";
3481e320:	e59f3958 	ldr	r3, [pc, #2392]	; 3481ec80 <inflate+0x118c>
3481e324:	e5893018 	str	r3, [r9, #24]
                state->mode = BAD;
3481e328:	e3a0301b 	mov	r3, #27
3481e32c:	e5843000 	str	r3, [r4]
            DROPBITS(2);
3481e330:	e1a05125 	lsr	r5, r5, #2
3481e334:	e2466003 	sub	r6, r6, #3
            break;
3481e338:	eafffe0b 	b	3481db6c <inflate+0x78>
            BYTEBITS();                         /* go to byte boundary */
3481e33c:	e2063007 	and	r3, r6, #7
3481e340:	e3c66007 	bic	r6, r6, #7
3481e344:	e1a05335 	lsr	r5, r5, r3
            NEEDBITS(32);
3481e348:	e356001f 	cmp	r6, #31
3481e34c:	8a000006 	bhi	3481e36c <inflate+0x878>
3481e350:	e3570000 	cmp	r7, #0
3481e354:	0a00028f 	beq	3481ed98 <inflate+0x12a4>
3481e358:	e4db3001 	ldrb	r3, [fp], #1
3481e35c:	e2477001 	sub	r7, r7, #1
3481e360:	e0855613 	add	r5, r5, r3, lsl r6
3481e364:	e2866008 	add	r6, r6, #8
3481e368:	eafffff6 	b	3481e348 <inflate+0x854>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481e36c:	e1a03825 	lsr	r3, r5, #16
3481e370:	e6ff2075 	uxth	r2, r5
3481e374:	e2233cff 	eor	r3, r3, #65280	; 0xff00
3481e378:	e22330ff 	eor	r3, r3, #255	; 0xff
3481e37c:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid stored block lengths";
3481e380:	159f38fc 	ldrne	r3, [pc, #2300]	; 3481ec84 <inflate+0x1190>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481e384:	1afffe4d 	bne	3481dcc0 <inflate+0x1cc>
            INITBITS();
3481e388:	e3a06000 	mov	r6, #0
            state->mode = COPY;
3481e38c:	e3a0300e 	mov	r3, #14
            INITBITS();
3481e390:	e1a05006 	mov	r5, r6
            state->length = (unsigned)hold & 0xffff;
3481e394:	e5842040 	str	r2, [r4, #64]	; 0x40
            state->mode = COPY;
3481e398:	e5843000 	str	r3, [r4]
            copy = state->length;
3481e39c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
3481e3a0:	e3530000 	cmp	r3, #0
3481e3a4:	0a000161 	beq	3481e930 <inflate+0xe3c>
3481e3a8:	e59d200c 	ldr	r2, [sp, #12]
3481e3ac:	e1520003 	cmp	r2, r3
3481e3b0:	21a0a003 	movcs	sl, r3
3481e3b4:	31a0a002 	movcc	sl, r2
3481e3b8:	e15a0007 	cmp	sl, r7
3481e3bc:	21a0a007 	movcs	sl, r7
                if (copy == 0) goto inf_leave;
3481e3c0:	e35a0000 	cmp	sl, #0
3481e3c4:	0a000273 	beq	3481ed98 <inflate+0x12a4>
                zmemcpy(put, next, copy);
3481e3c8:	e1a0200a 	mov	r2, sl
3481e3cc:	e1a0100b 	mov	r1, fp
3481e3d0:	e59d0010 	ldr	r0, [sp, #16]
                have -= copy;
3481e3d4:	e06a7007 	rsb	r7, sl, r7
                zmemcpy(put, next, copy);
3481e3d8:	ebfff607 	bl	3481bbfc <memcpy>
                left -= copy;
3481e3dc:	e59d300c 	ldr	r3, [sp, #12]
                next += copy;
3481e3e0:	e08bb00a 	add	fp, fp, sl
                left -= copy;
3481e3e4:	e06a3003 	rsb	r3, sl, r3
3481e3e8:	e58d300c 	str	r3, [sp, #12]
                put += copy;
3481e3ec:	e59d3010 	ldr	r3, [sp, #16]
3481e3f0:	e083300a 	add	r3, r3, sl
3481e3f4:	e58d3010 	str	r3, [sp, #16]
                state->length -= copy;
3481e3f8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481e3fc:	e06aa003 	rsb	sl, sl, r3
3481e400:	e584a040 	str	sl, [r4, #64]	; 0x40
                break;
3481e404:	eafffdd8 	b	3481db6c <inflate+0x78>
            NEEDBITS(14);
3481e408:	e3570000 	cmp	r7, #0
3481e40c:	0a000261 	beq	3481ed98 <inflate+0x12a4>
3481e410:	e4db3001 	ldrb	r3, [fp], #1
3481e414:	e2477001 	sub	r7, r7, #1
3481e418:	e0855613 	add	r5, r5, r3, lsl r6
3481e41c:	e2866008 	add	r6, r6, #8
3481e420:	e356000d 	cmp	r6, #13
3481e424:	9afffff7 	bls	3481e408 <inflate+0x914>
            state->nlen = BITS(5) + 257;
3481e428:	e205301f 	and	r3, r5, #31
            state->ndist = BITS(5) + 1;
3481e42c:	e7e422d5 	ubfx	r2, r5, #5, #5
            state->nlen = BITS(5) + 257;
3481e430:	e2831c01 	add	r1, r3, #256	; 0x100
            state->ndist = BITS(5) + 1;
3481e434:	e2823001 	add	r3, r2, #1
            state->ncode = BITS(4) + 4;
3481e438:	e7e32555 	ubfx	r2, r5, #10, #4
            state->nlen = BITS(5) + 257;
3481e43c:	e2811001 	add	r1, r1, #1
            state->ncode = BITS(4) + 4;
3481e440:	e2822004 	add	r2, r2, #4
            state->ndist = BITS(5) + 1;
3481e444:	e5843064 	str	r3, [r4, #100]	; 0x64
            state->ncode = BITS(4) + 4;
3481e448:	e584205c 	str	r2, [r4, #92]	; 0x5c
            if (state->nlen > 286 || state->ndist > 30) {
3481e44c:	e300211e 	movw	r2, #286	; 0x11e
3481e450:	e1510002 	cmp	r1, r2
3481e454:	9353001e 	cmpls	r3, #30
            state->nlen = BITS(5) + 257;
3481e458:	e5841060 	str	r1, [r4, #96]	; 0x60
            if (state->nlen > 286 || state->ndist > 30) {
3481e45c:	83a03001 	movhi	r3, #1
            DROPBITS(4);
3481e460:	e1a05725 	lsr	r5, r5, #14
3481e464:	e246600e 	sub	r6, r6, #14
                strm->msg = (char *)"too many length or distance symbols";
3481e468:	859f3818 	ldrhi	r3, [pc, #2072]	; 3481ec88 <inflate+0x1194>
            if (state->nlen > 286 || state->ndist > 30) {
3481e46c:	93a03000 	movls	r3, #0
3481e470:	8afffe12 	bhi	3481dcc0 <inflate+0x1cc>
            state->have = 0;
3481e474:	e5843068 	str	r3, [r4, #104]	; 0x68
            state->mode = LENLENS;
3481e478:	e3a03010 	mov	r3, #16
3481e47c:	e5843000 	str	r3, [r4]
            while (state->have < state->ncode) {
3481e480:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
3481e484:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481e488:	e1530002 	cmp	r3, r2
3481e48c:	2a000013 	bcs	3481e4e0 <inflate+0x9ec>
                NEEDBITS(3);
3481e490:	e3560002 	cmp	r6, #2
3481e494:	8a000006 	bhi	3481e4b4 <inflate+0x9c0>
3481e498:	e3570000 	cmp	r7, #0
3481e49c:	0a00023d 	beq	3481ed98 <inflate+0x12a4>
3481e4a0:	e4db1001 	ldrb	r1, [fp], #1
3481e4a4:	e2477001 	sub	r7, r7, #1
3481e4a8:	e0855611 	add	r5, r5, r1, lsl r6
3481e4ac:	e2866008 	add	r6, r6, #8
3481e4b0:	eafffff6 	b	3481e490 <inflate+0x99c>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481e4b4:	e2831001 	add	r1, r3, #1
3481e4b8:	e1a03083 	lsl	r3, r3, #1
3481e4bc:	e5841068 	str	r1, [r4, #104]	; 0x68
                DROPBITS(3);
3481e4c0:	e2466003 	sub	r6, r6, #3
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481e4c4:	e59f17c0 	ldr	r1, [pc, #1984]	; 3481ec8c <inflate+0x1198>
3481e4c8:	e19130b3 	ldrh	r3, [r1, r3]
3481e4cc:	e2051007 	and	r1, r5, #7
                DROPBITS(3);
3481e4d0:	e1a051a5 	lsr	r5, r5, #3
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481e4d4:	e0843083 	add	r3, r4, r3, lsl #1
3481e4d8:	e1c317b0 	strh	r1, [r3, #112]	; 0x70
3481e4dc:	eaffffe8 	b	3481e484 <inflate+0x990>
                state->lens[order[state->have++]] = 0;
3481e4e0:	e3a02000 	mov	r2, #0
            while (state->have < 19)
3481e4e4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481e4e8:	e3530012 	cmp	r3, #18
3481e4ec:	8a000008 	bhi	3481e514 <inflate+0xa20>
                state->lens[order[state->have++]] = 0;
3481e4f0:	e2831001 	add	r1, r3, #1
3481e4f4:	e1a03083 	lsl	r3, r3, #1
3481e4f8:	e5841068 	str	r1, [r4, #104]	; 0x68
3481e4fc:	e59f1788 	ldr	r1, [pc, #1928]	; 3481ec8c <inflate+0x1198>
3481e500:	e19130b3 	ldrh	r3, [r1, r3]
3481e504:	e2833038 	add	r3, r3, #56	; 0x38
3481e508:	e1a03083 	lsl	r3, r3, #1
3481e50c:	e18420b3 	strh	r2, [r4, r3]
3481e510:	eafffff3 	b	3481e4e4 <inflate+0x9f0>
            state->next = state->codes;
3481e514:	e2843e53 	add	r3, r4, #1328	; 0x530
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481e518:	e3a02013 	mov	r2, #19
            state->next = state->codes;
3481e51c:	e584306c 	str	r3, [r4, #108]	; 0x6c
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481e520:	e2841070 	add	r1, r4, #112	; 0x70
            state->lencode = (code const FAR *)(state->next);
3481e524:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
3481e528:	e3a03007 	mov	r3, #7
3481e52c:	e5843054 	str	r3, [r4, #84]	; 0x54
                                &(state->lenbits), state->work);
3481e530:	e2843e2f 	add	r3, r4, #752	; 0x2f0
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481e534:	e58d3004 	str	r3, [sp, #4]
3481e538:	e2843054 	add	r3, r4, #84	; 0x54
3481e53c:	e58d3000 	str	r3, [sp]
3481e540:	e3a00000 	mov	r0, #0
3481e544:	e284306c 	add	r3, r4, #108	; 0x6c
3481e548:	ebfffacd 	bl	3481d084 <inflate_table>
            if (ret) {
3481e54c:	e2503000 	subs	r3, r0, #0
3481e550:	e58d3014 	str	r3, [sp, #20]
                strm->msg = (char *)"invalid code lengths set";
3481e554:	159f3734 	ldrne	r3, [pc, #1844]	; 3481ec90 <inflate+0x119c>
            if (ret) {
3481e558:	1afffdd8 	bne	3481dcc0 <inflate+0x1cc>
            state->have = 0;
3481e55c:	e59d3014 	ldr	r3, [sp, #20]
3481e560:	e5843068 	str	r3, [r4, #104]	; 0x68
            state->mode = CODELENS;
3481e564:	e3a03011 	mov	r3, #17
3481e568:	e5843000 	str	r3, [r4]
            while (state->have < state->nlen + state->ndist) {
3481e56c:	e594e060 	ldr	lr, [r4, #96]	; 0x60
                    this = state->lencode[BITS(state->lenbits)];
3481e570:	e3a0a001 	mov	sl, #1
            while (state->have < state->nlen + state->ndist) {
3481e574:	e5940064 	ldr	r0, [r4, #100]	; 0x64
3481e578:	e08e0000 	add	r0, lr, r0
3481e57c:	e5942068 	ldr	r2, [r4, #104]	; 0x68
3481e580:	e1520000 	cmp	r2, r0
3481e584:	2a00006e 	bcs	3481e744 <inflate+0xc50>
                    this = state->lencode[BITS(state->lenbits)];
3481e588:	e5941054 	ldr	r1, [r4, #84]	; 0x54
3481e58c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
3481e590:	e1a0111a 	lsl	r1, sl, r1
3481e594:	e58d301c 	str	r3, [sp, #28]
3481e598:	e2411001 	sub	r1, r1, #1
3481e59c:	e59d301c 	ldr	r3, [sp, #28]
3481e5a0:	e005c001 	and	ip, r5, r1
3481e5a4:	e083c10c 	add	ip, r3, ip, lsl #2
3481e5a8:	e5dc3001 	ldrb	r3, [ip, #1]
3481e5ac:	e1dcc0b2 	ldrh	ip, [ip, #2]
                    if ((unsigned)(this.bits) <= bits) break;
3481e5b0:	e1530006 	cmp	r3, r6
3481e5b4:	9a000006 	bls	3481e5d4 <inflate+0xae0>
                    PULLBYTE();
3481e5b8:	e3570000 	cmp	r7, #0
3481e5bc:	0a0001f5 	beq	3481ed98 <inflate+0x12a4>
3481e5c0:	e4db3001 	ldrb	r3, [fp], #1
3481e5c4:	e2477001 	sub	r7, r7, #1
3481e5c8:	e0855613 	add	r5, r5, r3, lsl r6
3481e5cc:	e2866008 	add	r6, r6, #8
                }
3481e5d0:	eafffff1 	b	3481e59c <inflate+0xaa8>
                if (this.val < 16) {
3481e5d4:	e35c000f 	cmp	ip, #15
3481e5d8:	8a00000f 	bhi	3481e61c <inflate+0xb28>
                    NEEDBITS(this.bits);
3481e5dc:	e1560003 	cmp	r6, r3
3481e5e0:	2a000006 	bcs	3481e600 <inflate+0xb0c>
3481e5e4:	e3570000 	cmp	r7, #0
3481e5e8:	0a0001ea 	beq	3481ed98 <inflate+0x12a4>
3481e5ec:	e4db1001 	ldrb	r1, [fp], #1
3481e5f0:	e2477001 	sub	r7, r7, #1
3481e5f4:	e0855611 	add	r5, r5, r1, lsl r6
3481e5f8:	e2866008 	add	r6, r6, #8
3481e5fc:	eafffff6 	b	3481e5dc <inflate+0xae8>
                    DROPBITS(this.bits);
3481e600:	e1a05335 	lsr	r5, r5, r3
3481e604:	e0636006 	rsb	r6, r3, r6
                    state->lens[state->have++] = this.val;
3481e608:	e2823001 	add	r3, r2, #1
3481e60c:	e0842082 	add	r2, r4, r2, lsl #1
3481e610:	e5843068 	str	r3, [r4, #104]	; 0x68
3481e614:	e1c2c7b0 	strh	ip, [r2, #112]	; 0x70
3481e618:	eaffffd7 	b	3481e57c <inflate+0xa88>
                    if (this.val == 16) {
3481e61c:	e35c0010 	cmp	ip, #16
                        NEEDBITS(this.bits + 2);
3481e620:	02831002 	addeq	r1, r3, #2
                    if (this.val == 16) {
3481e624:	1a000013 	bne	3481e678 <inflate+0xb84>
                        NEEDBITS(this.bits + 2);
3481e628:	e1560001 	cmp	r6, r1
3481e62c:	2a000006 	bcs	3481e64c <inflate+0xb58>
3481e630:	e3570000 	cmp	r7, #0
3481e634:	0a0001d7 	beq	3481ed98 <inflate+0x12a4>
3481e638:	e4dbc001 	ldrb	ip, [fp], #1
3481e63c:	e2477001 	sub	r7, r7, #1
3481e640:	e085561c 	add	r5, r5, ip, lsl r6
3481e644:	e2866008 	add	r6, r6, #8
3481e648:	eafffff6 	b	3481e628 <inflate+0xb34>
                        if (state->have == 0) {
3481e64c:	e3520000 	cmp	r2, #0
                        DROPBITS(this.bits);
3481e650:	e1a05335 	lsr	r5, r5, r3
3481e654:	e0636006 	rsb	r6, r3, r6
                        if (state->have == 0) {
3481e658:	0a00002c 	beq	3481e710 <inflate+0xc1c>
                        len = state->lens[state->have - 1];
3481e65c:	e0843082 	add	r3, r4, r2, lsl #1
                        copy = 3 + BITS(2);
3481e660:	e2051003 	and	r1, r5, #3
3481e664:	e2811003 	add	r1, r1, #3
                        DROPBITS(2);
3481e668:	e1a05125 	lsr	r5, r5, #2
                        len = state->lens[state->have - 1];
3481e66c:	e1d3c6be 	ldrh	ip, [r3, #110]	; 0x6e
                        DROPBITS(2);
3481e670:	e2466002 	sub	r6, r6, #2
3481e674:	ea000022 	b	3481e704 <inflate+0xc10>
                    else if (this.val == 17) {
3481e678:	e35c0011 	cmp	ip, #17
                        NEEDBITS(this.bits + 7);
3481e67c:	12831007 	addne	r1, r3, #7
                        NEEDBITS(this.bits + 3);
3481e680:	02831003 	addeq	r1, r3, #3
                    else if (this.val == 17) {
3481e684:	1a000014 	bne	3481e6dc <inflate+0xbe8>
                        NEEDBITS(this.bits + 3);
3481e688:	e1560001 	cmp	r6, r1
3481e68c:	2a000006 	bcs	3481e6ac <inflate+0xbb8>
3481e690:	e3570000 	cmp	r7, #0
3481e694:	0a0001bf 	beq	3481ed98 <inflate+0x12a4>
3481e698:	e4dbc001 	ldrb	ip, [fp], #1
3481e69c:	e2477001 	sub	r7, r7, #1
3481e6a0:	e085561c 	add	r5, r5, ip, lsl r6
3481e6a4:	e2866008 	add	r6, r6, #8
3481e6a8:	eafffff6 	b	3481e688 <inflate+0xb94>
                        DROPBITS(this.bits);
3481e6ac:	e1a05335 	lsr	r5, r5, r3
3481e6b0:	e3e0c002 	mvn	ip, #2
                        copy = 3 + BITS(3);
3481e6b4:	e2051007 	and	r1, r5, #7
                        DROPBITS(3);
3481e6b8:	e1a051a5 	lsr	r5, r5, #3
                        copy = 3 + BITS(3);
3481e6bc:	e2811003 	add	r1, r1, #3
3481e6c0:	ea00000c 	b	3481e6f8 <inflate+0xc04>
                        NEEDBITS(this.bits + 7);
3481e6c4:	e3570000 	cmp	r7, #0
3481e6c8:	0a0001b2 	beq	3481ed98 <inflate+0x12a4>
3481e6cc:	e4dbc001 	ldrb	ip, [fp], #1
3481e6d0:	e2477001 	sub	r7, r7, #1
3481e6d4:	e085561c 	add	r5, r5, ip, lsl r6
3481e6d8:	e2866008 	add	r6, r6, #8
3481e6dc:	e1560001 	cmp	r6, r1
3481e6e0:	3afffff7 	bcc	3481e6c4 <inflate+0xbd0>
                        DROPBITS(this.bits);
3481e6e4:	e1a05335 	lsr	r5, r5, r3
3481e6e8:	e3e0c006 	mvn	ip, #6
                        copy = 11 + BITS(7);
3481e6ec:	e205107f 	and	r1, r5, #127	; 0x7f
                        DROPBITS(7);
3481e6f0:	e1a053a5 	lsr	r5, r5, #7
                        copy = 11 + BITS(7);
3481e6f4:	e281100b 	add	r1, r1, #11
3481e6f8:	e063c00c 	rsb	ip, r3, ip
                        DROPBITS(7);
3481e6fc:	e086600c 	add	r6, r6, ip
                        len = 0;
3481e700:	e3a0c000 	mov	ip, #0
                    if (state->have + copy > state->nlen + state->ndist) {
3481e704:	e0812002 	add	r2, r1, r2
3481e708:	e1520000 	cmp	r2, r0
3481e70c:	9a000004 	bls	3481e724 <inflate+0xc30>
                        strm->msg = (char *)"invalid bit length repeat";
3481e710:	e59f357c 	ldr	r3, [pc, #1404]	; 3481ec94 <inflate+0x11a0>
3481e714:	e5893018 	str	r3, [r9, #24]
                        state->mode = BAD;
3481e718:	e3a0301b 	mov	r3, #27
3481e71c:	e5843000 	str	r3, [r4]
                        break;
3481e720:	ea000007 	b	3481e744 <inflate+0xc50>
                    while (copy--)
3481e724:	e2511001 	subs	r1, r1, #1
3481e728:	3affff93 	bcc	3481e57c <inflate+0xa88>
                        state->lens[state->have++] = (unsigned short)len;
3481e72c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481e730:	e2832001 	add	r2, r3, #1
3481e734:	e0843083 	add	r3, r4, r3, lsl #1
3481e738:	e5842068 	str	r2, [r4, #104]	; 0x68
3481e73c:	e1c3c7b0 	strh	ip, [r3, #112]	; 0x70
3481e740:	eafffff7 	b	3481e724 <inflate+0xc30>
            if (state->mode == BAD) break;
3481e744:	e5943000 	ldr	r3, [r4]
3481e748:	e353001b 	cmp	r3, #27
3481e74c:	0afffd06 	beq	3481db6c <inflate+0x78>
            state->next = state->codes;
3481e750:	e2843e53 	add	r3, r4, #1328	; 0x530
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481e754:	e284a06c 	add	sl, r4, #108	; 0x6c
            state->next = state->codes;
3481e758:	e584306c 	str	r3, [r4, #108]	; 0x6c
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481e75c:	e1a0200e 	mov	r2, lr
            state->lencode = (code const FAR *)(state->next);
3481e760:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
3481e764:	e3a03009 	mov	r3, #9
3481e768:	e5843054 	str	r3, [r4, #84]	; 0x54
                                &(state->lenbits), state->work);
3481e76c:	e2843e2f 	add	r3, r4, #752	; 0x2f0
3481e770:	e58d301c 	str	r3, [sp, #28]
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481e774:	e2841070 	add	r1, r4, #112	; 0x70
3481e778:	e58d3004 	str	r3, [sp, #4]
3481e77c:	e2843054 	add	r3, r4, #84	; 0x54
3481e780:	e58d3000 	str	r3, [sp]
3481e784:	e3a00001 	mov	r0, #1
3481e788:	e1a0300a 	mov	r3, sl
3481e78c:	ebfffa3c 	bl	3481d084 <inflate_table>
            if (ret) {
3481e790:	e2503000 	subs	r3, r0, #0
3481e794:	e58d3014 	str	r3, [sp, #20]
                strm->msg = (char *)"invalid literal/lengths set";
3481e798:	159f34f8 	ldrne	r3, [pc, #1272]	; 3481ec98 <inflate+0x11a4>
            if (ret) {
3481e79c:	1afffd47 	bne	3481dcc0 <inflate+0x1cc>
            state->distcode = (code const FAR *)(state->next);
3481e7a0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481e7a4:	e3a00002 	mov	r0, #2
3481e7a8:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            state->distcode = (code const FAR *)(state->next);
3481e7ac:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
3481e7b0:	e3a03006 	mov	r3, #6
3481e7b4:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481e7b8:	e2811038 	add	r1, r1, #56	; 0x38
3481e7bc:	e59d301c 	ldr	r3, [sp, #28]
3481e7c0:	e0841081 	add	r1, r4, r1, lsl #1
3481e7c4:	e58d3004 	str	r3, [sp, #4]
3481e7c8:	e2843058 	add	r3, r4, #88	; 0x58
3481e7cc:	e58d3000 	str	r3, [sp]
3481e7d0:	e1a0300a 	mov	r3, sl
3481e7d4:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481e7d8:	ebfffa29 	bl	3481d084 <inflate_table>
            if (ret) {
3481e7dc:	e2503000 	subs	r3, r0, #0
3481e7e0:	e58d3014 	str	r3, [sp, #20]
                strm->msg = (char *)"invalid distances set";
3481e7e4:	159f34b0 	ldrne	r3, [pc, #1200]	; 3481ec9c <inflate+0x11a8>
            if (ret) {
3481e7e8:	1afffd34 	bne	3481dcc0 <inflate+0x1cc>
            state->mode = LEN;
3481e7ec:	e3a03012 	mov	r3, #18
3481e7f0:	e5843000 	str	r3, [r4]
            if (have >= 6 && left >= 258) {
3481e7f4:	e59d200c 	ldr	r2, [sp, #12]
3481e7f8:	e3003101 	movw	r3, #257	; 0x101
3481e7fc:	e3570005 	cmp	r7, #5
3481e800:	81520003 	cmphi	r2, r3
3481e804:	9a000012 	bls	3481e854 <inflate+0xd60>
                RESTORE();
3481e808:	e59d3010 	ldr	r3, [sp, #16]
                inflate_fast(strm, out);
3481e80c:	e1a00009 	mov	r0, r9
                RESTORE();
3481e810:	e589b000 	str	fp, [r9]
3481e814:	e5897004 	str	r7, [r9, #4]
3481e818:	e589300c 	str	r3, [r9, #12]
3481e81c:	e5892010 	str	r2, [r9, #16]
                inflate_fast(strm, out);
3481e820:	e59d1018 	ldr	r1, [sp, #24]
                RESTORE();
3481e824:	e5845038 	str	r5, [r4, #56]	; 0x38
3481e828:	e584603c 	str	r6, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
3481e82c:	ebfff8ae 	bl	3481caec <inflate_fast>
                LOAD();
3481e830:	e599300c 	ldr	r3, [r9, #12]
3481e834:	e599b000 	ldr	fp, [r9]
3481e838:	e5997004 	ldr	r7, [r9, #4]
3481e83c:	e58d3010 	str	r3, [sp, #16]
3481e840:	e5993010 	ldr	r3, [r9, #16]
3481e844:	e5945038 	ldr	r5, [r4, #56]	; 0x38
3481e848:	e594603c 	ldr	r6, [r4, #60]	; 0x3c
3481e84c:	e58d300c 	str	r3, [sp, #12]
                break;
3481e850:	eafffcc5 	b	3481db6c <inflate+0x78>
                this = state->lencode[BITS(state->lenbits)];
3481e854:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481e858:	e3e0c000 	mvn	ip, #0
3481e85c:	e594004c 	ldr	r0, [r4, #76]	; 0x4c
3481e860:	e1e0c31c 	mvn	ip, ip, lsl r3
3481e864:	e005300c 	and	r3, r5, ip
3481e868:	e0801103 	add	r1, r0, r3, lsl #2
3481e86c:	e7d03103 	ldrb	r3, [r0, r3, lsl #2]
3481e870:	e5d12001 	ldrb	r2, [r1, #1]
3481e874:	e1d1a0b2 	ldrh	sl, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481e878:	e1520006 	cmp	r2, r6
3481e87c:	e1a01002 	mov	r1, r2
3481e880:	9a000006 	bls	3481e8a0 <inflate+0xdac>
                PULLBYTE();
3481e884:	e3570000 	cmp	r7, #0
3481e888:	0a000142 	beq	3481ed98 <inflate+0x12a4>
3481e88c:	e4db3001 	ldrb	r3, [fp], #1
3481e890:	e2477001 	sub	r7, r7, #1
3481e894:	e0855613 	add	r5, r5, r3, lsl r6
3481e898:	e2866008 	add	r6, r6, #8
            }
3481e89c:	eafffff0 	b	3481e864 <inflate+0xd70>
            if (this.op && (this.op & 0xf0) == 0) {
3481e8a0:	e3530000 	cmp	r3, #0
                this = state->lencode[BITS(state->lenbits)];
3481e8a4:	e1a0e00a 	mov	lr, sl
            if (this.op && (this.op & 0xf0) == 0) {
3481e8a8:	0a000018 	beq	3481e910 <inflate+0xe1c>
3481e8ac:	e31300f0 	tst	r3, #240	; 0xf0
3481e8b0:	1a000016 	bne	3481e910 <inflate+0xe1c>
                            (BITS(last.bits + last.op) >> last.bits)];
3481e8b4:	e0823003 	add	r3, r2, r3
3481e8b8:	e3e0c000 	mvn	ip, #0
3481e8bc:	e1e0331c 	mvn	r3, ip, lsl r3
3481e8c0:	e58d301c 	str	r3, [sp, #28]
3481e8c4:	e59d301c 	ldr	r3, [sp, #28]
3481e8c8:	e0053003 	and	r3, r5, r3
                    this = state->lencode[last.val +
3481e8cc:	e08a3133 	add	r3, sl, r3, lsr r1
3481e8d0:	e080e103 	add	lr, r0, r3, lsl #2
3481e8d4:	e7d03103 	ldrb	r3, [r0, r3, lsl #2]
3481e8d8:	e5de2001 	ldrb	r2, [lr, #1]
3481e8dc:	e1dee0b2 	ldrh	lr, [lr, #2]
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481e8e0:	e081c002 	add	ip, r1, r2
3481e8e4:	e15c0006 	cmp	ip, r6
3481e8e8:	9a000006 	bls	3481e908 <inflate+0xe14>
                    PULLBYTE();
3481e8ec:	e3570000 	cmp	r7, #0
3481e8f0:	0a000128 	beq	3481ed98 <inflate+0x12a4>
3481e8f4:	e4db3001 	ldrb	r3, [fp], #1
3481e8f8:	e2477001 	sub	r7, r7, #1
3481e8fc:	e0855613 	add	r5, r5, r3, lsl r6
3481e900:	e2866008 	add	r6, r6, #8
                }
3481e904:	eaffffee 	b	3481e8c4 <inflate+0xdd0>
                DROPBITS(last.bits);
3481e908:	e1a05135 	lsr	r5, r5, r1
3481e90c:	e0616006 	rsb	r6, r1, r6
            if ((int)(this.op) == 0) {
3481e910:	e3530000 	cmp	r3, #0
            DROPBITS(this.bits);
3481e914:	e1a05235 	lsr	r5, r5, r2
3481e918:	e0626006 	rsb	r6, r2, r6
            state->length = (unsigned)this.val;
3481e91c:	e584e040 	str	lr, [r4, #64]	; 0x40
                state->mode = LIT;
3481e920:	03a03017 	moveq	r3, #23
            if ((int)(this.op) == 0) {
3481e924:	0afffce7 	beq	3481dcc8 <inflate+0x1d4>
            if (this.op & 32) {
3481e928:	e3130020 	tst	r3, #32
3481e92c:	0a000001 	beq	3481e938 <inflate+0xe44>
                state->mode = TYPE;
3481e930:	e3a0300b 	mov	r3, #11
3481e934:	eafffce3 	b	3481dcc8 <inflate+0x1d4>
            if (this.op & 64) {
3481e938:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
3481e93c:	159f335c 	ldrne	r3, [pc, #860]	; 3481eca0 <inflate+0x11ac>
            if (this.op & 64) {
3481e940:	1afffcde 	bne	3481dcc0 <inflate+0x1cc>
            state->extra = (unsigned)(this.op) & 15;
3481e944:	e203300f 	and	r3, r3, #15
3481e948:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
3481e94c:	e3a03013 	mov	r3, #19
3481e950:	e5843000 	str	r3, [r4]
            if (state->extra) {
3481e954:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481e958:	e3530000 	cmp	r3, #0
3481e95c:	0a00000f 	beq	3481e9a0 <inflate+0xeac>
                NEEDBITS(state->extra);
3481e960:	e1560003 	cmp	r6, r3
3481e964:	2a000006 	bcs	3481e984 <inflate+0xe90>
3481e968:	e3570000 	cmp	r7, #0
3481e96c:	0a000109 	beq	3481ed98 <inflate+0x12a4>
3481e970:	e4db2001 	ldrb	r2, [fp], #1
3481e974:	e2477001 	sub	r7, r7, #1
3481e978:	e0855612 	add	r5, r5, r2, lsl r6
3481e97c:	e2866008 	add	r6, r6, #8
3481e980:	eafffff6 	b	3481e960 <inflate+0xe6c>
                state->length += BITS(state->extra);
3481e984:	e3e02000 	mvn	r2, #0
                DROPBITS(state->extra);
3481e988:	e0636006 	rsb	r6, r3, r6
                state->length += BITS(state->extra);
3481e98c:	e1c51312 	bic	r1, r5, r2, lsl r3
3481e990:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
3481e994:	e1a05335 	lsr	r5, r5, r3
                state->length += BITS(state->extra);
3481e998:	e0822001 	add	r2, r2, r1
3481e99c:	e5842040 	str	r2, [r4, #64]	; 0x40
            state->mode = DIST;
3481e9a0:	e3a03014 	mov	r3, #20
3481e9a4:	e5843000 	str	r3, [r4]
                this = state->distcode[BITS(state->distbits)];
3481e9a8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481e9ac:	e3e0e000 	mvn	lr, #0
3481e9b0:	e5940050 	ldr	r0, [r4, #80]	; 0x50
3481e9b4:	e1e0e31e 	mvn	lr, lr, lsl r3
3481e9b8:	e005300e 	and	r3, r5, lr
3481e9bc:	e0801103 	add	r1, r0, r3, lsl #2
3481e9c0:	e7d03103 	ldrb	r3, [r0, r3, lsl #2]
3481e9c4:	e5d12001 	ldrb	r2, [r1, #1]
3481e9c8:	e1d1c0b2 	ldrh	ip, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481e9cc:	e1520006 	cmp	r2, r6
3481e9d0:	e1a01002 	mov	r1, r2
3481e9d4:	9a000006 	bls	3481e9f4 <inflate+0xf00>
                PULLBYTE();
3481e9d8:	e3570000 	cmp	r7, #0
3481e9dc:	0a0000ed 	beq	3481ed98 <inflate+0x12a4>
3481e9e0:	e4db3001 	ldrb	r3, [fp], #1
3481e9e4:	e2477001 	sub	r7, r7, #1
3481e9e8:	e0855613 	add	r5, r5, r3, lsl r6
3481e9ec:	e2866008 	add	r6, r6, #8
            }
3481e9f0:	eafffff0 	b	3481e9b8 <inflate+0xec4>
            if ((this.op & 0xf0) == 0) {
3481e9f4:	e31300f0 	tst	r3, #240	; 0xf0
                this = state->distcode[BITS(state->distbits)];
3481e9f8:	e1a0a00c 	mov	sl, ip
            if ((this.op & 0xf0) == 0) {
3481e9fc:	1a000016 	bne	3481ea5c <inflate+0xf68>
                            (BITS(last.bits + last.op) >> last.bits)];
3481ea00:	e0823003 	add	r3, r2, r3
3481ea04:	e3e0e000 	mvn	lr, #0
3481ea08:	e1e0331e 	mvn	r3, lr, lsl r3
3481ea0c:	e58d301c 	str	r3, [sp, #28]
3481ea10:	e59d301c 	ldr	r3, [sp, #28]
3481ea14:	e0053003 	and	r3, r5, r3
                    this = state->distcode[last.val +
3481ea18:	e08a3133 	add	r3, sl, r3, lsr r1
3481ea1c:	e080c103 	add	ip, r0, r3, lsl #2
3481ea20:	e7d03103 	ldrb	r3, [r0, r3, lsl #2]
3481ea24:	e5dc2001 	ldrb	r2, [ip, #1]
3481ea28:	e1dcc0b2 	ldrh	ip, [ip, #2]
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481ea2c:	e081e002 	add	lr, r1, r2
3481ea30:	e15e0006 	cmp	lr, r6
3481ea34:	9a000006 	bls	3481ea54 <inflate+0xf60>
                    PULLBYTE();
3481ea38:	e3570000 	cmp	r7, #0
3481ea3c:	0a0000d5 	beq	3481ed98 <inflate+0x12a4>
3481ea40:	e4db3001 	ldrb	r3, [fp], #1
3481ea44:	e2477001 	sub	r7, r7, #1
3481ea48:	e0855613 	add	r5, r5, r3, lsl r6
3481ea4c:	e2866008 	add	r6, r6, #8
                }
3481ea50:	eaffffee 	b	3481ea10 <inflate+0xf1c>
                DROPBITS(last.bits);
3481ea54:	e1a05135 	lsr	r5, r5, r1
3481ea58:	e0616006 	rsb	r6, r1, r6
            if (this.op & 64) {
3481ea5c:	e3130040 	tst	r3, #64	; 0x40
            DROPBITS(this.bits);
3481ea60:	e1a05235 	lsr	r5, r5, r2
3481ea64:	e0626006 	rsb	r6, r2, r6
                strm->msg = (char *)"invalid distance code";
3481ea68:	159f3234 	ldrne	r3, [pc, #564]	; 3481eca4 <inflate+0x11b0>
            if (this.op & 64) {
3481ea6c:	1afffc93 	bne	3481dcc0 <inflate+0x1cc>
            state->extra = (unsigned)(this.op) & 15;
3481ea70:	e203300f 	and	r3, r3, #15
            state->offset = (unsigned)this.val;
3481ea74:	e584c044 	str	ip, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
3481ea78:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = DISTEXT;
3481ea7c:	e3a03015 	mov	r3, #21
3481ea80:	e5843000 	str	r3, [r4]
            if (state->extra) {
3481ea84:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481ea88:	e3530000 	cmp	r3, #0
3481ea8c:	0a00000f 	beq	3481ead0 <inflate+0xfdc>
                NEEDBITS(state->extra);
3481ea90:	e1560003 	cmp	r6, r3
3481ea94:	2a000006 	bcs	3481eab4 <inflate+0xfc0>
3481ea98:	e3570000 	cmp	r7, #0
3481ea9c:	0a0000bd 	beq	3481ed98 <inflate+0x12a4>
3481eaa0:	e4db2001 	ldrb	r2, [fp], #1
3481eaa4:	e2477001 	sub	r7, r7, #1
3481eaa8:	e0855612 	add	r5, r5, r2, lsl r6
3481eaac:	e2866008 	add	r6, r6, #8
3481eab0:	eafffff6 	b	3481ea90 <inflate+0xf9c>
                state->offset += BITS(state->extra);
3481eab4:	e3e02000 	mvn	r2, #0
                DROPBITS(state->extra);
3481eab8:	e0636006 	rsb	r6, r3, r6
                state->offset += BITS(state->extra);
3481eabc:	e1c51312 	bic	r1, r5, r2, lsl r3
3481eac0:	e5942044 	ldr	r2, [r4, #68]	; 0x44
                DROPBITS(state->extra);
3481eac4:	e1a05335 	lsr	r5, r5, r3
                state->offset += BITS(state->extra);
3481eac8:	e0822001 	add	r2, r2, r1
3481eacc:	e5842044 	str	r2, [r4, #68]	; 0x44
            if (state->offset > state->whave + out - left) {
3481ead0:	e59d2018 	ldr	r2, [sp, #24]
3481ead4:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481ead8:	e0823003 	add	r3, r2, r3
3481eadc:	e59d200c 	ldr	r2, [sp, #12]
3481eae0:	e0623003 	rsb	r3, r2, r3
3481eae4:	e5942044 	ldr	r2, [r4, #68]	; 0x44
3481eae8:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
3481eaec:	859f31b4 	ldrhi	r3, [pc, #436]	; 3481eca8 <inflate+0x11b4>
            if (state->offset > state->whave + out - left) {
3481eaf0:	8afffc72 	bhi	3481dcc0 <inflate+0x1cc>
            state->mode = MATCH;
3481eaf4:	e3a03016 	mov	r3, #22
3481eaf8:	e5843000 	str	r3, [r4]
            if (left == 0) goto inf_leave;
3481eafc:	e59d300c 	ldr	r3, [sp, #12]
3481eb00:	e3530000 	cmp	r3, #0
3481eb04:	0a0000a3 	beq	3481ed98 <inflate+0x12a4>
            copy = out - left;
3481eb08:	e59d3018 	ldr	r3, [sp, #24]
3481eb0c:	e59d200c 	ldr	r2, [sp, #12]
3481eb10:	e0622003 	rsb	r2, r2, r3
            if (state->offset > copy) {         /* copy from window */
3481eb14:	e5943044 	ldr	r3, [r4, #68]	; 0x44
3481eb18:	e1530002 	cmp	r3, r2
                from = put - state->offset;
3481eb1c:	959d2010 	ldrls	r2, [sp, #16]
3481eb20:	90632002 	rsbls	r2, r3, r2
                copy = state->length;
3481eb24:	95943040 	ldrls	r3, [r4, #64]	; 0x40
            if (state->offset > copy) {         /* copy from window */
3481eb28:	9a00000a 	bls	3481eb58 <inflate+0x1064>
                if (copy > state->write) {
3481eb2c:	e5941030 	ldr	r1, [r4, #48]	; 0x30
                copy = state->offset - copy;
3481eb30:	e0623003 	rsb	r3, r2, r3
3481eb34:	e5942034 	ldr	r2, [r4, #52]	; 0x34
                if (copy > state->write) {
3481eb38:	e1530001 	cmp	r3, r1
                    copy -= state->write;
3481eb3c:	80613003 	rsbhi	r3, r1, r3
                    from = state->window + (state->wsize - copy);
3481eb40:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
                    from = state->window + (state->write - copy);
3481eb44:	e0631001 	rsb	r1, r3, r1
3481eb48:	e0822001 	add	r2, r2, r1
                if (copy > state->length) copy = state->length;
3481eb4c:	e5941040 	ldr	r1, [r4, #64]	; 0x40
3481eb50:	e1530001 	cmp	r3, r1
3481eb54:	21a03001 	movcs	r3, r1
3481eb58:	e59d100c 	ldr	r1, [sp, #12]
3481eb5c:	e1530001 	cmp	r3, r1
3481eb60:	21a03001 	movcs	r3, r1
            left -= copy;
3481eb64:	e0631001 	rsb	r1, r3, r1
3481eb68:	e0820003 	add	r0, r2, r3
3481eb6c:	e58d100c 	str	r1, [sp, #12]
            state->length -= copy;
3481eb70:	e5941040 	ldr	r1, [r4, #64]	; 0x40
3481eb74:	e0631001 	rsb	r1, r3, r1
3481eb78:	e5841040 	str	r1, [r4, #64]	; 0x40
3481eb7c:	e59d1010 	ldr	r1, [sp, #16]
3481eb80:	e2411001 	sub	r1, r1, #1
                *put++ = *from++;
3481eb84:	e4d2c001 	ldrb	ip, [r2], #1
            } while (--copy);
3481eb88:	e1520000 	cmp	r2, r0
                *put++ = *from++;
3481eb8c:	e5e1c001 	strb	ip, [r1, #1]!
            } while (--copy);
3481eb90:	1afffffb 	bne	3481eb84 <inflate+0x1090>
3481eb94:	e59d2010 	ldr	r2, [sp, #16]
3481eb98:	e0823003 	add	r3, r2, r3
3481eb9c:	e58d3010 	str	r3, [sp, #16]
            if (state->length == 0) state->mode = LEN;
3481eba0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481eba4:	e3530000 	cmp	r3, #0
3481eba8:	03a03012 	moveq	r3, #18
3481ebac:	0afffc45 	beq	3481dcc8 <inflate+0x1d4>
3481ebb0:	eafffbed 	b	3481db6c <inflate+0x78>
            if (left == 0) goto inf_leave;
3481ebb4:	e59d300c 	ldr	r3, [sp, #12]
3481ebb8:	e3530000 	cmp	r3, #0
3481ebbc:	0a000075 	beq	3481ed98 <inflate+0x12a4>
            *put++ = (unsigned char)(state->length);
3481ebc0:	e59d2010 	ldr	r2, [sp, #16]
3481ebc4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481ebc8:	e5c23000 	strb	r3, [r2]
            left--;
3481ebcc:	e59d300c 	ldr	r3, [sp, #12]
3481ebd0:	e2433001 	sub	r3, r3, #1
3481ebd4:	e58d300c 	str	r3, [sp, #12]
            state->mode = LEN;
3481ebd8:	e3a03012 	mov	r3, #18
3481ebdc:	e5843000 	str	r3, [r4]
            *put++ = (unsigned char)(state->length);
3481ebe0:	e2823001 	add	r3, r2, #1
3481ebe4:	e58d3010 	str	r3, [sp, #16]
            break;
3481ebe8:	eafffbdf 	b	3481db6c <inflate+0x78>
            if (state->wrap) {
3481ebec:	e5943008 	ldr	r3, [r4, #8]
3481ebf0:	e3530000 	cmp	r3, #0
3481ebf4:	0a000049 	beq	3481ed20 <inflate+0x122c>
                NEEDBITS(32);
3481ebf8:	e356001f 	cmp	r6, #31
3481ebfc:	8a000006 	bhi	3481ec1c <inflate+0x1128>
3481ec00:	e3570000 	cmp	r7, #0
3481ec04:	0a000063 	beq	3481ed98 <inflate+0x12a4>
3481ec08:	e4db3001 	ldrb	r3, [fp], #1
3481ec0c:	e2477001 	sub	r7, r7, #1
3481ec10:	e0855613 	add	r5, r5, r3, lsl r6
3481ec14:	e2866008 	add	r6, r6, #8
3481ec18:	eafffff6 	b	3481ebf8 <inflate+0x1104>
                out -= left;
3481ec1c:	e59d3018 	ldr	r3, [sp, #24]
3481ec20:	e59d200c 	ldr	r2, [sp, #12]
3481ec24:	e0622003 	rsb	r2, r2, r3
                strm->total_out += out;
3481ec28:	e5993014 	ldr	r3, [r9, #20]
                if (out)
3481ec2c:	e3520000 	cmp	r2, #0
                strm->total_out += out;
3481ec30:	e0833002 	add	r3, r3, r2
3481ec34:	e5893014 	str	r3, [r9, #20]
                state->total += out;
3481ec38:	e594301c 	ldr	r3, [r4, #28]
3481ec3c:	e0833002 	add	r3, r3, r2
3481ec40:	e584301c 	str	r3, [r4, #28]
                if (out)
3481ec44:	0a00001d 	beq	3481ecc0 <inflate+0x11cc>
                        UPDATE(state->check, put - out, out);
3481ec48:	e5943010 	ldr	r3, [r4, #16]
3481ec4c:	e5940018 	ldr	r0, [r4, #24]
3481ec50:	e3530000 	cmp	r3, #0
3481ec54:	e59d3010 	ldr	r3, [sp, #16]
3481ec58:	e0621003 	rsb	r1, r2, r3
3481ec5c:	0a000014 	beq	3481ecb4 <inflate+0x11c0>
3481ec60:	ebffec80 	bl	34819e68 <crc32>
3481ec64:	ea000013 	b	3481ecb8 <inflate+0x11c4>
3481ec68:	34826df0 	.word	0x34826df0
3481ec6c:	34826e22 	.word	0x34826e22
3481ec70:	34826e07 	.word	0x34826e07
3481ec74:	34826e36 	.word	0x34826e36
3481ec78:	34826e4f 	.word	0x34826e4f
3481ec7c:	34820b58 	.word	0x34820b58
3481ec80:	34826e63 	.word	0x34826e63
3481ec84:	34826e76 	.word	0x34826e76
3481ec88:	34826e93 	.word	0x34826e93
3481ec8c:	348213d8 	.word	0x348213d8
3481ec90:	34826eb7 	.word	0x34826eb7
3481ec94:	34826ed0 	.word	0x34826ed0
3481ec98:	34826eea 	.word	0x34826eea
3481ec9c:	34826f06 	.word	0x34826f06
3481eca0:	34826dd4 	.word	0x34826dd4
3481eca4:	34826dbe 	.word	0x34826dbe
3481eca8:	34826da0 	.word	0x34826da0
3481ecac:	34826f1c 	.word	0x34826f1c
3481ecb0:	34826f31 	.word	0x34826f31
3481ecb4:	ebfffac0 	bl	3481d7bc <adler32>
                    strm->adler = state->check =
3481ecb8:	e5840018 	str	r0, [r4, #24]
3481ecbc:	e5890034 	str	r0, [r9, #52]	; 0x34
                     state->flags ? hold :
3481ecc0:	e5943010 	ldr	r3, [r4, #16]
3481ecc4:	e3530000 	cmp	r3, #0
                     REVERSE(hold)) != state->check) {
3481ecc8:	01a03c25 	lsreq	r3, r5, #24
3481eccc:	11a03005 	movne	r3, r5
3481ecd0:	00832c05 	addeq	r2, r3, r5, lsl #24
3481ecd4:	01a03425 	lsreq	r3, r5, #8
3481ecd8:	02033cff 	andeq	r3, r3, #65280	; 0xff00
3481ecdc:	00823003 	addeq	r3, r2, r3
3481ece0:	02052cff 	andeq	r2, r5, #65280	; 0xff00
                     state->flags ? hold :
3481ece4:	00833402 	addeq	r3, r3, r2, lsl #8
                if ((
3481ece8:	e5942018 	ldr	r2, [r4, #24]
3481ecec:	e1530002 	cmp	r3, r2
3481ecf0:	0a000006 	beq	3481ed10 <inflate+0x121c>
                    strm->msg = (char *)"incorrect data check";
3481ecf4:	e51f3050 	ldr	r3, [pc, #-80]	; 3481ecac <inflate+0x11b8>
3481ecf8:	e5893018 	str	r3, [r9, #24]
                    state->mode = BAD;
3481ecfc:	e3a0301b 	mov	r3, #27
3481ed00:	e5843000 	str	r3, [r4]
                    break;
3481ed04:	e59d300c 	ldr	r3, [sp, #12]
3481ed08:	e58d3018 	str	r3, [sp, #24]
3481ed0c:	eafffb96 	b	3481db6c <inflate+0x78>
3481ed10:	e59d300c 	ldr	r3, [sp, #12]
                INITBITS();
3481ed14:	e3a06000 	mov	r6, #0
3481ed18:	e1a05006 	mov	r5, r6
3481ed1c:	e58d3018 	str	r3, [sp, #24]
            state->mode = LENGTH;
3481ed20:	e3a03019 	mov	r3, #25
3481ed24:	e5843000 	str	r3, [r4]
            if (state->wrap && state->flags) {
3481ed28:	e5943008 	ldr	r3, [r4, #8]
3481ed2c:	e3530000 	cmp	r3, #0
3481ed30:	0a000011 	beq	3481ed7c <inflate+0x1288>
3481ed34:	e5943010 	ldr	r3, [r4, #16]
3481ed38:	e3530000 	cmp	r3, #0
3481ed3c:	0a00000e 	beq	3481ed7c <inflate+0x1288>
                NEEDBITS(32);
3481ed40:	e356001f 	cmp	r6, #31
3481ed44:	8a000006 	bhi	3481ed64 <inflate+0x1270>
3481ed48:	e3570000 	cmp	r7, #0
3481ed4c:	0a000011 	beq	3481ed98 <inflate+0x12a4>
3481ed50:	e4db3001 	ldrb	r3, [fp], #1
3481ed54:	e2477001 	sub	r7, r7, #1
3481ed58:	e0855613 	add	r5, r5, r3, lsl r6
3481ed5c:	e2866008 	add	r6, r6, #8
3481ed60:	eafffff6 	b	3481ed40 <inflate+0x124c>
                if (hold != (state->total & 0xffffffffUL)) {
3481ed64:	e594301c 	ldr	r3, [r4, #28]
3481ed68:	e1550003 	cmp	r5, r3
                    strm->msg = (char *)"incorrect length check";
3481ed6c:	151f30c4 	ldrne	r3, [pc, #-196]	; 3481ecb0 <inflate+0x11bc>
3481ed70:	1afffbd2 	bne	3481dcc0 <inflate+0x1cc>
                INITBITS();
3481ed74:	e3a06000 	mov	r6, #0
3481ed78:	e1a05006 	mov	r5, r6
            state->mode = DONE;
3481ed7c:	e3a0301a 	mov	r3, #26
3481ed80:	e5843000 	str	r3, [r4]
3481ed84:	ea000001 	b	3481ed90 <inflate+0x129c>
            ret = Z_DATA_ERROR;
3481ed88:	e3e03002 	mvn	r3, #2
3481ed8c:	ea000000 	b	3481ed94 <inflate+0x12a0>
            ret = Z_STREAM_END;
3481ed90:	e3a03001 	mov	r3, #1
3481ed94:	e58d3014 	str	r3, [sp, #20]
    RESTORE();
3481ed98:	e59d3010 	ldr	r3, [sp, #16]
3481ed9c:	e589b000 	str	fp, [r9]
3481eda0:	e5897004 	str	r7, [r9, #4]
3481eda4:	e589300c 	str	r3, [r9, #12]
3481eda8:	e59d300c 	ldr	r3, [sp, #12]
3481edac:	e5893010 	str	r3, [r9, #16]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481edb0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
    RESTORE();
3481edb4:	e5845038 	str	r5, [r4, #56]	; 0x38
3481edb8:	e584603c 	str	r6, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481edbc:	e3530000 	cmp	r3, #0
3481edc0:	1a000006 	bne	3481ede0 <inflate+0x12ec>
3481edc4:	e5943000 	ldr	r3, [r4]
3481edc8:	e3530017 	cmp	r3, #23
3481edcc:	8a000049 	bhi	3481eef8 <inflate+0x1404>
3481edd0:	e59d3018 	ldr	r3, [sp, #24]
3481edd4:	e59d200c 	ldr	r2, [sp, #12]
3481edd8:	e1530002 	cmp	r3, r2
3481eddc:	0a000045 	beq	3481eef8 <inflate+0x1404>
    state = (struct inflate_state FAR *)strm->state;
3481ede0:	e599501c 	ldr	r5, [r9, #28]
    if (state->window == Z_NULL) {
3481ede4:	e5953034 	ldr	r3, [r5, #52]	; 0x34
3481ede8:	e3530000 	cmp	r3, #0
3481edec:	0a000009 	beq	3481ee18 <inflate+0x1324>
    if (state->wsize == 0) {
3481edf0:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481edf4:	e3530000 	cmp	r3, #0
3481edf8:	1a000012 	bne	3481ee48 <inflate+0x1354>
        state->wsize = 1U << state->wbits;
3481edfc:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481ee00:	e3a02001 	mov	r2, #1
        state->write = 0;
3481ee04:	e5853030 	str	r3, [r5, #48]	; 0x30
        state->whave = 0;
3481ee08:	e585302c 	str	r3, [r5, #44]	; 0x2c
        state->wsize = 1U << state->wbits;
3481ee0c:	e1a02112 	lsl	r2, r2, r1
3481ee10:	e5852028 	str	r2, [r5, #40]	; 0x28
3481ee14:	ea00000b 	b	3481ee48 <inflate+0x1354>
                        ZALLOC(strm, 1U << state->wbits,
3481ee18:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481ee1c:	e3a02001 	mov	r2, #1
3481ee20:	e5993020 	ldr	r3, [r9, #32]
3481ee24:	e5990028 	ldr	r0, [r9, #40]	; 0x28
3481ee28:	e1a01112 	lsl	r1, r2, r1
3481ee2c:	e12fff33 	blx	r3
        if (state->window == Z_NULL) return 1;
3481ee30:	e3500000 	cmp	r0, #0
        state->window = (unsigned char FAR *)
3481ee34:	e5850034 	str	r0, [r5, #52]	; 0x34
        if (state->window == Z_NULL) return 1;
3481ee38:	1affffec 	bne	3481edf0 <inflate+0x12fc>
            state->mode = MEM;
3481ee3c:	e3a0301c 	mov	r3, #28
3481ee40:	e5843000 	str	r3, [r4]
3481ee44:	ea000068 	b	3481efec <inflate+0x14f8>
    copy = out - strm->avail_out;
3481ee48:	e5996010 	ldr	r6, [r9, #16]
3481ee4c:	e59d3018 	ldr	r3, [sp, #24]
    if (copy >= state->wsize) {
3481ee50:	e5952028 	ldr	r2, [r5, #40]	; 0x28
3481ee54:	e599100c 	ldr	r1, [r9, #12]
    copy = out - strm->avail_out;
3481ee58:	e0666003 	rsb	r6, r6, r3
    if (copy >= state->wsize) {
3481ee5c:	e1560002 	cmp	r6, r2
3481ee60:	3a000005 	bcc	3481ee7c <inflate+0x1388>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
3481ee64:	e0621001 	rsb	r1, r2, r1
3481ee68:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481ee6c:	ebfff362 	bl	3481bbfc <memcpy>
        state->write = 0;
3481ee70:	e3a03000 	mov	r3, #0
3481ee74:	e5853030 	str	r3, [r5, #48]	; 0x30
3481ee78:	ea000011 	b	3481eec4 <inflate+0x13d0>
        dist = state->wsize - state->write;
3481ee7c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481ee80:	e0661001 	rsb	r1, r6, r1
3481ee84:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        dist = state->wsize - state->write;
3481ee88:	e0632002 	rsb	r2, r3, r2
3481ee8c:	e1560002 	cmp	r6, r2
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481ee90:	e0800003 	add	r0, r0, r3
3481ee94:	31a07006 	movcc	r7, r6
3481ee98:	21a07002 	movcs	r7, r2
3481ee9c:	e1a02007 	mov	r2, r7
3481eea0:	ebfff355 	bl	3481bbfc <memcpy>
        if (copy) {
3481eea4:	e0566007 	subs	r6, r6, r7
3481eea8:	0a000008 	beq	3481eed0 <inflate+0x13dc>
            zmemcpy(state->window, strm->next_out - copy, copy);
3481eeac:	e599100c 	ldr	r1, [r9, #12]
3481eeb0:	e1a02006 	mov	r2, r6
3481eeb4:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481eeb8:	e0661001 	rsb	r1, r6, r1
3481eebc:	ebfff34e 	bl	3481bbfc <memcpy>
            state->write = copy;
3481eec0:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
3481eec4:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481eec8:	e585302c 	str	r3, [r5, #44]	; 0x2c
3481eecc:	ea000009 	b	3481eef8 <inflate+0x1404>
            state->write += dist;
3481eed0:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
3481eed4:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            state->write += dist;
3481eed8:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
3481eedc:	e1530002 	cmp	r3, r2
            state->write += dist;
3481eee0:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481eee4:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            if (state->write == state->wsize) state->write = 0;
3481eee8:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481eeec:	e1530002 	cmp	r3, r2
3481eef0:	30877003 	addcc	r7, r7, r3
3481eef4:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
    in -= strm->avail_in;
3481eef8:	e5996004 	ldr	r6, [r9, #4]
3481eefc:	e59d3020 	ldr	r3, [sp, #32]
    out -= strm->avail_out;
3481ef00:	e5995010 	ldr	r5, [r9, #16]
    in -= strm->avail_in;
3481ef04:	e0666003 	rsb	r6, r6, r3
    out -= strm->avail_out;
3481ef08:	e59d3018 	ldr	r3, [sp, #24]
3481ef0c:	e0655003 	rsb	r5, r5, r3
    strm->total_in += in;
3481ef10:	e5993008 	ldr	r3, [r9, #8]
3481ef14:	e0833006 	add	r3, r3, r6
3481ef18:	e5893008 	str	r3, [r9, #8]
    strm->total_out += out;
3481ef1c:	e5993014 	ldr	r3, [r9, #20]
3481ef20:	e0833005 	add	r3, r3, r5
3481ef24:	e5893014 	str	r3, [r9, #20]
    state->total += out;
3481ef28:	e594301c 	ldr	r3, [r4, #28]
3481ef2c:	e0833005 	add	r3, r3, r5
3481ef30:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
3481ef34:	e5943008 	ldr	r3, [r4, #8]
3481ef38:	e3550000 	cmp	r5, #0
3481ef3c:	13530000 	cmpne	r3, #0
3481ef40:	0a00000b 	beq	3481ef74 <inflate+0x1480>
            UPDATE(state->check, strm->next_out - out, out);
3481ef44:	e5943010 	ldr	r3, [r4, #16]
3481ef48:	e1a02005 	mov	r2, r5
3481ef4c:	e599100c 	ldr	r1, [r9, #12]
3481ef50:	e5940018 	ldr	r0, [r4, #24]
3481ef54:	e3530000 	cmp	r3, #0
3481ef58:	e0651001 	rsb	r1, r5, r1
3481ef5c:	0a000001 	beq	3481ef68 <inflate+0x1474>
3481ef60:	ebffebc0 	bl	34819e68 <crc32>
3481ef64:	ea000000 	b	3481ef6c <inflate+0x1478>
3481ef68:	ebfffa13 	bl	3481d7bc <adler32>
        strm->adler = state->check =
3481ef6c:	e5840018 	str	r0, [r4, #24]
3481ef70:	e5890034 	str	r0, [r9, #52]	; 0x34
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481ef74:	e5943004 	ldr	r3, [r4, #4]
3481ef78:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
3481ef7c:	e3530000 	cmp	r3, #0
3481ef80:	13a03040 	movne	r3, #64	; 0x40
3481ef84:	03a03000 	moveq	r3, #0
3481ef88:	e0833002 	add	r3, r3, r2
3481ef8c:	e5942000 	ldr	r2, [r4]
3481ef90:	e352000b 	cmp	r2, #11
3481ef94:	03a02080 	moveq	r2, #128	; 0x80
3481ef98:	13a02000 	movne	r2, #0
3481ef9c:	e0833002 	add	r3, r3, r2
3481efa0:	e589302c 	str	r3, [r9, #44]	; 0x2c
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481efa4:	e1953006 	orrs	r3, r5, r6
3481efa8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481efac:	03a01001 	moveq	r1, #1
3481efb0:	13a01000 	movne	r1, #0
3481efb4:	e3530004 	cmp	r3, #4
3481efb8:	03811001 	orreq	r1, r1, #1
3481efbc:	e3510000 	cmp	r1, #0
3481efc0:	059d0014 	ldreq	r0, [sp, #20]
3481efc4:	0a000009 	beq	3481eff0 <inflate+0x14fc>
        ret = Z_BUF_ERROR;
3481efc8:	e59d3014 	ldr	r3, [sp, #20]
3481efcc:	e3530000 	cmp	r3, #0
3481efd0:	11a00003 	movne	r0, r3
3481efd4:	03e00004 	mvneq	r0, #4
3481efd8:	ea000004 	b	3481eff0 <inflate+0x14fc>
        return Z_STREAM_ERROR;
3481efdc:	e3e00001 	mvn	r0, #1
}
3481efe0:	e12fff1e 	bx	lr
        return Z_STREAM_ERROR;
3481efe4:	e3e00001 	mvn	r0, #1
3481efe8:	ea000000 	b	3481eff0 <inflate+0x14fc>
            return Z_MEM_ERROR;
3481efec:	e3e00003 	mvn	r0, #3
}
3481eff0:	e28dd030 	add	sp, sp, #48	; 0x30
3481eff4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481eff8 <raise>:

int raise (int signum)
{
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
3481eff8:	e1a01000 	mov	r1, r0
{
3481effc:	e92d4010 	push	{r4, lr}
	printf("raise: Signal # %d caught\n", signum);
3481f000:	e59f0008 	ldr	r0, [pc, #8]	; 3481f010 <raise+0x18>
3481f004:	ebffa9e4 	bl	3480979c <printf>
#endif
	return 0;
}
3481f008:	e3a00000 	mov	r0, #0
3481f00c:	e8bd8010 	pop	{r4, pc}
3481f010:	34826fbc 	.word	0x34826fbc

3481f014 <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
3481f014:	e12fff1e 	bx	lr

3481f018 <__aeabi_unwind_cpp_pr1>:
};

void __aeabi_unwind_cpp_pr1(void)
{
3481f018:	e12fff1e 	bx	lr
3481f01c:	00000000 	andeq	r0, r0, r0

3481f020 <__udivsi3>:
3481f020:	1e4a      	subs	r2, r1, #1
3481f022:	bf08      	it	eq
3481f024:	4770      	bxeq	lr
3481f026:	f0c0 8124 	bcc.w	3481f272 <__udivsi3+0x252>
3481f02a:	4288      	cmp	r0, r1
3481f02c:	f240 8116 	bls.w	3481f25c <__udivsi3+0x23c>
3481f030:	4211      	tst	r1, r2
3481f032:	f000 8117 	beq.w	3481f264 <__udivsi3+0x244>
3481f036:	fab0 f380 	clz	r3, r0
3481f03a:	fab1 f281 	clz	r2, r1
3481f03e:	eba2 0303 	sub.w	r3, r2, r3
3481f042:	f1c3 031f 	rsb	r3, r3, #31
3481f046:	a204      	add	r2, pc, #16	; (adr r2, 3481f058 <__udivsi3+0x38>)
3481f048:	eb02 1303 	add.w	r3, r2, r3, lsl #4
3481f04c:	f04f 0200 	mov.w	r2, #0
3481f050:	469f      	mov	pc, r3
3481f052:	bf00      	nop
3481f054:	f3af 8000 	nop.w
3481f058:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
3481f05c:	bf00      	nop
3481f05e:	eb42 0202 	adc.w	r2, r2, r2
3481f062:	bf28      	it	cs
3481f064:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
3481f068:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
3481f06c:	bf00      	nop
3481f06e:	eb42 0202 	adc.w	r2, r2, r2
3481f072:	bf28      	it	cs
3481f074:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
3481f078:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
3481f07c:	bf00      	nop
3481f07e:	eb42 0202 	adc.w	r2, r2, r2
3481f082:	bf28      	it	cs
3481f084:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
3481f088:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
3481f08c:	bf00      	nop
3481f08e:	eb42 0202 	adc.w	r2, r2, r2
3481f092:	bf28      	it	cs
3481f094:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
3481f098:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
3481f09c:	bf00      	nop
3481f09e:	eb42 0202 	adc.w	r2, r2, r2
3481f0a2:	bf28      	it	cs
3481f0a4:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
3481f0a8:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
3481f0ac:	bf00      	nop
3481f0ae:	eb42 0202 	adc.w	r2, r2, r2
3481f0b2:	bf28      	it	cs
3481f0b4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
3481f0b8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
3481f0bc:	bf00      	nop
3481f0be:	eb42 0202 	adc.w	r2, r2, r2
3481f0c2:	bf28      	it	cs
3481f0c4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
3481f0c8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
3481f0cc:	bf00      	nop
3481f0ce:	eb42 0202 	adc.w	r2, r2, r2
3481f0d2:	bf28      	it	cs
3481f0d4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
3481f0d8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
3481f0dc:	bf00      	nop
3481f0de:	eb42 0202 	adc.w	r2, r2, r2
3481f0e2:	bf28      	it	cs
3481f0e4:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
3481f0e8:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
3481f0ec:	bf00      	nop
3481f0ee:	eb42 0202 	adc.w	r2, r2, r2
3481f0f2:	bf28      	it	cs
3481f0f4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
3481f0f8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
3481f0fc:	bf00      	nop
3481f0fe:	eb42 0202 	adc.w	r2, r2, r2
3481f102:	bf28      	it	cs
3481f104:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
3481f108:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
3481f10c:	bf00      	nop
3481f10e:	eb42 0202 	adc.w	r2, r2, r2
3481f112:	bf28      	it	cs
3481f114:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
3481f118:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
3481f11c:	bf00      	nop
3481f11e:	eb42 0202 	adc.w	r2, r2, r2
3481f122:	bf28      	it	cs
3481f124:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
3481f128:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
3481f12c:	bf00      	nop
3481f12e:	eb42 0202 	adc.w	r2, r2, r2
3481f132:	bf28      	it	cs
3481f134:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
3481f138:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
3481f13c:	bf00      	nop
3481f13e:	eb42 0202 	adc.w	r2, r2, r2
3481f142:	bf28      	it	cs
3481f144:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
3481f148:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
3481f14c:	bf00      	nop
3481f14e:	eb42 0202 	adc.w	r2, r2, r2
3481f152:	bf28      	it	cs
3481f154:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
3481f158:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
3481f15c:	bf00      	nop
3481f15e:	eb42 0202 	adc.w	r2, r2, r2
3481f162:	bf28      	it	cs
3481f164:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
3481f168:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
3481f16c:	bf00      	nop
3481f16e:	eb42 0202 	adc.w	r2, r2, r2
3481f172:	bf28      	it	cs
3481f174:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
3481f178:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
3481f17c:	bf00      	nop
3481f17e:	eb42 0202 	adc.w	r2, r2, r2
3481f182:	bf28      	it	cs
3481f184:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
3481f188:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
3481f18c:	bf00      	nop
3481f18e:	eb42 0202 	adc.w	r2, r2, r2
3481f192:	bf28      	it	cs
3481f194:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
3481f198:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
3481f19c:	bf00      	nop
3481f19e:	eb42 0202 	adc.w	r2, r2, r2
3481f1a2:	bf28      	it	cs
3481f1a4:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
3481f1a8:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
3481f1ac:	bf00      	nop
3481f1ae:	eb42 0202 	adc.w	r2, r2, r2
3481f1b2:	bf28      	it	cs
3481f1b4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
3481f1b8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
3481f1bc:	bf00      	nop
3481f1be:	eb42 0202 	adc.w	r2, r2, r2
3481f1c2:	bf28      	it	cs
3481f1c4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
3481f1c8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
3481f1cc:	bf00      	nop
3481f1ce:	eb42 0202 	adc.w	r2, r2, r2
3481f1d2:	bf28      	it	cs
3481f1d4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
3481f1d8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
3481f1dc:	bf00      	nop
3481f1de:	eb42 0202 	adc.w	r2, r2, r2
3481f1e2:	bf28      	it	cs
3481f1e4:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
3481f1e8:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
3481f1ec:	bf00      	nop
3481f1ee:	eb42 0202 	adc.w	r2, r2, r2
3481f1f2:	bf28      	it	cs
3481f1f4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
3481f1f8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
3481f1fc:	bf00      	nop
3481f1fe:	eb42 0202 	adc.w	r2, r2, r2
3481f202:	bf28      	it	cs
3481f204:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
3481f208:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
3481f20c:	bf00      	nop
3481f20e:	eb42 0202 	adc.w	r2, r2, r2
3481f212:	bf28      	it	cs
3481f214:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
3481f218:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
3481f21c:	bf00      	nop
3481f21e:	eb42 0202 	adc.w	r2, r2, r2
3481f222:	bf28      	it	cs
3481f224:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
3481f228:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
3481f22c:	bf00      	nop
3481f22e:	eb42 0202 	adc.w	r2, r2, r2
3481f232:	bf28      	it	cs
3481f234:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
3481f238:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
3481f23c:	bf00      	nop
3481f23e:	eb42 0202 	adc.w	r2, r2, r2
3481f242:	bf28      	it	cs
3481f244:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
3481f248:	ebb0 0f01 	cmp.w	r0, r1
3481f24c:	bf00      	nop
3481f24e:	eb42 0202 	adc.w	r2, r2, r2
3481f252:	bf28      	it	cs
3481f254:	eba0 0001 	subcs.w	r0, r0, r1
3481f258:	4610      	mov	r0, r2
3481f25a:	4770      	bx	lr
3481f25c:	bf0c      	ite	eq
3481f25e:	2001      	moveq	r0, #1
3481f260:	2000      	movne	r0, #0
3481f262:	4770      	bx	lr
3481f264:	fab1 f281 	clz	r2, r1
3481f268:	f1c2 021f 	rsb	r2, r2, #31
3481f26c:	fa20 f002 	lsr.w	r0, r0, r2
3481f270:	4770      	bx	lr
3481f272:	b108      	cbz	r0, 3481f278 <__udivsi3+0x258>
3481f274:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3481f278:	f000 b98c 	b.w	3481f594 <__aeabi_ldiv0>

3481f27c <__aeabi_uidivmod>:
3481f27c:	2900      	cmp	r1, #0
3481f27e:	d0f8      	beq.n	3481f272 <__udivsi3+0x252>
3481f280:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
3481f284:	f7ff fecc 	bl	3481f020 <__udivsi3>
3481f288:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
3481f28c:	fb02 f300 	mul.w	r3, r2, r0
3481f290:	eba1 0103 	sub.w	r1, r1, r3
3481f294:	4770      	bx	lr
3481f296:	bf00      	nop

3481f298 <__divsi3>:
3481f298:	2900      	cmp	r1, #0
3481f29a:	f000 813e 	beq.w	3481f51a <.divsi3_skip_div0_test+0x27c>

3481f29e <.divsi3_skip_div0_test>:
3481f29e:	ea80 0c01 	eor.w	ip, r0, r1
3481f2a2:	bf48      	it	mi
3481f2a4:	4249      	negmi	r1, r1
3481f2a6:	1e4a      	subs	r2, r1, #1
3481f2a8:	f000 811f 	beq.w	3481f4ea <.divsi3_skip_div0_test+0x24c>
3481f2ac:	0003      	movs	r3, r0
3481f2ae:	bf48      	it	mi
3481f2b0:	4243      	negmi	r3, r0
3481f2b2:	428b      	cmp	r3, r1
3481f2b4:	f240 811e 	bls.w	3481f4f4 <.divsi3_skip_div0_test+0x256>
3481f2b8:	4211      	tst	r1, r2
3481f2ba:	f000 8123 	beq.w	3481f504 <.divsi3_skip_div0_test+0x266>
3481f2be:	fab3 f283 	clz	r2, r3
3481f2c2:	fab1 f081 	clz	r0, r1
3481f2c6:	eba0 0202 	sub.w	r2, r0, r2
3481f2ca:	f1c2 021f 	rsb	r2, r2, #31
3481f2ce:	a004      	add	r0, pc, #16	; (adr r0, 3481f2e0 <.divsi3_skip_div0_test+0x42>)
3481f2d0:	eb00 1202 	add.w	r2, r0, r2, lsl #4
3481f2d4:	f04f 0000 	mov.w	r0, #0
3481f2d8:	4697      	mov	pc, r2
3481f2da:	bf00      	nop
3481f2dc:	f3af 8000 	nop.w
3481f2e0:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
3481f2e4:	bf00      	nop
3481f2e6:	eb40 0000 	adc.w	r0, r0, r0
3481f2ea:	bf28      	it	cs
3481f2ec:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
3481f2f0:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
3481f2f4:	bf00      	nop
3481f2f6:	eb40 0000 	adc.w	r0, r0, r0
3481f2fa:	bf28      	it	cs
3481f2fc:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
3481f300:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
3481f304:	bf00      	nop
3481f306:	eb40 0000 	adc.w	r0, r0, r0
3481f30a:	bf28      	it	cs
3481f30c:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
3481f310:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
3481f314:	bf00      	nop
3481f316:	eb40 0000 	adc.w	r0, r0, r0
3481f31a:	bf28      	it	cs
3481f31c:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
3481f320:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
3481f324:	bf00      	nop
3481f326:	eb40 0000 	adc.w	r0, r0, r0
3481f32a:	bf28      	it	cs
3481f32c:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
3481f330:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
3481f334:	bf00      	nop
3481f336:	eb40 0000 	adc.w	r0, r0, r0
3481f33a:	bf28      	it	cs
3481f33c:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
3481f340:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
3481f344:	bf00      	nop
3481f346:	eb40 0000 	adc.w	r0, r0, r0
3481f34a:	bf28      	it	cs
3481f34c:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
3481f350:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
3481f354:	bf00      	nop
3481f356:	eb40 0000 	adc.w	r0, r0, r0
3481f35a:	bf28      	it	cs
3481f35c:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
3481f360:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
3481f364:	bf00      	nop
3481f366:	eb40 0000 	adc.w	r0, r0, r0
3481f36a:	bf28      	it	cs
3481f36c:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
3481f370:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
3481f374:	bf00      	nop
3481f376:	eb40 0000 	adc.w	r0, r0, r0
3481f37a:	bf28      	it	cs
3481f37c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
3481f380:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
3481f384:	bf00      	nop
3481f386:	eb40 0000 	adc.w	r0, r0, r0
3481f38a:	bf28      	it	cs
3481f38c:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
3481f390:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
3481f394:	bf00      	nop
3481f396:	eb40 0000 	adc.w	r0, r0, r0
3481f39a:	bf28      	it	cs
3481f39c:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
3481f3a0:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
3481f3a4:	bf00      	nop
3481f3a6:	eb40 0000 	adc.w	r0, r0, r0
3481f3aa:	bf28      	it	cs
3481f3ac:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
3481f3b0:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
3481f3b4:	bf00      	nop
3481f3b6:	eb40 0000 	adc.w	r0, r0, r0
3481f3ba:	bf28      	it	cs
3481f3bc:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
3481f3c0:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
3481f3c4:	bf00      	nop
3481f3c6:	eb40 0000 	adc.w	r0, r0, r0
3481f3ca:	bf28      	it	cs
3481f3cc:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
3481f3d0:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
3481f3d4:	bf00      	nop
3481f3d6:	eb40 0000 	adc.w	r0, r0, r0
3481f3da:	bf28      	it	cs
3481f3dc:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
3481f3e0:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
3481f3e4:	bf00      	nop
3481f3e6:	eb40 0000 	adc.w	r0, r0, r0
3481f3ea:	bf28      	it	cs
3481f3ec:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
3481f3f0:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
3481f3f4:	bf00      	nop
3481f3f6:	eb40 0000 	adc.w	r0, r0, r0
3481f3fa:	bf28      	it	cs
3481f3fc:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
3481f400:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
3481f404:	bf00      	nop
3481f406:	eb40 0000 	adc.w	r0, r0, r0
3481f40a:	bf28      	it	cs
3481f40c:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
3481f410:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
3481f414:	bf00      	nop
3481f416:	eb40 0000 	adc.w	r0, r0, r0
3481f41a:	bf28      	it	cs
3481f41c:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
3481f420:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
3481f424:	bf00      	nop
3481f426:	eb40 0000 	adc.w	r0, r0, r0
3481f42a:	bf28      	it	cs
3481f42c:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
3481f430:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
3481f434:	bf00      	nop
3481f436:	eb40 0000 	adc.w	r0, r0, r0
3481f43a:	bf28      	it	cs
3481f43c:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
3481f440:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
3481f444:	bf00      	nop
3481f446:	eb40 0000 	adc.w	r0, r0, r0
3481f44a:	bf28      	it	cs
3481f44c:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
3481f450:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
3481f454:	bf00      	nop
3481f456:	eb40 0000 	adc.w	r0, r0, r0
3481f45a:	bf28      	it	cs
3481f45c:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
3481f460:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
3481f464:	bf00      	nop
3481f466:	eb40 0000 	adc.w	r0, r0, r0
3481f46a:	bf28      	it	cs
3481f46c:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
3481f470:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
3481f474:	bf00      	nop
3481f476:	eb40 0000 	adc.w	r0, r0, r0
3481f47a:	bf28      	it	cs
3481f47c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
3481f480:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
3481f484:	bf00      	nop
3481f486:	eb40 0000 	adc.w	r0, r0, r0
3481f48a:	bf28      	it	cs
3481f48c:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
3481f490:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
3481f494:	bf00      	nop
3481f496:	eb40 0000 	adc.w	r0, r0, r0
3481f49a:	bf28      	it	cs
3481f49c:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
3481f4a0:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
3481f4a4:	bf00      	nop
3481f4a6:	eb40 0000 	adc.w	r0, r0, r0
3481f4aa:	bf28      	it	cs
3481f4ac:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
3481f4b0:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
3481f4b4:	bf00      	nop
3481f4b6:	eb40 0000 	adc.w	r0, r0, r0
3481f4ba:	bf28      	it	cs
3481f4bc:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
3481f4c0:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
3481f4c4:	bf00      	nop
3481f4c6:	eb40 0000 	adc.w	r0, r0, r0
3481f4ca:	bf28      	it	cs
3481f4cc:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
3481f4d0:	ebb3 0f01 	cmp.w	r3, r1
3481f4d4:	bf00      	nop
3481f4d6:	eb40 0000 	adc.w	r0, r0, r0
3481f4da:	bf28      	it	cs
3481f4dc:	eba3 0301 	subcs.w	r3, r3, r1
3481f4e0:	f1bc 0f00 	cmp.w	ip, #0
3481f4e4:	bf48      	it	mi
3481f4e6:	4240      	negmi	r0, r0
3481f4e8:	4770      	bx	lr
3481f4ea:	ea9c 0f00 	teq	ip, r0
3481f4ee:	bf48      	it	mi
3481f4f0:	4240      	negmi	r0, r0
3481f4f2:	4770      	bx	lr
3481f4f4:	bf38      	it	cc
3481f4f6:	2000      	movcc	r0, #0
3481f4f8:	bf04      	itt	eq
3481f4fa:	ea4f 70ec 	moveq.w	r0, ip, asr #31
3481f4fe:	f040 0001 	orreq.w	r0, r0, #1
3481f502:	4770      	bx	lr
3481f504:	fab1 f281 	clz	r2, r1
3481f508:	f1c2 021f 	rsb	r2, r2, #31
3481f50c:	f1bc 0f00 	cmp.w	ip, #0
3481f510:	fa23 f002 	lsr.w	r0, r3, r2
3481f514:	bf48      	it	mi
3481f516:	4240      	negmi	r0, r0
3481f518:	4770      	bx	lr
3481f51a:	2800      	cmp	r0, #0
3481f51c:	bfc8      	it	gt
3481f51e:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
3481f522:	bfb8      	it	lt
3481f524:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
3481f528:	f000 b834 	b.w	3481f594 <__aeabi_ldiv0>

3481f52c <__aeabi_idivmod>:
3481f52c:	2900      	cmp	r1, #0
3481f52e:	d0f4      	beq.n	3481f51a <.divsi3_skip_div0_test+0x27c>
3481f530:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
3481f534:	f7ff feb3 	bl	3481f29e <.divsi3_skip_div0_test>
3481f538:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
3481f53c:	fb02 f300 	mul.w	r3, r2, r0
3481f540:	eba1 0103 	sub.w	r1, r1, r3
3481f544:	4770      	bx	lr
3481f546:	bf00      	nop

3481f548 <__lshrdi3>:
3481f548:	40d0      	lsrs	r0, r2
3481f54a:	1c0b      	adds	r3, r1, #0
3481f54c:	40d1      	lsrs	r1, r2
3481f54e:	469c      	mov	ip, r3
3481f550:	3a20      	subs	r2, #32
3481f552:	40d3      	lsrs	r3, r2
3481f554:	4318      	orrs	r0, r3
3481f556:	4252      	negs	r2, r2
3481f558:	4663      	mov	r3, ip
3481f55a:	4093      	lsls	r3, r2
3481f55c:	4318      	orrs	r0, r3
3481f55e:	4770      	bx	lr

3481f560 <__ashrdi3>:
3481f560:	40d0      	lsrs	r0, r2
3481f562:	1c0b      	adds	r3, r1, #0
3481f564:	4111      	asrs	r1, r2
3481f566:	3a20      	subs	r2, #32
3481f568:	d403      	bmi.n	3481f572 <__ashrdi3+0x12>
3481f56a:	469c      	mov	ip, r3
3481f56c:	4113      	asrs	r3, r2
3481f56e:	4318      	orrs	r0, r3
3481f570:	4663      	mov	r3, ip
3481f572:	4252      	negs	r2, r2
3481f574:	4093      	lsls	r3, r2
3481f576:	4318      	orrs	r0, r3
3481f578:	4770      	bx	lr
3481f57a:	bf00      	nop

3481f57c <__ashldi3>:
3481f57c:	4091      	lsls	r1, r2
3481f57e:	1c03      	adds	r3, r0, #0
3481f580:	4090      	lsls	r0, r2
3481f582:	469c      	mov	ip, r3
3481f584:	3a20      	subs	r2, #32
3481f586:	4093      	lsls	r3, r2
3481f588:	4319      	orrs	r1, r3
3481f58a:	4252      	negs	r2, r2
3481f58c:	4663      	mov	r3, ip
3481f58e:	40d3      	lsrs	r3, r2
3481f590:	4319      	orrs	r1, r3
3481f592:	4770      	bx	lr

3481f594 <__aeabi_ldiv0>:
3481f594:	b502      	push	{r1, lr}
3481f596:	f04f 0008 	mov.w	r0, #8
3481f59a:	f7ff ed2e 	blx	3481eff8 <raise>
3481f59e:	bd02      	pop	{r1, pc}
